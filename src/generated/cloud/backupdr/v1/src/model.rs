// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Network configuration for ManagementServer instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkConfig {
    /// Optional. The resource name of the Google Compute Engine VPC network to
    /// which the ManagementServer instance is connected.
    pub network: std::string::String,

    /// Optional. The network connect mode of the ManagementServer instance. For
    /// this version, only PRIVATE_SERVICE_ACCESS is supported.
    pub peering_mode: crate::model::network_config::PeeringMode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::NetworkConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [peering_mode][crate::model::NetworkConfig::peering_mode].
    pub fn set_peering_mode<T: std::convert::Into<crate::model::network_config::PeeringMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.peering_mode = v.into();
        self
    }
}

impl wkt::message::Message for NetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.NetworkConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network,
            __peering_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "network" => Ok(__FieldTag::__network),
                            "peeringMode" => Ok(__FieldTag::__peering_mode),
                            "peering_mode" => Ok(__FieldTag::__peering_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__peering_mode => {
                            if !fields.insert(__FieldTag::__peering_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peering_mode",
                                ));
                            }
                            result.peering_mode = map.next_value::<std::option::Option<crate::model::network_config::PeeringMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !wkt::internal::is_default(&self.peering_mode) {
            state.serialize_entry("peeringMode", &self.peering_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [NetworkConfig].
pub mod network_config {
    #[allow(unused_imports)]
    use super::*;

    /// VPC peering modes supported by Cloud BackupDR.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PeeringMode {
        /// Peering mode not set.
        Unspecified,
        /// Connect using Private Service Access to the Management Server. Private
        /// services access provides an IP address range for multiple Google Cloud
        /// services, including Cloud BackupDR.
        PrivateServiceAccess,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PeeringMode::value] or
        /// [PeeringMode::name].
        UnknownValue(peering_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod peering_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PeeringMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PrivateServiceAccess => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PEERING_MODE_UNSPECIFIED"),
                Self::PrivateServiceAccess => std::option::Option::Some("PRIVATE_SERVICE_ACCESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PeeringMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PeeringMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PeeringMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PrivateServiceAccess,
                _ => Self::UnknownValue(peering_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PeeringMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PEERING_MODE_UNSPECIFIED" => Self::Unspecified,
                "PRIVATE_SERVICE_ACCESS" => Self::PrivateServiceAccess,
                _ => Self::UnknownValue(peering_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PeeringMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PrivateServiceAccess => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PeeringMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PeeringMode>::new(
                ".google.cloud.backupdr.v1.NetworkConfig.PeeringMode",
            ))
        }
    }
}

/// ManagementURI for the Management Server resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ManagementURI {
    /// Output only. The ManagementServer AGM/RD WebUI URL.
    pub web_ui: std::string::String,

    /// Output only. The ManagementServer AGM/RD API URL.
    pub api: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManagementURI {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [web_ui][crate::model::ManagementURI::web_ui].
    pub fn set_web_ui<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.web_ui = v.into();
        self
    }

    /// Sets the value of [api][crate::model::ManagementURI::api].
    pub fn set_api<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api = v.into();
        self
    }
}

impl wkt::message::Message for ManagementURI {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ManagementURI"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ManagementURI {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __web_ui,
            __api,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagementURI")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "webUi" => Ok(__FieldTag::__web_ui),
                            "web_ui" => Ok(__FieldTag::__web_ui),
                            "api" => Ok(__FieldTag::__api),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ManagementURI;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagementURI")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__web_ui => {
                            if !fields.insert(__FieldTag::__web_ui) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for web_ui",
                                ));
                            }
                            result.web_ui = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api => {
                            if !fields.insert(__FieldTag::__api) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api",
                                ));
                            }
                            result.api = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ManagementURI {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.web_ui.is_empty() {
            state.serialize_entry("webUi", &self.web_ui)?;
        }
        if !self.api.is_empty() {
            state.serialize_entry("api", &self.api)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// ManagementURI depending on the Workforce Identity i.e. either 1p or 3p.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkforceIdentityBasedManagementURI {
    /// Output only. First party Management URI for Google Identities.
    pub first_party_management_uri: std::string::String,

    /// Output only. Third party Management URI for External Identity Providers.
    pub third_party_management_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkforceIdentityBasedManagementURI {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [first_party_management_uri][crate::model::WorkforceIdentityBasedManagementURI::first_party_management_uri].
    pub fn set_first_party_management_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.first_party_management_uri = v.into();
        self
    }

    /// Sets the value of [third_party_management_uri][crate::model::WorkforceIdentityBasedManagementURI::third_party_management_uri].
    pub fn set_third_party_management_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.third_party_management_uri = v.into();
        self
    }
}

impl wkt::message::Message for WorkforceIdentityBasedManagementURI {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.WorkforceIdentityBasedManagementURI"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkforceIdentityBasedManagementURI {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __first_party_management_uri,
            __third_party_management_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkforceIdentityBasedManagementURI")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "firstPartyManagementUri" => {
                                Ok(__FieldTag::__first_party_management_uri)
                            }
                            "first_party_management_uri" => {
                                Ok(__FieldTag::__first_party_management_uri)
                            }
                            "thirdPartyManagementUri" => {
                                Ok(__FieldTag::__third_party_management_uri)
                            }
                            "third_party_management_uri" => {
                                Ok(__FieldTag::__third_party_management_uri)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkforceIdentityBasedManagementURI;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkforceIdentityBasedManagementURI")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__first_party_management_uri => {
                            if !fields.insert(__FieldTag::__first_party_management_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for first_party_management_uri",
                                ));
                            }
                            result.first_party_management_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__third_party_management_uri => {
                            if !fields.insert(__FieldTag::__third_party_management_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for third_party_management_uri",
                                ));
                            }
                            result.third_party_management_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkforceIdentityBasedManagementURI {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.first_party_management_uri.is_empty() {
            state.serialize_entry("firstPartyManagementUri", &self.first_party_management_uri)?;
        }
        if !self.third_party_management_uri.is_empty() {
            state.serialize_entry("thirdPartyManagementUri", &self.third_party_management_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// OAuth Client ID depending on the Workforce Identity i.e. either 1p or 3p,
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkforceIdentityBasedOAuth2ClientID {
    /// Output only. First party OAuth Client ID for Google Identities.
    pub first_party_oauth2_client_id: std::string::String,

    /// Output only. Third party OAuth Client ID for External Identity Providers.
    pub third_party_oauth2_client_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkforceIdentityBasedOAuth2ClientID {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [first_party_oauth2_client_id][crate::model::WorkforceIdentityBasedOAuth2ClientID::first_party_oauth2_client_id].
    pub fn set_first_party_oauth2_client_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.first_party_oauth2_client_id = v.into();
        self
    }

    /// Sets the value of [third_party_oauth2_client_id][crate::model::WorkforceIdentityBasedOAuth2ClientID::third_party_oauth2_client_id].
    pub fn set_third_party_oauth2_client_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.third_party_oauth2_client_id = v.into();
        self
    }
}

impl wkt::message::Message for WorkforceIdentityBasedOAuth2ClientID {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.WorkforceIdentityBasedOAuth2ClientID"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkforceIdentityBasedOAuth2ClientID {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __first_party_oauth2_client_id,
            __third_party_oauth2_client_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkforceIdentityBasedOAuth2ClientID")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "firstPartyOauth2ClientId" => {
                                Ok(__FieldTag::__first_party_oauth2_client_id)
                            }
                            "first_party_oauth2_client_id" => {
                                Ok(__FieldTag::__first_party_oauth2_client_id)
                            }
                            "thirdPartyOauth2ClientId" => {
                                Ok(__FieldTag::__third_party_oauth2_client_id)
                            }
                            "third_party_oauth2_client_id" => {
                                Ok(__FieldTag::__third_party_oauth2_client_id)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkforceIdentityBasedOAuth2ClientID;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkforceIdentityBasedOAuth2ClientID")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__first_party_oauth2_client_id => {
                            if !fields.insert(__FieldTag::__first_party_oauth2_client_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for first_party_oauth2_client_id",
                                ));
                            }
                            result.first_party_oauth2_client_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__third_party_oauth2_client_id => {
                            if !fields.insert(__FieldTag::__third_party_oauth2_client_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for third_party_oauth2_client_id",
                                ));
                            }
                            result.third_party_oauth2_client_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkforceIdentityBasedOAuth2ClientID {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.first_party_oauth2_client_id.is_empty() {
            state.serialize_entry(
                "firstPartyOauth2ClientId",
                &self.first_party_oauth2_client_id,
            )?;
        }
        if !self.third_party_oauth2_client_id.is_empty() {
            state.serialize_entry(
                "thirdPartyOauth2ClientId",
                &self.third_party_oauth2_client_id,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// ManagementServer describes a single BackupDR ManagementServer instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ManagementServer {
    /// Output only. Identifier. The resource name.
    pub name: std::string::String,

    /// Optional. The description of the ManagementServer instance (2048 characters
    /// or less).
    pub description: std::string::String,

    /// Optional. Resource labels to represent user provided metadata.
    /// Labels currently defined:
    ///
    /// 1. migrate_from_go=<false|true>
    ///    If set to true, the MS is created in migration ready mode.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The time when the instance was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the instance was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The type of the ManagementServer resource.
    pub r#type: crate::model::management_server::InstanceType,

    /// Output only. The hostname or ip address of the exposed AGM endpoints, used
    /// by clients to connect to AGM/RD graphical user interface and APIs.
    pub management_uri: std::option::Option<crate::model::ManagementURI>,

    /// Output only. The hostnames of the exposed AGM endpoints for both types of
    /// user i.e. 1p and 3p, used to connect AGM/RM UI.
    pub workforce_identity_based_management_uri:
        std::option::Option<crate::model::WorkforceIdentityBasedManagementURI>,

    /// Output only. The ManagementServer state.
    pub state: crate::model::management_server::InstanceState,

    /// Optional. VPC networks to which the ManagementServer instance is connected.
    /// For this version, only a single network is supported. This field is
    /// optional if MS is created without PSA
    pub networks: std::vec::Vec<crate::model::NetworkConfig>,

    /// Optional. Server specified ETag for the ManagementServer resource to
    /// prevent simultaneous updates from overwiting each other.
    pub etag: std::string::String,

    /// Output only. The OAuth 2.0 client id is required to make API calls to the
    /// BackupDR instance API of this ManagementServer. This is the value that
    /// should be provided in the 'aud' field of the OIDC ID Token (see openid
    /// specification
    /// <https://openid.net/specs/openid-connect-core-1_0.html#IDToken>).
    pub oauth2_client_id: std::string::String,

    /// Output only. The OAuth client IDs for both types of user i.e. 1p and 3p.
    pub workforce_identity_based_oauth2_client_id:
        std::option::Option<crate::model::WorkforceIdentityBasedOAuth2ClientID>,

    /// Output only. The hostname or ip address of the exposed AGM endpoints, used
    /// by BAs to connect to BA proxy.
    pub ba_proxy_uri: std::vec::Vec<std::string::String>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: std::option::Option<wkt::BoolValue>,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManagementServer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ManagementServer::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ManagementServer::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ManagementServer::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::ManagementServer::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ManagementServer::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ManagementServer::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ManagementServer::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::ManagementServer::type].
    pub fn set_type<T: std::convert::Into<crate::model::management_server::InstanceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [management_uri][crate::model::ManagementServer::management_uri].
    pub fn set_management_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManagementURI>,
    {
        self.management_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [management_uri][crate::model::ManagementServer::management_uri].
    pub fn set_or_clear_management_uri<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ManagementURI>,
    {
        self.management_uri = v.map(|x| x.into());
        self
    }

    /// Sets the value of [workforce_identity_based_management_uri][crate::model::ManagementServer::workforce_identity_based_management_uri].
    pub fn set_workforce_identity_based_management_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkforceIdentityBasedManagementURI>,
    {
        self.workforce_identity_based_management_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workforce_identity_based_management_uri][crate::model::ManagementServer::workforce_identity_based_management_uri].
    pub fn set_or_clear_workforce_identity_based_management_uri<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::WorkforceIdentityBasedManagementURI>,
    {
        self.workforce_identity_based_management_uri = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::ManagementServer::state].
    pub fn set_state<T: std::convert::Into<crate::model::management_server::InstanceState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [networks][crate::model::ManagementServer::networks].
    pub fn set_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkConfig>,
    {
        use std::iter::Iterator;
        self.networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [etag][crate::model::ManagementServer::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [oauth2_client_id][crate::model::ManagementServer::oauth2_client_id].
    pub fn set_oauth2_client_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.oauth2_client_id = v.into();
        self
    }

    /// Sets the value of [workforce_identity_based_oauth2_client_id][crate::model::ManagementServer::workforce_identity_based_oauth2_client_id].
    pub fn set_workforce_identity_based_oauth2_client_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkforceIdentityBasedOAuth2ClientID>,
    {
        self.workforce_identity_based_oauth2_client_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workforce_identity_based_oauth2_client_id][crate::model::ManagementServer::workforce_identity_based_oauth2_client_id].
    pub fn set_or_clear_workforce_identity_based_oauth2_client_id<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::WorkforceIdentityBasedOAuth2ClientID>,
    {
        self.workforce_identity_based_oauth2_client_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ba_proxy_uri][crate::model::ManagementServer::ba_proxy_uri].
    pub fn set_ba_proxy_uri<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ba_proxy_uri = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::ManagementServer::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::ManagementServer::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::ManagementServer::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }
}

impl wkt::message::Message for ManagementServer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ManagementServer"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ManagementServer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __labels,
            __create_time,
            __update_time,
            __type,
            __management_uri,
            __workforce_identity_based_management_uri,
            __state,
            __networks,
            __etag,
            __oauth2_client_id,
            __workforce_identity_based_oauth2_client_id,
            __ba_proxy_uri,
            __satisfies_pzs,
            __satisfies_pzi,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagementServer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "type" => Ok(__FieldTag::__type),
                            "managementUri" => Ok(__FieldTag::__management_uri),
                            "management_uri" => Ok(__FieldTag::__management_uri),
                            "workforceIdentityBasedManagementUri" => {
                                Ok(__FieldTag::__workforce_identity_based_management_uri)
                            }
                            "workforce_identity_based_management_uri" => {
                                Ok(__FieldTag::__workforce_identity_based_management_uri)
                            }
                            "state" => Ok(__FieldTag::__state),
                            "networks" => Ok(__FieldTag::__networks),
                            "etag" => Ok(__FieldTag::__etag),
                            "oauth2ClientId" => Ok(__FieldTag::__oauth2_client_id),
                            "oauth2_client_id" => Ok(__FieldTag::__oauth2_client_id),
                            "workforceIdentityBasedOauth2ClientId" => {
                                Ok(__FieldTag::__workforce_identity_based_oauth2_client_id)
                            }
                            "workforce_identity_based_oauth2_client_id" => {
                                Ok(__FieldTag::__workforce_identity_based_oauth2_client_id)
                            }
                            "baProxyUri" => Ok(__FieldTag::__ba_proxy_uri),
                            "ba_proxy_uri" => Ok(__FieldTag::__ba_proxy_uri),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ManagementServer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagementServer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type =
                                map.next_value::<std::option::Option<
                                    crate::model::management_server::InstanceType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__management_uri => {
                            if !fields.insert(__FieldTag::__management_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for management_uri",
                                ));
                            }
                            result.management_uri = map
                                .next_value::<std::option::Option<crate::model::ManagementURI>>()?;
                        }
                        __FieldTag::__workforce_identity_based_management_uri => {
                            if !fields.insert(__FieldTag::__workforce_identity_based_management_uri)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workforce_identity_based_management_uri",
                                ));
                            }
                            result.workforce_identity_based_management_uri =
                                map.next_value::<std::option::Option<
                                    crate::model::WorkforceIdentityBasedManagementURI,
                                >>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state =
                                map.next_value::<std::option::Option<
                                    crate::model::management_server::InstanceState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__networks => {
                            if !fields.insert(__FieldTag::__networks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for networks",
                                ));
                            }
                            result.networks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::NetworkConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oauth2_client_id => {
                            if !fields.insert(__FieldTag::__oauth2_client_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth2_client_id",
                                ));
                            }
                            result.oauth2_client_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workforce_identity_based_oauth2_client_id => {
                            if !fields
                                .insert(__FieldTag::__workforce_identity_based_oauth2_client_id)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workforce_identity_based_oauth2_client_id",
                                ));
                            }
                            result.workforce_identity_based_oauth2_client_id =
                                map.next_value::<std::option::Option<
                                    crate::model::WorkforceIdentityBasedOAuth2ClientID,
                                >>()?;
                        }
                        __FieldTag::__ba_proxy_uri => {
                            if !fields.insert(__FieldTag::__ba_proxy_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ba_proxy_uri",
                                ));
                            }
                            result.ba_proxy_uri = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ManagementServer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.management_uri.is_some() {
            state.serialize_entry("managementUri", &self.management_uri)?;
        }
        if self.workforce_identity_based_management_uri.is_some() {
            state.serialize_entry(
                "workforceIdentityBasedManagementUri",
                &self.workforce_identity_based_management_uri,
            )?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.networks.is_empty() {
            state.serialize_entry("networks", &self.networks)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.oauth2_client_id.is_empty() {
            state.serialize_entry("oauth2ClientId", &self.oauth2_client_id)?;
        }
        if self.workforce_identity_based_oauth2_client_id.is_some() {
            state.serialize_entry(
                "workforceIdentityBasedOauth2ClientId",
                &self.workforce_identity_based_oauth2_client_id,
            )?;
        }
        if !self.ba_proxy_uri.is_empty() {
            state.serialize_entry("baProxyUri", &self.ba_proxy_uri)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzi) {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ManagementServer].
pub mod management_server {
    #[allow(unused_imports)]
    use super::*;

    /// Type of backup service resource.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstanceType {
        /// Instance type is not mentioned.
        Unspecified,
        /// Instance for backup and restore management (i.e., AGM).
        BackupRestore,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstanceType::value] or
        /// [InstanceType::name].
        UnknownValue(instance_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod instance_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl InstanceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::BackupRestore => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INSTANCE_TYPE_UNSPECIFIED"),
                Self::BackupRestore => std::option::Option::Some("BACKUP_RESTORE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for InstanceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for InstanceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for InstanceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::BackupRestore,
                _ => Self::UnknownValue(instance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for InstanceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INSTANCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BACKUP_RESTORE" => Self::BackupRestore,
                _ => Self::UnknownValue(instance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for InstanceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::BackupRestore => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for InstanceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InstanceType>::new(
                ".google.cloud.backupdr.v1.ManagementServer.InstanceType",
            ))
        }
    }

    /// State of Management server instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstanceState {
        /// State not set.
        Unspecified,
        /// The instance is being created.
        Creating,
        /// The instance has been created and is fully usable.
        Ready,
        /// The instance configuration is being updated. Certain kinds of updates
        /// may cause the instance to become unusable while the update is in
        /// progress.
        Updating,
        /// The instance is being deleted.
        Deleting,
        /// The instance is being repaired and may be unstable.
        Repairing,
        /// Maintenance is being performed on this instance.
        Maintenance,
        /// The instance is experiencing an issue and might be unusable. You can get
        /// further details from the statusMessage field of Instance resource.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstanceState::value] or
        /// [InstanceState::name].
        UnknownValue(instance_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod instance_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl InstanceState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Repairing => std::option::Option::Some(5),
                Self::Maintenance => std::option::Option::Some(6),
                Self::Error => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INSTANCE_STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Repairing => std::option::Option::Some("REPAIRING"),
                Self::Maintenance => std::option::Option::Some("MAINTENANCE"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for InstanceState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for InstanceState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for InstanceState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Updating,
                4 => Self::Deleting,
                5 => Self::Repairing,
                6 => Self::Maintenance,
                7 => Self::Error,
                _ => Self::UnknownValue(instance_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for InstanceState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INSTANCE_STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                "REPAIRING" => Self::Repairing,
                "MAINTENANCE" => Self::Maintenance,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(instance_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for InstanceState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Repairing => serializer.serialize_i32(5),
                Self::Maintenance => serializer.serialize_i32(6),
                Self::Error => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for InstanceState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InstanceState>::new(
                ".google.cloud.backupdr.v1.ManagementServer.InstanceState",
            ))
        }
    }
}

/// Request message for listing management servers.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListManagementServersRequest {
    /// Required. The project and location for which to retrieve management servers
    /// information, in the format 'projects/{project_id}/locations/{location}'. In
    /// Cloud BackupDR, locations map to Google Cloud regions, for example
    /// **us-central1**. To retrieve management servers for all locations, use "-"
    /// for the
    /// '{location}' value.
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    pub filter: std::option::Option<std::string::String>,

    /// Optional. Hint for how to order the results.
    pub order_by: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListManagementServersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListManagementServersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListManagementServersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListManagementServersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListManagementServersRequest::filter].
    pub fn set_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [filter][crate::model::ListManagementServersRequest::filter].
    pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [order_by][crate::model::ListManagementServersRequest::order_by].
    pub fn set_order_by<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.order_by = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [order_by][crate::model::ListManagementServersRequest::order_by].
    pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.order_by = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListManagementServersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListManagementServersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListManagementServersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListManagementServersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListManagementServersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListManagementServersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListManagementServersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if self.filter.is_some() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.order_by.is_some() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for listing management servers.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListManagementServersResponse {
    /// The list of ManagementServer instances in the project for the specified
    /// location.
    ///
    /// If the '{location}' value in the request is "-", the response contains a
    /// list of instances from all locations. In case any location is unreachable,
    /// the response will only return management servers in reachable locations and
    /// the 'unreachable' field will be populated with a list of unreachable
    /// locations.
    pub management_servers: std::vec::Vec<crate::model::ManagementServer>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListManagementServersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [management_servers][crate::model::ListManagementServersResponse::management_servers].
    pub fn set_management_servers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ManagementServer>,
    {
        use std::iter::Iterator;
        self.management_servers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListManagementServersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListManagementServersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListManagementServersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListManagementServersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListManagementServersResponse {
    type PageItem = crate::model::ManagementServer;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.management_servers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListManagementServersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __management_servers,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListManagementServersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "managementServers" => Ok(__FieldTag::__management_servers),
                            "management_servers" => Ok(__FieldTag::__management_servers),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListManagementServersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListManagementServersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__management_servers => {
                            if !fields.insert(__FieldTag::__management_servers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for management_servers",
                                ));
                            }
                            result.management_servers =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ManagementServer>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListManagementServersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.management_servers.is_empty() {
            state.serialize_entry("managementServers", &self.management_servers)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for getting a management server instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetManagementServerRequest {
    /// Required. Name of the management server resource name, in the format
    /// 'projects/{project_id}/locations/{location}/managementServers/{resource_name}'
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetManagementServerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetManagementServerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetManagementServerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.GetManagementServerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetManagementServerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetManagementServerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetManagementServerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetManagementServerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetManagementServerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for creating a management server instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateManagementServerRequest {
    /// Required. The management server project and location in the format
    /// 'projects/{project_id}/locations/{location}'. In Cloud Backup and DR
    /// locations map to Google Cloud regions, for example **us-central1**.
    pub parent: std::string::String,

    /// Required. The name of the management server to create. The name must be
    /// unique for the specified project and location.
    pub management_server_id: std::string::String,

    /// Required. A [management server
    /// resource][google.cloud.backupdr.v1.ManagementServer]
    ///
    /// [google.cloud.backupdr.v1.ManagementServer]: crate::model::ManagementServer
    pub management_server: std::option::Option<crate::model::ManagementServer>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateManagementServerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateManagementServerRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [management_server_id][crate::model::CreateManagementServerRequest::management_server_id].
    pub fn set_management_server_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.management_server_id = v.into();
        self
    }

    /// Sets the value of [management_server][crate::model::CreateManagementServerRequest::management_server].
    pub fn set_management_server<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManagementServer>,
    {
        self.management_server = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [management_server][crate::model::CreateManagementServerRequest::management_server].
    pub fn set_or_clear_management_server<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ManagementServer>,
    {
        self.management_server = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateManagementServerRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateManagementServerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.CreateManagementServerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateManagementServerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __management_server_id,
            __management_server,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateManagementServerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "managementServerId" => Ok(__FieldTag::__management_server_id),
                            "management_server_id" => Ok(__FieldTag::__management_server_id),
                            "managementServer" => Ok(__FieldTag::__management_server),
                            "management_server" => Ok(__FieldTag::__management_server),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateManagementServerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateManagementServerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__management_server_id => {
                            if !fields.insert(__FieldTag::__management_server_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for management_server_id",
                                ));
                            }
                            result.management_server_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__management_server => {
                            if !fields.insert(__FieldTag::__management_server) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for management_server",
                                ));
                            }
                            result.management_server = map
                                .next_value::<std::option::Option<crate::model::ManagementServer>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateManagementServerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.management_server_id.is_empty() {
            state.serialize_entry("managementServerId", &self.management_server_id)?;
        }
        if self.management_server.is_some() {
            state.serialize_entry("managementServer", &self.management_server)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for deleting a management server instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteManagementServerRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteManagementServerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteManagementServerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteManagementServerRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteManagementServerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.DeleteManagementServerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteManagementServerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteManagementServerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteManagementServerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteManagementServerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteManagementServerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for initializing the service.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InitializeServiceRequest {
    /// Required. The resource name of the serviceConfig used to initialize the
    /// service. Format:
    /// `projects/{project_id}/locations/{location}/serviceConfig`.
    pub name: std::string::String,

    /// Required. The resource type to which the default service config will be
    /// applied. Examples include, "compute.googleapis.com/Instance" and
    /// "storage.googleapis.com/Bucket".
    pub resource_type: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InitializeServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InitializeServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [resource_type][crate::model::InitializeServiceRequest::resource_type].
    pub fn set_resource_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::InitializeServiceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for InitializeServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.InitializeServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InitializeServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __resource_type,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InitializeServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "resourceType" => Ok(__FieldTag::__resource_type),
                            "resource_type" => Ok(__FieldTag::__resource_type),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InitializeServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InitializeServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_type => {
                            if !fields.insert(__FieldTag::__resource_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type",
                                ));
                            }
                            result.resource_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InitializeServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.resource_type.is_empty() {
            state.serialize_entry("resourceType", &self.resource_type)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for initializing the service.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InitializeServiceResponse {
    /// The resource name of the default `BackupVault` created.
    /// Format:
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}`.
    pub backup_vault_name: std::string::String,

    /// The resource name of the default `BackupPlan` created.
    /// Format:
    /// `projects/{project_id}/locations/{location}/backupPlans/{backup_plan_id}`.
    pub backup_plan_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InitializeServiceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_vault_name][crate::model::InitializeServiceResponse::backup_vault_name].
    pub fn set_backup_vault_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_vault_name = v.into();
        self
    }

    /// Sets the value of [backup_plan_name][crate::model::InitializeServiceResponse::backup_plan_name].
    pub fn set_backup_plan_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_plan_name = v.into();
        self
    }
}

impl wkt::message::Message for InitializeServiceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.InitializeServiceResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InitializeServiceResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_vault_name,
            __backup_plan_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InitializeServiceResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupVaultName" => Ok(__FieldTag::__backup_vault_name),
                            "backup_vault_name" => Ok(__FieldTag::__backup_vault_name),
                            "backupPlanName" => Ok(__FieldTag::__backup_plan_name),
                            "backup_plan_name" => Ok(__FieldTag::__backup_plan_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InitializeServiceResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InitializeServiceResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_vault_name => {
                            if !fields.insert(__FieldTag::__backup_vault_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_vault_name",
                                ));
                            }
                            result.backup_vault_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_plan_name => {
                            if !fields.insert(__FieldTag::__backup_plan_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan_name",
                                ));
                            }
                            result.backup_plan_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InitializeServiceResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup_vault_name.is_empty() {
            state.serialize_entry("backupVaultName", &self.backup_vault_name)?;
        }
        if !self.backup_plan_name.is_empty() {
            state.serialize_entry("backupPlanName", &self.backup_plan_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to 'Code.CANCELLED'.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    /// Output only. AdditionalInfo contains additional Info related to backup plan
    /// association resource.
    pub additional_info: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [additional_info][crate::model::OperationMetadata::additional_info].
    pub fn set_additional_info<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.additional_info = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            __additional_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            "additionalInfo" => Ok(__FieldTag::__additional_info),
                            "additional_info" => Ok(__FieldTag::__additional_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_info => {
                            if !fields.insert(__FieldTag::__additional_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_info",
                                ));
                            }
                            result.additional_info = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self.additional_info.is_empty() {
            state.serialize_entry("additionalInfo", &self.additional_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A `BackupPlan` specifies some common fields, such as `description` as well
/// as one or more `BackupRule` messages. Each `BackupRule` has a retention
/// policy and defines a schedule by which the system is to perform backup
/// workloads.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupPlan {
    /// Output only. Identifier. The resource name of the `BackupPlan`.
    ///
    /// Format: `projects/{project}/locations/{location}/backupPlans/{backup_plan}`
    pub name: std::string::String,

    /// Optional. The description of the `BackupPlan` resource.
    ///
    /// The description allows for additional details about `BackupPlan` and its
    /// use cases to be provided. An example description is the following:  "This
    /// is a backup plan that performs a daily backup at 6pm and retains data for 3
    /// months". The description must be at most 2048 characters.
    pub description: std::string::String,

    /// Optional. This collection of key/value pairs allows for custom labels to be
    /// supplied by the user.  Example, {"tag": "Weekly"}.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. When the `BackupPlan` was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. When the `BackupPlan` was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. The backup rules for this `BackupPlan`. There must be at least
    /// one `BackupRule` message.
    pub backup_rules: std::vec::Vec<crate::model::BackupRule>,

    /// Output only. The `State` for the `BackupPlan`.
    pub state: crate::model::backup_plan::State,

    /// Required. The resource type to which the `BackupPlan` will be applied.
    /// Examples include, "compute.googleapis.com/Instance",
    /// "sqladmin.googleapis.com/Instance", or "alloydb.googleapis.com/Cluster".
    pub resource_type: std::string::String,

    /// Optional. `etag` is returned from the service in the response. As a user of
    /// the service, you may provide an etag value in this field to prevent stale
    /// resources.
    pub etag: std::string::String,

    /// Required. Resource name of backup vault which will be used as storage
    /// location for backups. Format:
    /// projects/{project}/locations/{location}/backupVaults/{backupvault}
    pub backup_vault: std::string::String,

    /// Output only. The Google Cloud Platform Service Account to be used by the
    /// BackupVault for taking backups. Specify the email address of the Backup
    /// Vault Service Account.
    pub backup_vault_service_account: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupPlan {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupPlan::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::BackupPlan::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::BackupPlan::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupPlan::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BackupPlan::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::BackupPlan::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::BackupPlan::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_rules][crate::model::BackupPlan::backup_rules].
    pub fn set_backup_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupRule>,
    {
        use std::iter::Iterator;
        self.backup_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::BackupPlan::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup_plan::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [resource_type][crate::model::BackupPlan::resource_type].
    pub fn set_resource_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::BackupPlan::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [backup_vault][crate::model::BackupPlan::backup_vault].
    pub fn set_backup_vault<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_vault = v.into();
        self
    }

    /// Sets the value of [backup_vault_service_account][crate::model::BackupPlan::backup_vault_service_account].
    pub fn set_backup_vault_service_account<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_vault_service_account = v.into();
        self
    }
}

impl wkt::message::Message for BackupPlan {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupPlan"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupPlan {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __labels,
            __create_time,
            __update_time,
            __backup_rules,
            __state,
            __resource_type,
            __etag,
            __backup_vault,
            __backup_vault_service_account,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupPlan")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "backupRules" => Ok(__FieldTag::__backup_rules),
                            "backup_rules" => Ok(__FieldTag::__backup_rules),
                            "state" => Ok(__FieldTag::__state),
                            "resourceType" => Ok(__FieldTag::__resource_type),
                            "resource_type" => Ok(__FieldTag::__resource_type),
                            "etag" => Ok(__FieldTag::__etag),
                            "backupVault" => Ok(__FieldTag::__backup_vault),
                            "backup_vault" => Ok(__FieldTag::__backup_vault),
                            "backupVaultServiceAccount" => {
                                Ok(__FieldTag::__backup_vault_service_account)
                            }
                            "backup_vault_service_account" => {
                                Ok(__FieldTag::__backup_vault_service_account)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupPlan;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupPlan")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__backup_rules => {
                            if !fields.insert(__FieldTag::__backup_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_rules",
                                ));
                            }
                            result.backup_rules = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BackupRule>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::backup_plan::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__resource_type => {
                            if !fields.insert(__FieldTag::__resource_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type",
                                ));
                            }
                            result.resource_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_vault => {
                            if !fields.insert(__FieldTag::__backup_vault) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_vault",
                                ));
                            }
                            result.backup_vault = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_vault_service_account => {
                            if !fields.insert(__FieldTag::__backup_vault_service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_vault_service_account",
                                ));
                            }
                            result.backup_vault_service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupPlan {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.backup_rules.is_empty() {
            state.serialize_entry("backupRules", &self.backup_rules)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.resource_type.is_empty() {
            state.serialize_entry("resourceType", &self.resource_type)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.backup_vault.is_empty() {
            state.serialize_entry("backupVault", &self.backup_vault)?;
        }
        if !self.backup_vault_service_account.is_empty() {
            state.serialize_entry(
                "backupVaultServiceAccount",
                &self.backup_vault_service_account,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BackupPlan].
pub mod backup_plan {
    #[allow(unused_imports)]
    use super::*;

    /// `State` enumerates the possible states for a `BackupPlan`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State not set.
        Unspecified,
        /// The resource is being created.
        Creating,
        /// The resource has been created and is fully usable.
        Active,
        /// The resource is being deleted.
        Deleting,
        /// The resource has been created but is not usable.
        Inactive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Inactive => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                4 => Self::Inactive,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "INACTIVE" => Self::Inactive,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Inactive => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.backupdr.v1.BackupPlan.State",
            ))
        }
    }
}

/// `BackupRule` binds the backup schedule to a retention policy.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupRule {
    /// Required. Immutable. The unique id of this `BackupRule`. The `rule_id` is
    /// unique per `BackupPlan`.The `rule_id` must start with a lowercase letter
    /// followed by up to 62 lowercase letters, numbers, or hyphens. Pattern,
    /// /[a-z][a-z0-9-]{,62}/.
    pub rule_id: std::string::String,

    /// Required. Configures the duration for which backup data will be kept. It is
    /// defined in “days”. The value should be greater than or equal to minimum
    /// enforced retention of the backup vault.
    ///
    /// Minimum value is 1 and maximum value is 90 for hourly backups.
    /// Minimum value is 1 and maximum value is 90 for daily backups.
    /// Minimum value is 7 and maximum value is 186 for weekly backups.
    /// Minimum value is 30 and maximum value is 732 for monthly backups.
    /// Minimum value is 365 and maximum value is 36159 for yearly backups.
    pub backup_retention_days: i32,

    /// The schedule that defines the automated backup workloads for this
    /// `BackupRule`.
    pub backup_schedule_oneof: std::option::Option<crate::model::backup_rule::BackupScheduleOneof>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rule_id][crate::model::BackupRule::rule_id].
    pub fn set_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_id = v.into();
        self
    }

    /// Sets the value of [backup_retention_days][crate::model::BackupRule::backup_retention_days].
    pub fn set_backup_retention_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.backup_retention_days = v.into();
        self
    }

    /// Sets the value of [backup_schedule_oneof][crate::model::BackupRule::backup_schedule_oneof].
    ///
    /// Note that all the setters affecting `backup_schedule_oneof` are mutually
    /// exclusive.
    pub fn set_backup_schedule_oneof<
        T: std::convert::Into<std::option::Option<crate::model::backup_rule::BackupScheduleOneof>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_schedule_oneof = v.into();
        self
    }

    /// The value of [backup_schedule_oneof][crate::model::BackupRule::backup_schedule_oneof]
    /// if it holds a `StandardSchedule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn standard_schedule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StandardSchedule>> {
        #[allow(unreachable_patterns)]
        self.backup_schedule_oneof.as_ref().and_then(|v| match v {
            crate::model::backup_rule::BackupScheduleOneof::StandardSchedule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backup_schedule_oneof][crate::model::BackupRule::backup_schedule_oneof]
    /// to hold a `StandardSchedule`.
    ///
    /// Note that all the setters affecting `backup_schedule_oneof` are
    /// mutually exclusive.
    pub fn set_standard_schedule<
        T: std::convert::Into<std::boxed::Box<crate::model::StandardSchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_schedule_oneof = std::option::Option::Some(
            crate::model::backup_rule::BackupScheduleOneof::StandardSchedule(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BackupRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rule_id,
            __backup_retention_days,
            __standard_schedule,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ruleId" => Ok(__FieldTag::__rule_id),
                            "rule_id" => Ok(__FieldTag::__rule_id),
                            "backupRetentionDays" => Ok(__FieldTag::__backup_retention_days),
                            "backup_retention_days" => Ok(__FieldTag::__backup_retention_days),
                            "standardSchedule" => Ok(__FieldTag::__standard_schedule),
                            "standard_schedule" => Ok(__FieldTag::__standard_schedule),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rule_id => {
                            if !fields.insert(__FieldTag::__rule_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule_id",
                                ));
                            }
                            result.rule_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_retention_days => {
                            if !fields.insert(__FieldTag::__backup_retention_days) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_retention_days",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.backup_retention_days =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__standard_schedule => {
                            if !fields.insert(__FieldTag::__standard_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for standard_schedule",
                                ));
                            }
                            if result.backup_schedule_oneof.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `backup_schedule_oneof`, a oneof with full ID .google.cloud.backupdr.v1.BackupRule.standard_schedule, latest field was standardSchedule",
                                ));
                            }
                            result.backup_schedule_oneof = std::option::Option::Some(
                                crate::model::backup_rule::BackupScheduleOneof::StandardSchedule(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StandardSchedule>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rule_id.is_empty() {
            state.serialize_entry("ruleId", &self.rule_id)?;
        }
        if !wkt::internal::is_default(&self.backup_retention_days) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("backupRetentionDays", &__With(&self.backup_retention_days))?;
        }
        if let Some(value) = self.standard_schedule() {
            state.serialize_entry("standardSchedule", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BackupRule].
pub mod backup_rule {
    #[allow(unused_imports)]
    use super::*;

    /// The schedule that defines the automated backup workloads for this
    /// `BackupRule`.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BackupScheduleOneof {
        /// Required. Defines a schedule that runs within the confines of a defined
        /// window of time.
        StandardSchedule(std::boxed::Box<crate::model::StandardSchedule>),
    }
}

/// `StandardSchedule` defines a schedule that run within the confines of a
/// defined window of days. We can define recurrence type for schedule as
/// HOURLY, DAILY, WEEKLY, MONTHLY or YEARLY.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StandardSchedule {
    /// Required. Specifies the `RecurrenceType` for the schedule.
    pub recurrence_type: crate::model::standard_schedule::RecurrenceType,

    /// Optional. Specifies frequency for hourly backups. A hourly frequency of 2
    /// means jobs will run every 2 hours from start time till end time defined.
    ///
    /// This is required for `recurrence_type`, `HOURLY` and is not applicable
    /// otherwise. A validation error will occur if a value is supplied and
    /// `recurrence_type` is not `HOURLY`.
    ///
    /// Value of hourly frequency should be between 6 and 23.
    ///
    /// Reason for limit : We found that there is bandwidth limitation of 3GB/S for
    /// GMI while taking a backup and 5GB/S while doing a restore. Given the amount
    /// of parallel backups and restore we are targeting, this will potentially
    /// take the backup time to mins and hours (in worst case scenario).
    pub hourly_frequency: i32,

    /// Optional. Specifies days of week like, MONDAY or TUESDAY, on which jobs
    /// will run.
    ///
    /// This is required for `recurrence_type`, `WEEKLY` and is not applicable
    /// otherwise. A validation error will occur if a value is supplied and
    /// `recurrence_type` is not `WEEKLY`.
    pub days_of_week: std::vec::Vec<gtype::model::DayOfWeek>,

    /// Optional. Specifies days of months like 1, 5, or 14 on which jobs will run.
    ///
    /// Values for `days_of_month` are only applicable for `recurrence_type`,
    /// `MONTHLY` and `YEARLY`. A validation error will occur if other values are
    /// supplied.
    pub days_of_month: std::vec::Vec<i32>,

    /// Optional. Specifies a week day of the month like, FIRST SUNDAY or LAST
    /// MONDAY, on which jobs will run. This will be specified by two fields in
    /// `WeekDayOfMonth`, one for the day, e.g. `MONDAY`, and one for the week,
    /// e.g. `LAST`.
    ///
    /// This field is only applicable for `recurrence_type`, `MONTHLY` and
    /// `YEARLY`. A validation error will occur if other values are supplied.
    pub week_day_of_month: std::option::Option<crate::model::WeekDayOfMonth>,

    /// Optional. Specifies the months of year, like `FEBRUARY` and/or `MAY`, on
    /// which jobs will run.
    ///
    /// This field is only applicable when `recurrence_type` is `YEARLY`. A
    /// validation error will occur if other values are supplied.
    pub months: std::vec::Vec<gtype::model::Month>,

    /// Required. A BackupWindow defines the window of day during which backup jobs
    /// will run. Jobs are queued at the beginning of the window and will be marked
    /// as `NOT_RUN` if they do not start by the end of the window.
    ///
    /// Note: running jobs will not be cancelled at the end of the window.
    pub backup_window: std::option::Option<crate::model::BackupWindow>,

    /// Required. The time zone to be used when interpreting the schedule.
    /// The value of this field must be a time zone name from the IANA tz database.
    /// See <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones> for the
    /// list of valid timezone names. For e.g., Europe/Paris.
    pub time_zone: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StandardSchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recurrence_type][crate::model::StandardSchedule::recurrence_type].
    pub fn set_recurrence_type<
        T: std::convert::Into<crate::model::standard_schedule::RecurrenceType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recurrence_type = v.into();
        self
    }

    /// Sets the value of [hourly_frequency][crate::model::StandardSchedule::hourly_frequency].
    pub fn set_hourly_frequency<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.hourly_frequency = v.into();
        self
    }

    /// Sets the value of [days_of_week][crate::model::StandardSchedule::days_of_week].
    pub fn set_days_of_week<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<gtype::model::DayOfWeek>,
    {
        use std::iter::Iterator;
        self.days_of_week = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [days_of_month][crate::model::StandardSchedule::days_of_month].
    pub fn set_days_of_month<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.days_of_month = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [week_day_of_month][crate::model::StandardSchedule::week_day_of_month].
    pub fn set_week_day_of_month<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WeekDayOfMonth>,
    {
        self.week_day_of_month = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [week_day_of_month][crate::model::StandardSchedule::week_day_of_month].
    pub fn set_or_clear_week_day_of_month<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WeekDayOfMonth>,
    {
        self.week_day_of_month = v.map(|x| x.into());
        self
    }

    /// Sets the value of [months][crate::model::StandardSchedule::months].
    pub fn set_months<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<gtype::model::Month>,
    {
        use std::iter::Iterator;
        self.months = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [backup_window][crate::model::StandardSchedule::backup_window].
    pub fn set_backup_window<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupWindow>,
    {
        self.backup_window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_window][crate::model::StandardSchedule::backup_window].
    pub fn set_or_clear_backup_window<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupWindow>,
    {
        self.backup_window = v.map(|x| x.into());
        self
    }

    /// Sets the value of [time_zone][crate::model::StandardSchedule::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }
}

impl wkt::message::Message for StandardSchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.StandardSchedule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StandardSchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __recurrence_type,
            __hourly_frequency,
            __days_of_week,
            __days_of_month,
            __week_day_of_month,
            __months,
            __backup_window,
            __time_zone,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StandardSchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recurrenceType" => Ok(__FieldTag::__recurrence_type),
                            "recurrence_type" => Ok(__FieldTag::__recurrence_type),
                            "hourlyFrequency" => Ok(__FieldTag::__hourly_frequency),
                            "hourly_frequency" => Ok(__FieldTag::__hourly_frequency),
                            "daysOfWeek" => Ok(__FieldTag::__days_of_week),
                            "days_of_week" => Ok(__FieldTag::__days_of_week),
                            "daysOfMonth" => Ok(__FieldTag::__days_of_month),
                            "days_of_month" => Ok(__FieldTag::__days_of_month),
                            "weekDayOfMonth" => Ok(__FieldTag::__week_day_of_month),
                            "week_day_of_month" => Ok(__FieldTag::__week_day_of_month),
                            "months" => Ok(__FieldTag::__months),
                            "backupWindow" => Ok(__FieldTag::__backup_window),
                            "backup_window" => Ok(__FieldTag::__backup_window),
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StandardSchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StandardSchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__recurrence_type => {
                            if !fields.insert(__FieldTag::__recurrence_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recurrence_type",
                                ));
                            }
                            result.recurrence_type = map
                                .next_value::<std::option::Option<
                                    crate::model::standard_schedule::RecurrenceType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hourly_frequency => {
                            if !fields.insert(__FieldTag::__hourly_frequency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hourly_frequency",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hourly_frequency =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__days_of_week => {
                            if !fields.insert(__FieldTag::__days_of_week) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for days_of_week",
                                ));
                            }
                            result.days_of_week = map.next_value::<std::option::Option<std::vec::Vec<gtype::model::DayOfWeek>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__days_of_month => {
                            if !fields.insert(__FieldTag::__days_of_month) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for days_of_month",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.days_of_month =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__week_day_of_month => {
                            if !fields.insert(__FieldTag::__week_day_of_month) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for week_day_of_month",
                                ));
                            }
                            result.week_day_of_month = map
                                .next_value::<std::option::Option<crate::model::WeekDayOfMonth>>(
                                )?;
                        }
                        __FieldTag::__months => {
                            if !fields.insert(__FieldTag::__months) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for months",
                                ));
                            }
                            result.months = map.next_value::<std::option::Option<std::vec::Vec<gtype::model::Month>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__backup_window => {
                            if !fields.insert(__FieldTag::__backup_window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_window",
                                ));
                            }
                            result.backup_window = map
                                .next_value::<std::option::Option<crate::model::BackupWindow>>()?;
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StandardSchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.recurrence_type) {
            state.serialize_entry("recurrenceType", &self.recurrence_type)?;
        }
        if !wkt::internal::is_default(&self.hourly_frequency) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("hourlyFrequency", &__With(&self.hourly_frequency))?;
        }
        if !self.days_of_week.is_empty() {
            state.serialize_entry("daysOfWeek", &self.days_of_week)?;
        }
        if !self.days_of_month.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("daysOfMonth", &__With(&self.days_of_month))?;
        }
        if self.week_day_of_month.is_some() {
            state.serialize_entry("weekDayOfMonth", &self.week_day_of_month)?;
        }
        if !self.months.is_empty() {
            state.serialize_entry("months", &self.months)?;
        }
        if self.backup_window.is_some() {
            state.serialize_entry("backupWindow", &self.backup_window)?;
        }
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StandardSchedule].
pub mod standard_schedule {
    #[allow(unused_imports)]
    use super::*;

    /// `RecurrenceTypes` enumerates the applicable periodicity for the schedule.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RecurrenceType {
        /// recurrence type not set
        Unspecified,
        /// The `BackupRule` is to be applied hourly.
        Hourly,
        /// The `BackupRule` is to be applied daily.
        Daily,
        /// The `BackupRule` is to be applied weekly.
        Weekly,
        /// The `BackupRule` is to be applied monthly.
        Monthly,
        /// The `BackupRule` is to be applied yearly.
        Yearly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RecurrenceType::value] or
        /// [RecurrenceType::name].
        UnknownValue(recurrence_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod recurrence_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RecurrenceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Hourly => std::option::Option::Some(1),
                Self::Daily => std::option::Option::Some(2),
                Self::Weekly => std::option::Option::Some(3),
                Self::Monthly => std::option::Option::Some(4),
                Self::Yearly => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RECURRENCE_TYPE_UNSPECIFIED"),
                Self::Hourly => std::option::Option::Some("HOURLY"),
                Self::Daily => std::option::Option::Some("DAILY"),
                Self::Weekly => std::option::Option::Some("WEEKLY"),
                Self::Monthly => std::option::Option::Some("MONTHLY"),
                Self::Yearly => std::option::Option::Some("YEARLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RecurrenceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RecurrenceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RecurrenceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Hourly,
                2 => Self::Daily,
                3 => Self::Weekly,
                4 => Self::Monthly,
                5 => Self::Yearly,
                _ => Self::UnknownValue(recurrence_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RecurrenceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RECURRENCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "HOURLY" => Self::Hourly,
                "DAILY" => Self::Daily,
                "WEEKLY" => Self::Weekly,
                "MONTHLY" => Self::Monthly,
                "YEARLY" => Self::Yearly,
                _ => Self::UnknownValue(recurrence_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RecurrenceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Hourly => serializer.serialize_i32(1),
                Self::Daily => serializer.serialize_i32(2),
                Self::Weekly => serializer.serialize_i32(3),
                Self::Monthly => serializer.serialize_i32(4),
                Self::Yearly => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RecurrenceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RecurrenceType>::new(
                ".google.cloud.backupdr.v1.StandardSchedule.RecurrenceType",
            ))
        }
    }
}

/// `BackupWindow` defines a window of the day during which backup jobs will run.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupWindow {
    /// Required. The hour of day (0-23) when the window starts for e.g. if value
    /// of start hour of day is 6 that mean backup window start at 6:00.
    pub start_hour_of_day: i32,

    /// Required. The hour of day (1-24) when the window end for e.g. if value of
    /// end hour of day is 10 that mean backup window end time is 10:00.
    ///
    /// End hour of day should be greater than start hour of day.
    /// 0 <= start_hour_of_day < end_hour_of_day <= 24
    ///
    /// End hour of day is not include in backup window that mean if
    /// end_hour_of_day= 10 jobs should start before 10:00.
    pub end_hour_of_day: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_hour_of_day][crate::model::BackupWindow::start_hour_of_day].
    pub fn set_start_hour_of_day<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.start_hour_of_day = v.into();
        self
    }

    /// Sets the value of [end_hour_of_day][crate::model::BackupWindow::end_hour_of_day].
    pub fn set_end_hour_of_day<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.end_hour_of_day = v.into();
        self
    }
}

impl wkt::message::Message for BackupWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupWindow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_hour_of_day,
            __end_hour_of_day,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startHourOfDay" => Ok(__FieldTag::__start_hour_of_day),
                            "start_hour_of_day" => Ok(__FieldTag::__start_hour_of_day),
                            "endHourOfDay" => Ok(__FieldTag::__end_hour_of_day),
                            "end_hour_of_day" => Ok(__FieldTag::__end_hour_of_day),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_hour_of_day => {
                            if !fields.insert(__FieldTag::__start_hour_of_day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_hour_of_day",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.start_hour_of_day =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__end_hour_of_day => {
                            if !fields.insert(__FieldTag::__end_hour_of_day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_hour_of_day",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.end_hour_of_day =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.start_hour_of_day) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("startHourOfDay", &__With(&self.start_hour_of_day))?;
        }
        if !wkt::internal::is_default(&self.end_hour_of_day) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("endHourOfDay", &__With(&self.end_hour_of_day))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `WeekDayOfMonth` defines the week day of the month on which the backups will
/// run. The message combines a `WeekOfMonth` and `DayOfWeek` to produce values
/// like `FIRST`/`MONDAY` or `LAST`/`FRIDAY`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WeekDayOfMonth {
    /// Required. Specifies the week of the month.
    pub week_of_month: crate::model::week_day_of_month::WeekOfMonth,

    /// Required. Specifies the day of the week.
    pub day_of_week: gtype::model::DayOfWeek,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WeekDayOfMonth {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [week_of_month][crate::model::WeekDayOfMonth::week_of_month].
    pub fn set_week_of_month<
        T: std::convert::Into<crate::model::week_day_of_month::WeekOfMonth>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.week_of_month = v.into();
        self
    }

    /// Sets the value of [day_of_week][crate::model::WeekDayOfMonth::day_of_week].
    pub fn set_day_of_week<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day_of_week = v.into();
        self
    }
}

impl wkt::message::Message for WeekDayOfMonth {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.WeekDayOfMonth"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WeekDayOfMonth {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __week_of_month,
            __day_of_week,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WeekDayOfMonth")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "weekOfMonth" => Ok(__FieldTag::__week_of_month),
                            "week_of_month" => Ok(__FieldTag::__week_of_month),
                            "dayOfWeek" => Ok(__FieldTag::__day_of_week),
                            "day_of_week" => Ok(__FieldTag::__day_of_week),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WeekDayOfMonth;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WeekDayOfMonth")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__week_of_month => {
                            if !fields.insert(__FieldTag::__week_of_month) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for week_of_month",
                                ));
                            }
                            result.week_of_month =
                                map.next_value::<std::option::Option<
                                    crate::model::week_day_of_month::WeekOfMonth,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__day_of_week => {
                            if !fields.insert(__FieldTag::__day_of_week) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for day_of_week",
                                ));
                            }
                            result.day_of_week = map
                                .next_value::<std::option::Option<gtype::model::DayOfWeek>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WeekDayOfMonth {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.week_of_month) {
            state.serialize_entry("weekOfMonth", &self.week_of_month)?;
        }
        if !wkt::internal::is_default(&self.day_of_week) {
            state.serialize_entry("dayOfWeek", &self.day_of_week)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [WeekDayOfMonth].
pub mod week_day_of_month {
    #[allow(unused_imports)]
    use super::*;

    /// `WeekOfMonth` enumerates possible weeks in the month, e.g. the first,
    /// third, or last week of the month.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WeekOfMonth {
        /// The zero value. Do not use.
        Unspecified,
        /// The first week of the month.
        First,
        /// The second week of the month.
        Second,
        /// The third week of the month.
        Third,
        /// The fourth  week of the month.
        Fourth,
        /// The last  week of the month.
        Last,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [WeekOfMonth::value] or
        /// [WeekOfMonth::name].
        UnknownValue(week_of_month::UnknownValue),
    }

    #[doc(hidden)]
    pub mod week_of_month {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl WeekOfMonth {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::First => std::option::Option::Some(1),
                Self::Second => std::option::Option::Some(2),
                Self::Third => std::option::Option::Some(3),
                Self::Fourth => std::option::Option::Some(4),
                Self::Last => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("WEEK_OF_MONTH_UNSPECIFIED"),
                Self::First => std::option::Option::Some("FIRST"),
                Self::Second => std::option::Option::Some("SECOND"),
                Self::Third => std::option::Option::Some("THIRD"),
                Self::Fourth => std::option::Option::Some("FOURTH"),
                Self::Last => std::option::Option::Some("LAST"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for WeekOfMonth {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for WeekOfMonth {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for WeekOfMonth {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::First,
                2 => Self::Second,
                3 => Self::Third,
                4 => Self::Fourth,
                5 => Self::Last,
                _ => Self::UnknownValue(week_of_month::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for WeekOfMonth {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "WEEK_OF_MONTH_UNSPECIFIED" => Self::Unspecified,
                "FIRST" => Self::First,
                "SECOND" => Self::Second,
                "THIRD" => Self::Third,
                "FOURTH" => Self::Fourth,
                "LAST" => Self::Last,
                _ => Self::UnknownValue(week_of_month::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for WeekOfMonth {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::First => serializer.serialize_i32(1),
                Self::Second => serializer.serialize_i32(2),
                Self::Third => serializer.serialize_i32(3),
                Self::Fourth => serializer.serialize_i32(4),
                Self::Last => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for WeekOfMonth {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<WeekOfMonth>::new(
                ".google.cloud.backupdr.v1.WeekDayOfMonth.WeekOfMonth",
            ))
        }
    }
}

/// The request message for creating a `BackupPlan`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBackupPlanRequest {
    /// Required. The `BackupPlan` project and location in the format
    /// `projects/{project}/locations/{location}`. In Cloud BackupDR locations
    /// map to GCP regions, for example **us-central1**.
    pub parent: std::string::String,

    /// Required. The name of the `BackupPlan` to create. The name must be unique
    /// for the specified project and location.The name must start with a lowercase
    /// letter followed by up to 62 lowercase letters, numbers, or hyphens.
    /// Pattern, /[a-z][a-z0-9-]{,62}/.
    pub backup_plan_id: std::string::String,

    /// Required. The `BackupPlan` resource object to create.
    pub backup_plan: std::option::Option<crate::model::BackupPlan>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupPlanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupPlanRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_plan_id][crate::model::CreateBackupPlanRequest::backup_plan_id].
    pub fn set_backup_plan_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_plan_id = v.into();
        self
    }

    /// Sets the value of [backup_plan][crate::model::CreateBackupPlanRequest::backup_plan].
    pub fn set_backup_plan<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupPlan>,
    {
        self.backup_plan = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_plan][crate::model::CreateBackupPlanRequest::backup_plan].
    pub fn set_or_clear_backup_plan<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupPlan>,
    {
        self.backup_plan = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateBackupPlanRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupPlanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.CreateBackupPlanRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBackupPlanRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __backup_plan_id,
            __backup_plan,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBackupPlanRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "backupPlanId" => Ok(__FieldTag::__backup_plan_id),
                            "backup_plan_id" => Ok(__FieldTag::__backup_plan_id),
                            "backupPlan" => Ok(__FieldTag::__backup_plan),
                            "backup_plan" => Ok(__FieldTag::__backup_plan),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBackupPlanRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBackupPlanRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_plan_id => {
                            if !fields.insert(__FieldTag::__backup_plan_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan_id",
                                ));
                            }
                            result.backup_plan_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_plan => {
                            if !fields.insert(__FieldTag::__backup_plan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan",
                                ));
                            }
                            result.backup_plan =
                                map.next_value::<std::option::Option<crate::model::BackupPlan>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBackupPlanRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.backup_plan_id.is_empty() {
            state.serialize_entry("backupPlanId", &self.backup_plan_id)?;
        }
        if self.backup_plan.is_some() {
            state.serialize_entry("backupPlan", &self.backup_plan)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for getting a list `BackupPlan`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupPlansRequest {
    /// Required. The project and location for which to retrieve `BackupPlans`
    /// information. Format: `projects/{project}/locations/{location}`. In Cloud
    /// BackupDR, locations map to GCP regions, for e.g. **us-central1**. To
    /// retrieve backup plans for all locations, use "-" for the
    /// `{location}` value.
    pub parent: std::string::String,

    /// Optional. The maximum number of `BackupPlans` to return in a single
    /// response. If not specified, a default value will be chosen by the service.
    /// Note that the response may include a partial list and a caller should
    /// only rely on the response's
    /// [next_page_token][google.cloud.backupdr.v1.ListBackupPlansResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.backupdr.v1.ListBackupPlansResponse.next_page_token]: crate::model::ListBackupPlansResponse::next_page_token
    pub page_size: i32,

    /// Optional. The value of
    /// [next_page_token][google.cloud.backupdr.v1.ListBackupPlansResponse.next_page_token]
    /// received from a previous `ListBackupPlans` call.
    /// Provide this to retrieve the subsequent page in a multi-page list of
    /// results. When paginating, all other parameters provided to
    /// `ListBackupPlans` must match the call that provided the page token.
    ///
    /// [google.cloud.backupdr.v1.ListBackupPlansResponse.next_page_token]: crate::model::ListBackupPlansResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Field match expression used to filter the results.
    pub filter: std::string::String,

    /// Optional. Field by which to sort the results.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupPlansRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupPlansRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupPlansRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupPlansRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupPlansRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupPlansRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupPlansRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListBackupPlansRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupPlansRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupPlansRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupPlansRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupPlansRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupPlansRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for getting a list of `BackupPlan`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupPlansResponse {
    /// The list of `BackupPlans` in the project for the specified
    /// location.
    ///
    /// If the `{location}` value in the request is "-", the response contains a
    /// list of resources from all locations. In case any location is unreachable,
    /// the response will only return backup plans in reachable locations and
    /// the 'unreachable' field will be populated with a list of unreachable
    /// locations.
    /// BackupPlan
    pub backup_plans: std::vec::Vec<crate::model::BackupPlan>,

    /// A token which may be sent as
    /// [page_token][google.cloud.backupdr.v1.ListBackupPlansRequest.page_token] in
    /// a subsequent `ListBackupPlans` call to retrieve the next page of results.
    /// If this field is omitted or empty, then there are no more results to
    /// return.
    ///
    /// [google.cloud.backupdr.v1.ListBackupPlansRequest.page_token]: crate::model::ListBackupPlansRequest::page_token
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupPlansResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_plans][crate::model::ListBackupPlansResponse::backup_plans].
    pub fn set_backup_plans<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupPlan>,
    {
        use std::iter::Iterator;
        self.backup_plans = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupPlansResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupPlansResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupPlansResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListBackupPlansResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupPlansResponse {
    type PageItem = crate::model::BackupPlan;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backup_plans
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupPlansResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_plans,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupPlansResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupPlans" => Ok(__FieldTag::__backup_plans),
                            "backup_plans" => Ok(__FieldTag::__backup_plans),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupPlansResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupPlansResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_plans => {
                            if !fields.insert(__FieldTag::__backup_plans) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plans",
                                ));
                            }
                            result.backup_plans = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BackupPlan>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupPlansResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup_plans.is_empty() {
            state.serialize_entry("backupPlans", &self.backup_plans)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for getting a `BackupPlan`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupPlanRequest {
    /// Required. The resource name of the `BackupPlan` to retrieve.
    ///
    /// Format: `projects/{project}/locations/{location}/backupPlans/{backup_plan}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupPlanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupPlanRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupPlanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.GetBackupPlanRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupPlanRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupPlanRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupPlanRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupPlanRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupPlanRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for deleting a `BackupPlan`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBackupPlanRequest {
    /// Required. The resource name of the `BackupPlan` to delete.
    ///
    /// Format: `projects/{project}/locations/{location}/backupPlans/{backup_plan}`
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupPlanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupPlanRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteBackupPlanRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupPlanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.DeleteBackupPlanRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBackupPlanRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBackupPlanRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBackupPlanRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBackupPlanRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBackupPlanRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A BackupPlanAssociation represents a single BackupPlanAssociation which
/// contains details like workload, backup plan etc
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupPlanAssociation {
    /// Output only. Identifier. The resource name of BackupPlanAssociation in
    /// below format Format :
    /// projects/{project}/locations/{location}/backupPlanAssociations/{backupPlanAssociationId}
    pub name: std::string::String,

    /// Required. Immutable. Resource type of workload on which backupplan is
    /// applied
    pub resource_type: std::string::String,

    /// Required. Immutable. Resource name of workload on which backupplan is
    /// applied
    pub resource: std::string::String,

    /// Required. Resource name of backup plan which needs to be applied on
    /// workload. Format:
    /// projects/{project}/locations/{location}/backupPlans/{backupPlanId}
    pub backup_plan: std::string::String,

    /// Output only. The time when the instance was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the instance was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The BackupPlanAssociation resource state.
    pub state: crate::model::backup_plan_association::State,

    /// Output only. The config info related to backup rules.
    pub rules_config_info: std::vec::Vec<crate::model::RuleConfigInfo>,

    /// Output only. Resource name of data source which will be used as storage
    /// location for backups taken. Format :
    /// projects/{project}/locations/{location}/backupVaults/{backupvault}/dataSources/{datasource}
    pub data_source: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupPlanAssociation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupPlanAssociation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [resource_type][crate::model::BackupPlanAssociation::resource_type].
    pub fn set_resource_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::BackupPlanAssociation::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [backup_plan][crate::model::BackupPlanAssociation::backup_plan].
    pub fn set_backup_plan<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_plan = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupPlanAssociation::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BackupPlanAssociation::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::BackupPlanAssociation::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::BackupPlanAssociation::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::BackupPlanAssociation::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup_plan_association::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [rules_config_info][crate::model::BackupPlanAssociation::rules_config_info].
    pub fn set_rules_config_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RuleConfigInfo>,
    {
        use std::iter::Iterator;
        self.rules_config_info = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_source][crate::model::BackupPlanAssociation::data_source].
    pub fn set_data_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_source = v.into();
        self
    }
}

impl wkt::message::Message for BackupPlanAssociation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupPlanAssociation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupPlanAssociation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __resource_type,
            __resource,
            __backup_plan,
            __create_time,
            __update_time,
            __state,
            __rules_config_info,
            __data_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupPlanAssociation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "resourceType" => Ok(__FieldTag::__resource_type),
                            "resource_type" => Ok(__FieldTag::__resource_type),
                            "resource" => Ok(__FieldTag::__resource),
                            "backupPlan" => Ok(__FieldTag::__backup_plan),
                            "backup_plan" => Ok(__FieldTag::__backup_plan),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "state" => Ok(__FieldTag::__state),
                            "rulesConfigInfo" => Ok(__FieldTag::__rules_config_info),
                            "rules_config_info" => Ok(__FieldTag::__rules_config_info),
                            "dataSource" => Ok(__FieldTag::__data_source),
                            "data_source" => Ok(__FieldTag::__data_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupPlanAssociation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupPlanAssociation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_type => {
                            if !fields.insert(__FieldTag::__resource_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type",
                                ));
                            }
                            result.resource_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_plan => {
                            if !fields.insert(__FieldTag::__backup_plan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan",
                                ));
                            }
                            result.backup_plan = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state =
                                map.next_value::<std::option::Option<
                                    crate::model::backup_plan_association::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rules_config_info => {
                            if !fields.insert(__FieldTag::__rules_config_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rules_config_info",
                                ));
                            }
                            result.rules_config_info =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RuleConfigInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_source => {
                            if !fields.insert(__FieldTag::__data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source",
                                ));
                            }
                            result.data_source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupPlanAssociation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.resource_type.is_empty() {
            state.serialize_entry("resourceType", &self.resource_type)?;
        }
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self.backup_plan.is_empty() {
            state.serialize_entry("backupPlan", &self.backup_plan)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.rules_config_info.is_empty() {
            state.serialize_entry("rulesConfigInfo", &self.rules_config_info)?;
        }
        if !self.data_source.is_empty() {
            state.serialize_entry("dataSource", &self.data_source)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BackupPlanAssociation].
pub mod backup_plan_association {
    #[allow(unused_imports)]
    use super::*;

    /// Enum for State of BackupPlan Association
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State not set.
        Unspecified,
        /// The resource is being created.
        Creating,
        /// The resource has been created and is fully usable.
        Active,
        /// The resource is being deleted.
        Deleting,
        /// The resource has been created but is not usable.
        Inactive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Inactive => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                4 => Self::Inactive,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "INACTIVE" => Self::Inactive,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Inactive => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.backupdr.v1.BackupPlanAssociation.State",
            ))
        }
    }
}

/// Message for rules config info.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RuleConfigInfo {
    /// Output only. Backup Rule id fetched from backup plan.
    pub rule_id: std::string::String,

    /// Output only. The last backup state for rule.
    pub last_backup_state: crate::model::rule_config_info::LastBackupState,

    /// Output only. google.rpc.Status object to store the last backup error.
    pub last_backup_error: std::option::Option<rpc::model::Status>,

    /// Output only. The point in time when the last successful backup was captured
    /// from the source.
    pub last_successful_backup_consistency_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuleConfigInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rule_id][crate::model::RuleConfigInfo::rule_id].
    pub fn set_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_id = v.into();
        self
    }

    /// Sets the value of [last_backup_state][crate::model::RuleConfigInfo::last_backup_state].
    pub fn set_last_backup_state<
        T: std::convert::Into<crate::model::rule_config_info::LastBackupState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.last_backup_state = v.into();
        self
    }

    /// Sets the value of [last_backup_error][crate::model::RuleConfigInfo::last_backup_error].
    pub fn set_last_backup_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.last_backup_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_backup_error][crate::model::RuleConfigInfo::last_backup_error].
    pub fn set_or_clear_last_backup_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.last_backup_error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_successful_backup_consistency_time][crate::model::RuleConfigInfo::last_successful_backup_consistency_time].
    pub fn set_last_successful_backup_consistency_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_successful_backup_consistency_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_successful_backup_consistency_time][crate::model::RuleConfigInfo::last_successful_backup_consistency_time].
    pub fn set_or_clear_last_successful_backup_consistency_time<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_successful_backup_consistency_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RuleConfigInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.RuleConfigInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RuleConfigInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rule_id,
            __last_backup_state,
            __last_backup_error,
            __last_successful_backup_consistency_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RuleConfigInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ruleId" => Ok(__FieldTag::__rule_id),
                            "rule_id" => Ok(__FieldTag::__rule_id),
                            "lastBackupState" => Ok(__FieldTag::__last_backup_state),
                            "last_backup_state" => Ok(__FieldTag::__last_backup_state),
                            "lastBackupError" => Ok(__FieldTag::__last_backup_error),
                            "last_backup_error" => Ok(__FieldTag::__last_backup_error),
                            "lastSuccessfulBackupConsistencyTime" => {
                                Ok(__FieldTag::__last_successful_backup_consistency_time)
                            }
                            "last_successful_backup_consistency_time" => {
                                Ok(__FieldTag::__last_successful_backup_consistency_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RuleConfigInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RuleConfigInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rule_id => {
                            if !fields.insert(__FieldTag::__rule_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule_id",
                                ));
                            }
                            result.rule_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_backup_state => {
                            if !fields.insert(__FieldTag::__last_backup_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_backup_state",
                                ));
                            }
                            result.last_backup_state = map
                                .next_value::<std::option::Option<
                                    crate::model::rule_config_info::LastBackupState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_backup_error => {
                            if !fields.insert(__FieldTag::__last_backup_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_backup_error",
                                ));
                            }
                            result.last_backup_error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__last_successful_backup_consistency_time => {
                            if !fields.insert(__FieldTag::__last_successful_backup_consistency_time)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_successful_backup_consistency_time",
                                ));
                            }
                            result.last_successful_backup_consistency_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RuleConfigInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rule_id.is_empty() {
            state.serialize_entry("ruleId", &self.rule_id)?;
        }
        if !wkt::internal::is_default(&self.last_backup_state) {
            state.serialize_entry("lastBackupState", &self.last_backup_state)?;
        }
        if self.last_backup_error.is_some() {
            state.serialize_entry("lastBackupError", &self.last_backup_error)?;
        }
        if self.last_successful_backup_consistency_time.is_some() {
            state.serialize_entry(
                "lastSuccessfulBackupConsistencyTime",
                &self.last_successful_backup_consistency_time,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RuleConfigInfo].
pub mod rule_config_info {
    #[allow(unused_imports)]
    use super::*;

    /// Enum for LastBackupState
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LastBackupState {
        /// State not set.
        Unspecified,
        /// The first backup is pending.
        FirstBackupPending,
        /// The most recent backup could not be run/failed because of the lack of
        /// permissions.
        PermissionDenied,
        /// The last backup operation succeeded.
        Succeeded,
        /// The last backup operation failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LastBackupState::value] or
        /// [LastBackupState::name].
        UnknownValue(last_backup_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod last_backup_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LastBackupState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FirstBackupPending => std::option::Option::Some(1),
                Self::PermissionDenied => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LAST_BACKUP_STATE_UNSPECIFIED"),
                Self::FirstBackupPending => std::option::Option::Some("FIRST_BACKUP_PENDING"),
                Self::PermissionDenied => std::option::Option::Some("PERMISSION_DENIED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LastBackupState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LastBackupState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LastBackupState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FirstBackupPending,
                2 => Self::PermissionDenied,
                3 => Self::Succeeded,
                4 => Self::Failed,
                _ => Self::UnknownValue(last_backup_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LastBackupState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LAST_BACKUP_STATE_UNSPECIFIED" => Self::Unspecified,
                "FIRST_BACKUP_PENDING" => Self::FirstBackupPending,
                "PERMISSION_DENIED" => Self::PermissionDenied,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(last_backup_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LastBackupState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FirstBackupPending => serializer.serialize_i32(1),
                Self::PermissionDenied => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LastBackupState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LastBackupState>::new(
                ".google.cloud.backupdr.v1.RuleConfigInfo.LastBackupState",
            ))
        }
    }
}

/// Request message for creating a backup plan.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBackupPlanAssociationRequest {
    /// Required. The backup plan association project and location in the format
    /// `projects/{project_id}/locations/{location}`. In Cloud BackupDR locations
    /// map to GCP regions, for example **us-central1**.
    pub parent: std::string::String,

    /// Required. The name of the backup plan association to create. The name must
    /// be unique for the specified project and location.
    pub backup_plan_association_id: std::string::String,

    /// Required. The resource being created
    pub backup_plan_association: std::option::Option<crate::model::BackupPlanAssociation>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupPlanAssociationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupPlanAssociationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_plan_association_id][crate::model::CreateBackupPlanAssociationRequest::backup_plan_association_id].
    pub fn set_backup_plan_association_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_plan_association_id = v.into();
        self
    }

    /// Sets the value of [backup_plan_association][crate::model::CreateBackupPlanAssociationRequest::backup_plan_association].
    pub fn set_backup_plan_association<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupPlanAssociation>,
    {
        self.backup_plan_association = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_plan_association][crate::model::CreateBackupPlanAssociationRequest::backup_plan_association].
    pub fn set_or_clear_backup_plan_association<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupPlanAssociation>,
    {
        self.backup_plan_association = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateBackupPlanAssociationRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupPlanAssociationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.CreateBackupPlanAssociationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBackupPlanAssociationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __backup_plan_association_id,
            __backup_plan_association,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBackupPlanAssociationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "backupPlanAssociationId" => {
                                Ok(__FieldTag::__backup_plan_association_id)
                            }
                            "backup_plan_association_id" => {
                                Ok(__FieldTag::__backup_plan_association_id)
                            }
                            "backupPlanAssociation" => Ok(__FieldTag::__backup_plan_association),
                            "backup_plan_association" => Ok(__FieldTag::__backup_plan_association),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBackupPlanAssociationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBackupPlanAssociationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_plan_association_id => {
                            if !fields.insert(__FieldTag::__backup_plan_association_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan_association_id",
                                ));
                            }
                            result.backup_plan_association_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_plan_association => {
                            if !fields.insert(__FieldTag::__backup_plan_association) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan_association",
                                ));
                            }
                            result.backup_plan_association = map.next_value::<std::option::Option<crate::model::BackupPlanAssociation>>()?
                                ;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBackupPlanAssociationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.backup_plan_association_id.is_empty() {
            state.serialize_entry("backupPlanAssociationId", &self.backup_plan_association_id)?;
        }
        if self.backup_plan_association.is_some() {
            state.serialize_entry("backupPlanAssociation", &self.backup_plan_association)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for List BackupPlanAssociation
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupPlanAssociationsRequest {
    /// Required. The project and location for which to retrieve backup Plan
    /// Associations information, in the format
    /// `projects/{project_id}/locations/{location}`. In Cloud BackupDR, locations
    /// map to GCP regions, for example **us-central1**. To retrieve backup plan
    /// associations for all locations, use "-" for the
    /// `{location}` value.
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupPlanAssociationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupPlanAssociationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupPlanAssociationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupPlanAssociationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupPlanAssociationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupPlanAssociationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListBackupPlanAssociationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupPlanAssociationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupPlanAssociationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupPlanAssociationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupPlanAssociationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupPlanAssociationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for List BackupPlanAssociation
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupPlanAssociationsResponse {
    /// The list of Backup Plan Associations in the project for the specified
    /// location.
    ///
    /// If the `{location}` value in the request is "-", the response contains a
    /// list of instances from all locations. In case any location is unreachable,
    /// the response will only return backup plan associations in reachable
    /// locations and the 'unreachable' field will be populated with a list of
    /// unreachable locations.
    pub backup_plan_associations: std::vec::Vec<crate::model::BackupPlanAssociation>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupPlanAssociationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_plan_associations][crate::model::ListBackupPlanAssociationsResponse::backup_plan_associations].
    pub fn set_backup_plan_associations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupPlanAssociation>,
    {
        use std::iter::Iterator;
        self.backup_plan_associations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupPlanAssociationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupPlanAssociationsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupPlanAssociationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListBackupPlanAssociationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupPlanAssociationsResponse {
    type PageItem = crate::model::BackupPlanAssociation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backup_plan_associations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupPlanAssociationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_plan_associations,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupPlanAssociationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupPlanAssociations" => Ok(__FieldTag::__backup_plan_associations),
                            "backup_plan_associations" => {
                                Ok(__FieldTag::__backup_plan_associations)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupPlanAssociationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupPlanAssociationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_plan_associations => {
                            if !fields.insert(__FieldTag::__backup_plan_associations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan_associations",
                                ));
                            }
                            result.backup_plan_associations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BackupPlanAssociation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupPlanAssociationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup_plan_associations.is_empty() {
            state.serialize_entry("backupPlanAssociations", &self.backup_plan_associations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for getting a BackupPlanAssociation resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupPlanAssociationRequest {
    /// Required. Name of the backup plan association resource, in the format
    /// `projects/{project}/locations/{location}/backupPlanAssociations/{backupPlanAssociationId}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupPlanAssociationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupPlanAssociationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupPlanAssociationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.GetBackupPlanAssociationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupPlanAssociationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupPlanAssociationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupPlanAssociationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupPlanAssociationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupPlanAssociationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for deleting a backup plan association.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBackupPlanAssociationRequest {
    /// Required. Name of the backup plan association resource, in the format
    /// `projects/{project}/locations/{location}/backupPlanAssociations/{backupPlanAssociationId}`
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupPlanAssociationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupPlanAssociationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteBackupPlanAssociationRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupPlanAssociationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.DeleteBackupPlanAssociationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBackupPlanAssociationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBackupPlanAssociationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBackupPlanAssociationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBackupPlanAssociationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBackupPlanAssociationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for triggering a backup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TriggerBackupRequest {
    /// Required. Name of the backup plan association resource, in the format
    /// `projects/{project}/locations/{location}/backupPlanAssociations/{backupPlanAssociationId}`
    pub name: std::string::String,

    /// Required. backup rule_id for which a backup needs to be triggered.
    pub rule_id: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TriggerBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TriggerBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [rule_id][crate::model::TriggerBackupRequest::rule_id].
    pub fn set_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::TriggerBackupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for TriggerBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.TriggerBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TriggerBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __rule_id,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TriggerBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ruleId" => Ok(__FieldTag::__rule_id),
                            "rule_id" => Ok(__FieldTag::__rule_id),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TriggerBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TriggerBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rule_id => {
                            if !fields.insert(__FieldTag::__rule_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule_id",
                                ));
                            }
                            result.rule_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TriggerBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.rule_id.is_empty() {
            state.serialize_entry("ruleId", &self.rule_id)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message describing a BackupVault object.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupVault {
    /// Output only. Identifier. Name of the backup vault to create. It must have
    /// the
    /// format`"projects/{project}/locations/{location}/backupVaults/{backupvault}"`.
    /// `{backupvault}` cannot be changed after creation. It must be between 3-63
    /// characters long and must be unique within the project and location.
    pub name: std::string::String,

    /// Optional. The description of the BackupVault instance (2048 characters or
    /// less).
    pub description: std::option::Option<std::string::String>,

    /// Optional. Resource labels to represent user provided metadata.
    /// No labels currently defined:
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The time when the instance was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the instance was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. The default and minimum enforced retention for each backup within
    /// the backup vault.  The enforced retention for each backup can be extended.
    pub backup_minimum_enforced_retention_duration: std::option::Option<wkt::Duration>,

    /// Output only. Set to true when there are no backups nested under this
    /// resource.
    pub deletable: std::option::Option<bool>,

    /// Optional. Server specified ETag for the backup vault resource to
    /// prevent simultaneous updates from overwiting each other.
    pub etag: std::option::Option<std::string::String>,

    /// Output only. The BackupVault resource instance state.
    pub state: crate::model::backup_vault::State,

    /// Optional. Time after which the BackupVault resource is locked.
    pub effective_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The number of backups in this backup vault.
    pub backup_count: i64,

    /// Output only. Service account used by the BackupVault Service for this
    /// BackupVault.  The user should grant this account permissions in their
    /// workload project to enable the service to run backups and restores there.
    pub service_account: std::string::String,

    /// Output only. Total size of the storage used by all backup resources.
    pub total_stored_bytes: i64,

    /// Output only. Immutable after resource creation until resource deletion.
    pub uid: std::string::String,

    /// Optional. User annotations. See <https://google.aip.dev/128#annotations>
    /// Stores small amounts of arbitrary data.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Note: This field is added for future use case and will not be
    /// supported in the current release.
    ///
    /// Access restriction for the backup vault.
    /// Default value is WITHIN_ORGANIZATION if not provided during creation.
    pub access_restriction: crate::model::backup_vault::AccessRestriction,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupVault {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupVault::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::BackupVault::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::BackupVault::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::BackupVault::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupVault::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BackupVault::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::BackupVault::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::BackupVault::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_minimum_enforced_retention_duration][crate::model::BackupVault::backup_minimum_enforced_retention_duration].
    pub fn set_backup_minimum_enforced_retention_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.backup_minimum_enforced_retention_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_minimum_enforced_retention_duration][crate::model::BackupVault::backup_minimum_enforced_retention_duration].
    pub fn set_or_clear_backup_minimum_enforced_retention_duration<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.backup_minimum_enforced_retention_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deletable][crate::model::BackupVault::deletable].
    pub fn set_deletable<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deletable = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deletable][crate::model::BackupVault::deletable].
    pub fn set_or_clear_deletable<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deletable = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::BackupVault::etag].
    pub fn set_etag<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.etag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [etag][crate::model::BackupVault::etag].
    pub fn set_or_clear_etag<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.etag = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::BackupVault::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup_vault::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [effective_time][crate::model::BackupVault::effective_time].
    pub fn set_effective_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.effective_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [effective_time][crate::model::BackupVault::effective_time].
    pub fn set_or_clear_effective_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.effective_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_count][crate::model::BackupVault::backup_count].
    pub fn set_backup_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.backup_count = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::BackupVault::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [total_stored_bytes][crate::model::BackupVault::total_stored_bytes].
    pub fn set_total_stored_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_stored_bytes = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::BackupVault::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::BackupVault::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [access_restriction][crate::model::BackupVault::access_restriction].
    pub fn set_access_restriction<
        T: std::convert::Into<crate::model::backup_vault::AccessRestriction>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.access_restriction = v.into();
        self
    }
}

impl wkt::message::Message for BackupVault {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupVault"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupVault {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __labels,
            __create_time,
            __update_time,
            __backup_minimum_enforced_retention_duration,
            __deletable,
            __etag,
            __state,
            __effective_time,
            __backup_count,
            __service_account,
            __total_stored_bytes,
            __uid,
            __annotations,
            __access_restriction,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupVault")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "backupMinimumEnforcedRetentionDuration" => {
                                Ok(__FieldTag::__backup_minimum_enforced_retention_duration)
                            }
                            "backup_minimum_enforced_retention_duration" => {
                                Ok(__FieldTag::__backup_minimum_enforced_retention_duration)
                            }
                            "deletable" => Ok(__FieldTag::__deletable),
                            "etag" => Ok(__FieldTag::__etag),
                            "state" => Ok(__FieldTag::__state),
                            "effectiveTime" => Ok(__FieldTag::__effective_time),
                            "effective_time" => Ok(__FieldTag::__effective_time),
                            "backupCount" => Ok(__FieldTag::__backup_count),
                            "backup_count" => Ok(__FieldTag::__backup_count),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "totalStoredBytes" => Ok(__FieldTag::__total_stored_bytes),
                            "total_stored_bytes" => Ok(__FieldTag::__total_stored_bytes),
                            "uid" => Ok(__FieldTag::__uid),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "accessRestriction" => Ok(__FieldTag::__access_restriction),
                            "access_restriction" => Ok(__FieldTag::__access_restriction),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupVault;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupVault")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__backup_minimum_enforced_retention_duration => {
                            if !fields
                                .insert(__FieldTag::__backup_minimum_enforced_retention_duration)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_minimum_enforced_retention_duration",
                                ));
                            }
                            result.backup_minimum_enforced_retention_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__deletable => {
                            if !fields.insert(__FieldTag::__deletable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deletable",
                                ));
                            }
                            result.deletable = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::backup_vault::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__effective_time => {
                            if !fields.insert(__FieldTag::__effective_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for effective_time",
                                ));
                            }
                            result.effective_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__backup_count => {
                            if !fields.insert(__FieldTag::__backup_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.backup_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_stored_bytes => {
                            if !fields.insert(__FieldTag::__total_stored_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_stored_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_stored_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__access_restriction => {
                            if !fields.insert(__FieldTag::__access_restriction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_restriction",
                                ));
                            }
                            result.access_restriction =
                                map.next_value::<std::option::Option<
                                    crate::model::backup_vault::AccessRestriction,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupVault {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.backup_minimum_enforced_retention_duration.is_some() {
            state.serialize_entry(
                "backupMinimumEnforcedRetentionDuration",
                &self.backup_minimum_enforced_retention_duration,
            )?;
        }
        if self.deletable.is_some() {
            state.serialize_entry("deletable", &self.deletable)?;
        }
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.effective_time.is_some() {
            state.serialize_entry("effectiveTime", &self.effective_time)?;
        }
        if !wkt::internal::is_default(&self.backup_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("backupCount", &__With(&self.backup_count))?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !wkt::internal::is_default(&self.total_stored_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalStoredBytes", &__With(&self.total_stored_bytes))?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !wkt::internal::is_default(&self.access_restriction) {
            state.serialize_entry("accessRestriction", &self.access_restriction)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BackupVault].
pub mod backup_vault {
    #[allow(unused_imports)]
    use super::*;

    /// Holds the state of the backup vault resource.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State not set.
        Unspecified,
        /// The backup vault is being created.
        Creating,
        /// The backup vault has been created and is fully usable.
        Active,
        /// The backup vault is being deleted.
        Deleting,
        /// The backup vault is experiencing an issue and might be unusable.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                4 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.backupdr.v1.BackupVault.State",
            ))
        }
    }

    /// Holds the access restriction for the backup vault.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AccessRestriction {
        /// Access restriction not set. If user does not provide any value or pass
        /// this value, it will be changed to WITHIN_ORGANIZATION.
        Unspecified,
        /// Access to or from resources outside your current project will be denied.
        WithinProject,
        /// Access to or from resources outside your current organization will be
        /// denied.
        WithinOrganization,
        /// No access restriction.
        Unrestricted,
        /// Access to or from resources outside your current organization will be
        /// denied except for backup appliance.
        WithinOrgButUnrestrictedForBa,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AccessRestriction::value] or
        /// [AccessRestriction::name].
        UnknownValue(access_restriction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod access_restriction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AccessRestriction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::WithinProject => std::option::Option::Some(1),
                Self::WithinOrganization => std::option::Option::Some(2),
                Self::Unrestricted => std::option::Option::Some(3),
                Self::WithinOrgButUnrestrictedForBa => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACCESS_RESTRICTION_UNSPECIFIED"),
                Self::WithinProject => std::option::Option::Some("WITHIN_PROJECT"),
                Self::WithinOrganization => std::option::Option::Some("WITHIN_ORGANIZATION"),
                Self::Unrestricted => std::option::Option::Some("UNRESTRICTED"),
                Self::WithinOrgButUnrestrictedForBa => {
                    std::option::Option::Some("WITHIN_ORG_BUT_UNRESTRICTED_FOR_BA")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AccessRestriction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AccessRestriction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AccessRestriction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::WithinProject,
                2 => Self::WithinOrganization,
                3 => Self::Unrestricted,
                4 => Self::WithinOrgButUnrestrictedForBa,
                _ => Self::UnknownValue(access_restriction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AccessRestriction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACCESS_RESTRICTION_UNSPECIFIED" => Self::Unspecified,
                "WITHIN_PROJECT" => Self::WithinProject,
                "WITHIN_ORGANIZATION" => Self::WithinOrganization,
                "UNRESTRICTED" => Self::Unrestricted,
                "WITHIN_ORG_BUT_UNRESTRICTED_FOR_BA" => Self::WithinOrgButUnrestrictedForBa,
                _ => Self::UnknownValue(access_restriction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AccessRestriction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::WithinProject => serializer.serialize_i32(1),
                Self::WithinOrganization => serializer.serialize_i32(2),
                Self::Unrestricted => serializer.serialize_i32(3),
                Self::WithinOrgButUnrestrictedForBa => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AccessRestriction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AccessRestriction>::new(
                ".google.cloud.backupdr.v1.BackupVault.AccessRestriction",
            ))
        }
    }
}

/// Message describing a DataSource object.
/// Datasource object used to represent Datasource details for both admin and
/// basic view.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataSource {
    /// Output only. Identifier. Name of the datasource to create.
    /// It must have the
    /// format`"projects/{project}/locations/{location}/backupVaults/{backupvault}/dataSources/{datasource}"`.
    /// `{datasource}` cannot be changed after creation. It must be between 3-63
    /// characters long and must be unique within the backup vault.
    pub name: std::string::String,

    /// Output only. The DataSource resource instance state.
    pub state: crate::model::data_source::State,

    /// Optional. Resource labels to represent user provided metadata.
    /// No labels currently defined:
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The time when the instance was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the instance was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Number of backups in the data source.
    pub backup_count: std::option::Option<i64>,

    /// Server specified ETag for the ManagementServer resource to prevent
    /// simultaneous updates from overwiting each other.
    pub etag: std::option::Option<std::string::String>,

    /// The number of bytes (metadata and data) stored in this datasource.
    pub total_stored_bytes: std::option::Option<i64>,

    /// Output only. The backup configuration state.
    pub config_state: crate::model::BackupConfigState,

    /// Output only. Details of how the resource is configured for backup.
    pub backup_config_info: std::option::Option<crate::model::BackupConfigInfo>,

    /// The source resource that is represented by this DataSource. It can be a
    /// Google Cloud resource, or one backed up by a Backup Appliance.
    pub source_resource: std::option::Option<crate::model::data_source::SourceResource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataSource::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DataSource::state].
    pub fn set_state<T: std::convert::Into<crate::model::data_source::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DataSource::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::DataSource::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DataSource::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DataSource::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DataSource::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_count][crate::model::DataSource::backup_count].
    pub fn set_backup_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.backup_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_count][crate::model::DataSource::backup_count].
    pub fn set_or_clear_backup_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.backup_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::DataSource::etag].
    pub fn set_etag<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.etag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [etag][crate::model::DataSource::etag].
    pub fn set_or_clear_etag<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.etag = v.map(|x| x.into());
        self
    }

    /// Sets the value of [total_stored_bytes][crate::model::DataSource::total_stored_bytes].
    pub fn set_total_stored_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.total_stored_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [total_stored_bytes][crate::model::DataSource::total_stored_bytes].
    pub fn set_or_clear_total_stored_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.total_stored_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config_state][crate::model::DataSource::config_state].
    pub fn set_config_state<T: std::convert::Into<crate::model::BackupConfigState>>(
        mut self,
        v: T,
    ) -> Self {
        self.config_state = v.into();
        self
    }

    /// Sets the value of [backup_config_info][crate::model::DataSource::backup_config_info].
    pub fn set_backup_config_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupConfigInfo>,
    {
        self.backup_config_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_config_info][crate::model::DataSource::backup_config_info].
    pub fn set_or_clear_backup_config_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupConfigInfo>,
    {
        self.backup_config_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_resource][crate::model::DataSource::source_resource].
    ///
    /// Note that all the setters affecting `source_resource` are mutually
    /// exclusive.
    pub fn set_source_resource<
        T: std::convert::Into<std::option::Option<crate::model::data_source::SourceResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_resource = v.into();
        self
    }

    /// The value of [source_resource][crate::model::DataSource::source_resource]
    /// if it holds a `DataSourceGcpResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_source_gcp_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataSourceGcpResource>> {
        #[allow(unreachable_patterns)]
        self.source_resource.as_ref().and_then(|v| match v {
            crate::model::data_source::SourceResource::DataSourceGcpResource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_resource][crate::model::DataSource::source_resource]
    /// to hold a `DataSourceGcpResource`.
    ///
    /// Note that all the setters affecting `source_resource` are
    /// mutually exclusive.
    pub fn set_data_source_gcp_resource<
        T: std::convert::Into<std::boxed::Box<crate::model::DataSourceGcpResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_resource = std::option::Option::Some(
            crate::model::data_source::SourceResource::DataSourceGcpResource(v.into()),
        );
        self
    }

    /// The value of [source_resource][crate::model::DataSource::source_resource]
    /// if it holds a `DataSourceBackupApplianceApplication`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_source_backup_appliance_application(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataSourceBackupApplianceApplication>>
    {
        #[allow(unreachable_patterns)]
        self.source_resource.as_ref().and_then(|v| match v {
            crate::model::data_source::SourceResource::DataSourceBackupApplianceApplication(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_resource][crate::model::DataSource::source_resource]
    /// to hold a `DataSourceBackupApplianceApplication`.
    ///
    /// Note that all the setters affecting `source_resource` are
    /// mutually exclusive.
    pub fn set_data_source_backup_appliance_application<
        T: std::convert::Into<std::boxed::Box<crate::model::DataSourceBackupApplianceApplication>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_resource = std::option::Option::Some(
            crate::model::data_source::SourceResource::DataSourceBackupApplianceApplication(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DataSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.DataSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state,
            __labels,
            __create_time,
            __update_time,
            __backup_count,
            __etag,
            __total_stored_bytes,
            __config_state,
            __backup_config_info,
            __data_source_gcp_resource,
            __data_source_backup_appliance_application,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "backupCount" => Ok(__FieldTag::__backup_count),
                            "backup_count" => Ok(__FieldTag::__backup_count),
                            "etag" => Ok(__FieldTag::__etag),
                            "totalStoredBytes" => Ok(__FieldTag::__total_stored_bytes),
                            "total_stored_bytes" => Ok(__FieldTag::__total_stored_bytes),
                            "configState" => Ok(__FieldTag::__config_state),
                            "config_state" => Ok(__FieldTag::__config_state),
                            "backupConfigInfo" => Ok(__FieldTag::__backup_config_info),
                            "backup_config_info" => Ok(__FieldTag::__backup_config_info),
                            "dataSourceGcpResource" => Ok(__FieldTag::__data_source_gcp_resource),
                            "data_source_gcp_resource" => {
                                Ok(__FieldTag::__data_source_gcp_resource)
                            }
                            "dataSourceBackupApplianceApplication" => {
                                Ok(__FieldTag::__data_source_backup_appliance_application)
                            }
                            "data_source_backup_appliance_application" => {
                                Ok(__FieldTag::__data_source_backup_appliance_application)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::data_source::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__backup_count => {
                            if !fields.insert(__FieldTag::__backup_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.backup_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__total_stored_bytes => {
                            if !fields.insert(__FieldTag::__total_stored_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_stored_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_stored_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__config_state => {
                            if !fields.insert(__FieldTag::__config_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_state",
                                ));
                            }
                            result.config_state = map
                                .next_value::<std::option::Option<crate::model::BackupConfigState>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_config_info => {
                            if !fields.insert(__FieldTag::__backup_config_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_config_info",
                                ));
                            }
                            result.backup_config_info = map
                                .next_value::<std::option::Option<crate::model::BackupConfigInfo>>(
                                )?;
                        }
                        __FieldTag::__data_source_gcp_resource => {
                            if !fields.insert(__FieldTag::__data_source_gcp_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source_gcp_resource",
                                ));
                            }
                            if result.source_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_resource`, a oneof with full ID .google.cloud.backupdr.v1.DataSource.data_source_gcp_resource, latest field was dataSourceGcpResource",
                                ));
                            }
                            result.source_resource = std::option::Option::Some(
                                crate::model::data_source::SourceResource::DataSourceGcpResource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DataSourceGcpResource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_source_backup_appliance_application => {
                            if !fields
                                .insert(__FieldTag::__data_source_backup_appliance_application)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source_backup_appliance_application",
                                ));
                            }
                            if result.source_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_resource`, a oneof with full ID .google.cloud.backupdr.v1.DataSource.data_source_backup_appliance_application, latest field was dataSourceBackupApplianceApplication",
                                ));
                            }
                            result.source_resource = std::option::Option::Some(
                                crate::model::data_source::SourceResource::DataSourceBackupApplianceApplication(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DataSourceBackupApplianceApplication>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.backup_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("backupCount", &__With(&self.backup_count))?;
        }
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.total_stored_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("totalStoredBytes", &__With(&self.total_stored_bytes))?;
        }
        if !wkt::internal::is_default(&self.config_state) {
            state.serialize_entry("configState", &self.config_state)?;
        }
        if self.backup_config_info.is_some() {
            state.serialize_entry("backupConfigInfo", &self.backup_config_info)?;
        }
        if let Some(value) = self.data_source_gcp_resource() {
            state.serialize_entry("dataSourceGcpResource", value)?;
        }
        if let Some(value) = self.data_source_backup_appliance_application() {
            state.serialize_entry("dataSourceBackupApplianceApplication", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataSource].
pub mod data_source {
    #[allow(unused_imports)]
    use super::*;

    /// Holds the state of the data source resource.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State not set.
        Unspecified,
        /// The data source is being created.
        Creating,
        /// The data source has been created and is fully usable.
        Active,
        /// The data source is being deleted.
        Deleting,
        /// The data source is experiencing an issue and might be unusable.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                4 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.backupdr.v1.DataSource.State",
            ))
        }
    }

    /// The source resource that is represented by this DataSource. It can be a
    /// Google Cloud resource, or one backed up by a Backup Appliance.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceResource {
        /// The backed up resource is a Google Cloud resource.
        /// The word 'DataSource' was included in the names to indicate that this is
        /// the representation of the Google Cloud resource used within the
        /// DataSource object.
        DataSourceGcpResource(std::boxed::Box<crate::model::DataSourceGcpResource>),
        /// The backed up resource is a backup appliance application.
        DataSourceBackupApplianceApplication(
            std::boxed::Box<crate::model::DataSourceBackupApplianceApplication>,
        ),
    }
}

/// BackupConfigInfo has information about how the resource is configured
/// for Backup and about the most recent backup to this vault.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupConfigInfo {
    /// Output only. The status of the last backup to this BackupVault
    pub last_backup_state: crate::model::backup_config_info::LastBackupState,

    /// Output only. If the last backup were successful, this field has the
    /// consistency date.
    pub last_successful_backup_consistency_time: std::option::Option<wkt::Timestamp>,

    /// Output only. If the last backup failed, this field has the error message.
    pub last_backup_error: std::option::Option<rpc::model::Status>,

    /// Configuration Info has the resource format-specific configuration.
    pub backup_config: std::option::Option<crate::model::backup_config_info::BackupConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupConfigInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [last_backup_state][crate::model::BackupConfigInfo::last_backup_state].
    pub fn set_last_backup_state<
        T: std::convert::Into<crate::model::backup_config_info::LastBackupState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.last_backup_state = v.into();
        self
    }

    /// Sets the value of [last_successful_backup_consistency_time][crate::model::BackupConfigInfo::last_successful_backup_consistency_time].
    pub fn set_last_successful_backup_consistency_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_successful_backup_consistency_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_successful_backup_consistency_time][crate::model::BackupConfigInfo::last_successful_backup_consistency_time].
    pub fn set_or_clear_last_successful_backup_consistency_time<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_successful_backup_consistency_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_backup_error][crate::model::BackupConfigInfo::last_backup_error].
    pub fn set_last_backup_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.last_backup_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_backup_error][crate::model::BackupConfigInfo::last_backup_error].
    pub fn set_or_clear_last_backup_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.last_backup_error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_config][crate::model::BackupConfigInfo::backup_config].
    ///
    /// Note that all the setters affecting `backup_config` are mutually
    /// exclusive.
    pub fn set_backup_config<
        T: std::convert::Into<std::option::Option<crate::model::backup_config_info::BackupConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_config = v.into();
        self
    }

    /// The value of [backup_config][crate::model::BackupConfigInfo::backup_config]
    /// if it holds a `GcpBackupConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcp_backup_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcpBackupConfig>> {
        #[allow(unreachable_patterns)]
        self.backup_config.as_ref().and_then(|v| match v {
            crate::model::backup_config_info::BackupConfig::GcpBackupConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backup_config][crate::model::BackupConfigInfo::backup_config]
    /// to hold a `GcpBackupConfig`.
    ///
    /// Note that all the setters affecting `backup_config` are
    /// mutually exclusive.
    pub fn set_gcp_backup_config<
        T: std::convert::Into<std::boxed::Box<crate::model::GcpBackupConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_config = std::option::Option::Some(
            crate::model::backup_config_info::BackupConfig::GcpBackupConfig(v.into()),
        );
        self
    }

    /// The value of [backup_config][crate::model::BackupConfigInfo::backup_config]
    /// if it holds a `BackupApplianceBackupConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backup_appliance_backup_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BackupApplianceBackupConfig>> {
        #[allow(unreachable_patterns)]
        self.backup_config.as_ref().and_then(|v| match v {
            crate::model::backup_config_info::BackupConfig::BackupApplianceBackupConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backup_config][crate::model::BackupConfigInfo::backup_config]
    /// to hold a `BackupApplianceBackupConfig`.
    ///
    /// Note that all the setters affecting `backup_config` are
    /// mutually exclusive.
    pub fn set_backup_appliance_backup_config<
        T: std::convert::Into<std::boxed::Box<crate::model::BackupApplianceBackupConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_config = std::option::Option::Some(
            crate::model::backup_config_info::BackupConfig::BackupApplianceBackupConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BackupConfigInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupConfigInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupConfigInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __last_backup_state,
            __last_successful_backup_consistency_time,
            __last_backup_error,
            __gcp_backup_config,
            __backup_appliance_backup_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupConfigInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lastBackupState" => Ok(__FieldTag::__last_backup_state),
                            "last_backup_state" => Ok(__FieldTag::__last_backup_state),
                            "lastSuccessfulBackupConsistencyTime" => {
                                Ok(__FieldTag::__last_successful_backup_consistency_time)
                            }
                            "last_successful_backup_consistency_time" => {
                                Ok(__FieldTag::__last_successful_backup_consistency_time)
                            }
                            "lastBackupError" => Ok(__FieldTag::__last_backup_error),
                            "last_backup_error" => Ok(__FieldTag::__last_backup_error),
                            "gcpBackupConfig" => Ok(__FieldTag::__gcp_backup_config),
                            "gcp_backup_config" => Ok(__FieldTag::__gcp_backup_config),
                            "backupApplianceBackupConfig" => {
                                Ok(__FieldTag::__backup_appliance_backup_config)
                            }
                            "backup_appliance_backup_config" => {
                                Ok(__FieldTag::__backup_appliance_backup_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupConfigInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupConfigInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__last_backup_state => {
                            if !fields.insert(__FieldTag::__last_backup_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_backup_state",
                                ));
                            }
                            result.last_backup_state = map
                                .next_value::<std::option::Option<
                                    crate::model::backup_config_info::LastBackupState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_successful_backup_consistency_time => {
                            if !fields.insert(__FieldTag::__last_successful_backup_consistency_time)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_successful_backup_consistency_time",
                                ));
                            }
                            result.last_successful_backup_consistency_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_backup_error => {
                            if !fields.insert(__FieldTag::__last_backup_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_backup_error",
                                ));
                            }
                            result.last_backup_error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__gcp_backup_config => {
                            if !fields.insert(__FieldTag::__gcp_backup_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_backup_config",
                                ));
                            }
                            if result.backup_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `backup_config`, a oneof with full ID .google.cloud.backupdr.v1.BackupConfigInfo.gcp_backup_config, latest field was gcpBackupConfig",
                                ));
                            }
                            result.backup_config = std::option::Option::Some(
                                crate::model::backup_config_info::BackupConfig::GcpBackupConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcpBackupConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__backup_appliance_backup_config => {
                            if !fields.insert(__FieldTag::__backup_appliance_backup_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_appliance_backup_config",
                                ));
                            }
                            if result.backup_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `backup_config`, a oneof with full ID .google.cloud.backupdr.v1.BackupConfigInfo.backup_appliance_backup_config, latest field was backupApplianceBackupConfig",
                                ));
                            }
                            result.backup_config = std::option::Option::Some(
                                crate::model::backup_config_info::BackupConfig::BackupApplianceBackupConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::BackupApplianceBackupConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupConfigInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.last_backup_state) {
            state.serialize_entry("lastBackupState", &self.last_backup_state)?;
        }
        if self.last_successful_backup_consistency_time.is_some() {
            state.serialize_entry(
                "lastSuccessfulBackupConsistencyTime",
                &self.last_successful_backup_consistency_time,
            )?;
        }
        if self.last_backup_error.is_some() {
            state.serialize_entry("lastBackupError", &self.last_backup_error)?;
        }
        if let Some(value) = self.gcp_backup_config() {
            state.serialize_entry("gcpBackupConfig", value)?;
        }
        if let Some(value) = self.backup_appliance_backup_config() {
            state.serialize_entry("backupApplianceBackupConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BackupConfigInfo].
pub mod backup_config_info {
    #[allow(unused_imports)]
    use super::*;

    /// LastBackupstate tracks whether the last backup was not yet started,
    /// successful, failed, or could not be run because of the lack of permissions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LastBackupState {
        /// Status not set.
        Unspecified,
        /// The first backup has not yet completed
        FirstBackupPending,
        /// The most recent backup was successful
        Succeeded,
        /// The most recent backup failed
        Failed,
        /// The most recent backup could not be run/failed because of the lack of
        /// permissions
        PermissionDenied,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LastBackupState::value] or
        /// [LastBackupState::name].
        UnknownValue(last_backup_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod last_backup_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LastBackupState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FirstBackupPending => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::PermissionDenied => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LAST_BACKUP_STATE_UNSPECIFIED"),
                Self::FirstBackupPending => std::option::Option::Some("FIRST_BACKUP_PENDING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::PermissionDenied => std::option::Option::Some("PERMISSION_DENIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LastBackupState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LastBackupState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LastBackupState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FirstBackupPending,
                2 => Self::Succeeded,
                3 => Self::Failed,
                4 => Self::PermissionDenied,
                _ => Self::UnknownValue(last_backup_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LastBackupState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LAST_BACKUP_STATE_UNSPECIFIED" => Self::Unspecified,
                "FIRST_BACKUP_PENDING" => Self::FirstBackupPending,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "PERMISSION_DENIED" => Self::PermissionDenied,
                _ => Self::UnknownValue(last_backup_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LastBackupState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FirstBackupPending => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::PermissionDenied => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LastBackupState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LastBackupState>::new(
                ".google.cloud.backupdr.v1.BackupConfigInfo.LastBackupState",
            ))
        }
    }

    /// Configuration Info has the resource format-specific configuration.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BackupConfig {
        /// Configuration for a Google Cloud resource.
        GcpBackupConfig(std::boxed::Box<crate::model::GcpBackupConfig>),
        /// Configuration for an application backed up by a Backup Appliance.
        BackupApplianceBackupConfig(std::boxed::Box<crate::model::BackupApplianceBackupConfig>),
    }
}

/// GcpBackupConfig captures the Backup configuration details for Google Cloud
/// resources. All Google Cloud resources regardless of type are protected with
/// backup plan associations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GcpBackupConfig {
    /// The name of the backup plan.
    pub backup_plan: std::string::String,

    /// The description of the backup plan.
    pub backup_plan_description: std::string::String,

    /// The name of the backup plan association.
    pub backup_plan_association: std::string::String,

    /// The names of the backup plan rules which point to this backupvault
    pub backup_plan_rules: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcpBackupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_plan][crate::model::GcpBackupConfig::backup_plan].
    pub fn set_backup_plan<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_plan = v.into();
        self
    }

    /// Sets the value of [backup_plan_description][crate::model::GcpBackupConfig::backup_plan_description].
    pub fn set_backup_plan_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_plan_description = v.into();
        self
    }

    /// Sets the value of [backup_plan_association][crate::model::GcpBackupConfig::backup_plan_association].
    pub fn set_backup_plan_association<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_plan_association = v.into();
        self
    }

    /// Sets the value of [backup_plan_rules][crate::model::GcpBackupConfig::backup_plan_rules].
    pub fn set_backup_plan_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.backup_plan_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GcpBackupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.GcpBackupConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcpBackupConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_plan,
            __backup_plan_description,
            __backup_plan_association,
            __backup_plan_rules,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcpBackupConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupPlan" => Ok(__FieldTag::__backup_plan),
                            "backup_plan" => Ok(__FieldTag::__backup_plan),
                            "backupPlanDescription" => Ok(__FieldTag::__backup_plan_description),
                            "backup_plan_description" => Ok(__FieldTag::__backup_plan_description),
                            "backupPlanAssociation" => Ok(__FieldTag::__backup_plan_association),
                            "backup_plan_association" => Ok(__FieldTag::__backup_plan_association),
                            "backupPlanRules" => Ok(__FieldTag::__backup_plan_rules),
                            "backup_plan_rules" => Ok(__FieldTag::__backup_plan_rules),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcpBackupConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcpBackupConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_plan => {
                            if !fields.insert(__FieldTag::__backup_plan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan",
                                ));
                            }
                            result.backup_plan = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_plan_description => {
                            if !fields.insert(__FieldTag::__backup_plan_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan_description",
                                ));
                            }
                            result.backup_plan_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_plan_association => {
                            if !fields.insert(__FieldTag::__backup_plan_association) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan_association",
                                ));
                            }
                            result.backup_plan_association = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_plan_rules => {
                            if !fields.insert(__FieldTag::__backup_plan_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan_rules",
                                ));
                            }
                            result.backup_plan_rules = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcpBackupConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup_plan.is_empty() {
            state.serialize_entry("backupPlan", &self.backup_plan)?;
        }
        if !self.backup_plan_description.is_empty() {
            state.serialize_entry("backupPlanDescription", &self.backup_plan_description)?;
        }
        if !self.backup_plan_association.is_empty() {
            state.serialize_entry("backupPlanAssociation", &self.backup_plan_association)?;
        }
        if !self.backup_plan_rules.is_empty() {
            state.serialize_entry("backupPlanRules", &self.backup_plan_rules)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// BackupApplianceBackupConfig captures the backup configuration for
/// applications that are protected by Backup Appliances.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupApplianceBackupConfig {
    /// The name of the backup appliance.
    pub backup_appliance_name: std::string::String,

    /// The ID of the backup appliance.
    pub backup_appliance_id: i64,

    /// The ID of the SLA of this application.
    pub sla_id: i64,

    /// The name of the application.
    pub application_name: std::string::String,

    /// The name of the host where the application is running.
    pub host_name: std::string::String,

    /// The name of the SLT associated with the application.
    pub slt_name: std::string::String,

    /// The name of the SLP associated with the application.
    pub slp_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupApplianceBackupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_appliance_name][crate::model::BackupApplianceBackupConfig::backup_appliance_name].
    pub fn set_backup_appliance_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_appliance_name = v.into();
        self
    }

    /// Sets the value of [backup_appliance_id][crate::model::BackupApplianceBackupConfig::backup_appliance_id].
    pub fn set_backup_appliance_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.backup_appliance_id = v.into();
        self
    }

    /// Sets the value of [sla_id][crate::model::BackupApplianceBackupConfig::sla_id].
    pub fn set_sla_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.sla_id = v.into();
        self
    }

    /// Sets the value of [application_name][crate::model::BackupApplianceBackupConfig::application_name].
    pub fn set_application_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.application_name = v.into();
        self
    }

    /// Sets the value of [host_name][crate::model::BackupApplianceBackupConfig::host_name].
    pub fn set_host_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_name = v.into();
        self
    }

    /// Sets the value of [slt_name][crate::model::BackupApplianceBackupConfig::slt_name].
    pub fn set_slt_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.slt_name = v.into();
        self
    }

    /// Sets the value of [slp_name][crate::model::BackupApplianceBackupConfig::slp_name].
    pub fn set_slp_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.slp_name = v.into();
        self
    }
}

impl wkt::message::Message for BackupApplianceBackupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupApplianceBackupConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupApplianceBackupConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_appliance_name,
            __backup_appliance_id,
            __sla_id,
            __application_name,
            __host_name,
            __slt_name,
            __slp_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupApplianceBackupConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupApplianceName" => Ok(__FieldTag::__backup_appliance_name),
                            "backup_appliance_name" => Ok(__FieldTag::__backup_appliance_name),
                            "backupApplianceId" => Ok(__FieldTag::__backup_appliance_id),
                            "backup_appliance_id" => Ok(__FieldTag::__backup_appliance_id),
                            "slaId" => Ok(__FieldTag::__sla_id),
                            "sla_id" => Ok(__FieldTag::__sla_id),
                            "applicationName" => Ok(__FieldTag::__application_name),
                            "application_name" => Ok(__FieldTag::__application_name),
                            "hostName" => Ok(__FieldTag::__host_name),
                            "host_name" => Ok(__FieldTag::__host_name),
                            "sltName" => Ok(__FieldTag::__slt_name),
                            "slt_name" => Ok(__FieldTag::__slt_name),
                            "slpName" => Ok(__FieldTag::__slp_name),
                            "slp_name" => Ok(__FieldTag::__slp_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupApplianceBackupConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupApplianceBackupConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_appliance_name => {
                            if !fields.insert(__FieldTag::__backup_appliance_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_appliance_name",
                                ));
                            }
                            result.backup_appliance_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_appliance_id => {
                            if !fields.insert(__FieldTag::__backup_appliance_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_appliance_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.backup_appliance_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__sla_id => {
                            if !fields.insert(__FieldTag::__sla_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sla_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sla_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__application_name => {
                            if !fields.insert(__FieldTag::__application_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for application_name",
                                ));
                            }
                            result.application_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__host_name => {
                            if !fields.insert(__FieldTag::__host_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host_name",
                                ));
                            }
                            result.host_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__slt_name => {
                            if !fields.insert(__FieldTag::__slt_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slt_name",
                                ));
                            }
                            result.slt_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__slp_name => {
                            if !fields.insert(__FieldTag::__slp_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slp_name",
                                ));
                            }
                            result.slp_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupApplianceBackupConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup_appliance_name.is_empty() {
            state.serialize_entry("backupApplianceName", &self.backup_appliance_name)?;
        }
        if !wkt::internal::is_default(&self.backup_appliance_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("backupApplianceId", &__With(&self.backup_appliance_id))?;
        }
        if !wkt::internal::is_default(&self.sla_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("slaId", &__With(&self.sla_id))?;
        }
        if !self.application_name.is_empty() {
            state.serialize_entry("applicationName", &self.application_name)?;
        }
        if !self.host_name.is_empty() {
            state.serialize_entry("hostName", &self.host_name)?;
        }
        if !self.slt_name.is_empty() {
            state.serialize_entry("sltName", &self.slt_name)?;
        }
        if !self.slp_name.is_empty() {
            state.serialize_entry("slpName", &self.slp_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// DataSourceGcpResource is used for protected resources that are Google Cloud
/// Resources. This name is easeier to understand than GcpResourceDataSource or
/// GcpDataSourceResource
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataSourceGcpResource {
    /// Output only. Full resource pathname URL of the source Google Cloud
    /// resource.
    pub gcp_resourcename: std::string::String,

    /// Location of the resource: \<region\>/\<zone\>/"global"/"unspecified".
    pub location: std::string::String,

    /// The type of the Google Cloud resource. Use the Unified Resource Type,
    /// eg. compute.googleapis.com/Instance.
    pub r#type: std::string::String,

    /// gcp_Properties has properties of the Google Cloud Resource.
    pub gcp_resource_properties:
        std::option::Option<crate::model::data_source_gcp_resource::GcpResourceProperties>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSourceGcpResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcp_resourcename][crate::model::DataSourceGcpResource::gcp_resourcename].
    pub fn set_gcp_resourcename<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gcp_resourcename = v.into();
        self
    }

    /// Sets the value of [location][crate::model::DataSourceGcpResource::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DataSourceGcpResource::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [gcp_resource_properties][crate::model::DataSourceGcpResource::gcp_resource_properties].
    ///
    /// Note that all the setters affecting `gcp_resource_properties` are mutually
    /// exclusive.
    pub fn set_gcp_resource_properties<
        T: std::convert::Into<
                std::option::Option<crate::model::data_source_gcp_resource::GcpResourceProperties>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gcp_resource_properties = v.into();
        self
    }

    /// The value of [gcp_resource_properties][crate::model::DataSourceGcpResource::gcp_resource_properties]
    /// if it holds a `ComputeInstanceDatasourceProperties`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_instance_datasource_properties(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeInstanceDataSourceProperties>>
    {
        #[allow(unreachable_patterns)]
        self.gcp_resource_properties.as_ref().and_then(|v| match v {
            crate::model::data_source_gcp_resource::GcpResourceProperties::ComputeInstanceDatasourceProperties(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [gcp_resource_properties][crate::model::DataSourceGcpResource::gcp_resource_properties]
    /// to hold a `ComputeInstanceDatasourceProperties`.
    ///
    /// Note that all the setters affecting `gcp_resource_properties` are
    /// mutually exclusive.
    pub fn set_compute_instance_datasource_properties<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeInstanceDataSourceProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gcp_resource_properties = std::option::Option::Some(
            crate::model::data_source_gcp_resource::GcpResourceProperties::ComputeInstanceDatasourceProperties(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for DataSourceGcpResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.DataSourceGcpResource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataSourceGcpResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcp_resourcename,
            __location,
            __type,
            __compute_instance_datasource_properties,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataSourceGcpResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcpResourcename" => Ok(__FieldTag::__gcp_resourcename),
                            "gcp_resourcename" => Ok(__FieldTag::__gcp_resourcename),
                            "location" => Ok(__FieldTag::__location),
                            "type" => Ok(__FieldTag::__type),
                            "computeInstanceDatasourceProperties" => {
                                Ok(__FieldTag::__compute_instance_datasource_properties)
                            }
                            "compute_instance_datasource_properties" => {
                                Ok(__FieldTag::__compute_instance_datasource_properties)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataSourceGcpResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataSourceGcpResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcp_resourcename => {
                            if !fields.insert(__FieldTag::__gcp_resourcename) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_resourcename",
                                ));
                            }
                            result.gcp_resourcename = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__compute_instance_datasource_properties => {
                            if !fields.insert(__FieldTag::__compute_instance_datasource_properties)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_instance_datasource_properties",
                                ));
                            }
                            if result.gcp_resource_properties.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `gcp_resource_properties`, a oneof with full ID .google.cloud.backupdr.v1.DataSourceGcpResource.compute_instance_datasource_properties, latest field was computeInstanceDatasourceProperties",
                                ));
                            }
                            result.gcp_resource_properties = std::option::Option::Some(
                                crate::model::data_source_gcp_resource::GcpResourceProperties::ComputeInstanceDatasourceProperties(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ComputeInstanceDataSourceProperties>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataSourceGcpResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.gcp_resourcename.is_empty() {
            state.serialize_entry("gcpResourcename", &self.gcp_resourcename)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if let Some(value) = self.compute_instance_datasource_properties() {
            state.serialize_entry("computeInstanceDatasourceProperties", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataSourceGcpResource].
pub mod data_source_gcp_resource {
    #[allow(unused_imports)]
    use super::*;

    /// gcp_Properties has properties of the Google Cloud Resource.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum GcpResourceProperties {
        /// ComputeInstanceDataSourceProperties has a subset of Compute Instance
        /// properties that are useful at the Datasource level.
        ComputeInstanceDatasourceProperties(
            std::boxed::Box<crate::model::ComputeInstanceDataSourceProperties>,
        ),
    }
}

/// BackupApplianceApplication describes a Source Resource when it is an
/// application backed up by a BackupAppliance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataSourceBackupApplianceApplication {
    /// The name of the Application as known to the Backup Appliance.
    pub application_name: std::string::String,

    /// Appliance name.
    pub backup_appliance: std::string::String,

    /// Appliance Id of the Backup Appliance.
    pub appliance_id: i64,

    /// The type of the application. e.g. VMBackup
    pub r#type: std::string::String,

    /// The appid field of the application within the Backup Appliance.
    pub application_id: i64,

    /// Hostname of the host where the application is running.
    pub hostname: std::string::String,

    /// Hostid of the application host.
    pub host_id: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSourceBackupApplianceApplication {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [application_name][crate::model::DataSourceBackupApplianceApplication::application_name].
    pub fn set_application_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.application_name = v.into();
        self
    }

    /// Sets the value of [backup_appliance][crate::model::DataSourceBackupApplianceApplication::backup_appliance].
    pub fn set_backup_appliance<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_appliance = v.into();
        self
    }

    /// Sets the value of [appliance_id][crate::model::DataSourceBackupApplianceApplication::appliance_id].
    pub fn set_appliance_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.appliance_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DataSourceBackupApplianceApplication::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [application_id][crate::model::DataSourceBackupApplianceApplication::application_id].
    pub fn set_application_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.application_id = v.into();
        self
    }

    /// Sets the value of [hostname][crate::model::DataSourceBackupApplianceApplication::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [host_id][crate::model::DataSourceBackupApplianceApplication::host_id].
    pub fn set_host_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.host_id = v.into();
        self
    }
}

impl wkt::message::Message for DataSourceBackupApplianceApplication {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.DataSourceBackupApplianceApplication"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataSourceBackupApplianceApplication {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __application_name,
            __backup_appliance,
            __appliance_id,
            __type,
            __application_id,
            __hostname,
            __host_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataSourceBackupApplianceApplication")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "applicationName" => Ok(__FieldTag::__application_name),
                            "application_name" => Ok(__FieldTag::__application_name),
                            "backupAppliance" => Ok(__FieldTag::__backup_appliance),
                            "backup_appliance" => Ok(__FieldTag::__backup_appliance),
                            "applianceId" => Ok(__FieldTag::__appliance_id),
                            "appliance_id" => Ok(__FieldTag::__appliance_id),
                            "type" => Ok(__FieldTag::__type),
                            "applicationId" => Ok(__FieldTag::__application_id),
                            "application_id" => Ok(__FieldTag::__application_id),
                            "hostname" => Ok(__FieldTag::__hostname),
                            "hostId" => Ok(__FieldTag::__host_id),
                            "host_id" => Ok(__FieldTag::__host_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataSourceBackupApplianceApplication;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataSourceBackupApplianceApplication")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__application_name => {
                            if !fields.insert(__FieldTag::__application_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for application_name",
                                ));
                            }
                            result.application_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_appliance => {
                            if !fields.insert(__FieldTag::__backup_appliance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_appliance",
                                ));
                            }
                            result.backup_appliance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__appliance_id => {
                            if !fields.insert(__FieldTag::__appliance_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for appliance_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.appliance_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__application_id => {
                            if !fields.insert(__FieldTag::__application_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for application_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.application_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__host_id => {
                            if !fields.insert(__FieldTag::__host_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.host_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataSourceBackupApplianceApplication {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.application_name.is_empty() {
            state.serialize_entry("applicationName", &self.application_name)?;
        }
        if !self.backup_appliance.is_empty() {
            state.serialize_entry("backupAppliance", &self.backup_appliance)?;
        }
        if !wkt::internal::is_default(&self.appliance_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("applianceId", &__With(&self.appliance_id))?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.application_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("applicationId", &__With(&self.application_id))?;
        }
        if !self.hostname.is_empty() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if !wkt::internal::is_default(&self.host_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("hostId", &__With(&self.host_id))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// ServiceLockInfo represents the details of a lock taken by the service on a
/// Backup resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ServiceLockInfo {
    /// Output only. The name of the operation that created this lock.
    /// The lock will automatically be released when the operation completes.
    pub operation: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceLockInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation][crate::model::ServiceLockInfo::operation].
    pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation = v.into();
        self
    }
}

impl wkt::message::Message for ServiceLockInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ServiceLockInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServiceLockInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServiceLockInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operation" => Ok(__FieldTag::__operation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServiceLockInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServiceLockInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operation => {
                            if !fields.insert(__FieldTag::__operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation",
                                ));
                            }
                            result.operation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServiceLockInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operation.is_empty() {
            state.serialize_entry("operation", &self.operation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// BackupApplianceLockInfo contains metadata about the backupappliance that
/// created the lock.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupApplianceLockInfo {
    /// Required. The ID of the backup/recovery appliance that created this lock.
    pub backup_appliance_id: i64,

    /// Required. The name of the backup/recovery appliance that created this lock.
    pub backup_appliance_name: std::string::String,

    /// Required. The reason for the lock: e.g. MOUNT/RESTORE/BACKUP/etc.  The
    /// value of this string is only meaningful to the client and it is not
    /// interpreted by the BackupVault service.
    pub lock_reason: std::string::String,

    /// The information about this lock.
    pub lock_source: std::option::Option<crate::model::backup_appliance_lock_info::LockSource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupApplianceLockInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_appliance_id][crate::model::BackupApplianceLockInfo::backup_appliance_id].
    pub fn set_backup_appliance_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.backup_appliance_id = v.into();
        self
    }

    /// Sets the value of [backup_appliance_name][crate::model::BackupApplianceLockInfo::backup_appliance_name].
    pub fn set_backup_appliance_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_appliance_name = v.into();
        self
    }

    /// Sets the value of [lock_reason][crate::model::BackupApplianceLockInfo::lock_reason].
    pub fn set_lock_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.lock_reason = v.into();
        self
    }

    /// Sets the value of [lock_source][crate::model::BackupApplianceLockInfo::lock_source].
    ///
    /// Note that all the setters affecting `lock_source` are mutually
    /// exclusive.
    pub fn set_lock_source<
        T: std::convert::Into<
                std::option::Option<crate::model::backup_appliance_lock_info::LockSource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.lock_source = v.into();
        self
    }

    /// The value of [lock_source][crate::model::BackupApplianceLockInfo::lock_source]
    /// if it holds a `JobName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn job_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.lock_source.as_ref().and_then(|v| match v {
            crate::model::backup_appliance_lock_info::LockSource::JobName(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [lock_source][crate::model::BackupApplianceLockInfo::lock_source]
    /// to hold a `JobName`.
    ///
    /// Note that all the setters affecting `lock_source` are
    /// mutually exclusive.
    pub fn set_job_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.lock_source = std::option::Option::Some(
            crate::model::backup_appliance_lock_info::LockSource::JobName(v.into()),
        );
        self
    }

    /// The value of [lock_source][crate::model::BackupApplianceLockInfo::lock_source]
    /// if it holds a `BackupImage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backup_image(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.lock_source.as_ref().and_then(|v| match v {
            crate::model::backup_appliance_lock_info::LockSource::BackupImage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [lock_source][crate::model::BackupApplianceLockInfo::lock_source]
    /// to hold a `BackupImage`.
    ///
    /// Note that all the setters affecting `lock_source` are
    /// mutually exclusive.
    pub fn set_backup_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.lock_source = std::option::Option::Some(
            crate::model::backup_appliance_lock_info::LockSource::BackupImage(v.into()),
        );
        self
    }

    /// The value of [lock_source][crate::model::BackupApplianceLockInfo::lock_source]
    /// if it holds a `SlaId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sla_id(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.lock_source.as_ref().and_then(|v| match v {
            crate::model::backup_appliance_lock_info::LockSource::SlaId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [lock_source][crate::model::BackupApplianceLockInfo::lock_source]
    /// to hold a `SlaId`.
    ///
    /// Note that all the setters affecting `lock_source` are
    /// mutually exclusive.
    pub fn set_sla_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.lock_source = std::option::Option::Some(
            crate::model::backup_appliance_lock_info::LockSource::SlaId(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BackupApplianceLockInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupApplianceLockInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupApplianceLockInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_appliance_id,
            __backup_appliance_name,
            __lock_reason,
            __job_name,
            __backup_image,
            __sla_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupApplianceLockInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupApplianceId" => Ok(__FieldTag::__backup_appliance_id),
                            "backup_appliance_id" => Ok(__FieldTag::__backup_appliance_id),
                            "backupApplianceName" => Ok(__FieldTag::__backup_appliance_name),
                            "backup_appliance_name" => Ok(__FieldTag::__backup_appliance_name),
                            "lockReason" => Ok(__FieldTag::__lock_reason),
                            "lock_reason" => Ok(__FieldTag::__lock_reason),
                            "jobName" => Ok(__FieldTag::__job_name),
                            "job_name" => Ok(__FieldTag::__job_name),
                            "backupImage" => Ok(__FieldTag::__backup_image),
                            "backup_image" => Ok(__FieldTag::__backup_image),
                            "slaId" => Ok(__FieldTag::__sla_id),
                            "sla_id" => Ok(__FieldTag::__sla_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupApplianceLockInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupApplianceLockInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_appliance_id => {
                            if !fields.insert(__FieldTag::__backup_appliance_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_appliance_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.backup_appliance_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__backup_appliance_name => {
                            if !fields.insert(__FieldTag::__backup_appliance_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_appliance_name",
                                ));
                            }
                            result.backup_appliance_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lock_reason => {
                            if !fields.insert(__FieldTag::__lock_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lock_reason",
                                ));
                            }
                            result.lock_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_name => {
                            if !fields.insert(__FieldTag::__job_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_name",
                                ));
                            }
                            if result.lock_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `lock_source`, a oneof with full ID .google.cloud.backupdr.v1.BackupApplianceLockInfo.job_name, latest field was jobName",
                                ));
                            }
                            result.lock_source = std::option::Option::Some(
                                crate::model::backup_appliance_lock_info::LockSource::JobName(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__backup_image => {
                            if !fields.insert(__FieldTag::__backup_image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_image",
                                ));
                            }
                            if result.lock_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `lock_source`, a oneof with full ID .google.cloud.backupdr.v1.BackupApplianceLockInfo.backup_image, latest field was backupImage",
                                ));
                            }
                            result.lock_source = std::option::Option::Some(
                                crate::model::backup_appliance_lock_info::LockSource::BackupImage(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__sla_id => {
                            if !fields.insert(__FieldTag::__sla_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sla_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.lock_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `lock_source`, a oneof with full ID .google.cloud.backupdr.v1.BackupApplianceLockInfo.sla_id, latest field was slaId",
                                ));
                            }
                            result.lock_source = std::option::Option::Some(
                                crate::model::backup_appliance_lock_info::LockSource::SlaId(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupApplianceLockInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.backup_appliance_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("backupApplianceId", &__With(&self.backup_appliance_id))?;
        }
        if !self.backup_appliance_name.is_empty() {
            state.serialize_entry("backupApplianceName", &self.backup_appliance_name)?;
        }
        if !self.lock_reason.is_empty() {
            state.serialize_entry("lockReason", &self.lock_reason)?;
        }
        if let Some(value) = self.job_name() {
            state.serialize_entry("jobName", value)?;
        }
        if let Some(value) = self.backup_image() {
            state.serialize_entry("backupImage", value)?;
        }
        if let Some(value) = self.sla_id() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("slaId", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BackupApplianceLockInfo].
pub mod backup_appliance_lock_info {
    #[allow(unused_imports)]
    use super::*;

    /// The information about this lock.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LockSource {
        /// The job name on the backup/recovery appliance that created this lock.
        JobName(std::string::String),
        /// The image name that depends on this Backup.
        BackupImage(std::string::String),
        /// The SLA on the backup/recovery appliance that owns the lock.
        SlaId(i64),
    }
}

/// BackupLock represents a single lock on a Backup resource.  An unexpired
/// lock on a Backup prevents the Backup from being deleted.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupLock {
    /// Required. The time after which this lock is not considered valid and will
    /// no longer protect the Backup from deletion.
    pub lock_until_time: std::option::Option<wkt::Timestamp>,

    /// Metadata about the owner and reason for the lock.
    pub client_lock_info: std::option::Option<crate::model::backup_lock::ClientLockInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupLock {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lock_until_time][crate::model::BackupLock::lock_until_time].
    pub fn set_lock_until_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.lock_until_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lock_until_time][crate::model::BackupLock::lock_until_time].
    pub fn set_or_clear_lock_until_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.lock_until_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [client_lock_info][crate::model::BackupLock::client_lock_info].
    ///
    /// Note that all the setters affecting `client_lock_info` are mutually
    /// exclusive.
    pub fn set_client_lock_info<
        T: std::convert::Into<std::option::Option<crate::model::backup_lock::ClientLockInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.client_lock_info = v.into();
        self
    }

    /// The value of [client_lock_info][crate::model::BackupLock::client_lock_info]
    /// if it holds a `BackupApplianceLockInfo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backup_appliance_lock_info(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BackupApplianceLockInfo>> {
        #[allow(unreachable_patterns)]
        self.client_lock_info.as_ref().and_then(|v| match v {
            crate::model::backup_lock::ClientLockInfo::BackupApplianceLockInfo(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [client_lock_info][crate::model::BackupLock::client_lock_info]
    /// to hold a `BackupApplianceLockInfo`.
    ///
    /// Note that all the setters affecting `client_lock_info` are
    /// mutually exclusive.
    pub fn set_backup_appliance_lock_info<
        T: std::convert::Into<std::boxed::Box<crate::model::BackupApplianceLockInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.client_lock_info = std::option::Option::Some(
            crate::model::backup_lock::ClientLockInfo::BackupApplianceLockInfo(v.into()),
        );
        self
    }

    /// The value of [client_lock_info][crate::model::BackupLock::client_lock_info]
    /// if it holds a `ServiceLockInfo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn service_lock_info(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ServiceLockInfo>> {
        #[allow(unreachable_patterns)]
        self.client_lock_info.as_ref().and_then(|v| match v {
            crate::model::backup_lock::ClientLockInfo::ServiceLockInfo(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [client_lock_info][crate::model::BackupLock::client_lock_info]
    /// to hold a `ServiceLockInfo`.
    ///
    /// Note that all the setters affecting `client_lock_info` are
    /// mutually exclusive.
    pub fn set_service_lock_info<
        T: std::convert::Into<std::boxed::Box<crate::model::ServiceLockInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.client_lock_info = std::option::Option::Some(
            crate::model::backup_lock::ClientLockInfo::ServiceLockInfo(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BackupLock {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupLock"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupLock {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __lock_until_time,
            __backup_appliance_lock_info,
            __service_lock_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupLock")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lockUntilTime" => Ok(__FieldTag::__lock_until_time),
                            "lock_until_time" => Ok(__FieldTag::__lock_until_time),
                            "backupApplianceLockInfo" => {
                                Ok(__FieldTag::__backup_appliance_lock_info)
                            }
                            "backup_appliance_lock_info" => {
                                Ok(__FieldTag::__backup_appliance_lock_info)
                            }
                            "serviceLockInfo" => Ok(__FieldTag::__service_lock_info),
                            "service_lock_info" => Ok(__FieldTag::__service_lock_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupLock;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupLock")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__lock_until_time => {
                            if !fields.insert(__FieldTag::__lock_until_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lock_until_time",
                                ));
                            }
                            result.lock_until_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__backup_appliance_lock_info => {
                            if !fields.insert(__FieldTag::__backup_appliance_lock_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_appliance_lock_info",
                                ));
                            }
                            if result.client_lock_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `client_lock_info`, a oneof with full ID .google.cloud.backupdr.v1.BackupLock.backup_appliance_lock_info, latest field was backupApplianceLockInfo",
                                ));
                            }
                            result.client_lock_info = std::option::Option::Some(
                                crate::model::backup_lock::ClientLockInfo::BackupApplianceLockInfo(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BackupApplianceLockInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__service_lock_info => {
                            if !fields.insert(__FieldTag::__service_lock_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_lock_info",
                                ));
                            }
                            if result.client_lock_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `client_lock_info`, a oneof with full ID .google.cloud.backupdr.v1.BackupLock.service_lock_info, latest field was serviceLockInfo",
                                ));
                            }
                            result.client_lock_info = std::option::Option::Some(
                                crate::model::backup_lock::ClientLockInfo::ServiceLockInfo(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ServiceLockInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupLock {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.lock_until_time.is_some() {
            state.serialize_entry("lockUntilTime", &self.lock_until_time)?;
        }
        if let Some(value) = self.backup_appliance_lock_info() {
            state.serialize_entry("backupApplianceLockInfo", value)?;
        }
        if let Some(value) = self.service_lock_info() {
            state.serialize_entry("serviceLockInfo", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BackupLock].
pub mod backup_lock {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata about the owner and reason for the lock.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ClientLockInfo {
        /// If the client is a backup and recovery appliance, this
        /// contains metadata about why the lock exists.
        BackupApplianceLockInfo(std::boxed::Box<crate::model::BackupApplianceLockInfo>),
        /// Output only. Contains metadata about the lock exist for Google Cloud
        /// native backups.
        ServiceLockInfo(std::boxed::Box<crate::model::ServiceLockInfo>),
    }
}

/// Message describing a Backup object.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Backup {
    /// Output only. Identifier. Name of the backup to create. It must have the
    /// format`"projects/<project>/locations/<location>/backupVaults/<backupvault>/dataSources/{datasource}/backups/{backup}"`.
    /// `{backup}` cannot be changed after creation. It must be between 3-63
    /// characters long and must be unique within the datasource.
    pub name: std::string::String,

    /// Output only. The description of the Backup instance (2048 characters or
    /// less).
    pub description: std::option::Option<std::string::String>,

    /// Output only. The time when the instance was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the instance was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Resource labels to represent user provided metadata.
    /// No labels currently defined.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The backup can not be deleted before this time.
    pub enforced_retention_end_time: std::option::Option<wkt::Timestamp>,

    /// Optional. When this backup is automatically expired.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The point in time when this backup was captured from the
    /// source.
    pub consistency_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Server specified ETag to prevent updates from overwriting each
    /// other.
    pub etag: std::option::Option<std::string::String>,

    /// Output only. The Backup resource instance state.
    pub state: crate::model::backup::State,

    /// Output only. The list of BackupLocks taken by the service to prevent the
    /// deletion of the backup.
    pub service_locks: std::vec::Vec<crate::model::BackupLock>,

    /// Optional. The list of BackupLocks taken by the accessor Backup Appliance.
    pub backup_appliance_locks: std::vec::Vec<crate::model::BackupLock>,

    /// Output only. Type of the backup, unspecified, scheduled or ondemand.
    pub backup_type: crate::model::backup::BackupType,

    /// Output only. source resource size in bytes at the time of the backup.
    pub resource_size_bytes: i64,

    /// Workload specific backup properties.
    pub backup_properties: std::option::Option<crate::model::backup::BackupProperties>,

    /// Configuration Info has the resource format-specific configuration.
    pub plan_info: std::option::Option<crate::model::backup::PlanInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Backup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Backup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Backup::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::Backup::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Backup::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Backup::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Backup::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Backup::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Backup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [enforced_retention_end_time][crate::model::Backup::enforced_retention_end_time].
    pub fn set_enforced_retention_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.enforced_retention_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enforced_retention_end_time][crate::model::Backup::enforced_retention_end_time].
    pub fn set_or_clear_enforced_retention_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.enforced_retention_end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::Backup::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::Backup::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [consistency_time][crate::model::Backup::consistency_time].
    pub fn set_consistency_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.consistency_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [consistency_time][crate::model::Backup::consistency_time].
    pub fn set_or_clear_consistency_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.consistency_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::Backup::etag].
    pub fn set_etag<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.etag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [etag][crate::model::Backup::etag].
    pub fn set_or_clear_etag<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.etag = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [service_locks][crate::model::Backup::service_locks].
    pub fn set_service_locks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupLock>,
    {
        use std::iter::Iterator;
        self.service_locks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [backup_appliance_locks][crate::model::Backup::backup_appliance_locks].
    pub fn set_backup_appliance_locks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupLock>,
    {
        use std::iter::Iterator;
        self.backup_appliance_locks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [backup_type][crate::model::Backup::backup_type].
    pub fn set_backup_type<T: std::convert::Into<crate::model::backup::BackupType>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_type = v.into();
        self
    }

    /// Sets the value of [resource_size_bytes][crate::model::Backup::resource_size_bytes].
    pub fn set_resource_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.resource_size_bytes = v.into();
        self
    }

    /// Sets the value of [backup_properties][crate::model::Backup::backup_properties].
    ///
    /// Note that all the setters affecting `backup_properties` are mutually
    /// exclusive.
    pub fn set_backup_properties<
        T: std::convert::Into<std::option::Option<crate::model::backup::BackupProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_properties = v.into();
        self
    }

    /// The value of [backup_properties][crate::model::Backup::backup_properties]
    /// if it holds a `ComputeInstanceBackupProperties`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_instance_backup_properties(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeInstanceBackupProperties>> {
        #[allow(unreachable_patterns)]
        self.backup_properties.as_ref().and_then(|v| match v {
            crate::model::backup::BackupProperties::ComputeInstanceBackupProperties(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backup_properties][crate::model::Backup::backup_properties]
    /// to hold a `ComputeInstanceBackupProperties`.
    ///
    /// Note that all the setters affecting `backup_properties` are
    /// mutually exclusive.
    pub fn set_compute_instance_backup_properties<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeInstanceBackupProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_properties = std::option::Option::Some(
            crate::model::backup::BackupProperties::ComputeInstanceBackupProperties(v.into()),
        );
        self
    }

    /// The value of [backup_properties][crate::model::Backup::backup_properties]
    /// if it holds a `BackupApplianceBackupProperties`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backup_appliance_backup_properties(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BackupApplianceBackupProperties>> {
        #[allow(unreachable_patterns)]
        self.backup_properties.as_ref().and_then(|v| match v {
            crate::model::backup::BackupProperties::BackupApplianceBackupProperties(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backup_properties][crate::model::Backup::backup_properties]
    /// to hold a `BackupApplianceBackupProperties`.
    ///
    /// Note that all the setters affecting `backup_properties` are
    /// mutually exclusive.
    pub fn set_backup_appliance_backup_properties<
        T: std::convert::Into<std::boxed::Box<crate::model::BackupApplianceBackupProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_properties = std::option::Option::Some(
            crate::model::backup::BackupProperties::BackupApplianceBackupProperties(v.into()),
        );
        self
    }

    /// Sets the value of [plan_info][crate::model::Backup::plan_info].
    ///
    /// Note that all the setters affecting `plan_info` are mutually
    /// exclusive.
    pub fn set_plan_info<
        T: std::convert::Into<std::option::Option<crate::model::backup::PlanInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.plan_info = v.into();
        self
    }

    /// The value of [plan_info][crate::model::Backup::plan_info]
    /// if it holds a `GcpBackupPlanInfo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcp_backup_plan_info(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::backup::GCPBackupPlanInfo>> {
        #[allow(unreachable_patterns)]
        self.plan_info.as_ref().and_then(|v| match v {
            crate::model::backup::PlanInfo::GcpBackupPlanInfo(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [plan_info][crate::model::Backup::plan_info]
    /// to hold a `GcpBackupPlanInfo`.
    ///
    /// Note that all the setters affecting `plan_info` are
    /// mutually exclusive.
    pub fn set_gcp_backup_plan_info<
        T: std::convert::Into<std::boxed::Box<crate::model::backup::GCPBackupPlanInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.plan_info =
            std::option::Option::Some(crate::model::backup::PlanInfo::GcpBackupPlanInfo(v.into()));
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.Backup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Backup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __create_time,
            __update_time,
            __labels,
            __enforced_retention_end_time,
            __expire_time,
            __consistency_time,
            __etag,
            __state,
            __service_locks,
            __backup_appliance_locks,
            __compute_instance_backup_properties,
            __backup_appliance_backup_properties,
            __backup_type,
            __gcp_backup_plan_info,
            __resource_size_bytes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Backup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "enforcedRetentionEndTime" => {
                                Ok(__FieldTag::__enforced_retention_end_time)
                            }
                            "enforced_retention_end_time" => {
                                Ok(__FieldTag::__enforced_retention_end_time)
                            }
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "consistencyTime" => Ok(__FieldTag::__consistency_time),
                            "consistency_time" => Ok(__FieldTag::__consistency_time),
                            "etag" => Ok(__FieldTag::__etag),
                            "state" => Ok(__FieldTag::__state),
                            "serviceLocks" => Ok(__FieldTag::__service_locks),
                            "service_locks" => Ok(__FieldTag::__service_locks),
                            "backupApplianceLocks" => Ok(__FieldTag::__backup_appliance_locks),
                            "backup_appliance_locks" => Ok(__FieldTag::__backup_appliance_locks),
                            "computeInstanceBackupProperties" => {
                                Ok(__FieldTag::__compute_instance_backup_properties)
                            }
                            "compute_instance_backup_properties" => {
                                Ok(__FieldTag::__compute_instance_backup_properties)
                            }
                            "backupApplianceBackupProperties" => {
                                Ok(__FieldTag::__backup_appliance_backup_properties)
                            }
                            "backup_appliance_backup_properties" => {
                                Ok(__FieldTag::__backup_appliance_backup_properties)
                            }
                            "backupType" => Ok(__FieldTag::__backup_type),
                            "backup_type" => Ok(__FieldTag::__backup_type),
                            "gcpBackupPlanInfo" => Ok(__FieldTag::__gcp_backup_plan_info),
                            "gcp_backup_plan_info" => Ok(__FieldTag::__gcp_backup_plan_info),
                            "resourceSizeBytes" => Ok(__FieldTag::__resource_size_bytes),
                            "resource_size_bytes" => Ok(__FieldTag::__resource_size_bytes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Backup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Backup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enforced_retention_end_time => {
                            if !fields.insert(__FieldTag::__enforced_retention_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enforced_retention_end_time",
                                ));
                            }
                            result.enforced_retention_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__consistency_time => {
                            if !fields.insert(__FieldTag::__consistency_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for consistency_time",
                                ));
                            }
                            result.consistency_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::backup::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_locks => {
                            if !fields.insert(__FieldTag::__service_locks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_locks",
                                ));
                            }
                            result.service_locks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BackupLock>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__backup_appliance_locks => {
                            if !fields.insert(__FieldTag::__backup_appliance_locks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_appliance_locks",
                                ));
                            }
                            result.backup_appliance_locks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BackupLock>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__compute_instance_backup_properties => {
                            if !fields.insert(__FieldTag::__compute_instance_backup_properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_instance_backup_properties",
                                ));
                            }
                            if result.backup_properties.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `backup_properties`, a oneof with full ID .google.cloud.backupdr.v1.Backup.compute_instance_backup_properties, latest field was computeInstanceBackupProperties",
                                ));
                            }
                            result.backup_properties = std::option::Option::Some(
                                crate::model::backup::BackupProperties::ComputeInstanceBackupProperties(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ComputeInstanceBackupProperties>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__backup_appliance_backup_properties => {
                            if !fields.insert(__FieldTag::__backup_appliance_backup_properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_appliance_backup_properties",
                                ));
                            }
                            if result.backup_properties.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `backup_properties`, a oneof with full ID .google.cloud.backupdr.v1.Backup.backup_appliance_backup_properties, latest field was backupApplianceBackupProperties",
                                ));
                            }
                            result.backup_properties = std::option::Option::Some(
                                crate::model::backup::BackupProperties::BackupApplianceBackupProperties(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::BackupApplianceBackupProperties>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__backup_type => {
                            if !fields.insert(__FieldTag::__backup_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_type",
                                ));
                            }
                            result.backup_type = map.next_value::<std::option::Option<crate::model::backup::BackupType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__gcp_backup_plan_info => {
                            if !fields.insert(__FieldTag::__gcp_backup_plan_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_backup_plan_info",
                                ));
                            }
                            if result.plan_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `plan_info`, a oneof with full ID .google.cloud.backupdr.v1.Backup.gcp_backup_plan_info, latest field was gcpBackupPlanInfo",
                                ));
                            }
                            result.plan_info = std::option::Option::Some(
                                crate::model::backup::PlanInfo::GcpBackupPlanInfo(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::backup::GCPBackupPlanInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__resource_size_bytes => {
                            if !fields.insert(__FieldTag::__resource_size_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_size_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.resource_size_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Backup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.enforced_retention_end_time.is_some() {
            state.serialize_entry(
                "enforcedRetentionEndTime",
                &self.enforced_retention_end_time,
            )?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if self.consistency_time.is_some() {
            state.serialize_entry("consistencyTime", &self.consistency_time)?;
        }
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.service_locks.is_empty() {
            state.serialize_entry("serviceLocks", &self.service_locks)?;
        }
        if !self.backup_appliance_locks.is_empty() {
            state.serialize_entry("backupApplianceLocks", &self.backup_appliance_locks)?;
        }
        if let Some(value) = self.compute_instance_backup_properties() {
            state.serialize_entry("computeInstanceBackupProperties", value)?;
        }
        if let Some(value) = self.backup_appliance_backup_properties() {
            state.serialize_entry("backupApplianceBackupProperties", value)?;
        }
        if !wkt::internal::is_default(&self.backup_type) {
            state.serialize_entry("backupType", &self.backup_type)?;
        }
        if let Some(value) = self.gcp_backup_plan_info() {
            state.serialize_entry("gcpBackupPlanInfo", value)?;
        }
        if !wkt::internal::is_default(&self.resource_size_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("resourceSizeBytes", &__With(&self.resource_size_bytes))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Backup].
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// GCPBackupPlanInfo captures the plan configuration details of Google Cloud
    /// resources at the time of backup.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GCPBackupPlanInfo {
        /// Resource name of backup plan by which workload is protected at the time
        /// of the backup.
        /// Format:
        /// projects/{project}/locations/{location}/backupPlans/{backupPlanId}
        pub backup_plan: std::string::String,

        /// The rule id of the backup plan which triggered this backup in case of
        /// scheduled backup or used for
        pub backup_plan_rule_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GCPBackupPlanInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [backup_plan][crate::model::backup::GCPBackupPlanInfo::backup_plan].
        pub fn set_backup_plan<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.backup_plan = v.into();
            self
        }

        /// Sets the value of [backup_plan_rule_id][crate::model::backup::GCPBackupPlanInfo::backup_plan_rule_id].
        pub fn set_backup_plan_rule_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.backup_plan_rule_id = v.into();
            self
        }
    }

    impl wkt::message::Message for GCPBackupPlanInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.backupdr.v1.Backup.GCPBackupPlanInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GCPBackupPlanInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __backup_plan,
                __backup_plan_rule_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GCPBackupPlanInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "backupPlan" => Ok(__FieldTag::__backup_plan),
                                "backup_plan" => Ok(__FieldTag::__backup_plan),
                                "backupPlanRuleId" => Ok(__FieldTag::__backup_plan_rule_id),
                                "backup_plan_rule_id" => Ok(__FieldTag::__backup_plan_rule_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GCPBackupPlanInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GCPBackupPlanInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__backup_plan => {
                                if !fields.insert(__FieldTag::__backup_plan) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for backup_plan",
                                    ));
                                }
                                result.backup_plan = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__backup_plan_rule_id => {
                                if !fields.insert(__FieldTag::__backup_plan_rule_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for backup_plan_rule_id",
                                    ));
                                }
                                result.backup_plan_rule_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GCPBackupPlanInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.backup_plan.is_empty() {
                state.serialize_entry("backupPlan", &self.backup_plan)?;
            }
            if !self.backup_plan_rule_id.is_empty() {
                state.serialize_entry("backupPlanRuleId", &self.backup_plan_rule_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Holds the state of the backup resource.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State not set.
        Unspecified,
        /// The backup is being created.
        Creating,
        /// The backup has been created and is fully usable.
        Active,
        /// The backup is being deleted.
        Deleting,
        /// The backup is experiencing an issue and might be unusable.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                4 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.backupdr.v1.Backup.State",
            ))
        }
    }

    /// Type of the backup, scheduled or ondemand.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BackupType {
        /// Backup type is unspecified.
        Unspecified,
        /// Scheduled backup.
        Scheduled,
        /// On demand backup.
        OnDemand,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BackupType::value] or
        /// [BackupType::name].
        UnknownValue(backup_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod backup_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BackupType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Scheduled => std::option::Option::Some(1),
                Self::OnDemand => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BACKUP_TYPE_UNSPECIFIED"),
                Self::Scheduled => std::option::Option::Some("SCHEDULED"),
                Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BackupType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BackupType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BackupType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Scheduled,
                2 => Self::OnDemand,
                _ => Self::UnknownValue(backup_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BackupType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BACKUP_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SCHEDULED" => Self::Scheduled,
                "ON_DEMAND" => Self::OnDemand,
                _ => Self::UnknownValue(backup_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BackupType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Scheduled => serializer.serialize_i32(1),
                Self::OnDemand => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BackupType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackupType>::new(
                ".google.cloud.backupdr.v1.Backup.BackupType",
            ))
        }
    }

    /// Workload specific backup properties.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BackupProperties {
        /// Output only. Compute Engine specific backup properties.
        ComputeInstanceBackupProperties(
            std::boxed::Box<crate::model::ComputeInstanceBackupProperties>,
        ),
        /// Output only. Backup Appliance specific backup properties.
        BackupApplianceBackupProperties(
            std::boxed::Box<crate::model::BackupApplianceBackupProperties>,
        ),
    }

    /// Configuration Info has the resource format-specific configuration.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PlanInfo {
        /// Output only. Configuration for a Google Cloud resource.
        GcpBackupPlanInfo(std::boxed::Box<crate::model::backup::GCPBackupPlanInfo>),
    }
}

/// Message for creating a BackupVault.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBackupVaultRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. ID of the requesting object
    /// If auto-generating ID server-side, remove this field and
    /// backup_vault_id from the method_signature of Create RPC
    pub backup_vault_id: std::string::String,

    /// Required. The resource being created
    pub backup_vault: std::option::Option<crate::model::BackupVault>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is 'false'.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupVaultRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_vault_id][crate::model::CreateBackupVaultRequest::backup_vault_id].
    pub fn set_backup_vault_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_vault_id = v.into();
        self
    }

    /// Sets the value of [backup_vault][crate::model::CreateBackupVaultRequest::backup_vault].
    pub fn set_backup_vault<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupVault>,
    {
        self.backup_vault = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_vault][crate::model::CreateBackupVaultRequest::backup_vault].
    pub fn set_or_clear_backup_vault<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupVault>,
    {
        self.backup_vault = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateBackupVaultRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateBackupVaultRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.CreateBackupVaultRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBackupVaultRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __backup_vault_id,
            __backup_vault,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBackupVaultRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "backupVaultId" => Ok(__FieldTag::__backup_vault_id),
                            "backup_vault_id" => Ok(__FieldTag::__backup_vault_id),
                            "backupVault" => Ok(__FieldTag::__backup_vault),
                            "backup_vault" => Ok(__FieldTag::__backup_vault),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBackupVaultRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBackupVaultRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_vault_id => {
                            if !fields.insert(__FieldTag::__backup_vault_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_vault_id",
                                ));
                            }
                            result.backup_vault_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_vault => {
                            if !fields.insert(__FieldTag::__backup_vault) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_vault",
                                ));
                            }
                            result.backup_vault =
                                map.next_value::<std::option::Option<crate::model::BackupVault>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBackupVaultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.backup_vault_id.is_empty() {
            state.serialize_entry("backupVaultId", &self.backup_vault_id)?;
        }
        if self.backup_vault.is_some() {
            state.serialize_entry("backupVault", &self.backup_vault)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for listing backupvault stores.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupVaultsRequest {
    /// Required. The project and location for which to retrieve backupvault stores
    /// information, in the format 'projects/{project_id}/locations/{location}'. In
    /// Cloud Backup and DR, locations map to Google Cloud regions, for example
    /// **us-central1**.
    /// To retrieve backupvault stores for all locations, use "-" for the
    /// '{location}' value.
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    pub order_by: std::string::String,

    /// Optional. Reserved for future use to provide a BASIC & FULL view of Backup
    /// Vault.
    pub view: crate::model::BackupVaultView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupVaultsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupVaultsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupVaultsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupVaultsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupVaultsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupVaultsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListBackupVaultsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::BackupVaultView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupVaultsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListBackupVaultsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupVaultsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupVaultsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupVaultsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupVaultsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::BackupVaultView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupVaultsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for listing BackupVaults.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupVaultsResponse {
    /// The list of BackupVault instances in the project for the specified
    /// location.
    ///
    /// If the '{location}' value in the request is "-", the response contains a
    /// list of instances from all locations. In case any location is unreachable,
    /// the response will only return backup vaults in reachable locations and
    /// the 'unreachable' field will be populated with a list of unreachable
    /// locations.
    pub backup_vaults: std::vec::Vec<crate::model::BackupVault>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupVaultsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_vaults][crate::model::ListBackupVaultsResponse::backup_vaults].
    pub fn set_backup_vaults<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupVault>,
    {
        use std::iter::Iterator;
        self.backup_vaults = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupVaultsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupVaultsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupVaultsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListBackupVaultsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupVaultsResponse {
    type PageItem = crate::model::BackupVault;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backup_vaults
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupVaultsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_vaults,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupVaultsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupVaults" => Ok(__FieldTag::__backup_vaults),
                            "backup_vaults" => Ok(__FieldTag::__backup_vaults),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupVaultsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupVaultsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_vaults => {
                            if !fields.insert(__FieldTag::__backup_vaults) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_vaults",
                                ));
                            }
                            result.backup_vaults = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BackupVault>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupVaultsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup_vaults.is_empty() {
            state.serialize_entry("backupVaults", &self.backup_vaults)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for fetching usable BackupVaults.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchUsableBackupVaultsRequest {
    /// Required. The project and location for which to retrieve backupvault stores
    /// information, in the format 'projects/{project_id}/locations/{location}'. In
    /// Cloud Backup and DR, locations map to Google Cloud regions, for example
    /// **us-central1**.
    /// To retrieve backupvault stores for all locations, use "-" for the
    /// '{location}' value.
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchUsableBackupVaultsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::FetchUsableBackupVaultsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::FetchUsableBackupVaultsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::FetchUsableBackupVaultsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::FetchUsableBackupVaultsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::FetchUsableBackupVaultsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for FetchUsableBackupVaultsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.FetchUsableBackupVaultsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchUsableBackupVaultsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchUsableBackupVaultsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchUsableBackupVaultsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchUsableBackupVaultsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchUsableBackupVaultsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for fetching usable BackupVaults.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchUsableBackupVaultsResponse {
    /// The list of BackupVault instances in the project for the specified
    /// location.
    ///
    /// If the '{location}' value in the request is "-", the response contains a
    /// list of instances from all locations. In case any location is unreachable,
    /// the response will only return backup vaults in reachable locations and
    /// the 'unreachable' field will be populated with a list of unreachable
    /// locations.
    pub backup_vaults: std::vec::Vec<crate::model::BackupVault>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchUsableBackupVaultsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_vaults][crate::model::FetchUsableBackupVaultsResponse::backup_vaults].
    pub fn set_backup_vaults<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupVault>,
    {
        use std::iter::Iterator;
        self.backup_vaults = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::FetchUsableBackupVaultsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::FetchUsableBackupVaultsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FetchUsableBackupVaultsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.FetchUsableBackupVaultsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for FetchUsableBackupVaultsResponse {
    type PageItem = crate::model::BackupVault;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backup_vaults
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchUsableBackupVaultsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_vaults,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchUsableBackupVaultsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupVaults" => Ok(__FieldTag::__backup_vaults),
                            "backup_vaults" => Ok(__FieldTag::__backup_vaults),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchUsableBackupVaultsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchUsableBackupVaultsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_vaults => {
                            if !fields.insert(__FieldTag::__backup_vaults) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_vaults",
                                ));
                            }
                            result.backup_vaults = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BackupVault>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchUsableBackupVaultsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup_vaults.is_empty() {
            state.serialize_entry("backupVaults", &self.backup_vaults)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for getting a BackupVault.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupVaultRequest {
    /// Required. Name of the backupvault store resource name, in the format
    /// 'projects/{project_id}/locations/{location}/backupVaults/{resource_name}'
    pub name: std::string::String,

    /// Optional. Reserved for future use to provide a BASIC & FULL view of Backup
    /// Vault
    pub view: crate::model::BackupVaultView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupVaultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetBackupVaultRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::BackupVaultView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.GetBackupVaultRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupVaultRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupVaultRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupVaultRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupVaultRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::BackupVaultView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupVaultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for updating a BackupVault.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBackupVaultRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// BackupVault resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then the request will fail.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub backup_vault: std::option::Option<crate::model::BackupVault>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is 'false'.
    pub validate_only: bool,

    /// Optional. If set to true, will not check plan duration against backup vault
    /// enforcement duration.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBackupVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupVaultRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBackupVaultRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_vault][crate::model::UpdateBackupVaultRequest::backup_vault].
    pub fn set_backup_vault<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupVault>,
    {
        self.backup_vault = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_vault][crate::model::UpdateBackupVaultRequest::backup_vault].
    pub fn set_or_clear_backup_vault<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupVault>,
    {
        self.backup_vault = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateBackupVaultRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateBackupVaultRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [force][crate::model::UpdateBackupVaultRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBackupVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.UpdateBackupVaultRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateBackupVaultRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __backup_vault,
            __request_id,
            __validate_only,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBackupVaultRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "backupVault" => Ok(__FieldTag::__backup_vault),
                            "backup_vault" => Ok(__FieldTag::__backup_vault),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateBackupVaultRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBackupVaultRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__backup_vault => {
                            if !fields.insert(__FieldTag::__backup_vault) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_vault",
                                ));
                            }
                            result.backup_vault =
                                map.next_value::<std::option::Option<crate::model::BackupVault>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateBackupVaultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.backup_vault.is_some() {
            state.serialize_entry("backupVault", &self.backup_vault)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for deleting a BackupVault.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBackupVaultRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, any data source from this backup vault will also
    /// be deleted.
    pub force: bool,

    /// The current etag of the backup vault.
    /// If an etag is provided and does not match the current etag of the
    /// connection, deletion will be blocked.
    pub etag: std::string::String,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is 'false'.
    pub validate_only: bool,

    /// Optional. If true and the BackupVault is not found, the request will
    /// succeed but no action will be taken.
    pub allow_missing: bool,

    /// Optional. If set to true, backupvault deletion will proceed even if there
    /// are backup plans referencing the backupvault. The default is 'false'.
    pub ignore_backup_plan_references: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupVaultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteBackupVaultRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteBackupVaultRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteBackupVaultRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteBackupVaultRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteBackupVaultRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [ignore_backup_plan_references][crate::model::DeleteBackupVaultRequest::ignore_backup_plan_references].
    pub fn set_ignore_backup_plan_references<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_backup_plan_references = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.DeleteBackupVaultRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBackupVaultRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __force,
            __etag,
            __validate_only,
            __allow_missing,
            __ignore_backup_plan_references,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBackupVaultRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "force" => Ok(__FieldTag::__force),
                            "etag" => Ok(__FieldTag::__etag),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "ignoreBackupPlanReferences" => {
                                Ok(__FieldTag::__ignore_backup_plan_references)
                            }
                            "ignore_backup_plan_references" => {
                                Ok(__FieldTag::__ignore_backup_plan_references)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBackupVaultRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBackupVaultRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_backup_plan_references => {
                            if !fields.insert(__FieldTag::__ignore_backup_plan_references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_backup_plan_references",
                                ));
                            }
                            result.ignore_backup_plan_references = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBackupVaultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.ignore_backup_plan_references) {
            state.serialize_entry(
                "ignoreBackupPlanReferences",
                &self.ignore_backup_plan_references,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for listing DataSources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDataSourcesRequest {
    /// Required. The project and location for which to retrieve data
    /// sources information, in the format
    /// 'projects/{project_id}/locations/{location}'. In Cloud Backup and DR,
    /// locations map to Google Cloud regions, for example **us-central1**.
    /// To retrieve data sources for all locations, use "-" for the
    /// '{location}' value.
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataSourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataSourcesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataSourcesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataSourcesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDataSourcesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDataSourcesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDataSourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListDataSourcesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDataSourcesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDataSourcesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDataSourcesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDataSourcesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDataSourcesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for listing DataSources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDataSourcesResponse {
    /// The list of DataSource instances in the project for the specified
    /// location.
    ///
    /// If the '{location}' value in the request is "-", the response contains a
    /// list of instances from all locations. In case any location is unreachable,
    /// the response will only return data sources in reachable locations
    /// and the 'unreachable' field will be populated with a list of unreachable
    /// locations.
    pub data_sources: std::vec::Vec<crate::model::DataSource>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataSourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_sources][crate::model::ListDataSourcesResponse::data_sources].
    pub fn set_data_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataSource>,
    {
        use std::iter::Iterator;
        self.data_sources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDataSourcesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDataSourcesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDataSourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListDataSourcesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDataSourcesResponse {
    type PageItem = crate::model::DataSource;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_sources
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDataSourcesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_sources,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDataSourcesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataSources" => Ok(__FieldTag::__data_sources),
                            "data_sources" => Ok(__FieldTag::__data_sources),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDataSourcesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDataSourcesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_sources => {
                            if !fields.insert(__FieldTag::__data_sources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_sources",
                                ));
                            }
                            result.data_sources = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DataSource>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDataSourcesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_sources.is_empty() {
            state.serialize_entry("dataSources", &self.data_sources)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for getting a DataSource instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDataSourceRequest {
    /// Required. Name of the data source resource name, in the format
    /// 'projects/{project_id}/locations/{location}/backupVaults/{resource_name}/dataSource/{resource_name}'
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDataSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDataSourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDataSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.GetDataSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDataSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDataSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDataSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDataSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDataSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for updating a data source instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDataSourceRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// DataSource resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then the request will fail.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub data_source: std::option::Option<crate::model::DataSource>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. Enable upsert.
    pub allow_missing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDataSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDataSourceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDataSourceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_source][crate::model::UpdateDataSourceRequest::data_source].
    pub fn set_data_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataSource>,
    {
        self.data_source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_source][crate::model::UpdateDataSourceRequest::data_source].
    pub fn set_or_clear_data_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataSource>,
    {
        self.data_source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateDataSourceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateDataSourceRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDataSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.UpdateDataSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDataSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __data_source,
            __request_id,
            __allow_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDataSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "dataSource" => Ok(__FieldTag::__data_source),
                            "data_source" => Ok(__FieldTag::__data_source),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDataSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDataSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__data_source => {
                            if !fields.insert(__FieldTag::__data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source",
                                ));
                            }
                            result.data_source =
                                map.next_value::<std::option::Option<crate::model::DataSource>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDataSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.data_source.is_some() {
            state.serialize_entry("dataSource", &self.data_source)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for listing Backups.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. The project and location for which to retrieve backup
    /// information, in the format
    /// 'projects/{project_id}/locations/{location}'. In Cloud Backup and DR,
    /// locations map to Google Cloud regions, for example **us-central1**.
    /// To retrieve data sources for all locations, use "-" for the
    /// '{location}' value.
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    pub order_by: std::string::String,

    /// Optional. Reserved for future use to provide a BASIC & FULL view of Backup
    /// resource.
    pub view: crate::model::BackupView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListBackupsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::BackupView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListBackupsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::BackupView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for listing Backups.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// The list of Backup instances in the project for the specified
    /// location.
    ///
    /// If the '{location}' value in the request is "-", the response contains a
    /// list of instances from all locations. In case any location is unreachable,
    /// the response will only return data sources in reachable locations
    /// and the 'unreachable' field will be populated with a list of unreachable
    /// locations.
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListBackupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupsResponse {
    type PageItem = crate::model::Backup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backups,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backups" => Ok(__FieldTag::__backups),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backups => {
                            if !fields.insert(__FieldTag::__backups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backups",
                                ));
                            }
                            result.backups = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Backup>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backups.is_empty() {
            state.serialize_entry("backups", &self.backups)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for getting a Backup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. Name of the data source resource name, in the format
    /// 'projects/{project_id}/locations/{location}/backupVaults/{backupVault}/dataSources/{datasource}/backups/{backup}'
    pub name: std::string::String,

    /// Optional. Reserved for future use to provide a BASIC & FULL view of Backup
    /// resource.
    pub view: crate::model::BackupView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetBackupRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::BackupView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.GetBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::BackupView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for updating a Backup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBackupRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Backup resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then the request will fail.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub backup: std::option::Option<crate::model::Backup>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup][crate::model::UpdateBackupRequest::backup].
    pub fn set_backup<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup][crate::model::UpdateBackupRequest::backup].
    pub fn set_or_clear_backup<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateBackupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.UpdateBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __backup,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "backup" => Ok(__FieldTag::__backup),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__backup => {
                            if !fields.insert(__FieldTag::__backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup",
                                ));
                            }
                            result.backup =
                                map.next_value::<std::option::Option<crate::model::Backup>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.backup.is_some() {
            state.serialize_entry("backup", &self.backup)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for deleting a Backup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteBackupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.DeleteBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for restoring from a Backup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreBackupRequest {
    /// Required. The resource name of the Backup instance, in the format
    /// 'projects/*/locations/*/backupVaults/*/dataSources/*/backups/'.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// The target environment for the restore operation.
    pub target_environment:
        std::option::Option<crate::model::restore_backup_request::TargetEnvironment>,

    /// The property overrides for the instance being restored.
    pub instance_properties:
        std::option::Option<crate::model::restore_backup_request::InstanceProperties>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestoreBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::RestoreBackupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [target_environment][crate::model::RestoreBackupRequest::target_environment].
    ///
    /// Note that all the setters affecting `target_environment` are mutually
    /// exclusive.
    pub fn set_target_environment<
        T: std::convert::Into<
                std::option::Option<crate::model::restore_backup_request::TargetEnvironment>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_environment = v.into();
        self
    }

    /// The value of [target_environment][crate::model::RestoreBackupRequest::target_environment]
    /// if it holds a `ComputeInstanceTargetEnvironment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_instance_target_environment(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeInstanceTargetEnvironment>> {
        #[allow(unreachable_patterns)]
        self.target_environment.as_ref().and_then(|v| match v {
            crate::model::restore_backup_request::TargetEnvironment::ComputeInstanceTargetEnvironment(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_environment][crate::model::RestoreBackupRequest::target_environment]
    /// to hold a `ComputeInstanceTargetEnvironment`.
    ///
    /// Note that all the setters affecting `target_environment` are
    /// mutually exclusive.
    pub fn set_compute_instance_target_environment<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeInstanceTargetEnvironment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_environment = std::option::Option::Some(
            crate::model::restore_backup_request::TargetEnvironment::ComputeInstanceTargetEnvironment(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [instance_properties][crate::model::RestoreBackupRequest::instance_properties].
    ///
    /// Note that all the setters affecting `instance_properties` are mutually
    /// exclusive.
    pub fn set_instance_properties<
        T: std::convert::Into<
                std::option::Option<crate::model::restore_backup_request::InstanceProperties>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_properties = v.into();
        self
    }

    /// The value of [instance_properties][crate::model::RestoreBackupRequest::instance_properties]
    /// if it holds a `ComputeInstanceRestoreProperties`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_instance_restore_properties(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeInstanceRestoreProperties>> {
        #[allow(unreachable_patterns)]
        self.instance_properties.as_ref().and_then(|v| match v {
            crate::model::restore_backup_request::InstanceProperties::ComputeInstanceRestoreProperties(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [instance_properties][crate::model::RestoreBackupRequest::instance_properties]
    /// to hold a `ComputeInstanceRestoreProperties`.
    ///
    /// Note that all the setters affecting `instance_properties` are
    /// mutually exclusive.
    pub fn set_compute_instance_restore_properties<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeInstanceRestoreProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_properties = std::option::Option::Some(
            crate::model::restore_backup_request::InstanceProperties::ComputeInstanceRestoreProperties(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for RestoreBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.RestoreBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __compute_instance_target_environment,
            __compute_instance_restore_properties,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "computeInstanceTargetEnvironment" => {
                                Ok(__FieldTag::__compute_instance_target_environment)
                            }
                            "compute_instance_target_environment" => {
                                Ok(__FieldTag::__compute_instance_target_environment)
                            }
                            "computeInstanceRestoreProperties" => {
                                Ok(__FieldTag::__compute_instance_restore_properties)
                            }
                            "compute_instance_restore_properties" => {
                                Ok(__FieldTag::__compute_instance_restore_properties)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__compute_instance_target_environment => {
                            if !fields.insert(__FieldTag::__compute_instance_target_environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_instance_target_environment",
                                ));
                            }
                            if result.target_environment.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_environment`, a oneof with full ID .google.cloud.backupdr.v1.RestoreBackupRequest.compute_instance_target_environment, latest field was computeInstanceTargetEnvironment",
                                ));
                            }
                            result.target_environment = std::option::Option::Some(
                                crate::model::restore_backup_request::TargetEnvironment::ComputeInstanceTargetEnvironment(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ComputeInstanceTargetEnvironment>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__compute_instance_restore_properties => {
                            if !fields.insert(__FieldTag::__compute_instance_restore_properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_instance_restore_properties",
                                ));
                            }
                            if result.instance_properties.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `instance_properties`, a oneof with full ID .google.cloud.backupdr.v1.RestoreBackupRequest.compute_instance_restore_properties, latest field was computeInstanceRestoreProperties",
                                ));
                            }
                            result.instance_properties = std::option::Option::Some(
                                crate::model::restore_backup_request::InstanceProperties::ComputeInstanceRestoreProperties(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ComputeInstanceRestoreProperties>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestoreBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if let Some(value) = self.compute_instance_target_environment() {
            state.serialize_entry("computeInstanceTargetEnvironment", value)?;
        }
        if let Some(value) = self.compute_instance_restore_properties() {
            state.serialize_entry("computeInstanceRestoreProperties", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RestoreBackupRequest].
pub mod restore_backup_request {
    #[allow(unused_imports)]
    use super::*;

    /// The target environment for the restore operation.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetEnvironment {
        /// Compute Engine target environment to be used during restore.
        ComputeInstanceTargetEnvironment(
            std::boxed::Box<crate::model::ComputeInstanceTargetEnvironment>,
        ),
    }

    /// The property overrides for the instance being restored.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstanceProperties {
        /// Compute Engine instance properties to be overridden during restore.
        ComputeInstanceRestoreProperties(
            std::boxed::Box<crate::model::ComputeInstanceRestoreProperties>,
        ),
    }
}

/// Response message for restoring from a Backup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreBackupResponse {
    /// Details of the target resource created/modified as part of restore.
    pub target_resource: std::option::Option<crate::model::TargetResource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreBackupResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_resource][crate::model::RestoreBackupResponse::target_resource].
    pub fn set_target_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetResource>,
    {
        self.target_resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_resource][crate::model::RestoreBackupResponse::target_resource].
    pub fn set_or_clear_target_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetResource>,
    {
        self.target_resource = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RestoreBackupResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.RestoreBackupResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreBackupResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreBackupResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetResource" => Ok(__FieldTag::__target_resource),
                            "target_resource" => Ok(__FieldTag::__target_resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreBackupResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreBackupResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_resource => {
                            if !fields.insert(__FieldTag::__target_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_resource",
                                ));
                            }
                            result.target_resource = map
                                .next_value::<std::option::Option<crate::model::TargetResource>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestoreBackupResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.target_resource.is_some() {
            state.serialize_entry("targetResource", &self.target_resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Details of the target resource created/modified as part of restore.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TargetResource {
    /// Minimum details to identify the restored resource.
    pub target_resource_info:
        std::option::Option<crate::model::target_resource::TargetResourceInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_resource_info][crate::model::TargetResource::target_resource_info].
    ///
    /// Note that all the setters affecting `target_resource_info` are mutually
    /// exclusive.
    pub fn set_target_resource_info<
        T: std::convert::Into<std::option::Option<crate::model::target_resource::TargetResourceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_resource_info = v.into();
        self
    }

    /// The value of [target_resource_info][crate::model::TargetResource::target_resource_info]
    /// if it holds a `GcpResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcp_resource(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcpResource>> {
        #[allow(unreachable_patterns)]
        self.target_resource_info.as_ref().and_then(|v| match v {
            crate::model::target_resource::TargetResourceInfo::GcpResource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_resource_info][crate::model::TargetResource::target_resource_info]
    /// to hold a `GcpResource`.
    ///
    /// Note that all the setters affecting `target_resource_info` are
    /// mutually exclusive.
    pub fn set_gcp_resource<T: std::convert::Into<std::boxed::Box<crate::model::GcpResource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_resource_info = std::option::Option::Some(
            crate::model::target_resource::TargetResourceInfo::GcpResource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TargetResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.TargetResource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TargetResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcp_resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TargetResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcpResource" => Ok(__FieldTag::__gcp_resource),
                            "gcp_resource" => Ok(__FieldTag::__gcp_resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TargetResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TargetResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcp_resource => {
                            if !fields.insert(__FieldTag::__gcp_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_resource",
                                ));
                            }
                            if result.target_resource_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_resource_info`, a oneof with full ID .google.cloud.backupdr.v1.TargetResource.gcp_resource, latest field was gcpResource",
                                ));
                            }
                            result.target_resource_info = std::option::Option::Some(
                                crate::model::target_resource::TargetResourceInfo::GcpResource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcpResource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TargetResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcp_resource() {
            state.serialize_entry("gcpResource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TargetResource].
pub mod target_resource {
    #[allow(unused_imports)]
    use super::*;

    /// Minimum details to identify the restored resource.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetResourceInfo {
        /// Details of the native Google Cloud resource created as part of restore.
        GcpResource(std::boxed::Box<crate::model::GcpResource>),
    }
}

/// Minimum details to identify a Google Cloud resource
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GcpResource {
    /// Name of the Google Cloud resource.
    pub gcp_resourcename: std::string::String,

    /// Location of the resource: \<region\>/\<zone\>/"global"/"unspecified".
    pub location: std::string::String,

    /// Type of the resource. Use the Unified Resource Type,
    /// eg. compute.googleapis.com/Instance.
    pub r#type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcpResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcp_resourcename][crate::model::GcpResource::gcp_resourcename].
    pub fn set_gcp_resourcename<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gcp_resourcename = v.into();
        self
    }

    /// Sets the value of [location][crate::model::GcpResource::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::GcpResource::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for GcpResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.GcpResource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcpResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcp_resourcename,
            __location,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcpResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcpResourcename" => Ok(__FieldTag::__gcp_resourcename),
                            "gcp_resourcename" => Ok(__FieldTag::__gcp_resourcename),
                            "location" => Ok(__FieldTag::__location),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcpResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcpResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcp_resourcename => {
                            if !fields.insert(__FieldTag::__gcp_resourcename) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_resourcename",
                                ));
                            }
                            result.gcp_resourcename = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcpResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.gcp_resourcename.is_empty() {
            state.serialize_entry("gcpResourcename", &self.gcp_resourcename)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// BackupApplianceBackupProperties represents BackupDR backup appliance's
/// properties.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupApplianceBackupProperties {
    /// Output only. The numeric generation ID of the backup (monotonically
    /// increasing).
    pub generation_id: std::option::Option<i32>,

    /// Output only. The time when this backup object was finalized (if none,
    /// backup is not finalized).
    pub finalize_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The earliest timestamp of data available in this Backup.
    pub recovery_range_start_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The latest timestamp of data available in this Backup.
    pub recovery_range_end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupApplianceBackupProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generation_id][crate::model::BackupApplianceBackupProperties::generation_id].
    pub fn set_generation_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.generation_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [generation_id][crate::model::BackupApplianceBackupProperties::generation_id].
    pub fn set_or_clear_generation_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.generation_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [finalize_time][crate::model::BackupApplianceBackupProperties::finalize_time].
    pub fn set_finalize_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finalize_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [finalize_time][crate::model::BackupApplianceBackupProperties::finalize_time].
    pub fn set_or_clear_finalize_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finalize_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recovery_range_start_time][crate::model::BackupApplianceBackupProperties::recovery_range_start_time].
    pub fn set_recovery_range_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.recovery_range_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recovery_range_start_time][crate::model::BackupApplianceBackupProperties::recovery_range_start_time].
    pub fn set_or_clear_recovery_range_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.recovery_range_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recovery_range_end_time][crate::model::BackupApplianceBackupProperties::recovery_range_end_time].
    pub fn set_recovery_range_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.recovery_range_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recovery_range_end_time][crate::model::BackupApplianceBackupProperties::recovery_range_end_time].
    pub fn set_or_clear_recovery_range_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.recovery_range_end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BackupApplianceBackupProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupApplianceBackupProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupApplianceBackupProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generation_id,
            __finalize_time,
            __recovery_range_start_time,
            __recovery_range_end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupApplianceBackupProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generationId" => Ok(__FieldTag::__generation_id),
                            "generation_id" => Ok(__FieldTag::__generation_id),
                            "finalizeTime" => Ok(__FieldTag::__finalize_time),
                            "finalize_time" => Ok(__FieldTag::__finalize_time),
                            "recoveryRangeStartTime" => Ok(__FieldTag::__recovery_range_start_time),
                            "recovery_range_start_time" => {
                                Ok(__FieldTag::__recovery_range_start_time)
                            }
                            "recoveryRangeEndTime" => Ok(__FieldTag::__recovery_range_end_time),
                            "recovery_range_end_time" => Ok(__FieldTag::__recovery_range_end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupApplianceBackupProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupApplianceBackupProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generation_id => {
                            if !fields.insert(__FieldTag::__generation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation_id",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation_id = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__finalize_time => {
                            if !fields.insert(__FieldTag::__finalize_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finalize_time",
                                ));
                            }
                            result.finalize_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__recovery_range_start_time => {
                            if !fields.insert(__FieldTag::__recovery_range_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recovery_range_start_time",
                                ));
                            }
                            result.recovery_range_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__recovery_range_end_time => {
                            if !fields.insert(__FieldTag::__recovery_range_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recovery_range_end_time",
                                ));
                            }
                            result.recovery_range_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupApplianceBackupProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.generation_id.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("generationId", &__With(&self.generation_id))?;
        }
        if self.finalize_time.is_some() {
            state.serialize_entry("finalizeTime", &self.finalize_time)?;
        }
        if self.recovery_range_start_time.is_some() {
            state.serialize_entry("recoveryRangeStartTime", &self.recovery_range_start_time)?;
        }
        if self.recovery_range_end_time.is_some() {
            state.serialize_entry("recoveryRangeEndTime", &self.recovery_range_end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// ComputeInstanceBackupProperties represents Compute Engine instance backup
/// properties.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeInstanceBackupProperties {
    /// An optional text description for the instances that are created from these
    /// properties.
    pub description: std::option::Option<std::string::String>,

    /// A list of tags to apply to the instances that are created from these
    /// properties. The tags identify valid sources or targets for network
    /// firewalls. The setTags method can modify this list of tags. Each tag within
    /// the list must comply with RFC1035 (<https://www.ietf.org/rfc/rfc1035.txt>).
    pub tags: std::option::Option<crate::model::Tags>,

    /// The machine type to use for instances that are created from these
    /// properties.
    pub machine_type: std::option::Option<std::string::String>,

    /// Enables instances created based on these properties to send packets with
    /// source IP addresses other than their own and receive packets with
    /// destination IP addresses other than their own. If these instances will be
    /// used as an IP gateway or it will be set as the next-hop in a Route
    /// resource, specify `true`. If unsure, leave this set to `false`. See the
    /// <https://cloud.google.com/vpc/docs/using-routes#canipforward>
    /// documentation for more information.
    pub can_ip_forward: std::option::Option<bool>,

    /// An array of network access configurations for this interface.
    pub network_interface: std::vec::Vec<crate::model::NetworkInterface>,

    /// An array of disks that are associated with the instances that are created
    /// from these properties.
    pub disk: std::vec::Vec<crate::model::AttachedDisk>,

    /// The metadata key/value pairs to assign to instances that are created from
    /// these properties. These pairs can consist of custom metadata or predefined
    /// keys. See <https://cloud.google.com/compute/docs/metadata/overview> for more
    /// information.
    pub metadata: std::option::Option<crate::model::Metadata>,

    /// A list of service accounts with specified scopes. Access tokens for these
    /// service accounts are available to the instances that are created from
    /// these properties. Use metadata queries to obtain the access tokens for
    /// these instances.
    pub service_account: std::vec::Vec<crate::model::ServiceAccount>,

    /// Specifies the scheduling options for the instances that are created from
    /// these properties.
    pub scheduling: std::option::Option<crate::model::Scheduling>,

    /// A list of guest accelerator cards' type and count to use for instances
    /// created from these properties.
    pub guest_accelerator: std::vec::Vec<crate::model::AcceleratorConfig>,

    /// Minimum cpu/platform to be used by instances. The instance may be
    /// scheduled on the specified or newer cpu/platform. Applicable values are the
    /// friendly names of CPU platforms, such as
    /// `minCpuPlatform: Intel Haswell` or `minCpuPlatform: Intel Sandy Bridge`.
    /// For more information, read
    /// <https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform>.
    pub min_cpu_platform: std::option::Option<std::string::String>,

    /// KeyRevocationActionType of the instance. Supported options are "STOP" and
    /// "NONE". The default value is "NONE" if it is not specified.
    pub key_revocation_action_type: std::option::Option<crate::model::KeyRevocationActionType>,

    /// The source instance used to create this backup. This can be a partial or
    /// full URL to the resource. For example, the following are valid values:
    /// -<https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance>
    /// -projects/project/zones/zone/instances/instance
    pub source_instance: std::option::Option<std::string::String>,

    /// Labels to apply to instances that are created from these properties.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeInstanceBackupProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::ComputeInstanceBackupProperties::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::ComputeInstanceBackupProperties::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tags][crate::model::ComputeInstanceBackupProperties::tags].
    pub fn set_tags<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Tags>,
    {
        self.tags = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tags][crate::model::ComputeInstanceBackupProperties::tags].
    pub fn set_or_clear_tags<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Tags>,
    {
        self.tags = v.map(|x| x.into());
        self
    }

    /// Sets the value of [machine_type][crate::model::ComputeInstanceBackupProperties::machine_type].
    pub fn set_machine_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.machine_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [machine_type][crate::model::ComputeInstanceBackupProperties::machine_type].
    pub fn set_or_clear_machine_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.machine_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [can_ip_forward][crate::model::ComputeInstanceBackupProperties::can_ip_forward].
    pub fn set_can_ip_forward<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.can_ip_forward = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [can_ip_forward][crate::model::ComputeInstanceBackupProperties::can_ip_forward].
    pub fn set_or_clear_can_ip_forward<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.can_ip_forward = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_interface][crate::model::ComputeInstanceBackupProperties::network_interface].
    pub fn set_network_interface<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interface = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [disk][crate::model::ComputeInstanceBackupProperties::disk].
    pub fn set_disk<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedDisk>,
    {
        use std::iter::Iterator;
        self.disk = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::ComputeInstanceBackupProperties::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::ComputeInstanceBackupProperties::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_account][crate::model::ComputeInstanceBackupProperties::service_account].
    pub fn set_service_account<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ServiceAccount>,
    {
        use std::iter::Iterator;
        self.service_account = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [scheduling][crate::model::ComputeInstanceBackupProperties::scheduling].
    pub fn set_scheduling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Scheduling>,
    {
        self.scheduling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scheduling][crate::model::ComputeInstanceBackupProperties::scheduling].
    pub fn set_or_clear_scheduling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Scheduling>,
    {
        self.scheduling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [guest_accelerator][crate::model::ComputeInstanceBackupProperties::guest_accelerator].
    pub fn set_guest_accelerator<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AcceleratorConfig>,
    {
        use std::iter::Iterator;
        self.guest_accelerator = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [min_cpu_platform][crate::model::ComputeInstanceBackupProperties::min_cpu_platform].
    pub fn set_min_cpu_platform<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.min_cpu_platform = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_cpu_platform][crate::model::ComputeInstanceBackupProperties::min_cpu_platform].
    pub fn set_or_clear_min_cpu_platform<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.min_cpu_platform = v.map(|x| x.into());
        self
    }

    /// Sets the value of [key_revocation_action_type][crate::model::ComputeInstanceBackupProperties::key_revocation_action_type].
    pub fn set_key_revocation_action_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KeyRevocationActionType>,
    {
        self.key_revocation_action_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key_revocation_action_type][crate::model::ComputeInstanceBackupProperties::key_revocation_action_type].
    pub fn set_or_clear_key_revocation_action_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KeyRevocationActionType>,
    {
        self.key_revocation_action_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_instance][crate::model::ComputeInstanceBackupProperties::source_instance].
    pub fn set_source_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_instance][crate::model::ComputeInstanceBackupProperties::source_instance].
    pub fn set_or_clear_source_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::ComputeInstanceBackupProperties::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ComputeInstanceBackupProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ComputeInstanceBackupProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeInstanceBackupProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __description,
            __tags,
            __machine_type,
            __can_ip_forward,
            __network_interface,
            __disk,
            __metadata,
            __service_account,
            __scheduling,
            __guest_accelerator,
            __min_cpu_platform,
            __key_revocation_action_type,
            __source_instance,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeInstanceBackupProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "description" => Ok(__FieldTag::__description),
                            "tags" => Ok(__FieldTag::__tags),
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "canIpForward" => Ok(__FieldTag::__can_ip_forward),
                            "can_ip_forward" => Ok(__FieldTag::__can_ip_forward),
                            "networkInterface" => Ok(__FieldTag::__network_interface),
                            "network_interface" => Ok(__FieldTag::__network_interface),
                            "disk" => Ok(__FieldTag::__disk),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "scheduling" => Ok(__FieldTag::__scheduling),
                            "guestAccelerator" => Ok(__FieldTag::__guest_accelerator),
                            "guest_accelerator" => Ok(__FieldTag::__guest_accelerator),
                            "minCpuPlatform" => Ok(__FieldTag::__min_cpu_platform),
                            "min_cpu_platform" => Ok(__FieldTag::__min_cpu_platform),
                            "keyRevocationActionType" => {
                                Ok(__FieldTag::__key_revocation_action_type)
                            }
                            "key_revocation_action_type" => {
                                Ok(__FieldTag::__key_revocation_action_type)
                            }
                            "sourceInstance" => Ok(__FieldTag::__source_instance),
                            "source_instance" => Ok(__FieldTag::__source_instance),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeInstanceBackupProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeInstanceBackupProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags =
                                map.next_value::<std::option::Option<crate::model::Tags>>()?;
                        }
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__can_ip_forward => {
                            if !fields.insert(__FieldTag::__can_ip_forward) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for can_ip_forward",
                                ));
                            }
                            result.can_ip_forward =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__network_interface => {
                            if !fields.insert(__FieldTag::__network_interface) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_interface",
                                ));
                            }
                            result.network_interface =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NetworkInterface>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk => {
                            if !fields.insert(__FieldTag::__disk) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk",
                                ));
                            }
                            result.disk = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AttachedDisk>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata =
                                map.next_value::<std::option::Option<crate::model::Metadata>>()?;
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ServiceAccount>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scheduling => {
                            if !fields.insert(__FieldTag::__scheduling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scheduling",
                                ));
                            }
                            result.scheduling =
                                map.next_value::<std::option::Option<crate::model::Scheduling>>()?;
                        }
                        __FieldTag::__guest_accelerator => {
                            if !fields.insert(__FieldTag::__guest_accelerator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for guest_accelerator",
                                ));
                            }
                            result.guest_accelerator =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AcceleratorConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_cpu_platform => {
                            if !fields.insert(__FieldTag::__min_cpu_platform) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_cpu_platform",
                                ));
                            }
                            result.min_cpu_platform =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__key_revocation_action_type => {
                            if !fields.insert(__FieldTag::__key_revocation_action_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_revocation_action_type",
                                ));
                            }
                            result.key_revocation_action_type = map.next_value::<std::option::Option<crate::model::KeyRevocationActionType>>()?
                                ;
                        }
                        __FieldTag::__source_instance => {
                            if !fields.insert(__FieldTag::__source_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_instance",
                                ));
                            }
                            result.source_instance =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeInstanceBackupProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.tags.is_some() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if self.machine_type.is_some() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if self.can_ip_forward.is_some() {
            state.serialize_entry("canIpForward", &self.can_ip_forward)?;
        }
        if !self.network_interface.is_empty() {
            state.serialize_entry("networkInterface", &self.network_interface)?;
        }
        if !self.disk.is_empty() {
            state.serialize_entry("disk", &self.disk)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if self.scheduling.is_some() {
            state.serialize_entry("scheduling", &self.scheduling)?;
        }
        if !self.guest_accelerator.is_empty() {
            state.serialize_entry("guestAccelerator", &self.guest_accelerator)?;
        }
        if self.min_cpu_platform.is_some() {
            state.serialize_entry("minCpuPlatform", &self.min_cpu_platform)?;
        }
        if self.key_revocation_action_type.is_some() {
            state.serialize_entry("keyRevocationActionType", &self.key_revocation_action_type)?;
        }
        if self.source_instance.is_some() {
            state.serialize_entry("sourceInstance", &self.source_instance)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// ComputeInstanceRestoreProperties represents Compute Engine instance
/// properties to be overridden during restore.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeInstanceRestoreProperties {
    /// Required. Name of the compute instance.
    pub name: std::option::Option<std::string::String>,

    /// Optional. Controls for advanced machine-related behavior features.
    pub advanced_machine_features: std::option::Option<crate::model::AdvancedMachineFeatures>,

    /// Optional. Allows this instance to send and receive packets with
    /// non-matching destination or source IPs.
    pub can_ip_forward: std::option::Option<bool>,

    /// Optional. Controls Confidential compute options on the instance
    pub confidential_instance_config: std::option::Option<crate::model::ConfidentialInstanceConfig>,

    /// Optional. Whether the resource should be protected against deletion.
    pub deletion_protection: std::option::Option<bool>,

    /// Optional. An optional description of this resource. Provide this property
    /// when you create the resource.
    pub description: std::option::Option<std::string::String>,

    /// Optional. Array of disks associated with this instance. Persistent disks
    /// must be created before you can assign them.
    pub disks: std::vec::Vec<crate::model::AttachedDisk>,

    /// Optional. Enables display device for the instance.
    pub display_device: std::option::Option<crate::model::DisplayDevice>,

    /// Optional. A list of the type and count of accelerator cards attached to the
    /// instance.
    pub guest_accelerators: std::vec::Vec<crate::model::AcceleratorConfig>,

    /// Optional. Specifies the hostname of the instance. The specified hostname
    /// must be RFC1035 compliant. If hostname is not specified, the default
    /// hostname is [INSTANCE_NAME].c.[PROJECT_ID].internal when using the global
    /// DNS, and [INSTANCE_NAME].[ZONE].c.[PROJECT_ID].internal when using zonal
    /// DNS.
    pub hostname: std::option::Option<std::string::String>,

    /// Optional. Encrypts suspended data for an instance with a
    /// customer-managed encryption key.
    pub instance_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// Optional. KeyRevocationActionType of the instance.
    pub key_revocation_action_type: std::option::Option<crate::model::KeyRevocationActionType>,

    /// Optional. Labels to apply to this instance.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Full or partial URL of the machine type resource to use for this
    /// instance.
    pub machine_type: std::option::Option<std::string::String>,

    /// Optional. This includes custom metadata and predefined keys.
    pub metadata: std::option::Option<crate::model::Metadata>,

    /// Optional. Minimum CPU platform to use for this instance.
    pub min_cpu_platform: std::option::Option<std::string::String>,

    /// Optional. An array of network configurations for this instance. These
    /// specify how interfaces are configured to interact with other network
    /// services, such as connecting to the internet. Multiple interfaces are
    /// supported per instance.
    pub network_interfaces: std::vec::Vec<crate::model::NetworkInterface>,

    /// Optional. Configure network performance such as egress bandwidth tier.
    pub network_performance_config: std::option::Option<crate::model::NetworkPerformanceConfig>,

    /// Input only. Additional params passed with the request, but not persisted
    /// as part of resource payload.
    pub params: std::option::Option<crate::model::InstanceParams>,

    /// Optional. The private IPv6 google access type for the VM.
    /// If not specified, use INHERIT_FROM_SUBNETWORK as default.
    pub private_ipv6_google_access: std::option::Option<
        crate::model::compute_instance_restore_properties::InstancePrivateIpv6GoogleAccess,
    >,

    /// Optional. Specifies the reservations that this instance can consume from.
    pub allocation_affinity: std::option::Option<crate::model::AllocationAffinity>,

    /// Optional. Resource policies applied to this instance.
    pub resource_policies: std::vec::Vec<std::string::String>,

    /// Optional. Sets the scheduling options for this instance.
    pub scheduling: std::option::Option<crate::model::Scheduling>,

    /// Optional. A list of service accounts, with their specified scopes,
    /// authorized for this instance. Only one service account per VM instance is
    /// supported.
    pub service_accounts: std::vec::Vec<crate::model::ServiceAccount>,

    /// Optional. Tags to apply to this instance. Tags are used to identify valid
    /// sources or targets for network firewalls and are specified by the client
    /// during instance creation.
    pub tags: std::option::Option<crate::model::Tags>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeInstanceRestoreProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ComputeInstanceRestoreProperties::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::ComputeInstanceRestoreProperties::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [advanced_machine_features][crate::model::ComputeInstanceRestoreProperties::advanced_machine_features].
    pub fn set_advanced_machine_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedMachineFeatures>,
    {
        self.advanced_machine_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [advanced_machine_features][crate::model::ComputeInstanceRestoreProperties::advanced_machine_features].
    pub fn set_or_clear_advanced_machine_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedMachineFeatures>,
    {
        self.advanced_machine_features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [can_ip_forward][crate::model::ComputeInstanceRestoreProperties::can_ip_forward].
    pub fn set_can_ip_forward<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.can_ip_forward = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [can_ip_forward][crate::model::ComputeInstanceRestoreProperties::can_ip_forward].
    pub fn set_or_clear_can_ip_forward<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.can_ip_forward = v.map(|x| x.into());
        self
    }

    /// Sets the value of [confidential_instance_config][crate::model::ComputeInstanceRestoreProperties::confidential_instance_config].
    pub fn set_confidential_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialInstanceConfig>,
    {
        self.confidential_instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [confidential_instance_config][crate::model::ComputeInstanceRestoreProperties::confidential_instance_config].
    pub fn set_or_clear_confidential_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialInstanceConfig>,
    {
        self.confidential_instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deletion_protection][crate::model::ComputeInstanceRestoreProperties::deletion_protection].
    pub fn set_deletion_protection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deletion_protection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deletion_protection][crate::model::ComputeInstanceRestoreProperties::deletion_protection].
    pub fn set_or_clear_deletion_protection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deletion_protection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::ComputeInstanceRestoreProperties::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::ComputeInstanceRestoreProperties::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disks][crate::model::ComputeInstanceRestoreProperties::disks].
    pub fn set_disks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedDisk>,
    {
        use std::iter::Iterator;
        self.disks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [display_device][crate::model::ComputeInstanceRestoreProperties::display_device].
    pub fn set_display_device<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DisplayDevice>,
    {
        self.display_device = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [display_device][crate::model::ComputeInstanceRestoreProperties::display_device].
    pub fn set_or_clear_display_device<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DisplayDevice>,
    {
        self.display_device = v.map(|x| x.into());
        self
    }

    /// Sets the value of [guest_accelerators][crate::model::ComputeInstanceRestoreProperties::guest_accelerators].
    pub fn set_guest_accelerators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AcceleratorConfig>,
    {
        use std::iter::Iterator;
        self.guest_accelerators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hostname][crate::model::ComputeInstanceRestoreProperties::hostname].
    pub fn set_hostname<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.hostname = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hostname][crate::model::ComputeInstanceRestoreProperties::hostname].
    pub fn set_or_clear_hostname<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.hostname = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_encryption_key][crate::model::ComputeInstanceRestoreProperties::instance_encryption_key].
    pub fn set_instance_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.instance_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_encryption_key][crate::model::ComputeInstanceRestoreProperties::instance_encryption_key].
    pub fn set_or_clear_instance_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.instance_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [key_revocation_action_type][crate::model::ComputeInstanceRestoreProperties::key_revocation_action_type].
    pub fn set_key_revocation_action_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KeyRevocationActionType>,
    {
        self.key_revocation_action_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key_revocation_action_type][crate::model::ComputeInstanceRestoreProperties::key_revocation_action_type].
    pub fn set_or_clear_key_revocation_action_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KeyRevocationActionType>,
    {
        self.key_revocation_action_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::ComputeInstanceRestoreProperties::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [machine_type][crate::model::ComputeInstanceRestoreProperties::machine_type].
    pub fn set_machine_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.machine_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [machine_type][crate::model::ComputeInstanceRestoreProperties::machine_type].
    pub fn set_or_clear_machine_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.machine_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::ComputeInstanceRestoreProperties::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::ComputeInstanceRestoreProperties::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [min_cpu_platform][crate::model::ComputeInstanceRestoreProperties::min_cpu_platform].
    pub fn set_min_cpu_platform<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.min_cpu_platform = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_cpu_platform][crate::model::ComputeInstanceRestoreProperties::min_cpu_platform].
    pub fn set_or_clear_min_cpu_platform<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.min_cpu_platform = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_interfaces][crate::model::ComputeInstanceRestoreProperties::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [network_performance_config][crate::model::ComputeInstanceRestoreProperties::network_performance_config].
    pub fn set_network_performance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPerformanceConfig>,
    {
        self.network_performance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_performance_config][crate::model::ComputeInstanceRestoreProperties::network_performance_config].
    pub fn set_or_clear_network_performance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPerformanceConfig>,
    {
        self.network_performance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [params][crate::model::ComputeInstanceRestoreProperties::params].
    pub fn set_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceParams>,
    {
        self.params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [params][crate::model::ComputeInstanceRestoreProperties::params].
    pub fn set_or_clear_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceParams>,
    {
        self.params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_ipv6_google_access][crate::model::ComputeInstanceRestoreProperties::private_ipv6_google_access].
    pub fn set_private_ipv6_google_access<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::compute_instance_restore_properties::InstancePrivateIpv6GoogleAccess,
            >,
    {
        self.private_ipv6_google_access = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_ipv6_google_access][crate::model::ComputeInstanceRestoreProperties::private_ipv6_google_access].
    pub fn set_or_clear_private_ipv6_google_access<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::compute_instance_restore_properties::InstancePrivateIpv6GoogleAccess,
            >,
    {
        self.private_ipv6_google_access = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allocation_affinity][crate::model::ComputeInstanceRestoreProperties::allocation_affinity].
    pub fn set_allocation_affinity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AllocationAffinity>,
    {
        self.allocation_affinity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [allocation_affinity][crate::model::ComputeInstanceRestoreProperties::allocation_affinity].
    pub fn set_or_clear_allocation_affinity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AllocationAffinity>,
    {
        self.allocation_affinity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_policies][crate::model::ComputeInstanceRestoreProperties::resource_policies].
    pub fn set_resource_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [scheduling][crate::model::ComputeInstanceRestoreProperties::scheduling].
    pub fn set_scheduling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Scheduling>,
    {
        self.scheduling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scheduling][crate::model::ComputeInstanceRestoreProperties::scheduling].
    pub fn set_or_clear_scheduling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Scheduling>,
    {
        self.scheduling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_accounts][crate::model::ComputeInstanceRestoreProperties::service_accounts].
    pub fn set_service_accounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ServiceAccount>,
    {
        use std::iter::Iterator;
        self.service_accounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tags][crate::model::ComputeInstanceRestoreProperties::tags].
    pub fn set_tags<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Tags>,
    {
        self.tags = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tags][crate::model::ComputeInstanceRestoreProperties::tags].
    pub fn set_or_clear_tags<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Tags>,
    {
        self.tags = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ComputeInstanceRestoreProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ComputeInstanceRestoreProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeInstanceRestoreProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __advanced_machine_features,
            __can_ip_forward,
            __confidential_instance_config,
            __deletion_protection,
            __description,
            __disks,
            __display_device,
            __guest_accelerators,
            __hostname,
            __instance_encryption_key,
            __key_revocation_action_type,
            __labels,
            __machine_type,
            __metadata,
            __min_cpu_platform,
            __network_interfaces,
            __network_performance_config,
            __params,
            __private_ipv6_google_access,
            __allocation_affinity,
            __resource_policies,
            __scheduling,
            __service_accounts,
            __tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeInstanceRestoreProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "advancedMachineFeatures" => {
                                Ok(__FieldTag::__advanced_machine_features)
                            }
                            "advanced_machine_features" => {
                                Ok(__FieldTag::__advanced_machine_features)
                            }
                            "canIpForward" => Ok(__FieldTag::__can_ip_forward),
                            "can_ip_forward" => Ok(__FieldTag::__can_ip_forward),
                            "confidentialInstanceConfig" => {
                                Ok(__FieldTag::__confidential_instance_config)
                            }
                            "confidential_instance_config" => {
                                Ok(__FieldTag::__confidential_instance_config)
                            }
                            "deletionProtection" => Ok(__FieldTag::__deletion_protection),
                            "deletion_protection" => Ok(__FieldTag::__deletion_protection),
                            "description" => Ok(__FieldTag::__description),
                            "disks" => Ok(__FieldTag::__disks),
                            "displayDevice" => Ok(__FieldTag::__display_device),
                            "display_device" => Ok(__FieldTag::__display_device),
                            "guestAccelerators" => Ok(__FieldTag::__guest_accelerators),
                            "guest_accelerators" => Ok(__FieldTag::__guest_accelerators),
                            "hostname" => Ok(__FieldTag::__hostname),
                            "instanceEncryptionKey" => Ok(__FieldTag::__instance_encryption_key),
                            "instance_encryption_key" => Ok(__FieldTag::__instance_encryption_key),
                            "keyRevocationActionType" => {
                                Ok(__FieldTag::__key_revocation_action_type)
                            }
                            "key_revocation_action_type" => {
                                Ok(__FieldTag::__key_revocation_action_type)
                            }
                            "labels" => Ok(__FieldTag::__labels),
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "minCpuPlatform" => Ok(__FieldTag::__min_cpu_platform),
                            "min_cpu_platform" => Ok(__FieldTag::__min_cpu_platform),
                            "networkInterfaces" => Ok(__FieldTag::__network_interfaces),
                            "network_interfaces" => Ok(__FieldTag::__network_interfaces),
                            "networkPerformanceConfig" => {
                                Ok(__FieldTag::__network_performance_config)
                            }
                            "network_performance_config" => {
                                Ok(__FieldTag::__network_performance_config)
                            }
                            "params" => Ok(__FieldTag::__params),
                            "privateIpv6GoogleAccess" => {
                                Ok(__FieldTag::__private_ipv6_google_access)
                            }
                            "private_ipv6_google_access" => {
                                Ok(__FieldTag::__private_ipv6_google_access)
                            }
                            "allocationAffinity" => Ok(__FieldTag::__allocation_affinity),
                            "allocation_affinity" => Ok(__FieldTag::__allocation_affinity),
                            "resourcePolicies" => Ok(__FieldTag::__resource_policies),
                            "resource_policies" => Ok(__FieldTag::__resource_policies),
                            "scheduling" => Ok(__FieldTag::__scheduling),
                            "serviceAccounts" => Ok(__FieldTag::__service_accounts),
                            "service_accounts" => Ok(__FieldTag::__service_accounts),
                            "tags" => Ok(__FieldTag::__tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeInstanceRestoreProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeInstanceRestoreProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__advanced_machine_features => {
                            if !fields.insert(__FieldTag::__advanced_machine_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advanced_machine_features",
                                ));
                            }
                            result.advanced_machine_features = map.next_value::<std::option::Option<crate::model::AdvancedMachineFeatures>>()?
                                ;
                        }
                        __FieldTag::__can_ip_forward => {
                            if !fields.insert(__FieldTag::__can_ip_forward) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for can_ip_forward",
                                ));
                            }
                            result.can_ip_forward =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__confidential_instance_config => {
                            if !fields.insert(__FieldTag::__confidential_instance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidential_instance_config",
                                ));
                            }
                            result.confidential_instance_config = map.next_value::<std::option::Option<crate::model::ConfidentialInstanceConfig>>()?
                                ;
                        }
                        __FieldTag::__deletion_protection => {
                            if !fields.insert(__FieldTag::__deletion_protection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deletion_protection",
                                ));
                            }
                            result.deletion_protection =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__disks => {
                            if !fields.insert(__FieldTag::__disks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disks",
                                ));
                            }
                            result.disks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AttachedDisk>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__display_device => {
                            if !fields.insert(__FieldTag::__display_device) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_device",
                                ));
                            }
                            result.display_device = map
                                .next_value::<std::option::Option<crate::model::DisplayDevice>>()?;
                        }
                        __FieldTag::__guest_accelerators => {
                            if !fields.insert(__FieldTag::__guest_accelerators) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for guest_accelerators",
                                ));
                            }
                            result.guest_accelerators =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AcceleratorConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__instance_encryption_key => {
                            if !fields.insert(__FieldTag::__instance_encryption_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_encryption_key",
                                ));
                            }
                            result.instance_encryption_key = map.next_value::<std::option::Option<crate::model::CustomerEncryptionKey>>()?
                                ;
                        }
                        __FieldTag::__key_revocation_action_type => {
                            if !fields.insert(__FieldTag::__key_revocation_action_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_revocation_action_type",
                                ));
                            }
                            result.key_revocation_action_type = map.next_value::<std::option::Option<crate::model::KeyRevocationActionType>>()?
                                ;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata =
                                map.next_value::<std::option::Option<crate::model::Metadata>>()?;
                        }
                        __FieldTag::__min_cpu_platform => {
                            if !fields.insert(__FieldTag::__min_cpu_platform) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_cpu_platform",
                                ));
                            }
                            result.min_cpu_platform =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__network_interfaces => {
                            if !fields.insert(__FieldTag::__network_interfaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_interfaces",
                                ));
                            }
                            result.network_interfaces =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NetworkInterface>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_performance_config => {
                            if !fields.insert(__FieldTag::__network_performance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_performance_config",
                                ));
                            }
                            result.network_performance_config = map.next_value::<std::option::Option<crate::model::NetworkPerformanceConfig>>()?
                                ;
                        }
                        __FieldTag::__params => {
                            if !fields.insert(__FieldTag::__params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for params",
                                ));
                            }
                            result.params = map
                                .next_value::<std::option::Option<crate::model::InstanceParams>>(
                                )?;
                        }
                        __FieldTag::__private_ipv6_google_access => {
                            if !fields.insert(__FieldTag::__private_ipv6_google_access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_ipv6_google_access",
                                ));
                            }
                            result.private_ipv6_google_access = map.next_value::<std::option::Option<crate::model::compute_instance_restore_properties::InstancePrivateIpv6GoogleAccess>>()?
                                ;
                        }
                        __FieldTag::__allocation_affinity => {
                            if !fields.insert(__FieldTag::__allocation_affinity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allocation_affinity",
                                ));
                            }
                            result.allocation_affinity = map.next_value::<std::option::Option<crate::model::AllocationAffinity>>()?
                                ;
                        }
                        __FieldTag::__resource_policies => {
                            if !fields.insert(__FieldTag::__resource_policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_policies",
                                ));
                            }
                            result.resource_policies = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__scheduling => {
                            if !fields.insert(__FieldTag::__scheduling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scheduling",
                                ));
                            }
                            result.scheduling =
                                map.next_value::<std::option::Option<crate::model::Scheduling>>()?;
                        }
                        __FieldTag::__service_accounts => {
                            if !fields.insert(__FieldTag::__service_accounts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_accounts",
                                ));
                            }
                            result.service_accounts =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ServiceAccount>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags =
                                map.next_value::<std::option::Option<crate::model::Tags>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeInstanceRestoreProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.advanced_machine_features.is_some() {
            state.serialize_entry("advancedMachineFeatures", &self.advanced_machine_features)?;
        }
        if self.can_ip_forward.is_some() {
            state.serialize_entry("canIpForward", &self.can_ip_forward)?;
        }
        if self.confidential_instance_config.is_some() {
            state.serialize_entry(
                "confidentialInstanceConfig",
                &self.confidential_instance_config,
            )?;
        }
        if self.deletion_protection.is_some() {
            state.serialize_entry("deletionProtection", &self.deletion_protection)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.disks.is_empty() {
            state.serialize_entry("disks", &self.disks)?;
        }
        if self.display_device.is_some() {
            state.serialize_entry("displayDevice", &self.display_device)?;
        }
        if !self.guest_accelerators.is_empty() {
            state.serialize_entry("guestAccelerators", &self.guest_accelerators)?;
        }
        if self.hostname.is_some() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if self.instance_encryption_key.is_some() {
            state.serialize_entry("instanceEncryptionKey", &self.instance_encryption_key)?;
        }
        if self.key_revocation_action_type.is_some() {
            state.serialize_entry("keyRevocationActionType", &self.key_revocation_action_type)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.machine_type.is_some() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if self.min_cpu_platform.is_some() {
            state.serialize_entry("minCpuPlatform", &self.min_cpu_platform)?;
        }
        if !self.network_interfaces.is_empty() {
            state.serialize_entry("networkInterfaces", &self.network_interfaces)?;
        }
        if self.network_performance_config.is_some() {
            state.serialize_entry("networkPerformanceConfig", &self.network_performance_config)?;
        }
        if self.params.is_some() {
            state.serialize_entry("params", &self.params)?;
        }
        if self.private_ipv6_google_access.is_some() {
            state.serialize_entry("privateIpv6GoogleAccess", &self.private_ipv6_google_access)?;
        }
        if self.allocation_affinity.is_some() {
            state.serialize_entry("allocationAffinity", &self.allocation_affinity)?;
        }
        if !self.resource_policies.is_empty() {
            state.serialize_entry("resourcePolicies", &self.resource_policies)?;
        }
        if self.scheduling.is_some() {
            state.serialize_entry("scheduling", &self.scheduling)?;
        }
        if !self.service_accounts.is_empty() {
            state.serialize_entry("serviceAccounts", &self.service_accounts)?;
        }
        if self.tags.is_some() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ComputeInstanceRestoreProperties].
pub mod compute_instance_restore_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The private IPv6 google access type for the VMs.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstancePrivateIpv6GoogleAccess {
        /// Default value. This value is unused.
        Unspecified,
        /// Each network interface inherits PrivateIpv6GoogleAccess from its
        /// subnetwork.
        InheritFromSubnetwork,
        /// Outbound private IPv6 access from VMs in this subnet to Google services.
        /// If specified, the subnetwork who is attached to the instance's default
        /// network interface will be assigned an internal IPv6 prefix if it doesn't
        /// have before.
        EnableOutboundVmAccessToGoogle,
        /// Bidirectional private IPv6 access to/from Google services. If
        /// specified, the subnetwork who is attached to the instance's default
        /// network interface will be assigned an internal IPv6 prefix if it doesn't
        /// have before.
        EnableBidirectionalAccessToGoogle,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstancePrivateIpv6GoogleAccess::value] or
        /// [InstancePrivateIpv6GoogleAccess::name].
        UnknownValue(instance_private_ipv_6_google_access::UnknownValue),
    }

    #[doc(hidden)]
    pub mod instance_private_ipv_6_google_access {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl InstancePrivateIpv6GoogleAccess {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InheritFromSubnetwork => std::option::Option::Some(1),
                Self::EnableOutboundVmAccessToGoogle => std::option::Option::Some(2),
                Self::EnableBidirectionalAccessToGoogle => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("INSTANCE_PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED")
                }
                Self::InheritFromSubnetwork => std::option::Option::Some("INHERIT_FROM_SUBNETWORK"),
                Self::EnableOutboundVmAccessToGoogle => {
                    std::option::Option::Some("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE")
                }
                Self::EnableBidirectionalAccessToGoogle => {
                    std::option::Option::Some("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for InstancePrivateIpv6GoogleAccess {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for InstancePrivateIpv6GoogleAccess {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for InstancePrivateIpv6GoogleAccess {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InheritFromSubnetwork,
                2 => Self::EnableOutboundVmAccessToGoogle,
                3 => Self::EnableBidirectionalAccessToGoogle,
                _ => Self::UnknownValue(instance_private_ipv_6_google_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for InstancePrivateIpv6GoogleAccess {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INSTANCE_PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED" => Self::Unspecified,
                "INHERIT_FROM_SUBNETWORK" => Self::InheritFromSubnetwork,
                "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE" => Self::EnableOutboundVmAccessToGoogle,
                "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE" => Self::EnableBidirectionalAccessToGoogle,
                _ => Self::UnknownValue(instance_private_ipv_6_google_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for InstancePrivateIpv6GoogleAccess {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InheritFromSubnetwork => serializer.serialize_i32(1),
                Self::EnableOutboundVmAccessToGoogle => serializer.serialize_i32(2),
                Self::EnableBidirectionalAccessToGoogle => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for InstancePrivateIpv6GoogleAccess {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InstancePrivateIpv6GoogleAccess>::new(
                ".google.cloud.backupdr.v1.ComputeInstanceRestoreProperties.InstancePrivateIpv6GoogleAccess"))
        }
    }
}

/// ComputeInstanceTargetEnvironment represents Compute Engine target
/// environment to be used during restore.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeInstanceTargetEnvironment {
    /// Required. Target project for the Compute Engine instance.
    pub project: std::string::String,

    /// Required. The zone of the Compute Engine instance.
    pub zone: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeInstanceTargetEnvironment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::ComputeInstanceTargetEnvironment::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::ComputeInstanceTargetEnvironment::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }
}

impl wkt::message::Message for ComputeInstanceTargetEnvironment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ComputeInstanceTargetEnvironment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeInstanceTargetEnvironment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project,
            __zone,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeInstanceTargetEnvironment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "project" => Ok(__FieldTag::__project),
                            "zone" => Ok(__FieldTag::__zone),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeInstanceTargetEnvironment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeInstanceTargetEnvironment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeInstanceTargetEnvironment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// ComputeInstanceDataSourceProperties represents the properties of a
/// ComputeEngine resource that are stored in the DataSource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeInstanceDataSourceProperties {
    /// Name of the compute instance backed up by the datasource.
    pub name: std::string::String,

    /// The description of the Compute Engine instance.
    pub description: std::string::String,

    /// The machine type of the instance.
    pub machine_type: std::string::String,

    /// The total number of disks attached to the Instance.
    pub total_disk_count: i64,

    /// The sum of all the disk sizes.
    pub total_disk_size_gb: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeInstanceDataSourceProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ComputeInstanceDataSourceProperties::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ComputeInstanceDataSourceProperties::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [machine_type][crate::model::ComputeInstanceDataSourceProperties::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [total_disk_count][crate::model::ComputeInstanceDataSourceProperties::total_disk_count].
    pub fn set_total_disk_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_disk_count = v.into();
        self
    }

    /// Sets the value of [total_disk_size_gb][crate::model::ComputeInstanceDataSourceProperties::total_disk_size_gb].
    pub fn set_total_disk_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_disk_size_gb = v.into();
        self
    }
}

impl wkt::message::Message for ComputeInstanceDataSourceProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ComputeInstanceDataSourceProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeInstanceDataSourceProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __machine_type,
            __total_disk_count,
            __total_disk_size_gb,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeInstanceDataSourceProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "totalDiskCount" => Ok(__FieldTag::__total_disk_count),
                            "total_disk_count" => Ok(__FieldTag::__total_disk_count),
                            "totalDiskSizeGb" => Ok(__FieldTag::__total_disk_size_gb),
                            "total_disk_size_gb" => Ok(__FieldTag::__total_disk_size_gb),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeInstanceDataSourceProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeInstanceDataSourceProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_disk_count => {
                            if !fields.insert(__FieldTag::__total_disk_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_disk_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_disk_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_disk_size_gb => {
                            if !fields.insert(__FieldTag::__total_disk_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_disk_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_disk_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeInstanceDataSourceProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.machine_type.is_empty() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !wkt::internal::is_default(&self.total_disk_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalDiskCount", &__With(&self.total_disk_count))?;
        }
        if !wkt::internal::is_default(&self.total_disk_size_gb) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalDiskSizeGb", &__With(&self.total_disk_size_gb))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specifies options for controlling advanced machine features.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AdvancedMachineFeatures {
    /// Optional. Whether to enable nested virtualization or not (default is
    /// false).
    pub enable_nested_virtualization: std::option::Option<bool>,

    /// Optional. The number of threads per physical core. To disable simultaneous
    /// multithreading (SMT) set this to 1. If unset, the maximum number
    /// of threads supported per core by the underlying processor is
    /// assumed.
    pub threads_per_core: std::option::Option<i32>,

    /// Optional. The number of physical cores to expose to an instance. Multiply
    /// by the number of threads per core to compute the total number of virtual
    /// CPUs to expose to the instance. If unset, the number of cores is
    /// inferred from the instance's nominal CPU count and the underlying
    /// platform's SMT width.
    pub visible_core_count: std::option::Option<i32>,

    /// Optional. Whether to enable UEFI networking for instance creation.
    pub enable_uefi_networking: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvancedMachineFeatures {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_nested_virtualization][crate::model::AdvancedMachineFeatures::enable_nested_virtualization].
    pub fn set_enable_nested_virtualization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_nested_virtualization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_nested_virtualization][crate::model::AdvancedMachineFeatures::enable_nested_virtualization].
    pub fn set_or_clear_enable_nested_virtualization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_nested_virtualization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [threads_per_core][crate::model::AdvancedMachineFeatures::threads_per_core].
    pub fn set_threads_per_core<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.threads_per_core = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threads_per_core][crate::model::AdvancedMachineFeatures::threads_per_core].
    pub fn set_or_clear_threads_per_core<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.threads_per_core = v.map(|x| x.into());
        self
    }

    /// Sets the value of [visible_core_count][crate::model::AdvancedMachineFeatures::visible_core_count].
    pub fn set_visible_core_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.visible_core_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [visible_core_count][crate::model::AdvancedMachineFeatures::visible_core_count].
    pub fn set_or_clear_visible_core_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.visible_core_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_uefi_networking][crate::model::AdvancedMachineFeatures::enable_uefi_networking].
    pub fn set_enable_uefi_networking<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_uefi_networking = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_uefi_networking][crate::model::AdvancedMachineFeatures::enable_uefi_networking].
    pub fn set_or_clear_enable_uefi_networking<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_uefi_networking = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AdvancedMachineFeatures {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.AdvancedMachineFeatures"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdvancedMachineFeatures {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_nested_virtualization,
            __threads_per_core,
            __visible_core_count,
            __enable_uefi_networking,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdvancedMachineFeatures")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableNestedVirtualization" => {
                                Ok(__FieldTag::__enable_nested_virtualization)
                            }
                            "enable_nested_virtualization" => {
                                Ok(__FieldTag::__enable_nested_virtualization)
                            }
                            "threadsPerCore" => Ok(__FieldTag::__threads_per_core),
                            "threads_per_core" => Ok(__FieldTag::__threads_per_core),
                            "visibleCoreCount" => Ok(__FieldTag::__visible_core_count),
                            "visible_core_count" => Ok(__FieldTag::__visible_core_count),
                            "enableUefiNetworking" => Ok(__FieldTag::__enable_uefi_networking),
                            "enable_uefi_networking" => Ok(__FieldTag::__enable_uefi_networking),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdvancedMachineFeatures;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdvancedMachineFeatures")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_nested_virtualization => {
                            if !fields.insert(__FieldTag::__enable_nested_virtualization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_nested_virtualization",
                                ));
                            }
                            result.enable_nested_virtualization =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__threads_per_core => {
                            if !fields.insert(__FieldTag::__threads_per_core) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threads_per_core",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.threads_per_core = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__visible_core_count => {
                            if !fields.insert(__FieldTag::__visible_core_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for visible_core_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.visible_core_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__enable_uefi_networking => {
                            if !fields.insert(__FieldTag::__enable_uefi_networking) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_uefi_networking",
                                ));
                            }
                            result.enable_uefi_networking =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdvancedMachineFeatures {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enable_nested_virtualization.is_some() {
            state.serialize_entry(
                "enableNestedVirtualization",
                &self.enable_nested_virtualization,
            )?;
        }
        if self.threads_per_core.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("threadsPerCore", &__With(&self.threads_per_core))?;
        }
        if self.visible_core_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("visibleCoreCount", &__With(&self.visible_core_count))?;
        }
        if self.enable_uefi_networking.is_some() {
            state.serialize_entry("enableUefiNetworking", &self.enable_uefi_networking)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A set of Confidential Instance options.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ConfidentialInstanceConfig {
    /// Optional. Defines whether the instance should have confidential compute
    /// enabled.
    pub enable_confidential_compute: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfidentialInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_confidential_compute][crate::model::ConfidentialInstanceConfig::enable_confidential_compute].
    pub fn set_enable_confidential_compute<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_confidential_compute = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_confidential_compute][crate::model::ConfidentialInstanceConfig::enable_confidential_compute].
    pub fn set_or_clear_enable_confidential_compute<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_confidential_compute = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ConfidentialInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ConfidentialInstanceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConfidentialInstanceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_confidential_compute,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfidentialInstanceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableConfidentialCompute" => {
                                Ok(__FieldTag::__enable_confidential_compute)
                            }
                            "enable_confidential_compute" => {
                                Ok(__FieldTag::__enable_confidential_compute)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConfidentialInstanceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfidentialInstanceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_confidential_compute => {
                            if !fields.insert(__FieldTag::__enable_confidential_compute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_confidential_compute",
                                ));
                            }
                            result.enable_confidential_compute =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConfidentialInstanceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enable_confidential_compute.is_some() {
            state.serialize_entry(
                "enableConfidentialCompute",
                &self.enable_confidential_compute,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A set of Display Device options
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DisplayDevice {
    /// Optional. Enables display for the Compute Engine VM
    pub enable_display: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisplayDevice {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_display][crate::model::DisplayDevice::enable_display].
    pub fn set_enable_display<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_display = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_display][crate::model::DisplayDevice::enable_display].
    pub fn set_or_clear_enable_display<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_display = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DisplayDevice {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.DisplayDevice"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DisplayDevice {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_display,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DisplayDevice")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableDisplay" => Ok(__FieldTag::__enable_display),
                            "enable_display" => Ok(__FieldTag::__enable_display),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DisplayDevice;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisplayDevice")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_display => {
                            if !fields.insert(__FieldTag::__enable_display) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_display",
                                ));
                            }
                            result.enable_display =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DisplayDevice {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enable_display.is_some() {
            state.serialize_entry("enableDisplay", &self.enable_display)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A specification of the type and number of accelerator cards attached to the
/// instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AcceleratorConfig {
    /// Optional. Full or partial URL of the accelerator type resource to attach to
    /// this instance.
    pub accelerator_type: std::option::Option<std::string::String>,

    /// Optional. The number of the guest accelerator cards exposed to this
    /// instance.
    pub accelerator_count: std::option::Option<i32>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AcceleratorConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [accelerator_type][crate::model::AcceleratorConfig::accelerator_type].
    pub fn set_accelerator_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.accelerator_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [accelerator_type][crate::model::AcceleratorConfig::accelerator_type].
    pub fn set_or_clear_accelerator_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.accelerator_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [accelerator_count][crate::model::AcceleratorConfig::accelerator_count].
    pub fn set_accelerator_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.accelerator_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [accelerator_count][crate::model::AcceleratorConfig::accelerator_count].
    pub fn set_or_clear_accelerator_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.accelerator_count = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AcceleratorConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.AcceleratorConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AcceleratorConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __accelerator_type,
            __accelerator_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AcceleratorConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "acceleratorType" => Ok(__FieldTag::__accelerator_type),
                            "accelerator_type" => Ok(__FieldTag::__accelerator_type),
                            "acceleratorCount" => Ok(__FieldTag::__accelerator_count),
                            "accelerator_count" => Ok(__FieldTag::__accelerator_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AcceleratorConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AcceleratorConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__accelerator_type => {
                            if !fields.insert(__FieldTag::__accelerator_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerator_type",
                                ));
                            }
                            result.accelerator_type =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__accelerator_count => {
                            if !fields.insert(__FieldTag::__accelerator_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerator_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.accelerator_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AcceleratorConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.accelerator_type.is_some() {
            state.serialize_entry("acceleratorType", &self.accelerator_type)?;
        }
        if self.accelerator_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("acceleratorCount", &__With(&self.accelerator_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A customer-supplied encryption key.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomerEncryptionKey {
    /// Optional. The service account being used for the encryption request for the
    /// given KMS key. If absent, the Compute Engine default service account is
    /// used.
    pub kms_key_service_account: std::option::Option<std::string::String>,

    /// The key to use for encryption.
    pub key: std::option::Option<crate::model::customer_encryption_key::Key>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomerEncryptionKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_service_account][crate::model::CustomerEncryptionKey::kms_key_service_account].
    pub fn set_kms_key_service_account<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kms_key_service_account = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kms_key_service_account][crate::model::CustomerEncryptionKey::kms_key_service_account].
    pub fn set_or_clear_kms_key_service_account<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kms_key_service_account = v.map(|x| x.into());
        self
    }

    /// Sets the value of [key][crate::model::CustomerEncryptionKey::key].
    ///
    /// Note that all the setters affecting `key` are mutually
    /// exclusive.
    pub fn set_key<
        T: std::convert::Into<std::option::Option<crate::model::customer_encryption_key::Key>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.key = v.into();
        self
    }

    /// The value of [key][crate::model::CustomerEncryptionKey::key]
    /// if it holds a `RawKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn raw_key(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.key.as_ref().and_then(|v| match v {
            crate::model::customer_encryption_key::Key::RawKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [key][crate::model::CustomerEncryptionKey::key]
    /// to hold a `RawKey`.
    ///
    /// Note that all the setters affecting `key` are
    /// mutually exclusive.
    pub fn set_raw_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key =
            std::option::Option::Some(crate::model::customer_encryption_key::Key::RawKey(v.into()));
        self
    }

    /// The value of [key][crate::model::CustomerEncryptionKey::key]
    /// if it holds a `RsaEncryptedKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rsa_encrypted_key(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.key.as_ref().and_then(|v| match v {
            crate::model::customer_encryption_key::Key::RsaEncryptedKey(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [key][crate::model::CustomerEncryptionKey::key]
    /// to hold a `RsaEncryptedKey`.
    ///
    /// Note that all the setters affecting `key` are
    /// mutually exclusive.
    pub fn set_rsa_encrypted_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.key = std::option::Option::Some(
            crate::model::customer_encryption_key::Key::RsaEncryptedKey(v.into()),
        );
        self
    }

    /// The value of [key][crate::model::CustomerEncryptionKey::key]
    /// if it holds a `KmsKeyName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn kms_key_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.key.as_ref().and_then(|v| match v {
            crate::model::customer_encryption_key::Key::KmsKeyName(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [key][crate::model::CustomerEncryptionKey::key]
    /// to hold a `KmsKeyName`.
    ///
    /// Note that all the setters affecting `key` are
    /// mutually exclusive.
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = std::option::Option::Some(
            crate::model::customer_encryption_key::Key::KmsKeyName(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CustomerEncryptionKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.CustomerEncryptionKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomerEncryptionKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __raw_key,
            __rsa_encrypted_key,
            __kms_key_name,
            __kms_key_service_account,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomerEncryptionKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rawKey" => Ok(__FieldTag::__raw_key),
                            "raw_key" => Ok(__FieldTag::__raw_key),
                            "rsaEncryptedKey" => Ok(__FieldTag::__rsa_encrypted_key),
                            "rsa_encrypted_key" => Ok(__FieldTag::__rsa_encrypted_key),
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "kmsKeyServiceAccount" => Ok(__FieldTag::__kms_key_service_account),
                            "kms_key_service_account" => Ok(__FieldTag::__kms_key_service_account),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomerEncryptionKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomerEncryptionKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__raw_key => {
                            if !fields.insert(__FieldTag::__raw_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for raw_key",
                                ));
                            }
                            if result.key.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `key`, a oneof with full ID .google.cloud.backupdr.v1.CustomerEncryptionKey.raw_key, latest field was rawKey",
                                ));
                            }
                            result.key = std::option::Option::Some(
                                crate::model::customer_encryption_key::Key::RawKey(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__rsa_encrypted_key => {
                            if !fields.insert(__FieldTag::__rsa_encrypted_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rsa_encrypted_key",
                                ));
                            }
                            if result.key.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `key`, a oneof with full ID .google.cloud.backupdr.v1.CustomerEncryptionKey.rsa_encrypted_key, latest field was rsaEncryptedKey",
                                ));
                            }
                            result.key = std::option::Option::Some(
                                crate::model::customer_encryption_key::Key::RsaEncryptedKey(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            if result.key.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `key`, a oneof with full ID .google.cloud.backupdr.v1.CustomerEncryptionKey.kms_key_name, latest field was kmsKeyName",
                                ));
                            }
                            result.key = std::option::Option::Some(
                                crate::model::customer_encryption_key::Key::KmsKeyName(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__kms_key_service_account => {
                            if !fields.insert(__FieldTag::__kms_key_service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_service_account",
                                ));
                            }
                            result.kms_key_service_account =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomerEncryptionKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.raw_key() {
            state.serialize_entry("rawKey", value)?;
        }
        if let Some(value) = self.rsa_encrypted_key() {
            state.serialize_entry("rsaEncryptedKey", value)?;
        }
        if let Some(value) = self.kms_key_name() {
            state.serialize_entry("kmsKeyName", value)?;
        }
        if self.kms_key_service_account.is_some() {
            state.serialize_entry("kmsKeyServiceAccount", &self.kms_key_service_account)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CustomerEncryptionKey].
pub mod customer_encryption_key {
    #[allow(unused_imports)]
    use super::*;

    /// The key to use for encryption.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Key {
        /// Optional. Specifies a 256-bit customer-supplied
        /// encryption key.
        RawKey(std::string::String),
        /// Optional. RSA-wrapped 2048-bit
        /// customer-supplied encryption key to either encrypt or decrypt this
        /// resource.
        RsaEncryptedKey(std::string::String),
        /// Optional. The name of the encryption key that is stored in Google Cloud
        /// KMS.
        KmsKeyName(std::string::String),
    }
}

/// A key/value pair to be used for storing metadata.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Entry {
    /// Optional. Key for the metadata entry.
    pub key: std::option::Option<std::string::String>,

    /// Optional. Value for the metadata entry. These are free-form strings, and
    /// only have meaning as interpreted by the image running in the instance. The
    /// only restriction placed on values is that their size must be less than
    /// or equal to 262144 bytes (256 KiB).
    pub value: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::Entry::key].
    pub fn set_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key][crate::model::Entry::key].
    pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [value][crate::model::Entry::value].
    pub fn set_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [value][crate::model::Entry::value].
    pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.value = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Entry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.Entry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Entry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Entry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Entry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Entry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Entry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A metadata key/value entry.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Metadata {
    /// Optional. Array of key/value pairs. The total size of all keys and values
    /// must be less than 512 KB.
    pub items: std::vec::Vec<crate::model::Entry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Metadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [items][crate::model::Metadata::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entry>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Metadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.Metadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Metadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __items,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Metadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "items" => Ok(__FieldTag::__items),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Metadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Metadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items",
                                ));
                            }
                            result.items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Entry>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Metadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A network interface resource attached to an instance.
/// s
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkInterface {
    /// Optional. URL of the VPC network resource for this instance.
    pub network: std::option::Option<std::string::String>,

    /// Optional. The URL of the Subnetwork resource for this instance.
    pub subnetwork: std::option::Option<std::string::String>,

    /// Optional. An IPv4 internal IP address to assign to the instance for this
    /// network interface. If not specified by the user, an unused internal IP is
    /// assigned by the system.
    pub ip_address: std::option::Option<std::string::String>,

    /// Optional. An IPv6 internal network address for this network interface. To
    /// use a static internal IP address, it must be unused and in the same region
    /// as the instance's zone. If not specified, Google Cloud will automatically
    /// assign an internal IPv6 address from the instance's subnetwork.
    pub ipv6_address: std::option::Option<std::string::String>,

    /// Optional. The prefix length of the primary internal IPv6 range.
    pub internal_ipv6_prefix_length: std::option::Option<i32>,

    /// Output only. [Output Only] The name of the network interface, which is
    /// generated by the server.
    pub name: std::option::Option<std::string::String>,

    /// Optional. An array of configurations for this interface. Currently, only
    /// one access config,ONE_TO_ONE_NAT is supported. If there are no
    /// accessConfigs specified, then this instance will have
    /// no external internet access.
    pub access_configs: std::vec::Vec<crate::model::AccessConfig>,

    /// Optional. An array of IPv6 access configurations for this interface.
    /// Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there
    /// is no ipv6AccessConfig specified, then this instance will
    /// have no external IPv6 Internet access.
    pub ipv6_access_configs: std::vec::Vec<crate::model::AccessConfig>,

    /// Optional. An array of alias IP ranges for this network interface.
    /// You can only specify this field for network interfaces in VPC networks.
    pub alias_ip_ranges: std::vec::Vec<crate::model::AliasIpRange>,

    /// The stack type for this network interface.
    pub stack_type: std::option::Option<crate::model::network_interface::StackType>,

    /// Optional. [Output Only] One of EXTERNAL, INTERNAL to indicate whether the
    /// IP can be accessed from the Internet. This field is always inherited from
    /// its subnetwork.
    pub ipv6_access_type: std::option::Option<crate::model::network_interface::Ipv6AccessType>,

    /// Optional. The networking queue count that's specified by users for the
    /// network interface. Both Rx and Tx queues will be set to this number. It'll
    /// be empty if not specified by the users.
    pub queue_count: std::option::Option<i32>,

    /// Optional. The type of vNIC to be used on this interface. This may be gVNIC
    /// or VirtioNet.
    pub nic_type: std::option::Option<crate::model::network_interface::NicType>,

    /// Optional. The URL of the network attachment that this interface should
    /// connect to in the following format:
    /// projects/{project_number}/regions/{region_name}/networkAttachments/{network_attachment_name}.
    pub network_attachment: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkInterface {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::NetworkInterface::network].
    pub fn set_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network][crate::model::NetworkInterface::network].
    pub fn set_or_clear_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subnetwork][crate::model::NetworkInterface::subnetwork].
    pub fn set_subnetwork<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subnetwork = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subnetwork][crate::model::NetworkInterface::subnetwork].
    pub fn set_or_clear_subnetwork<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subnetwork = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ip_address][crate::model::NetworkInterface::ip_address].
    pub fn set_ip_address<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ip_address = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ip_address][crate::model::NetworkInterface::ip_address].
    pub fn set_or_clear_ip_address<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ip_address = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ipv6_address][crate::model::NetworkInterface::ipv6_address].
    pub fn set_ipv6_address<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ipv6_address = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ipv6_address][crate::model::NetworkInterface::ipv6_address].
    pub fn set_or_clear_ipv6_address<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ipv6_address = v.map(|x| x.into());
        self
    }

    /// Sets the value of [internal_ipv6_prefix_length][crate::model::NetworkInterface::internal_ipv6_prefix_length].
    pub fn set_internal_ipv6_prefix_length<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.internal_ipv6_prefix_length = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [internal_ipv6_prefix_length][crate::model::NetworkInterface::internal_ipv6_prefix_length].
    pub fn set_or_clear_internal_ipv6_prefix_length<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.internal_ipv6_prefix_length = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::NetworkInterface::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::NetworkInterface::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [access_configs][crate::model::NetworkInterface::access_configs].
    pub fn set_access_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AccessConfig>,
    {
        use std::iter::Iterator;
        self.access_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ipv6_access_configs][crate::model::NetworkInterface::ipv6_access_configs].
    pub fn set_ipv6_access_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AccessConfig>,
    {
        use std::iter::Iterator;
        self.ipv6_access_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [alias_ip_ranges][crate::model::NetworkInterface::alias_ip_ranges].
    pub fn set_alias_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AliasIpRange>,
    {
        use std::iter::Iterator;
        self.alias_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [stack_type][crate::model::NetworkInterface::stack_type].
    pub fn set_stack_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::network_interface::StackType>,
    {
        self.stack_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stack_type][crate::model::NetworkInterface::stack_type].
    pub fn set_or_clear_stack_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::network_interface::StackType>,
    {
        self.stack_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ipv6_access_type][crate::model::NetworkInterface::ipv6_access_type].
    pub fn set_ipv6_access_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::network_interface::Ipv6AccessType>,
    {
        self.ipv6_access_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ipv6_access_type][crate::model::NetworkInterface::ipv6_access_type].
    pub fn set_or_clear_ipv6_access_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::network_interface::Ipv6AccessType>,
    {
        self.ipv6_access_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [queue_count][crate::model::NetworkInterface::queue_count].
    pub fn set_queue_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.queue_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [queue_count][crate::model::NetworkInterface::queue_count].
    pub fn set_or_clear_queue_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.queue_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [nic_type][crate::model::NetworkInterface::nic_type].
    pub fn set_nic_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::network_interface::NicType>,
    {
        self.nic_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nic_type][crate::model::NetworkInterface::nic_type].
    pub fn set_or_clear_nic_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::network_interface::NicType>,
    {
        self.nic_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_attachment][crate::model::NetworkInterface::network_attachment].
    pub fn set_network_attachment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network_attachment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_attachment][crate::model::NetworkInterface::network_attachment].
    pub fn set_or_clear_network_attachment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network_attachment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NetworkInterface {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.NetworkInterface"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkInterface {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network,
            __subnetwork,
            __ip_address,
            __ipv6_address,
            __internal_ipv6_prefix_length,
            __name,
            __access_configs,
            __ipv6_access_configs,
            __alias_ip_ranges,
            __stack_type,
            __ipv6_access_type,
            __queue_count,
            __nic_type,
            __network_attachment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkInterface")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "network" => Ok(__FieldTag::__network),
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "ipv6Address" => Ok(__FieldTag::__ipv6_address),
                            "ipv6_address" => Ok(__FieldTag::__ipv6_address),
                            "internalIpv6PrefixLength" => {
                                Ok(__FieldTag::__internal_ipv6_prefix_length)
                            }
                            "internal_ipv6_prefix_length" => {
                                Ok(__FieldTag::__internal_ipv6_prefix_length)
                            }
                            "name" => Ok(__FieldTag::__name),
                            "accessConfigs" => Ok(__FieldTag::__access_configs),
                            "access_configs" => Ok(__FieldTag::__access_configs),
                            "ipv6AccessConfigs" => Ok(__FieldTag::__ipv6_access_configs),
                            "ipv6_access_configs" => Ok(__FieldTag::__ipv6_access_configs),
                            "aliasIpRanges" => Ok(__FieldTag::__alias_ip_ranges),
                            "alias_ip_ranges" => Ok(__FieldTag::__alias_ip_ranges),
                            "stackType" => Ok(__FieldTag::__stack_type),
                            "stack_type" => Ok(__FieldTag::__stack_type),
                            "ipv6AccessType" => Ok(__FieldTag::__ipv6_access_type),
                            "ipv6_access_type" => Ok(__FieldTag::__ipv6_access_type),
                            "queueCount" => Ok(__FieldTag::__queue_count),
                            "queue_count" => Ok(__FieldTag::__queue_count),
                            "nicType" => Ok(__FieldTag::__nic_type),
                            "nic_type" => Ok(__FieldTag::__nic_type),
                            "networkAttachment" => Ok(__FieldTag::__network_attachment),
                            "network_attachment" => Ok(__FieldTag::__network_attachment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkInterface;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkInterface")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__ipv6_address => {
                            if !fields.insert(__FieldTag::__ipv6_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ipv6_address",
                                ));
                            }
                            result.ipv6_address =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__internal_ipv6_prefix_length => {
                            if !fields.insert(__FieldTag::__internal_ipv6_prefix_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_ipv6_prefix_length",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.internal_ipv6_prefix_length = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__access_configs => {
                            if !fields.insert(__FieldTag::__access_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_configs",
                                ));
                            }
                            result.access_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AccessConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ipv6_access_configs => {
                            if !fields.insert(__FieldTag::__ipv6_access_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ipv6_access_configs",
                                ));
                            }
                            result.ipv6_access_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AccessConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__alias_ip_ranges => {
                            if !fields.insert(__FieldTag::__alias_ip_ranges) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alias_ip_ranges",
                                ));
                            }
                            result.alias_ip_ranges = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AliasIpRange>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__stack_type => {
                            if !fields.insert(__FieldTag::__stack_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stack_type",
                                ));
                            }
                            result.stack_type = map.next_value::<std::option::Option<crate::model::network_interface::StackType>>()?
                                ;
                        }
                        __FieldTag::__ipv6_access_type => {
                            if !fields.insert(__FieldTag::__ipv6_access_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ipv6_access_type",
                                ));
                            }
                            result.ipv6_access_type = map.next_value::<std::option::Option<
                                crate::model::network_interface::Ipv6AccessType,
                            >>()?;
                        }
                        __FieldTag::__queue_count => {
                            if !fields.insert(__FieldTag::__queue_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for queue_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.queue_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__nic_type => {
                            if !fields.insert(__FieldTag::__nic_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nic_type",
                                ));
                            }
                            result.nic_type = map.next_value::<std::option::Option<crate::model::network_interface::NicType>>()?
                                ;
                        }
                        __FieldTag::__network_attachment => {
                            if !fields.insert(__FieldTag::__network_attachment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_attachment",
                                ));
                            }
                            result.network_attachment =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkInterface {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.subnetwork.is_some() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if self.ip_address.is_some() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if self.ipv6_address.is_some() {
            state.serialize_entry("ipv6Address", &self.ipv6_address)?;
        }
        if self.internal_ipv6_prefix_length.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "internalIpv6PrefixLength",
                &__With(&self.internal_ipv6_prefix_length),
            )?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.access_configs.is_empty() {
            state.serialize_entry("accessConfigs", &self.access_configs)?;
        }
        if !self.ipv6_access_configs.is_empty() {
            state.serialize_entry("ipv6AccessConfigs", &self.ipv6_access_configs)?;
        }
        if !self.alias_ip_ranges.is_empty() {
            state.serialize_entry("aliasIpRanges", &self.alias_ip_ranges)?;
        }
        if self.stack_type.is_some() {
            state.serialize_entry("stackType", &self.stack_type)?;
        }
        if self.ipv6_access_type.is_some() {
            state.serialize_entry("ipv6AccessType", &self.ipv6_access_type)?;
        }
        if self.queue_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("queueCount", &__With(&self.queue_count))?;
        }
        if self.nic_type.is_some() {
            state.serialize_entry("nicType", &self.nic_type)?;
        }
        if self.network_attachment.is_some() {
            state.serialize_entry("networkAttachment", &self.network_attachment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [NetworkInterface].
pub mod network_interface {
    #[allow(unused_imports)]
    use super::*;

    /// Stack type for this network interface.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StackType {
        /// Default should be STACK_TYPE_UNSPECIFIED.
        Unspecified,
        /// The network interface will be assigned IPv4 address.
        Ipv4Only,
        /// The network interface can have both IPv4 and IPv6 addresses.
        Ipv4Ipv6,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StackType::value] or
        /// [StackType::name].
        UnknownValue(stack_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod stack_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StackType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ipv4Only => std::option::Option::Some(1),
                Self::Ipv4Ipv6 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STACK_TYPE_UNSPECIFIED"),
                Self::Ipv4Only => std::option::Option::Some("IPV4_ONLY"),
                Self::Ipv4Ipv6 => std::option::Option::Some("IPV4_IPV6"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StackType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StackType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StackType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ipv4Only,
                2 => Self::Ipv4Ipv6,
                _ => Self::UnknownValue(stack_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StackType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STACK_TYPE_UNSPECIFIED" => Self::Unspecified,
                "IPV4_ONLY" => Self::Ipv4Only,
                "IPV4_IPV6" => Self::Ipv4Ipv6,
                _ => Self::UnknownValue(stack_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StackType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ipv4Only => serializer.serialize_i32(1),
                Self::Ipv4Ipv6 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StackType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StackType>::new(
                ".google.cloud.backupdr.v1.NetworkInterface.StackType",
            ))
        }
    }

    /// IPv6 access type for this network interface.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Ipv6AccessType {
        /// IPv6 access type not set. Means this network interface hasn't been
        /// turned on IPv6 yet.
        UnspecifiedIpv6AccessType,
        /// This network interface can have internal IPv6.
        Internal,
        /// This network interface can have external IPv6.
        External,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Ipv6AccessType::value] or
        /// [Ipv6AccessType::name].
        UnknownValue(ipv_6_access_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ipv_6_access_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Ipv6AccessType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::UnspecifiedIpv6AccessType => std::option::Option::Some(0),
                Self::Internal => std::option::Option::Some(1),
                Self::External => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::UnspecifiedIpv6AccessType => {
                    std::option::Option::Some("UNSPECIFIED_IPV6_ACCESS_TYPE")
                }
                Self::Internal => std::option::Option::Some("INTERNAL"),
                Self::External => std::option::Option::Some("EXTERNAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Ipv6AccessType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Ipv6AccessType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Ipv6AccessType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::UnspecifiedIpv6AccessType,
                1 => Self::Internal,
                2 => Self::External,
                _ => Self::UnknownValue(ipv_6_access_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Ipv6AccessType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED_IPV6_ACCESS_TYPE" => Self::UnspecifiedIpv6AccessType,
                "INTERNAL" => Self::Internal,
                "EXTERNAL" => Self::External,
                _ => Self::UnknownValue(ipv_6_access_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Ipv6AccessType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::UnspecifiedIpv6AccessType => serializer.serialize_i32(0),
                Self::Internal => serializer.serialize_i32(1),
                Self::External => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Ipv6AccessType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Ipv6AccessType>::new(
                ".google.cloud.backupdr.v1.NetworkInterface.Ipv6AccessType",
            ))
        }
    }

    /// Nic type for this network interface.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NicType {
        /// Default should be NIC_TYPE_UNSPECIFIED.
        Unspecified,
        /// VIRTIO
        VirtioNet,
        /// GVNIC
        Gvnic,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NicType::value] or
        /// [NicType::name].
        UnknownValue(nic_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod nic_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NicType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::VirtioNet => std::option::Option::Some(1),
                Self::Gvnic => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("NIC_TYPE_UNSPECIFIED"),
                Self::VirtioNet => std::option::Option::Some("VIRTIO_NET"),
                Self::Gvnic => std::option::Option::Some("GVNIC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NicType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NicType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NicType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::VirtioNet,
                2 => Self::Gvnic,
                _ => Self::UnknownValue(nic_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NicType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NIC_TYPE_UNSPECIFIED" => Self::Unspecified,
                "VIRTIO_NET" => Self::VirtioNet,
                "GVNIC" => Self::Gvnic,
                _ => Self::UnknownValue(nic_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NicType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::VirtioNet => serializer.serialize_i32(1),
                Self::Gvnic => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NicType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NicType>::new(
                ".google.cloud.backupdr.v1.NetworkInterface.NicType",
            ))
        }
    }
}

/// Network performance configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkPerformanceConfig {
    /// Optional. The tier of the total egress bandwidth.
    pub total_egress_bandwidth_tier:
        std::option::Option<crate::model::network_performance_config::Tier>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkPerformanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_egress_bandwidth_tier][crate::model::NetworkPerformanceConfig::total_egress_bandwidth_tier].
    pub fn set_total_egress_bandwidth_tier<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::network_performance_config::Tier>,
    {
        self.total_egress_bandwidth_tier = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [total_egress_bandwidth_tier][crate::model::NetworkPerformanceConfig::total_egress_bandwidth_tier].
    pub fn set_or_clear_total_egress_bandwidth_tier<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::network_performance_config::Tier>,
    {
        self.total_egress_bandwidth_tier = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NetworkPerformanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.NetworkPerformanceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkPerformanceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __total_egress_bandwidth_tier,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkPerformanceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "totalEgressBandwidthTier" => {
                                Ok(__FieldTag::__total_egress_bandwidth_tier)
                            }
                            "total_egress_bandwidth_tier" => {
                                Ok(__FieldTag::__total_egress_bandwidth_tier)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkPerformanceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkPerformanceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__total_egress_bandwidth_tier => {
                            if !fields.insert(__FieldTag::__total_egress_bandwidth_tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_egress_bandwidth_tier",
                                ));
                            }
                            result.total_egress_bandwidth_tier = map
                                .next_value::<std::option::Option<
                                    crate::model::network_performance_config::Tier,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkPerformanceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.total_egress_bandwidth_tier.is_some() {
            state.serialize_entry(
                "totalEgressBandwidthTier",
                &self.total_egress_bandwidth_tier,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [NetworkPerformanceConfig].
pub mod network_performance_config {
    #[allow(unused_imports)]
    use super::*;

    /// Network performance tier.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Tier {
        /// This value is unused.
        Unspecified,
        /// Default network performance config.
        Default,
        /// Tier 1 network performance config.
        Tier1,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Tier::value] or
        /// [Tier::name].
        UnknownValue(tier::UnknownValue),
    }

    #[doc(hidden)]
    pub mod tier {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Tier {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Default => std::option::Option::Some(1),
                Self::Tier1 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TIER_UNSPECIFIED"),
                Self::Default => std::option::Option::Some("DEFAULT"),
                Self::Tier1 => std::option::Option::Some("TIER_1"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Tier {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Tier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Tier {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Default,
                2 => Self::Tier1,
                _ => Self::UnknownValue(tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Tier {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TIER_UNSPECIFIED" => Self::Unspecified,
                "DEFAULT" => Self::Default,
                "TIER_1" => Self::Tier1,
                _ => Self::UnknownValue(tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Tier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Default => serializer.serialize_i32(1),
                Self::Tier1 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Tier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Tier>::new(
                ".google.cloud.backupdr.v1.NetworkPerformanceConfig.Tier",
            ))
        }
    }
}

/// An access configuration attached to an instance's network interface.
/// Only one access config per instance is supported.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AccessConfig {
    /// Optional. In accessConfigs (IPv4), the
    /// default and only option is ONE_TO_ONE_NAT. In
    /// ipv6AccessConfigs, the default and only option is
    /// DIRECT_IPV6.
    pub r#type: std::option::Option<crate::model::access_config::AccessType>,

    /// Optional. The name of this access configuration.
    pub name: std::option::Option<std::string::String>,

    /// Optional. The external IP address of this access configuration.
    pub external_ip: std::option::Option<std::string::String>,

    /// Optional. The external IPv6 address of this access configuration.
    pub external_ipv6: std::option::Option<std::string::String>,

    /// Optional. The prefix length of the external IPv6 range.
    pub external_ipv6_prefix_length: std::option::Option<i32>,

    /// Optional. Specifies whether a public DNS 'PTR' record should be created to
    /// map the external IP address of the instance to a DNS domain name.
    pub set_public_ptr: std::option::Option<bool>,

    /// Optional. The DNS domain name for the public PTR record.
    pub public_ptr_domain_name: std::option::Option<std::string::String>,

    /// Optional. This signifies the networking tier used for configuring this
    /// access
    pub network_tier: std::option::Option<crate::model::access_config::NetworkTier>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::AccessConfig::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::access_config::AccessType>,
    {
        self.r#type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#type][crate::model::AccessConfig::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::access_config::AccessType>,
    {
        self.r#type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::AccessConfig::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::AccessConfig::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_ip][crate::model::AccessConfig::external_ip].
    pub fn set_external_ip<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.external_ip = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_ip][crate::model::AccessConfig::external_ip].
    pub fn set_or_clear_external_ip<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.external_ip = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_ipv6][crate::model::AccessConfig::external_ipv6].
    pub fn set_external_ipv6<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.external_ipv6 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_ipv6][crate::model::AccessConfig::external_ipv6].
    pub fn set_or_clear_external_ipv6<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.external_ipv6 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_ipv6_prefix_length][crate::model::AccessConfig::external_ipv6_prefix_length].
    pub fn set_external_ipv6_prefix_length<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.external_ipv6_prefix_length = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_ipv6_prefix_length][crate::model::AccessConfig::external_ipv6_prefix_length].
    pub fn set_or_clear_external_ipv6_prefix_length<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.external_ipv6_prefix_length = v.map(|x| x.into());
        self
    }

    /// Sets the value of [set_public_ptr][crate::model::AccessConfig::set_public_ptr].
    pub fn set_set_public_ptr<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.set_public_ptr = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [set_public_ptr][crate::model::AccessConfig::set_public_ptr].
    pub fn set_or_clear_set_public_ptr<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.set_public_ptr = v.map(|x| x.into());
        self
    }

    /// Sets the value of [public_ptr_domain_name][crate::model::AccessConfig::public_ptr_domain_name].
    pub fn set_public_ptr_domain_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.public_ptr_domain_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [public_ptr_domain_name][crate::model::AccessConfig::public_ptr_domain_name].
    pub fn set_or_clear_public_ptr_domain_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.public_ptr_domain_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_tier][crate::model::AccessConfig::network_tier].
    pub fn set_network_tier<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::access_config::NetworkTier>,
    {
        self.network_tier = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_tier][crate::model::AccessConfig::network_tier].
    pub fn set_or_clear_network_tier<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::access_config::NetworkTier>,
    {
        self.network_tier = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AccessConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.AccessConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AccessConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __name,
            __external_ip,
            __external_ipv6,
            __external_ipv6_prefix_length,
            __set_public_ptr,
            __public_ptr_domain_name,
            __network_tier,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccessConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "name" => Ok(__FieldTag::__name),
                            "externalIp" => Ok(__FieldTag::__external_ip),
                            "external_ip" => Ok(__FieldTag::__external_ip),
                            "externalIpv6" => Ok(__FieldTag::__external_ipv6),
                            "external_ipv6" => Ok(__FieldTag::__external_ipv6),
                            "externalIpv6PrefixLength" => {
                                Ok(__FieldTag::__external_ipv6_prefix_length)
                            }
                            "external_ipv6_prefix_length" => {
                                Ok(__FieldTag::__external_ipv6_prefix_length)
                            }
                            "setPublicPtr" => Ok(__FieldTag::__set_public_ptr),
                            "set_public_ptr" => Ok(__FieldTag::__set_public_ptr),
                            "publicPtrDomainName" => Ok(__FieldTag::__public_ptr_domain_name),
                            "public_ptr_domain_name" => Ok(__FieldTag::__public_ptr_domain_name),
                            "networkTier" => Ok(__FieldTag::__network_tier),
                            "network_tier" => Ok(__FieldTag::__network_tier),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AccessConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccessConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::access_config::AccessType>>()?
                                ;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__external_ip => {
                            if !fields.insert(__FieldTag::__external_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_ip",
                                ));
                            }
                            result.external_ip =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__external_ipv6 => {
                            if !fields.insert(__FieldTag::__external_ipv6) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_ipv6",
                                ));
                            }
                            result.external_ipv6 =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__external_ipv6_prefix_length => {
                            if !fields.insert(__FieldTag::__external_ipv6_prefix_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_ipv6_prefix_length",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.external_ipv6_prefix_length = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__set_public_ptr => {
                            if !fields.insert(__FieldTag::__set_public_ptr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for set_public_ptr",
                                ));
                            }
                            result.set_public_ptr =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__public_ptr_domain_name => {
                            if !fields.insert(__FieldTag::__public_ptr_domain_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_ptr_domain_name",
                                ));
                            }
                            result.public_ptr_domain_name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__network_tier => {
                            if !fields.insert(__FieldTag::__network_tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_tier",
                                ));
                            }
                            result.network_tier = map.next_value::<std::option::Option<crate::model::access_config::NetworkTier>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AccessConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.external_ip.is_some() {
            state.serialize_entry("externalIp", &self.external_ip)?;
        }
        if self.external_ipv6.is_some() {
            state.serialize_entry("externalIpv6", &self.external_ipv6)?;
        }
        if self.external_ipv6_prefix_length.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "externalIpv6PrefixLength",
                &__With(&self.external_ipv6_prefix_length),
            )?;
        }
        if self.set_public_ptr.is_some() {
            state.serialize_entry("setPublicPtr", &self.set_public_ptr)?;
        }
        if self.public_ptr_domain_name.is_some() {
            state.serialize_entry("publicPtrDomainName", &self.public_ptr_domain_name)?;
        }
        if self.network_tier.is_some() {
            state.serialize_entry("networkTier", &self.network_tier)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AccessConfig].
pub mod access_config {
    #[allow(unused_imports)]
    use super::*;

    /// The type of configuration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AccessType {
        /// Default value. This value is unused.
        Unspecified,
        /// ONE_TO_ONE_NAT
        OneToOneNat,
        /// Direct IPv6 access.
        DirectIpv6,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AccessType::value] or
        /// [AccessType::name].
        UnknownValue(access_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod access_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AccessType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::OneToOneNat => std::option::Option::Some(1),
                Self::DirectIpv6 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACCESS_TYPE_UNSPECIFIED"),
                Self::OneToOneNat => std::option::Option::Some("ONE_TO_ONE_NAT"),
                Self::DirectIpv6 => std::option::Option::Some("DIRECT_IPV6"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AccessType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AccessType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AccessType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::OneToOneNat,
                2 => Self::DirectIpv6,
                _ => Self::UnknownValue(access_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AccessType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACCESS_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ONE_TO_ONE_NAT" => Self::OneToOneNat,
                "DIRECT_IPV6" => Self::DirectIpv6,
                _ => Self::UnknownValue(access_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AccessType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::OneToOneNat => serializer.serialize_i32(1),
                Self::DirectIpv6 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AccessType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AccessType>::new(
                ".google.cloud.backupdr.v1.AccessConfig.AccessType",
            ))
        }
    }

    /// Network tier property used by addresses, instances and forwarding rules.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NetworkTier {
        /// Default value. This value is unused.
        Unspecified,
        /// High quality, Google-grade network tier, support for all networking
        /// products.
        Premium,
        /// Public internet quality, only limited support for other networking
        /// products.
        Standard,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NetworkTier::value] or
        /// [NetworkTier::name].
        UnknownValue(network_tier::UnknownValue),
    }

    #[doc(hidden)]
    pub mod network_tier {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NetworkTier {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Premium => std::option::Option::Some(1),
                Self::Standard => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("NETWORK_TIER_UNSPECIFIED"),
                Self::Premium => std::option::Option::Some("PREMIUM"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NetworkTier {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NetworkTier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NetworkTier {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Premium,
                2 => Self::Standard,
                _ => Self::UnknownValue(network_tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NetworkTier {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NETWORK_TIER_UNSPECIFIED" => Self::Unspecified,
                "PREMIUM" => Self::Premium,
                "STANDARD" => Self::Standard,
                _ => Self::UnknownValue(network_tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NetworkTier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Premium => serializer.serialize_i32(1),
                Self::Standard => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NetworkTier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NetworkTier>::new(
                ".google.cloud.backupdr.v1.AccessConfig.NetworkTier",
            ))
        }
    }
}

/// An alias IP range attached to an instance's network interface.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AliasIpRange {
    /// Optional. The IP alias ranges to allocate for this interface.
    pub ip_cidr_range: std::option::Option<std::string::String>,

    /// Optional. The name of a subnetwork secondary IP range from which to
    /// allocate an IP alias range. If not specified, the primary range of the
    /// subnetwork is used.
    pub subnetwork_range_name: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AliasIpRange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip_cidr_range][crate::model::AliasIpRange::ip_cidr_range].
    pub fn set_ip_cidr_range<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ip_cidr_range = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ip_cidr_range][crate::model::AliasIpRange::ip_cidr_range].
    pub fn set_or_clear_ip_cidr_range<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ip_cidr_range = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subnetwork_range_name][crate::model::AliasIpRange::subnetwork_range_name].
    pub fn set_subnetwork_range_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subnetwork_range_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subnetwork_range_name][crate::model::AliasIpRange::subnetwork_range_name].
    pub fn set_or_clear_subnetwork_range_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subnetwork_range_name = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AliasIpRange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.AliasIpRange"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AliasIpRange {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ip_cidr_range,
            __subnetwork_range_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AliasIpRange")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ipCidrRange" => Ok(__FieldTag::__ip_cidr_range),
                            "ip_cidr_range" => Ok(__FieldTag::__ip_cidr_range),
                            "subnetworkRangeName" => Ok(__FieldTag::__subnetwork_range_name),
                            "subnetwork_range_name" => Ok(__FieldTag::__subnetwork_range_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AliasIpRange;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AliasIpRange")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ip_cidr_range => {
                            if !fields.insert(__FieldTag::__ip_cidr_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_cidr_range",
                                ));
                            }
                            result.ip_cidr_range =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__subnetwork_range_name => {
                            if !fields.insert(__FieldTag::__subnetwork_range_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork_range_name",
                                ));
                            }
                            result.subnetwork_range_name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AliasIpRange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ip_cidr_range.is_some() {
            state.serialize_entry("ipCidrRange", &self.ip_cidr_range)?;
        }
        if self.subnetwork_range_name.is_some() {
            state.serialize_entry("subnetworkRangeName", &self.subnetwork_range_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Additional instance params.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceParams {
    /// Optional. Resource manager tags to be bound to the instance.
    pub resource_manager_tags: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_manager_tags][crate::model::InstanceParams::resource_manager_tags].
    pub fn set_resource_manager_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_manager_tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for InstanceParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.InstanceParams"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstanceParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_manager_tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstanceParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceManagerTags" => Ok(__FieldTag::__resource_manager_tags),
                            "resource_manager_tags" => Ok(__FieldTag::__resource_manager_tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstanceParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstanceParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_manager_tags => {
                            if !fields.insert(__FieldTag::__resource_manager_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_manager_tags",
                                ));
                            }
                            result.resource_manager_tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstanceParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_manager_tags.is_empty() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specifies the reservations that this instance can consume from.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AllocationAffinity {
    /// Optional. Specifies the type of reservation from which this instance can
    /// consume
    pub consume_allocation_type: std::option::Option<crate::model::allocation_affinity::Type>,

    /// Optional. Corresponds to the label key of a reservation resource.
    pub key: std::option::Option<std::string::String>,

    /// Optional. Corresponds to the label values of a reservation resource.
    pub values: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AllocationAffinity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [consume_allocation_type][crate::model::AllocationAffinity::consume_allocation_type].
    pub fn set_consume_allocation_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::allocation_affinity::Type>,
    {
        self.consume_allocation_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [consume_allocation_type][crate::model::AllocationAffinity::consume_allocation_type].
    pub fn set_or_clear_consume_allocation_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::allocation_affinity::Type>,
    {
        self.consume_allocation_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [key][crate::model::AllocationAffinity::key].
    pub fn set_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key][crate::model::AllocationAffinity::key].
    pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [values][crate::model::AllocationAffinity::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AllocationAffinity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.AllocationAffinity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AllocationAffinity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __consume_allocation_type,
            __key,
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AllocationAffinity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "consumeAllocationType" => Ok(__FieldTag::__consume_allocation_type),
                            "consume_allocation_type" => Ok(__FieldTag::__consume_allocation_type),
                            "key" => Ok(__FieldTag::__key),
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AllocationAffinity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AllocationAffinity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__consume_allocation_type => {
                            if !fields.insert(__FieldTag::__consume_allocation_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for consume_allocation_type",
                                ));
                            }
                            result.consume_allocation_type = map.next_value::<std::option::Option<crate::model::allocation_affinity::Type>>()?
                                ;
                        }
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AllocationAffinity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.consume_allocation_type.is_some() {
            state.serialize_entry("consumeAllocationType", &self.consume_allocation_type)?;
        }
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AllocationAffinity].
pub mod allocation_affinity {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates whether to consume from a reservation or not.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Default value. This value is unused.
        Unspecified,
        /// Do not consume from any allocated capacity.
        NoReservation,
        /// Consume any allocation available.
        AnyReservation,
        /// Must consume from a specific reservation. Must specify key value fields
        /// for specifying the reservations.
        SpecificReservation,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoReservation => std::option::Option::Some(1),
                Self::AnyReservation => std::option::Option::Some(2),
                Self::SpecificReservation => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::NoReservation => std::option::Option::Some("NO_RESERVATION"),
                Self::AnyReservation => std::option::Option::Some("ANY_RESERVATION"),
                Self::SpecificReservation => std::option::Option::Some("SPECIFIC_RESERVATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoReservation,
                2 => Self::AnyReservation,
                3 => Self::SpecificReservation,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "NO_RESERVATION" => Self::NoReservation,
                "ANY_RESERVATION" => Self::AnyReservation,
                "SPECIFIC_RESERVATION" => Self::SpecificReservation,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoReservation => serializer.serialize_i32(1),
                Self::AnyReservation => serializer.serialize_i32(2),
                Self::SpecificReservation => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.backupdr.v1.AllocationAffinity.Type",
            ))
        }
    }
}

/// Sets the scheduling options for an Instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Scheduling {
    /// Optional. Defines the maintenance behavior for this instance.
    pub on_host_maintenance: std::option::Option<crate::model::scheduling::OnHostMaintenance>,

    /// Optional. Specifies whether the instance should be automatically restarted
    /// if it is terminated by Compute Engine (not terminated by a user).
    pub automatic_restart: std::option::Option<bool>,

    /// Optional. Defines whether the instance is preemptible.
    pub preemptible: std::option::Option<bool>,

    /// Optional. A set of node affinity and anti-affinity configurations.
    /// Overrides reservationAffinity.
    pub node_affinities: std::vec::Vec<crate::model::scheduling::NodeAffinity>,

    /// Optional. The minimum number of virtual CPUs this instance will consume
    /// when running on a sole-tenant node.
    pub min_node_cpus: std::option::Option<i32>,

    /// Optional. Specifies the provisioning model of the instance.
    pub provisioning_model: std::option::Option<crate::model::scheduling::ProvisioningModel>,

    /// Optional. Specifies the termination action for the instance.
    pub instance_termination_action:
        std::option::Option<crate::model::scheduling::InstanceTerminationAction>,

    /// Optional. Specifies the maximum amount of time a Local Ssd Vm should wait
    /// while recovery of the Local Ssd state is attempted. Its value should be in
    /// between 0 and 168 hours with hour granularity and the default value being 1
    /// hour.
    pub local_ssd_recovery_timeout: std::option::Option<crate::model::SchedulingDuration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Scheduling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [on_host_maintenance][crate::model::Scheduling::on_host_maintenance].
    pub fn set_on_host_maintenance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::scheduling::OnHostMaintenance>,
    {
        self.on_host_maintenance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [on_host_maintenance][crate::model::Scheduling::on_host_maintenance].
    pub fn set_or_clear_on_host_maintenance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::scheduling::OnHostMaintenance>,
    {
        self.on_host_maintenance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [automatic_restart][crate::model::Scheduling::automatic_restart].
    pub fn set_automatic_restart<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.automatic_restart = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automatic_restart][crate::model::Scheduling::automatic_restart].
    pub fn set_or_clear_automatic_restart<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.automatic_restart = v.map(|x| x.into());
        self
    }

    /// Sets the value of [preemptible][crate::model::Scheduling::preemptible].
    pub fn set_preemptible<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.preemptible = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [preemptible][crate::model::Scheduling::preemptible].
    pub fn set_or_clear_preemptible<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.preemptible = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_affinities][crate::model::Scheduling::node_affinities].
    pub fn set_node_affinities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::scheduling::NodeAffinity>,
    {
        use std::iter::Iterator;
        self.node_affinities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [min_node_cpus][crate::model::Scheduling::min_node_cpus].
    pub fn set_min_node_cpus<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.min_node_cpus = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_node_cpus][crate::model::Scheduling::min_node_cpus].
    pub fn set_or_clear_min_node_cpus<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.min_node_cpus = v.map(|x| x.into());
        self
    }

    /// Sets the value of [provisioning_model][crate::model::Scheduling::provisioning_model].
    pub fn set_provisioning_model<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::scheduling::ProvisioningModel>,
    {
        self.provisioning_model = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provisioning_model][crate::model::Scheduling::provisioning_model].
    pub fn set_or_clear_provisioning_model<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::scheduling::ProvisioningModel>,
    {
        self.provisioning_model = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_termination_action][crate::model::Scheduling::instance_termination_action].
    pub fn set_instance_termination_action<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::scheduling::InstanceTerminationAction>,
    {
        self.instance_termination_action = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_termination_action][crate::model::Scheduling::instance_termination_action].
    pub fn set_or_clear_instance_termination_action<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::scheduling::InstanceTerminationAction>,
    {
        self.instance_termination_action = v.map(|x| x.into());
        self
    }

    /// Sets the value of [local_ssd_recovery_timeout][crate::model::Scheduling::local_ssd_recovery_timeout].
    pub fn set_local_ssd_recovery_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SchedulingDuration>,
    {
        self.local_ssd_recovery_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [local_ssd_recovery_timeout][crate::model::Scheduling::local_ssd_recovery_timeout].
    pub fn set_or_clear_local_ssd_recovery_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SchedulingDuration>,
    {
        self.local_ssd_recovery_timeout = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Scheduling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.Scheduling"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Scheduling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __on_host_maintenance,
            __automatic_restart,
            __preemptible,
            __node_affinities,
            __min_node_cpus,
            __provisioning_model,
            __instance_termination_action,
            __local_ssd_recovery_timeout,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Scheduling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "onHostMaintenance" => Ok(__FieldTag::__on_host_maintenance),
                            "on_host_maintenance" => Ok(__FieldTag::__on_host_maintenance),
                            "automaticRestart" => Ok(__FieldTag::__automatic_restart),
                            "automatic_restart" => Ok(__FieldTag::__automatic_restart),
                            "preemptible" => Ok(__FieldTag::__preemptible),
                            "nodeAffinities" => Ok(__FieldTag::__node_affinities),
                            "node_affinities" => Ok(__FieldTag::__node_affinities),
                            "minNodeCpus" => Ok(__FieldTag::__min_node_cpus),
                            "min_node_cpus" => Ok(__FieldTag::__min_node_cpus),
                            "provisioningModel" => Ok(__FieldTag::__provisioning_model),
                            "provisioning_model" => Ok(__FieldTag::__provisioning_model),
                            "instanceTerminationAction" => {
                                Ok(__FieldTag::__instance_termination_action)
                            }
                            "instance_termination_action" => {
                                Ok(__FieldTag::__instance_termination_action)
                            }
                            "localSsdRecoveryTimeout" => {
                                Ok(__FieldTag::__local_ssd_recovery_timeout)
                            }
                            "local_ssd_recovery_timeout" => {
                                Ok(__FieldTag::__local_ssd_recovery_timeout)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Scheduling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Scheduling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__on_host_maintenance => {
                            if !fields.insert(__FieldTag::__on_host_maintenance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for on_host_maintenance",
                                ));
                            }
                            result.on_host_maintenance =
                                map.next_value::<std::option::Option<
                                    crate::model::scheduling::OnHostMaintenance,
                                >>()?;
                        }
                        __FieldTag::__automatic_restart => {
                            if !fields.insert(__FieldTag::__automatic_restart) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automatic_restart",
                                ));
                            }
                            result.automatic_restart =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__preemptible => {
                            if !fields.insert(__FieldTag::__preemptible) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preemptible",
                                ));
                            }
                            result.preemptible = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__node_affinities => {
                            if !fields.insert(__FieldTag::__node_affinities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_affinities",
                                ));
                            }
                            result.node_affinities = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::scheduling::NodeAffinity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_node_cpus => {
                            if !fields.insert(__FieldTag::__min_node_cpus) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_node_cpus",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_node_cpus = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__provisioning_model => {
                            if !fields.insert(__FieldTag::__provisioning_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provisioning_model",
                                ));
                            }
                            result.provisioning_model =
                                map.next_value::<std::option::Option<
                                    crate::model::scheduling::ProvisioningModel,
                                >>()?;
                        }
                        __FieldTag::__instance_termination_action => {
                            if !fields.insert(__FieldTag::__instance_termination_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_termination_action",
                                ));
                            }
                            result.instance_termination_action = map
                                .next_value::<std::option::Option<
                                    crate::model::scheduling::InstanceTerminationAction,
                                >>()?;
                        }
                        __FieldTag::__local_ssd_recovery_timeout => {
                            if !fields.insert(__FieldTag::__local_ssd_recovery_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_ssd_recovery_timeout",
                                ));
                            }
                            result.local_ssd_recovery_timeout = map.next_value::<std::option::Option<crate::model::SchedulingDuration>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Scheduling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.on_host_maintenance.is_some() {
            state.serialize_entry("onHostMaintenance", &self.on_host_maintenance)?;
        }
        if self.automatic_restart.is_some() {
            state.serialize_entry("automaticRestart", &self.automatic_restart)?;
        }
        if self.preemptible.is_some() {
            state.serialize_entry("preemptible", &self.preemptible)?;
        }
        if !self.node_affinities.is_empty() {
            state.serialize_entry("nodeAffinities", &self.node_affinities)?;
        }
        if self.min_node_cpus.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minNodeCpus", &__With(&self.min_node_cpus))?;
        }
        if self.provisioning_model.is_some() {
            state.serialize_entry("provisioningModel", &self.provisioning_model)?;
        }
        if self.instance_termination_action.is_some() {
            state.serialize_entry(
                "instanceTerminationAction",
                &self.instance_termination_action,
            )?;
        }
        if self.local_ssd_recovery_timeout.is_some() {
            state.serialize_entry("localSsdRecoveryTimeout", &self.local_ssd_recovery_timeout)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Scheduling].
pub mod scheduling {
    #[allow(unused_imports)]
    use super::*;

    /// Node Affinity: the configuration of desired nodes onto which this Instance
    /// could be scheduled.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NodeAffinity {
        /// Optional. Corresponds to the label key of Node resource.
        pub key: std::option::Option<std::string::String>,

        /// Optional. Defines the operation of node selection.
        pub operator: std::option::Option<crate::model::scheduling::node_affinity::Operator>,

        /// Optional. Corresponds to the label values of Node resource.
        pub values: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NodeAffinity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::scheduling::NodeAffinity::key].
        pub fn set_key<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.key = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [key][crate::model::scheduling::NodeAffinity::key].
        pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.key = v.map(|x| x.into());
            self
        }

        /// Sets the value of [operator][crate::model::scheduling::NodeAffinity::operator].
        pub fn set_operator<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::scheduling::node_affinity::Operator>,
        {
            self.operator = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [operator][crate::model::scheduling::NodeAffinity::operator].
        pub fn set_or_clear_operator<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::scheduling::node_affinity::Operator>,
        {
            self.operator = v.map(|x| x.into());
            self
        }

        /// Sets the value of [values][crate::model::scheduling::NodeAffinity::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for NodeAffinity {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.backupdr.v1.Scheduling.NodeAffinity"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NodeAffinity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __key,
                __operator,
                __values,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NodeAffinity")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "key" => Ok(__FieldTag::__key),
                                "operator" => Ok(__FieldTag::__operator),
                                "values" => Ok(__FieldTag::__values),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NodeAffinity;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NodeAffinity")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__key => {
                                if !fields.insert(__FieldTag::__key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for key",
                                    ));
                                }
                                result.key =
                                    map.next_value::<std::option::Option<std::string::String>>()?;
                            }
                            __FieldTag::__operator => {
                                if !fields.insert(__FieldTag::__operator) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for operator",
                                    ));
                                }
                                result.operator = map.next_value::<std::option::Option<
                                    crate::model::scheduling::node_affinity::Operator,
                                >>()?;
                            }
                            __FieldTag::__values => {
                                if !fields.insert(__FieldTag::__values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for values",
                                    ));
                                }
                                result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NodeAffinity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.key.is_some() {
                state.serialize_entry("key", &self.key)?;
            }
            if self.operator.is_some() {
                state.serialize_entry("operator", &self.operator)?;
            }
            if !self.values.is_empty() {
                state.serialize_entry("values", &self.values)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [NodeAffinity].
    pub mod node_affinity {
        #[allow(unused_imports)]
        use super::*;

        /// Defines the type of node selections.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Operator {
            /// Default value. This value is unused.
            Unspecified,
            /// Requires Compute Engine to seek for matched nodes.
            In,
            /// Requires Compute Engine to avoid certain nodes.
            NotIn,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Operator::value] or
            /// [Operator::name].
            UnknownValue(operator::UnknownValue),
        }

        #[doc(hidden)]
        pub mod operator {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Operator {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::In => std::option::Option::Some(1),
                    Self::NotIn => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("OPERATOR_UNSPECIFIED"),
                    Self::In => std::option::Option::Some("IN"),
                    Self::NotIn => std::option::Option::Some("NOT_IN"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Operator {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Operator {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Operator {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::In,
                    2 => Self::NotIn,
                    _ => Self::UnknownValue(operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Operator {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "OPERATOR_UNSPECIFIED" => Self::Unspecified,
                    "IN" => Self::In,
                    "NOT_IN" => Self::NotIn,
                    _ => Self::UnknownValue(operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Operator {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::In => serializer.serialize_i32(1),
                    Self::NotIn => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Operator {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Operator>::new(
                    ".google.cloud.backupdr.v1.Scheduling.NodeAffinity.Operator",
                ))
            }
        }
    }

    /// Defines the maintenance behavior for this instance=
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OnHostMaintenance {
        /// Default value. This value is unused.
        Unspecified,
        /// Tells Compute Engine to terminate and (optionally) restart the instance
        /// away from the maintenance activity.
        Terminate,
        /// Default, Allows Compute Engine to automatically migrate instances
        /// out of the way of maintenance events.
        Migrate,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OnHostMaintenance::value] or
        /// [OnHostMaintenance::name].
        UnknownValue(on_host_maintenance::UnknownValue),
    }

    #[doc(hidden)]
    pub mod on_host_maintenance {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OnHostMaintenance {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Terminate => std::option::Option::Some(1),
                Self::Migrate => std::option::Option::Some(1000),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ON_HOST_MAINTENANCE_UNSPECIFIED"),
                Self::Terminate => std::option::Option::Some("TERMINATE"),
                Self::Migrate => std::option::Option::Some("MIGRATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OnHostMaintenance {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OnHostMaintenance {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OnHostMaintenance {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Terminate,
                1000 => Self::Migrate,
                _ => Self::UnknownValue(on_host_maintenance::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OnHostMaintenance {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ON_HOST_MAINTENANCE_UNSPECIFIED" => Self::Unspecified,
                "TERMINATE" => Self::Terminate,
                "MIGRATE" => Self::Migrate,
                _ => Self::UnknownValue(on_host_maintenance::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OnHostMaintenance {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Terminate => serializer.serialize_i32(1),
                Self::Migrate => serializer.serialize_i32(1000),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OnHostMaintenance {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OnHostMaintenance>::new(
                ".google.cloud.backupdr.v1.Scheduling.OnHostMaintenance",
            ))
        }
    }

    /// Defines the provisioning model for an instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ProvisioningModel {
        /// Default value. This value is not used.
        Unspecified,
        /// Standard provisioning with user controlled runtime, no discounts.
        Standard,
        /// Heavily discounted, no guaranteed runtime.
        Spot,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ProvisioningModel::value] or
        /// [ProvisioningModel::name].
        UnknownValue(provisioning_model::UnknownValue),
    }

    #[doc(hidden)]
    pub mod provisioning_model {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ProvisioningModel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Standard => std::option::Option::Some(1),
                Self::Spot => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROVISIONING_MODEL_UNSPECIFIED"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::Spot => std::option::Option::Some("SPOT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ProvisioningModel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ProvisioningModel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ProvisioningModel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Standard,
                2 => Self::Spot,
                _ => Self::UnknownValue(provisioning_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ProvisioningModel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROVISIONING_MODEL_UNSPECIFIED" => Self::Unspecified,
                "STANDARD" => Self::Standard,
                "SPOT" => Self::Spot,
                _ => Self::UnknownValue(provisioning_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ProvisioningModel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Standard => serializer.serialize_i32(1),
                Self::Spot => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ProvisioningModel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ProvisioningModel>::new(
                ".google.cloud.backupdr.v1.Scheduling.ProvisioningModel",
            ))
        }
    }

    /// Defines the supported termination actions for an instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstanceTerminationAction {
        /// Default value. This value is unused.
        Unspecified,
        /// Delete the VM.
        Delete,
        /// Stop the VM without storing in-memory content. default action.
        Stop,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstanceTerminationAction::value] or
        /// [InstanceTerminationAction::name].
        UnknownValue(instance_termination_action::UnknownValue),
    }

    #[doc(hidden)]
    pub mod instance_termination_action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl InstanceTerminationAction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Delete => std::option::Option::Some(1),
                Self::Stop => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("INSTANCE_TERMINATION_ACTION_UNSPECIFIED")
                }
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::Stop => std::option::Option::Some("STOP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for InstanceTerminationAction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for InstanceTerminationAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for InstanceTerminationAction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Delete,
                2 => Self::Stop,
                _ => Self::UnknownValue(instance_termination_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for InstanceTerminationAction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INSTANCE_TERMINATION_ACTION_UNSPECIFIED" => Self::Unspecified,
                "DELETE" => Self::Delete,
                "STOP" => Self::Stop,
                _ => Self::UnknownValue(instance_termination_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for InstanceTerminationAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Delete => serializer.serialize_i32(1),
                Self::Stop => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for InstanceTerminationAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<InstanceTerminationAction>::new(
                    ".google.cloud.backupdr.v1.Scheduling.InstanceTerminationAction",
                ),
            )
        }
    }
}

/// A SchedulingDuration represents a fixed-length span of time represented
/// as a count of seconds and fractions of seconds at nanosecond
/// resolution. It is independent of any calendar and concepts like "day"
/// or "month". Range is approximately 10,000 years.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SchedulingDuration {
    /// Optional. Span of time at a resolution of a second.
    pub seconds: std::option::Option<i64>,

    /// Optional. Span of time that's a fraction of a second at nanosecond
    /// resolution.
    pub nanos: std::option::Option<i32>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchedulingDuration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [seconds][crate::model::SchedulingDuration::seconds].
    pub fn set_seconds<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.seconds = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [seconds][crate::model::SchedulingDuration::seconds].
    pub fn set_or_clear_seconds<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.seconds = v.map(|x| x.into());
        self
    }

    /// Sets the value of [nanos][crate::model::SchedulingDuration::nanos].
    pub fn set_nanos<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.nanos = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nanos][crate::model::SchedulingDuration::nanos].
    pub fn set_or_clear_nanos<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.nanos = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SchedulingDuration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.SchedulingDuration"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SchedulingDuration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __seconds,
            __nanos,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SchedulingDuration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "seconds" => Ok(__FieldTag::__seconds),
                            "nanos" => Ok(__FieldTag::__nanos),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SchedulingDuration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SchedulingDuration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__seconds => {
                            if !fields.insert(__FieldTag::__seconds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for seconds",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.seconds = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__nanos => {
                            if !fields.insert(__FieldTag::__nanos) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nanos",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.nanos = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SchedulingDuration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.seconds.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("seconds", &__With(&self.seconds))?;
        }
        if self.nanos.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("nanos", &__With(&self.nanos))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A service account.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ServiceAccount {
    /// Optional. Email address of the service account.
    pub email: std::option::Option<std::string::String>,

    /// Optional. The list of scopes to be made available for this service account.
    pub scopes: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceAccount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [email][crate::model::ServiceAccount::email].
    pub fn set_email<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.email = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [email][crate::model::ServiceAccount::email].
    pub fn set_or_clear_email<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.email = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scopes][crate::model::ServiceAccount::scopes].
    pub fn set_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ServiceAccount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ServiceAccount"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServiceAccount {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __email,
            __scopes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServiceAccount")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "email" => Ok(__FieldTag::__email),
                            "scopes" => Ok(__FieldTag::__scopes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServiceAccount;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServiceAccount")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email",
                                ));
                            }
                            result.email =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__scopes => {
                            if !fields.insert(__FieldTag::__scopes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scopes",
                                ));
                            }
                            result.scopes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServiceAccount {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.email.is_some() {
            state.serialize_entry("email", &self.email)?;
        }
        if !self.scopes.is_empty() {
            state.serialize_entry("scopes", &self.scopes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A set of instance tags.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Tags {
    /// Optional. An array of tags. Each tag must be 1-63 characters long, and
    /// comply with RFC1035.
    pub items: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Tags {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [items][crate::model::Tags::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Tags {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.Tags"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Tags {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __items,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Tags")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "items" => Ok(__FieldTag::__items),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Tags;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Tags")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items",
                                ));
                            }
                            result.items = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Tags {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An instance-attached disk resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttachedDisk {
    /// Optional. Specifies the parameters to initialize this disk.
    pub initialize_params: std::option::Option<crate::model::attached_disk::InitializeParams>,

    /// Optional. This is used as an identifier for the disks. This is the unique
    /// name has to provided to modify disk parameters like disk_name and
    /// replica_zones (in case of RePDs)
    pub device_name: std::option::Option<std::string::String>,

    /// Optional. Type of the resource.
    pub kind: std::option::Option<std::string::String>,

    /// Specifies the type of the disk.
    #[deprecated]
    pub disk_type_deprecated: std::option::Option<crate::model::attached_disk::DiskType>,

    /// Optional. The mode in which to attach this disk.
    pub mode: std::option::Option<crate::model::attached_disk::DiskMode>,

    /// Optional. Specifies a valid partial or full URL to an existing Persistent
    /// Disk resource.
    pub source: std::option::Option<std::string::String>,

    /// Optional. A zero-based index to this disk, where 0 is reserved for the
    /// boot disk.
    pub index: std::option::Option<i64>,

    /// Optional. Indicates that this is a boot disk. The virtual machine will use
    /// the first partition of the disk for its root filesystem.
    pub boot: std::option::Option<bool>,

    /// Optional. Specifies whether the disk will be auto-deleted when the instance
    /// is deleted (but not when the disk is detached from the instance).
    pub auto_delete: std::option::Option<bool>,

    /// Optional. Any valid publicly visible licenses.
    pub license: std::vec::Vec<std::string::String>,

    /// Optional. Specifies the disk interface to use for attaching this disk.
    pub disk_interface: std::option::Option<crate::model::attached_disk::DiskInterface>,

    /// Optional. A list of features to enable on the guest operating system.
    /// Applicable only for bootable images.
    pub guest_os_feature: std::vec::Vec<crate::model::GuestOsFeature>,

    /// Optional. Encrypts or decrypts a disk using a customer-supplied
    /// encryption key.
    pub disk_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// Optional. The size of the disk in GB.
    pub disk_size_gb: std::option::Option<i64>,

    /// Optional. Output only. The state of the disk.
    pub saved_state: std::option::Option<crate::model::attached_disk::DiskSavedState>,

    /// Optional. Output only. The URI of the disk type resource. For example:
    /// projects/project/zones/zone/diskTypes/pd-standard or pd-ssd
    pub disk_type: std::option::Option<std::string::String>,

    /// Optional. Specifies the type of the disk.
    pub r#type: std::option::Option<crate::model::attached_disk::DiskType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttachedDisk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [initialize_params][crate::model::AttachedDisk::initialize_params].
    pub fn set_initialize_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::InitializeParams>,
    {
        self.initialize_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [initialize_params][crate::model::AttachedDisk::initialize_params].
    pub fn set_or_clear_initialize_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::InitializeParams>,
    {
        self.initialize_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [device_name][crate::model::AttachedDisk::device_name].
    pub fn set_device_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.device_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [device_name][crate::model::AttachedDisk::device_name].
    pub fn set_or_clear_device_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.device_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::AttachedDisk::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::AttachedDisk::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_type_deprecated][crate::model::AttachedDisk::disk_type_deprecated].
    #[deprecated]
    pub fn set_disk_type_deprecated<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::DiskType>,
    {
        self.disk_type_deprecated = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_type_deprecated][crate::model::AttachedDisk::disk_type_deprecated].
    #[deprecated]
    pub fn set_or_clear_disk_type_deprecated<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::DiskType>,
    {
        self.disk_type_deprecated = v.map(|x| x.into());
        self
    }

    /// Sets the value of [mode][crate::model::AttachedDisk::mode].
    pub fn set_mode<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::DiskMode>,
    {
        self.mode = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mode][crate::model::AttachedDisk::mode].
    pub fn set_or_clear_mode<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::DiskMode>,
    {
        self.mode = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::AttachedDisk::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::AttachedDisk::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [index][crate::model::AttachedDisk::index].
    pub fn set_index<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.index = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [index][crate::model::AttachedDisk::index].
    pub fn set_or_clear_index<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.index = v.map(|x| x.into());
        self
    }

    /// Sets the value of [boot][crate::model::AttachedDisk::boot].
    pub fn set_boot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.boot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [boot][crate::model::AttachedDisk::boot].
    pub fn set_or_clear_boot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.boot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [auto_delete][crate::model::AttachedDisk::auto_delete].
    pub fn set_auto_delete<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.auto_delete = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [auto_delete][crate::model::AttachedDisk::auto_delete].
    pub fn set_or_clear_auto_delete<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.auto_delete = v.map(|x| x.into());
        self
    }

    /// Sets the value of [license][crate::model::AttachedDisk::license].
    pub fn set_license<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.license = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [disk_interface][crate::model::AttachedDisk::disk_interface].
    pub fn set_disk_interface<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::DiskInterface>,
    {
        self.disk_interface = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_interface][crate::model::AttachedDisk::disk_interface].
    pub fn set_or_clear_disk_interface<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::DiskInterface>,
    {
        self.disk_interface = v.map(|x| x.into());
        self
    }

    /// Sets the value of [guest_os_feature][crate::model::AttachedDisk::guest_os_feature].
    pub fn set_guest_os_feature<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GuestOsFeature>,
    {
        use std::iter::Iterator;
        self.guest_os_feature = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [disk_encryption_key][crate::model::AttachedDisk::disk_encryption_key].
    pub fn set_disk_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.disk_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_encryption_key][crate::model::AttachedDisk::disk_encryption_key].
    pub fn set_or_clear_disk_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.disk_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::AttachedDisk::disk_size_gb].
    pub fn set_disk_size_gb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.disk_size_gb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_size_gb][crate::model::AttachedDisk::disk_size_gb].
    pub fn set_or_clear_disk_size_gb<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.disk_size_gb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [saved_state][crate::model::AttachedDisk::saved_state].
    pub fn set_saved_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::DiskSavedState>,
    {
        self.saved_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [saved_state][crate::model::AttachedDisk::saved_state].
    pub fn set_or_clear_saved_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::DiskSavedState>,
    {
        self.saved_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_type][crate::model::AttachedDisk::disk_type].
    pub fn set_disk_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.disk_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_type][crate::model::AttachedDisk::disk_type].
    pub fn set_or_clear_disk_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.disk_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::AttachedDisk::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::DiskType>,
    {
        self.r#type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#type][crate::model::AttachedDisk::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::DiskType>,
    {
        self.r#type = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AttachedDisk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.AttachedDisk"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttachedDisk {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __initialize_params,
            __device_name,
            __kind,
            __disk_type_deprecated,
            __mode,
            __source,
            __index,
            __boot,
            __auto_delete,
            __license,
            __disk_interface,
            __guest_os_feature,
            __disk_encryption_key,
            __disk_size_gb,
            __saved_state,
            __disk_type,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttachedDisk")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "initializeParams" => Ok(__FieldTag::__initialize_params),
                            "initialize_params" => Ok(__FieldTag::__initialize_params),
                            "deviceName" => Ok(__FieldTag::__device_name),
                            "device_name" => Ok(__FieldTag::__device_name),
                            "kind" => Ok(__FieldTag::__kind),
                            "diskTypeDeprecated" => Ok(__FieldTag::__disk_type_deprecated),
                            "disk_type_deprecated" => Ok(__FieldTag::__disk_type_deprecated),
                            "mode" => Ok(__FieldTag::__mode),
                            "source" => Ok(__FieldTag::__source),
                            "index" => Ok(__FieldTag::__index),
                            "boot" => Ok(__FieldTag::__boot),
                            "autoDelete" => Ok(__FieldTag::__auto_delete),
                            "auto_delete" => Ok(__FieldTag::__auto_delete),
                            "license" => Ok(__FieldTag::__license),
                            "diskInterface" => Ok(__FieldTag::__disk_interface),
                            "disk_interface" => Ok(__FieldTag::__disk_interface),
                            "guestOsFeature" => Ok(__FieldTag::__guest_os_feature),
                            "guest_os_feature" => Ok(__FieldTag::__guest_os_feature),
                            "diskEncryptionKey" => Ok(__FieldTag::__disk_encryption_key),
                            "disk_encryption_key" => Ok(__FieldTag::__disk_encryption_key),
                            "diskSizeGb" => Ok(__FieldTag::__disk_size_gb),
                            "disk_size_gb" => Ok(__FieldTag::__disk_size_gb),
                            "savedState" => Ok(__FieldTag::__saved_state),
                            "saved_state" => Ok(__FieldTag::__saved_state),
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttachedDisk;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttachedDisk")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__initialize_params => {
                            if !fields.insert(__FieldTag::__initialize_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initialize_params",
                                ));
                            }
                            result.initialize_params = map.next_value::<std::option::Option<
                                crate::model::attached_disk::InitializeParams,
                            >>()?;
                        }
                        __FieldTag::__device_name => {
                            if !fields.insert(__FieldTag::__device_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for device_name",
                                ));
                            }
                            result.device_name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__disk_type_deprecated => {
                            if !fields.insert(__FieldTag::__disk_type_deprecated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type_deprecated",
                                ));
                            }
                            result.disk_type_deprecated = map.next_value::<std::option::Option<crate::model::attached_disk::DiskType>>()?
                                ;
                        }
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map.next_value::<std::option::Option<crate::model::attached_disk::DiskMode>>()?
                                ;
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__index => {
                            if !fields.insert(__FieldTag::__index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.index = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__boot => {
                            if !fields.insert(__FieldTag::__boot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot",
                                ));
                            }
                            result.boot = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__auto_delete => {
                            if !fields.insert(__FieldTag::__auto_delete) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_delete",
                                ));
                            }
                            result.auto_delete = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__license => {
                            if !fields.insert(__FieldTag::__license) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for license",
                                ));
                            }
                            result.license = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__disk_interface => {
                            if !fields.insert(__FieldTag::__disk_interface) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_interface",
                                ));
                            }
                            result.disk_interface = map.next_value::<std::option::Option<crate::model::attached_disk::DiskInterface>>()?
                                ;
                        }
                        __FieldTag::__guest_os_feature => {
                            if !fields.insert(__FieldTag::__guest_os_feature) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for guest_os_feature",
                                ));
                            }
                            result.guest_os_feature =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::GuestOsFeature>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_encryption_key => {
                            if !fields.insert(__FieldTag::__disk_encryption_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_encryption_key",
                                ));
                            }
                            result.disk_encryption_key = map.next_value::<std::option::Option<crate::model::CustomerEncryptionKey>>()?
                                ;
                        }
                        __FieldTag::__disk_size_gb => {
                            if !fields.insert(__FieldTag::__disk_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_size_gb = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__saved_state => {
                            if !fields.insert(__FieldTag::__saved_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for saved_state",
                                ));
                            }
                            result.saved_state =
                                map.next_value::<std::option::Option<
                                    crate::model::attached_disk::DiskSavedState,
                                >>()?;
                        }
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::attached_disk::DiskType>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttachedDisk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.initialize_params.is_some() {
            state.serialize_entry("initializeParams", &self.initialize_params)?;
        }
        if self.device_name.is_some() {
            state.serialize_entry("deviceName", &self.device_name)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.disk_type_deprecated.is_some() {
            state.serialize_entry("diskTypeDeprecated", &self.disk_type_deprecated)?;
        }
        if self.mode.is_some() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if self.index.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("index", &__With(&self.index))?;
        }
        if self.boot.is_some() {
            state.serialize_entry("boot", &self.boot)?;
        }
        if self.auto_delete.is_some() {
            state.serialize_entry("autoDelete", &self.auto_delete)?;
        }
        if !self.license.is_empty() {
            state.serialize_entry("license", &self.license)?;
        }
        if self.disk_interface.is_some() {
            state.serialize_entry("diskInterface", &self.disk_interface)?;
        }
        if !self.guest_os_feature.is_empty() {
            state.serialize_entry("guestOsFeature", &self.guest_os_feature)?;
        }
        if self.disk_encryption_key.is_some() {
            state.serialize_entry("diskEncryptionKey", &self.disk_encryption_key)?;
        }
        if self.disk_size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if self.saved_state.is_some() {
            state.serialize_entry("savedState", &self.saved_state)?;
        }
        if self.disk_type.is_some() {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AttachedDisk].
pub mod attached_disk {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the parameters to initialize this disk.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InitializeParams {
        /// Optional. Specifies the disk name. If not specified, the default is to
        /// use the name of the instance.
        pub disk_name: std::option::Option<std::string::String>,

        /// Optional. URL of the zone where the disk should be created.
        /// Required for each regional disk associated with the instance.
        pub replica_zones: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InitializeParams {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [disk_name][crate::model::attached_disk::InitializeParams::disk_name].
        pub fn set_disk_name<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.disk_name = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [disk_name][crate::model::attached_disk::InitializeParams::disk_name].
        pub fn set_or_clear_disk_name<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.disk_name = v.map(|x| x.into());
            self
        }

        /// Sets the value of [replica_zones][crate::model::attached_disk::InitializeParams::replica_zones].
        pub fn set_replica_zones<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.replica_zones = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for InitializeParams {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.backupdr.v1.AttachedDisk.InitializeParams"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InitializeParams {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __disk_name,
                __replica_zones,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InitializeParams")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "diskName" => Ok(__FieldTag::__disk_name),
                                "disk_name" => Ok(__FieldTag::__disk_name),
                                "replicaZones" => Ok(__FieldTag::__replica_zones),
                                "replica_zones" => Ok(__FieldTag::__replica_zones),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InitializeParams;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InitializeParams")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__disk_name => {
                                if !fields.insert(__FieldTag::__disk_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disk_name",
                                    ));
                                }
                                result.disk_name =
                                    map.next_value::<std::option::Option<std::string::String>>()?;
                            }
                            __FieldTag::__replica_zones => {
                                if !fields.insert(__FieldTag::__replica_zones) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for replica_zones",
                                    ));
                                }
                                result.replica_zones = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InitializeParams {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.disk_name.is_some() {
                state.serialize_entry("diskName", &self.disk_name)?;
            }
            if !self.replica_zones.is_empty() {
                state.serialize_entry("replicaZones", &self.replica_zones)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// List of the Disk Types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DiskType {
        /// Default value, which is unused.
        Unspecified,
        /// A scratch disk type.
        Scratch,
        /// A persistent disk type.
        Persistent,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DiskType::value] or
        /// [DiskType::name].
        UnknownValue(disk_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod disk_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DiskType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Scratch => std::option::Option::Some(1),
                Self::Persistent => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DISK_TYPE_UNSPECIFIED"),
                Self::Scratch => std::option::Option::Some("SCRATCH"),
                Self::Persistent => std::option::Option::Some("PERSISTENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DiskType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DiskType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DiskType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Scratch,
                2 => Self::Persistent,
                _ => Self::UnknownValue(disk_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DiskType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISK_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SCRATCH" => Self::Scratch,
                "PERSISTENT" => Self::Persistent,
                _ => Self::UnknownValue(disk_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DiskType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Scratch => serializer.serialize_i32(1),
                Self::Persistent => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DiskType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DiskType>::new(
                ".google.cloud.backupdr.v1.AttachedDisk.DiskType",
            ))
        }
    }

    /// List of the Disk Modes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DiskMode {
        /// Default value, which is unused.
        Unspecified,
        /// Attaches this disk in read-write mode. Only one
        /// virtual machine at a time can be attached to a disk in read-write mode.
        ReadWrite,
        /// Attaches this disk in read-only mode. Multiple virtual machines can use
        /// a disk in read-only mode at a time.
        ReadOnly,
        /// The disk is locked for administrative reasons. Nobody else
        /// can use the disk. This mode is used (for example) when taking
        /// a snapshot of a disk to prevent mounting the disk while it is
        /// being snapshotted.
        Locked,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DiskMode::value] or
        /// [DiskMode::name].
        UnknownValue(disk_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod disk_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DiskMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ReadWrite => std::option::Option::Some(1),
                Self::ReadOnly => std::option::Option::Some(2),
                Self::Locked => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DISK_MODE_UNSPECIFIED"),
                Self::ReadWrite => std::option::Option::Some("READ_WRITE"),
                Self::ReadOnly => std::option::Option::Some("READ_ONLY"),
                Self::Locked => std::option::Option::Some("LOCKED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DiskMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DiskMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DiskMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ReadWrite,
                2 => Self::ReadOnly,
                3 => Self::Locked,
                _ => Self::UnknownValue(disk_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DiskMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISK_MODE_UNSPECIFIED" => Self::Unspecified,
                "READ_WRITE" => Self::ReadWrite,
                "READ_ONLY" => Self::ReadOnly,
                "LOCKED" => Self::Locked,
                _ => Self::UnknownValue(disk_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DiskMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ReadWrite => serializer.serialize_i32(1),
                Self::ReadOnly => serializer.serialize_i32(2),
                Self::Locked => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DiskMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DiskMode>::new(
                ".google.cloud.backupdr.v1.AttachedDisk.DiskMode",
            ))
        }
    }

    /// List of the Disk Interfaces.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DiskInterface {
        /// Default value, which is unused.
        Unspecified,
        /// SCSI Disk Interface.
        Scsi,
        /// NVME Disk Interface.
        Nvme,
        /// NVDIMM Disk Interface.
        Nvdimm,
        /// ISCSI Disk Interface.
        Iscsi,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DiskInterface::value] or
        /// [DiskInterface::name].
        UnknownValue(disk_interface::UnknownValue),
    }

    #[doc(hidden)]
    pub mod disk_interface {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DiskInterface {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Scsi => std::option::Option::Some(1),
                Self::Nvme => std::option::Option::Some(2),
                Self::Nvdimm => std::option::Option::Some(3),
                Self::Iscsi => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DISK_INTERFACE_UNSPECIFIED"),
                Self::Scsi => std::option::Option::Some("SCSI"),
                Self::Nvme => std::option::Option::Some("NVME"),
                Self::Nvdimm => std::option::Option::Some("NVDIMM"),
                Self::Iscsi => std::option::Option::Some("ISCSI"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DiskInterface {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DiskInterface {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DiskInterface {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Scsi,
                2 => Self::Nvme,
                3 => Self::Nvdimm,
                4 => Self::Iscsi,
                _ => Self::UnknownValue(disk_interface::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DiskInterface {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISK_INTERFACE_UNSPECIFIED" => Self::Unspecified,
                "SCSI" => Self::Scsi,
                "NVME" => Self::Nvme,
                "NVDIMM" => Self::Nvdimm,
                "ISCSI" => Self::Iscsi,
                _ => Self::UnknownValue(disk_interface::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DiskInterface {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Scsi => serializer.serialize_i32(1),
                Self::Nvme => serializer.serialize_i32(2),
                Self::Nvdimm => serializer.serialize_i32(3),
                Self::Iscsi => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DiskInterface {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DiskInterface>::new(
                ".google.cloud.backupdr.v1.AttachedDisk.DiskInterface",
            ))
        }
    }

    /// List of the states of the Disk.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DiskSavedState {
        /// Default Disk state has not been preserved.
        Unspecified,
        /// Disk state has been preserved.
        Preserved,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DiskSavedState::value] or
        /// [DiskSavedState::name].
        UnknownValue(disk_saved_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod disk_saved_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DiskSavedState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Preserved => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DISK_SAVED_STATE_UNSPECIFIED"),
                Self::Preserved => std::option::Option::Some("PRESERVED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DiskSavedState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DiskSavedState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DiskSavedState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Preserved,
                _ => Self::UnknownValue(disk_saved_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DiskSavedState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISK_SAVED_STATE_UNSPECIFIED" => Self::Unspecified,
                "PRESERVED" => Self::Preserved,
                _ => Self::UnknownValue(disk_saved_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DiskSavedState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Preserved => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DiskSavedState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DiskSavedState>::new(
                ".google.cloud.backupdr.v1.AttachedDisk.DiskSavedState",
            ))
        }
    }
}

/// Feature type of the Guest OS.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GuestOsFeature {
    /// The ID of a supported feature.
    pub r#type: std::option::Option<crate::model::guest_os_feature::FeatureType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GuestOsFeature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::GuestOsFeature::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::guest_os_feature::FeatureType>,
    {
        self.r#type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#type][crate::model::GuestOsFeature::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::guest_os_feature::FeatureType>,
    {
        self.r#type = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GuestOsFeature {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.GuestOsFeature"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GuestOsFeature {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GuestOsFeature")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GuestOsFeature;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GuestOsFeature")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type =
                                map.next_value::<std::option::Option<
                                    crate::model::guest_os_feature::FeatureType,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GuestOsFeature {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GuestOsFeature].
pub mod guest_os_feature {
    #[allow(unused_imports)]
    use super::*;

    /// List of the Feature Types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FeatureType {
        /// Default value, which is unused.
        Unspecified,
        /// VIRTIO_SCSI_MULTIQUEUE feature type.
        VirtioScsiMultiqueue,
        /// WINDOWS feature type.
        Windows,
        /// MULTI_IP_SUBNET feature type.
        MultiIpSubnet,
        /// UEFI_COMPATIBLE feature type.
        UefiCompatible,
        /// SECURE_BOOT feature type.
        SecureBoot,
        /// GVNIC feature type.
        Gvnic,
        /// SEV_CAPABLE feature type.
        SevCapable,
        /// BARE_METAL_LINUX_COMPATIBLE feature type.
        BareMetalLinuxCompatible,
        /// SUSPEND_RESUME_COMPATIBLE feature type.
        SuspendResumeCompatible,
        /// SEV_LIVE_MIGRATABLE feature type.
        SevLiveMigratable,
        /// SEV_SNP_CAPABLE feature type.
        SevSnpCapable,
        /// TDX_CAPABLE feature type.
        TdxCapable,
        /// IDPF feature type.
        Idpf,
        /// SEV_LIVE_MIGRATABLE_V2 feature type.
        SevLiveMigratableV2,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FeatureType::value] or
        /// [FeatureType::name].
        UnknownValue(feature_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod feature_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FeatureType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::VirtioScsiMultiqueue => std::option::Option::Some(1),
                Self::Windows => std::option::Option::Some(2),
                Self::MultiIpSubnet => std::option::Option::Some(3),
                Self::UefiCompatible => std::option::Option::Some(4),
                Self::SecureBoot => std::option::Option::Some(5),
                Self::Gvnic => std::option::Option::Some(6),
                Self::SevCapable => std::option::Option::Some(7),
                Self::BareMetalLinuxCompatible => std::option::Option::Some(8),
                Self::SuspendResumeCompatible => std::option::Option::Some(9),
                Self::SevLiveMigratable => std::option::Option::Some(10),
                Self::SevSnpCapable => std::option::Option::Some(11),
                Self::TdxCapable => std::option::Option::Some(12),
                Self::Idpf => std::option::Option::Some(13),
                Self::SevLiveMigratableV2 => std::option::Option::Some(14),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FEATURE_TYPE_UNSPECIFIED"),
                Self::VirtioScsiMultiqueue => std::option::Option::Some("VIRTIO_SCSI_MULTIQUEUE"),
                Self::Windows => std::option::Option::Some("WINDOWS"),
                Self::MultiIpSubnet => std::option::Option::Some("MULTI_IP_SUBNET"),
                Self::UefiCompatible => std::option::Option::Some("UEFI_COMPATIBLE"),
                Self::SecureBoot => std::option::Option::Some("SECURE_BOOT"),
                Self::Gvnic => std::option::Option::Some("GVNIC"),
                Self::SevCapable => std::option::Option::Some("SEV_CAPABLE"),
                Self::BareMetalLinuxCompatible => {
                    std::option::Option::Some("BARE_METAL_LINUX_COMPATIBLE")
                }
                Self::SuspendResumeCompatible => {
                    std::option::Option::Some("SUSPEND_RESUME_COMPATIBLE")
                }
                Self::SevLiveMigratable => std::option::Option::Some("SEV_LIVE_MIGRATABLE"),
                Self::SevSnpCapable => std::option::Option::Some("SEV_SNP_CAPABLE"),
                Self::TdxCapable => std::option::Option::Some("TDX_CAPABLE"),
                Self::Idpf => std::option::Option::Some("IDPF"),
                Self::SevLiveMigratableV2 => std::option::Option::Some("SEV_LIVE_MIGRATABLE_V2"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FeatureType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FeatureType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FeatureType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::VirtioScsiMultiqueue,
                2 => Self::Windows,
                3 => Self::MultiIpSubnet,
                4 => Self::UefiCompatible,
                5 => Self::SecureBoot,
                6 => Self::Gvnic,
                7 => Self::SevCapable,
                8 => Self::BareMetalLinuxCompatible,
                9 => Self::SuspendResumeCompatible,
                10 => Self::SevLiveMigratable,
                11 => Self::SevSnpCapable,
                12 => Self::TdxCapable,
                13 => Self::Idpf,
                14 => Self::SevLiveMigratableV2,
                _ => Self::UnknownValue(feature_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FeatureType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FEATURE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "VIRTIO_SCSI_MULTIQUEUE" => Self::VirtioScsiMultiqueue,
                "WINDOWS" => Self::Windows,
                "MULTI_IP_SUBNET" => Self::MultiIpSubnet,
                "UEFI_COMPATIBLE" => Self::UefiCompatible,
                "SECURE_BOOT" => Self::SecureBoot,
                "GVNIC" => Self::Gvnic,
                "SEV_CAPABLE" => Self::SevCapable,
                "BARE_METAL_LINUX_COMPATIBLE" => Self::BareMetalLinuxCompatible,
                "SUSPEND_RESUME_COMPATIBLE" => Self::SuspendResumeCompatible,
                "SEV_LIVE_MIGRATABLE" => Self::SevLiveMigratable,
                "SEV_SNP_CAPABLE" => Self::SevSnpCapable,
                "TDX_CAPABLE" => Self::TdxCapable,
                "IDPF" => Self::Idpf,
                "SEV_LIVE_MIGRATABLE_V2" => Self::SevLiveMigratableV2,
                _ => Self::UnknownValue(feature_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FeatureType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::VirtioScsiMultiqueue => serializer.serialize_i32(1),
                Self::Windows => serializer.serialize_i32(2),
                Self::MultiIpSubnet => serializer.serialize_i32(3),
                Self::UefiCompatible => serializer.serialize_i32(4),
                Self::SecureBoot => serializer.serialize_i32(5),
                Self::Gvnic => serializer.serialize_i32(6),
                Self::SevCapable => serializer.serialize_i32(7),
                Self::BareMetalLinuxCompatible => serializer.serialize_i32(8),
                Self::SuspendResumeCompatible => serializer.serialize_i32(9),
                Self::SevLiveMigratable => serializer.serialize_i32(10),
                Self::SevSnpCapable => serializer.serialize_i32(11),
                Self::TdxCapable => serializer.serialize_i32(12),
                Self::Idpf => serializer.serialize_i32(13),
                Self::SevLiveMigratableV2 => serializer.serialize_i32(14),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FeatureType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FeatureType>::new(
                ".google.cloud.backupdr.v1.GuestOsFeature.FeatureType",
            ))
        }
    }
}

/// Backup configuration state. Is the resource configured for backup?
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BackupConfigState {
    /// The possible states of backup configuration.
    /// Status not set.
    Unspecified,
    /// The data source is actively protected (i.e. there is a
    /// BackupPlanAssociation or Appliance SLA pointing to it)
    Active,
    /// The data source is no longer protected (but may have backups under it)
    Passive,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BackupConfigState::value] or
    /// [BackupConfigState::name].
    UnknownValue(backup_config_state::UnknownValue),
}

#[doc(hidden)]
pub mod backup_config_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BackupConfigState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Active => std::option::Option::Some(1),
            Self::Passive => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("BACKUP_CONFIG_STATE_UNSPECIFIED"),
            Self::Active => std::option::Option::Some("ACTIVE"),
            Self::Passive => std::option::Option::Some("PASSIVE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BackupConfigState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BackupConfigState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BackupConfigState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Active,
            2 => Self::Passive,
            _ => Self::UnknownValue(backup_config_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BackupConfigState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BACKUP_CONFIG_STATE_UNSPECIFIED" => Self::Unspecified,
            "ACTIVE" => Self::Active,
            "PASSIVE" => Self::Passive,
            _ => Self::UnknownValue(backup_config_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BackupConfigState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Active => serializer.serialize_i32(1),
            Self::Passive => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BackupConfigState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackupConfigState>::new(
            ".google.cloud.backupdr.v1.BackupConfigState",
        ))
    }
}

/// BackupView contains enum options for Partial and Full view.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BackupView {
    /// If the value is not set, the default 'FULL' view is used.
    Unspecified,
    /// Includes basic data about the Backup, but not the full contents.
    Basic,
    /// Includes all data about the Backup.
    /// This is the default value (for both ListBackups and GetBackup).
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BackupView::value] or
    /// [BackupView::name].
    UnknownValue(backup_view::UnknownValue),
}

#[doc(hidden)]
pub mod backup_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BackupView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("BACKUP_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("BACKUP_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("BACKUP_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BackupView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BackupView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BackupView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(backup_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BackupView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BACKUP_VIEW_UNSPECIFIED" => Self::Unspecified,
            "BACKUP_VIEW_BASIC" => Self::Basic,
            "BACKUP_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(backup_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BackupView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BackupView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackupView>::new(
            ".google.cloud.backupdr.v1.BackupView",
        ))
    }
}

/// BackupVaultView contains enum options for Partial and Full view.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BackupVaultView {
    /// If the value is not set, the default 'FULL' view is used.
    Unspecified,
    /// Includes basic data about the Backup Vault, but not the full contents.
    Basic,
    /// Includes all data about the Backup Vault.
    /// This is the default value (for both ListBackupVaults and GetBackupVault).
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BackupVaultView::value] or
    /// [BackupVaultView::name].
    UnknownValue(backup_vault_view::UnknownValue),
}

#[doc(hidden)]
pub mod backup_vault_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BackupVaultView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("BACKUP_VAULT_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("BACKUP_VAULT_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("BACKUP_VAULT_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BackupVaultView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BackupVaultView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BackupVaultView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(backup_vault_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BackupVaultView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BACKUP_VAULT_VIEW_UNSPECIFIED" => Self::Unspecified,
            "BACKUP_VAULT_VIEW_BASIC" => Self::Basic,
            "BACKUP_VAULT_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(backup_vault_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BackupVaultView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BackupVaultView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackupVaultView>::new(
            ".google.cloud.backupdr.v1.BackupVaultView",
        ))
    }
}

/// Specifies whether the virtual machine instance will be shut down on key
/// revocation. It is currently used in instance, instance properties and GMI
/// protos
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum KeyRevocationActionType {
    /// Default value. This value is unused.
    Unspecified,
    /// Indicates user chose no operation.
    None,
    /// Indicates user chose to opt for VM shutdown on key revocation.
    Stop,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [KeyRevocationActionType::value] or
    /// [KeyRevocationActionType::name].
    UnknownValue(key_revocation_action_type::UnknownValue),
}

#[doc(hidden)]
pub mod key_revocation_action_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl KeyRevocationActionType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::None => std::option::Option::Some(1),
            Self::Stop => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED")
            }
            Self::None => std::option::Option::Some("NONE"),
            Self::Stop => std::option::Option::Some("STOP"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for KeyRevocationActionType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for KeyRevocationActionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for KeyRevocationActionType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::None,
            2 => Self::Stop,
            _ => Self::UnknownValue(key_revocation_action_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for KeyRevocationActionType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "NONE" => Self::None,
            "STOP" => Self::Stop,
            _ => Self::UnknownValue(key_revocation_action_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for KeyRevocationActionType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::None => serializer.serialize_i32(1),
            Self::Stop => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for KeyRevocationActionType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<KeyRevocationActionType>::new(
            ".google.cloud.backupdr.v1.KeyRevocationActionType",
        ))
    }
}
