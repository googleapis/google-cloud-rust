// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::NetworkConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkConfig");
        debug_struct.field("network", &self.network);
        debug_struct.field("peering_mode", &self.peering_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ManagementURI {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ManagementURI");
        debug_struct.field("web_ui", &self.web_ui);
        debug_struct.field("api", &self.api);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WorkforceIdentityBasedManagementURI {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkforceIdentityBasedManagementURI");
        debug_struct.field(
            "first_party_management_uri",
            &self.first_party_management_uri,
        );
        debug_struct.field(
            "third_party_management_uri",
            &self.third_party_management_uri,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WorkforceIdentityBasedOAuth2ClientID {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkforceIdentityBasedOAuth2ClientID");
        debug_struct.field(
            "first_party_oauth2_client_id",
            &self.first_party_oauth2_client_id,
        );
        debug_struct.field(
            "third_party_oauth2_client_id",
            &self.third_party_oauth2_client_id,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ManagementServer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ManagementServer");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("management_uri", &self.management_uri);
        debug_struct.field(
            "workforce_identity_based_management_uri",
            &self.workforce_identity_based_management_uri,
        );
        debug_struct.field("state", &self.state);
        debug_struct.field("networks", &self.networks);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("oauth2_client_id", &self.oauth2_client_id);
        debug_struct.field(
            "workforce_identity_based_oauth2_client_id",
            &self.workforce_identity_based_oauth2_client_id,
        );
        debug_struct.field("ba_proxy_uri", &self.ba_proxy_uri);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("satisfies_pzi", &self.satisfies_pzi);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListManagementServersRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListManagementServersRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListManagementServersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListManagementServersResponse");
        debug_struct.field("management_servers", &self.management_servers);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetManagementServerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetManagementServerRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateManagementServerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateManagementServerRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("management_server_id", &self.management_server_id);
        debug_struct.field("management_server", &self.management_server);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteManagementServerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteManagementServerRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InitializeServiceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InitializeServiceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("resource_type", &self.resource_type);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("initialization_config", &self.initialization_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InitializeServiceResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InitializeServiceResponse");
        debug_struct.field("backup_vault_name", &self.backup_vault_name);
        debug_struct.field("backup_plan_name", &self.backup_plan_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("requested_cancellation", &self.requested_cancellation);
        debug_struct.field("api_version", &self.api_version);
        debug_struct.field("additional_info", &self.additional_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackupPlan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupPlan");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("backup_rules", &self.backup_rules);
        debug_struct.field("state", &self.state);
        debug_struct.field("resource_type", &self.resource_type);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("backup_vault", &self.backup_vault);
        debug_struct.field(
            "backup_vault_service_account",
            &self.backup_vault_service_account,
        );
        debug_struct.field("log_retention_days", &self.log_retention_days);
        debug_struct.field("supported_resource_types", &self.supported_resource_types);
        debug_struct.field("revision_id", &self.revision_id);
        debug_struct.field("revision_name", &self.revision_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackupRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupRule");
        debug_struct.field("rule_id", &self.rule_id);
        debug_struct.field("backup_retention_days", &self.backup_retention_days);
        debug_struct.field("backup_schedule_oneof", &self.backup_schedule_oneof);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StandardSchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StandardSchedule");
        debug_struct.field("recurrence_type", &self.recurrence_type);
        debug_struct.field("hourly_frequency", &self.hourly_frequency);
        debug_struct.field("days_of_week", &self.days_of_week);
        debug_struct.field("days_of_month", &self.days_of_month);
        debug_struct.field("week_day_of_month", &self.week_day_of_month);
        debug_struct.field("months", &self.months);
        debug_struct.field("backup_window", &self.backup_window);
        debug_struct.field("time_zone", &self.time_zone);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackupWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupWindow");
        debug_struct.field("start_hour_of_day", &self.start_hour_of_day);
        debug_struct.field("end_hour_of_day", &self.end_hour_of_day);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WeekDayOfMonth {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WeekDayOfMonth");
        debug_struct.field("week_of_month", &self.week_of_month);
        debug_struct.field("day_of_week", &self.day_of_week);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateBackupPlanRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateBackupPlanRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("backup_plan_id", &self.backup_plan_id);
        debug_struct.field("backup_plan", &self.backup_plan);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListBackupPlansRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupPlansRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListBackupPlansResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupPlansResponse");
        debug_struct.field("backup_plans", &self.backup_plans);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetBackupPlanRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBackupPlanRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteBackupPlanRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteBackupPlanRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateBackupPlanRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateBackupPlanRequest");
        debug_struct.field("backup_plan", &self.backup_plan);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackupPlanRevision {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupPlanRevision");
        debug_struct.field("name", &self.name);
        debug_struct.field("revision_id", &self.revision_id);
        debug_struct.field("state", &self.state);
        debug_struct.field("backup_plan_snapshot", &self.backup_plan_snapshot);
        debug_struct.field("create_time", &self.create_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetBackupPlanRevisionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBackupPlanRevisionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListBackupPlanRevisionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupPlanRevisionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListBackupPlanRevisionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupPlanRevisionsResponse");
        debug_struct.field("backup_plan_revisions", &self.backup_plan_revisions);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackupPlanAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupPlanAssociation");
        debug_struct.field("name", &self.name);
        debug_struct.field("resource_type", &self.resource_type);
        debug_struct.field("resource", &self.resource);
        debug_struct.field("backup_plan", &self.backup_plan);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("state", &self.state);
        debug_struct.field("rules_config_info", &self.rules_config_info);
        debug_struct.field("data_source", &self.data_source);
        debug_struct.field("backup_plan_revision_id", &self.backup_plan_revision_id);
        debug_struct.field("backup_plan_revision_name", &self.backup_plan_revision_name);
        debug_struct.field("resource_properties", &self.resource_properties);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RuleConfigInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RuleConfigInfo");
        debug_struct.field("rule_id", &self.rule_id);
        debug_struct.field("last_backup_state", &self.last_backup_state);
        debug_struct.field("last_backup_error", &self.last_backup_error);
        debug_struct.field(
            "last_successful_backup_consistency_time",
            &self.last_successful_backup_consistency_time,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateBackupPlanAssociationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateBackupPlanAssociationRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field(
            "backup_plan_association_id",
            &self.backup_plan_association_id,
        );
        debug_struct.field("backup_plan_association", &self.backup_plan_association);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListBackupPlanAssociationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupPlanAssociationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListBackupPlanAssociationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupPlanAssociationsResponse");
        debug_struct.field("backup_plan_associations", &self.backup_plan_associations);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchBackupPlanAssociationsForResourceTypeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchBackupPlanAssociationsForResourceTypeRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("resource_type", &self.resource_type);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchBackupPlanAssociationsForResourceTypeResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchBackupPlanAssociationsForResourceTypeResponse");
        debug_struct.field("backup_plan_associations", &self.backup_plan_associations);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetBackupPlanAssociationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBackupPlanAssociationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteBackupPlanAssociationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteBackupPlanAssociationRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateBackupPlanAssociationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateBackupPlanAssociationRequest");
        debug_struct.field("backup_plan_association", &self.backup_plan_association);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TriggerBackupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TriggerBackupRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("rule_id", &self.rule_id);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackupVault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupVault");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field(
            "backup_minimum_enforced_retention_duration",
            &self.backup_minimum_enforced_retention_duration,
        );
        debug_struct.field("deletable", &self.deletable);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("state", &self.state);
        debug_struct.field("effective_time", &self.effective_time);
        debug_struct.field("backup_count", &self.backup_count);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("total_stored_bytes", &self.total_stored_bytes);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("access_restriction", &self.access_restriction);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataSource");
        debug_struct.field("name", &self.name);
        debug_struct.field("state", &self.state);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("backup_count", &self.backup_count);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("total_stored_bytes", &self.total_stored_bytes);
        debug_struct.field("config_state", &self.config_state);
        debug_struct.field("backup_config_info", &self.backup_config_info);
        debug_struct.field(
            "backup_blocked_by_vault_access_restriction",
            &self.backup_blocked_by_vault_access_restriction,
        );
        debug_struct.field("source_resource", &self.source_resource);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackupConfigInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupConfigInfo");
        debug_struct.field("last_backup_state", &self.last_backup_state);
        debug_struct.field(
            "last_successful_backup_consistency_time",
            &self.last_successful_backup_consistency_time,
        );
        debug_struct.field("last_backup_error", &self.last_backup_error);
        debug_struct.field("backup_config", &self.backup_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GcpBackupConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcpBackupConfig");
        debug_struct.field("backup_plan", &self.backup_plan);
        debug_struct.field("backup_plan_description", &self.backup_plan_description);
        debug_struct.field("backup_plan_association", &self.backup_plan_association);
        debug_struct.field("backup_plan_rules", &self.backup_plan_rules);
        debug_struct.field("backup_plan_revision_name", &self.backup_plan_revision_name);
        debug_struct.field("backup_plan_revision_id", &self.backup_plan_revision_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackupApplianceBackupConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupApplianceBackupConfig");
        debug_struct.field("backup_appliance_name", &self.backup_appliance_name);
        debug_struct.field("backup_appliance_id", &self.backup_appliance_id);
        debug_struct.field("sla_id", &self.sla_id);
        debug_struct.field("application_name", &self.application_name);
        debug_struct.field("host_name", &self.host_name);
        debug_struct.field("slt_name", &self.slt_name);
        debug_struct.field("slp_name", &self.slp_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DataSourceGcpResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataSourceGcpResource");
        debug_struct.field("gcp_resourcename", &self.gcp_resourcename);
        debug_struct.field("location", &self.location);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("gcp_resource_properties", &self.gcp_resource_properties);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DataSourceBackupApplianceApplication {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataSourceBackupApplianceApplication");
        debug_struct.field("application_name", &self.application_name);
        debug_struct.field("backup_appliance", &self.backup_appliance);
        debug_struct.field("appliance_id", &self.appliance_id);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("application_id", &self.application_id);
        debug_struct.field("hostname", &self.hostname);
        debug_struct.field("host_id", &self.host_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ServiceLockInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ServiceLockInfo");
        debug_struct.field("operation", &self.operation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackupApplianceLockInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupApplianceLockInfo");
        debug_struct.field("backup_appliance_id", &self.backup_appliance_id);
        debug_struct.field("backup_appliance_name", &self.backup_appliance_name);
        debug_struct.field("lock_reason", &self.lock_reason);
        debug_struct.field("lock_source", &self.lock_source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackupLock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupLock");
        debug_struct.field("lock_until_time", &self.lock_until_time);
        debug_struct.field("client_lock_info", &self.client_lock_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Backup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Backup");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field(
            "enforced_retention_end_time",
            &self.enforced_retention_end_time,
        );
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("consistency_time", &self.consistency_time);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("state", &self.state);
        debug_struct.field("service_locks", &self.service_locks);
        debug_struct.field("backup_appliance_locks", &self.backup_appliance_locks);
        debug_struct.field("backup_type", &self.backup_type);
        debug_struct.field("resource_size_bytes", &self.resource_size_bytes);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("satisfies_pzi", &self.satisfies_pzi);
        debug_struct.field("backup_properties", &self.backup_properties);
        debug_struct.field("plan_info", &self.plan_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::backup::GCPBackupPlanInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GCPBackupPlanInfo");
        debug_struct.field("backup_plan", &self.backup_plan);
        debug_struct.field("backup_plan_rule_id", &self.backup_plan_rule_id);
        debug_struct.field("backup_plan_revision_name", &self.backup_plan_revision_name);
        debug_struct.field("backup_plan_revision_id", &self.backup_plan_revision_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateBackupVaultRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateBackupVaultRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("backup_vault_id", &self.backup_vault_id);
        debug_struct.field("backup_vault", &self.backup_vault);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListBackupVaultsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupVaultsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListBackupVaultsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupVaultsResponse");
        debug_struct.field("backup_vaults", &self.backup_vaults);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchUsableBackupVaultsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchUsableBackupVaultsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchUsableBackupVaultsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchUsableBackupVaultsResponse");
        debug_struct.field("backup_vaults", &self.backup_vaults);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetBackupVaultRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBackupVaultRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateBackupVaultRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateBackupVaultRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("backup_vault", &self.backup_vault);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("force", &self.force);
        debug_struct.field(
            "force_update_access_restriction",
            &self.force_update_access_restriction,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteBackupVaultRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteBackupVaultRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("force", &self.force);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field(
            "ignore_backup_plan_references",
            &self.ignore_backup_plan_references,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListDataSourcesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDataSourcesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListDataSourcesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDataSourcesResponse");
        debug_struct.field("data_sources", &self.data_sources);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetDataSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDataSourceRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateDataSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateDataSourceRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("data_source", &self.data_source);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("allow_missing", &self.allow_missing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListBackupsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListBackupsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupsResponse");
        debug_struct.field("backups", &self.backups);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetBackupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBackupRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateBackupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateBackupRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("backup", &self.backup);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteBackupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteBackupRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RestoreBackupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RestoreBackupRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("target_environment", &self.target_environment);
        debug_struct.field("instance_properties", &self.instance_properties);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RestoreBackupResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RestoreBackupResponse");
        debug_struct.field("target_resource", &self.target_resource);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TargetResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TargetResource");
        debug_struct.field("target_resource_info", &self.target_resource_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GcpResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcpResource");
        debug_struct.field("gcp_resourcename", &self.gcp_resourcename);
        debug_struct.field("location", &self.location);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackupApplianceBackupProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupApplianceBackupProperties");
        debug_struct.field("generation_id", &self.generation_id);
        debug_struct.field("finalize_time", &self.finalize_time);
        debug_struct.field("recovery_range_start_time", &self.recovery_range_start_time);
        debug_struct.field("recovery_range_end_time", &self.recovery_range_end_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CloudSqlInstanceDataSourceProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudSqlInstanceDataSourceProperties");
        debug_struct.field("name", &self.name);
        debug_struct.field(
            "database_installed_version",
            &self.database_installed_version,
        );
        debug_struct.field("instance_create_time", &self.instance_create_time);
        debug_struct.field("instance_tier", &self.instance_tier);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CloudSqlInstanceBackupProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudSqlInstanceBackupProperties");
        debug_struct.field(
            "database_installed_version",
            &self.database_installed_version,
        );
        debug_struct.field("final_backup", &self.final_backup);
        debug_struct.field("source_instance", &self.source_instance);
        debug_struct.field("instance_tier", &self.instance_tier);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CloudSqlInstanceDataSourceReferenceProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudSqlInstanceDataSourceReferenceProperties");
        debug_struct.field("name", &self.name);
        debug_struct.field(
            "database_installed_version",
            &self.database_installed_version,
        );
        debug_struct.field("instance_create_time", &self.instance_create_time);
        debug_struct.field("instance_tier", &self.instance_tier);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CloudSqlInstanceInitializationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudSqlInstanceInitializationConfig");
        debug_struct.field("edition", &self.edition);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CloudSqlInstanceBackupPlanAssociationProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudSqlInstanceBackupPlanAssociationProperties");
        debug_struct.field("instance_create_time", &self.instance_create_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DiskTargetEnvironment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiskTargetEnvironment");
        debug_struct.field("project", &self.project);
        debug_struct.field("zone", &self.zone);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RegionDiskTargetEnvironment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RegionDiskTargetEnvironment");
        debug_struct.field("project", &self.project);
        debug_struct.field("region", &self.region);
        debug_struct.field("replica_zones", &self.replica_zones);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DiskRestoreProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiskRestoreProperties");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("size_gb", &self.size_gb);
        debug_struct.field("licenses", &self.licenses);
        debug_struct.field("guest_os_feature", &self.guest_os_feature);
        debug_struct.field("disk_encryption_key", &self.disk_encryption_key);
        debug_struct.field("physical_block_size_bytes", &self.physical_block_size_bytes);
        debug_struct.field("provisioned_iops", &self.provisioned_iops);
        debug_struct.field("provisioned_throughput", &self.provisioned_throughput);
        debug_struct.field(
            "enable_confidential_compute",
            &self.enable_confidential_compute,
        );
        debug_struct.field("storage_pool", &self.storage_pool);
        debug_struct.field("access_mode", &self.access_mode);
        debug_struct.field("architecture", &self.architecture);
        debug_struct.field("resource_policy", &self.resource_policy);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("resource_manager_tags", &self.resource_manager_tags);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DiskBackupProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiskBackupProperties");
        debug_struct.field("description", &self.description);
        debug_struct.field("licenses", &self.licenses);
        debug_struct.field("guest_os_feature", &self.guest_os_feature);
        debug_struct.field("architecture", &self.architecture);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("size_gb", &self.size_gb);
        debug_struct.field("region", &self.region);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("replica_zones", &self.replica_zones);
        debug_struct.field("source_disk", &self.source_disk);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DiskDataSourceProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiskDataSourceProperties");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("size_gb", &self.size_gb);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ComputeInstanceBackupProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComputeInstanceBackupProperties");
        debug_struct.field("description", &self.description);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("can_ip_forward", &self.can_ip_forward);
        debug_struct.field("network_interface", &self.network_interface);
        debug_struct.field("disk", &self.disk);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("scheduling", &self.scheduling);
        debug_struct.field("guest_accelerator", &self.guest_accelerator);
        debug_struct.field("min_cpu_platform", &self.min_cpu_platform);
        debug_struct.field(
            "key_revocation_action_type",
            &self.key_revocation_action_type,
        );
        debug_struct.field("source_instance", &self.source_instance);
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ComputeInstanceRestoreProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComputeInstanceRestoreProperties");
        debug_struct.field("name", &self.name);
        debug_struct.field("advanced_machine_features", &self.advanced_machine_features);
        debug_struct.field("can_ip_forward", &self.can_ip_forward);
        debug_struct.field(
            "confidential_instance_config",
            &self.confidential_instance_config,
        );
        debug_struct.field("deletion_protection", &self.deletion_protection);
        debug_struct.field("description", &self.description);
        debug_struct.field("disks", &self.disks);
        debug_struct.field("display_device", &self.display_device);
        debug_struct.field("guest_accelerators", &self.guest_accelerators);
        debug_struct.field("hostname", &self.hostname);
        debug_struct.field("instance_encryption_key", &self.instance_encryption_key);
        debug_struct.field(
            "key_revocation_action_type",
            &self.key_revocation_action_type,
        );
        debug_struct.field("labels", &self.labels);
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("min_cpu_platform", &self.min_cpu_platform);
        debug_struct.field("network_interfaces", &self.network_interfaces);
        debug_struct.field(
            "network_performance_config",
            &self.network_performance_config,
        );
        debug_struct.field("params", &self.params);
        debug_struct.field(
            "private_ipv6_google_access",
            &self.private_ipv6_google_access,
        );
        debug_struct.field("allocation_affinity", &self.allocation_affinity);
        debug_struct.field("resource_policies", &self.resource_policies);
        debug_struct.field("scheduling", &self.scheduling);
        debug_struct.field("service_accounts", &self.service_accounts);
        debug_struct.field("tags", &self.tags);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ComputeInstanceTargetEnvironment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComputeInstanceTargetEnvironment");
        debug_struct.field("project", &self.project);
        debug_struct.field("zone", &self.zone);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ComputeInstanceDataSourceProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComputeInstanceDataSourceProperties");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("total_disk_count", &self.total_disk_count);
        debug_struct.field("total_disk_size_gb", &self.total_disk_size_gb);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AdvancedMachineFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdvancedMachineFeatures");
        debug_struct.field(
            "enable_nested_virtualization",
            &self.enable_nested_virtualization,
        );
        debug_struct.field("threads_per_core", &self.threads_per_core);
        debug_struct.field("visible_core_count", &self.visible_core_count);
        debug_struct.field("enable_uefi_networking", &self.enable_uefi_networking);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConfidentialInstanceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfidentialInstanceConfig");
        debug_struct.field(
            "enable_confidential_compute",
            &self.enable_confidential_compute,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DisplayDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DisplayDevice");
        debug_struct.field("enable_display", &self.enable_display);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AcceleratorConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AcceleratorConfig");
        debug_struct.field("accelerator_type", &self.accelerator_type);
        debug_struct.field("accelerator_count", &self.accelerator_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CustomerEncryptionKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomerEncryptionKey");
        debug_struct.field("kms_key_service_account", &self.kms_key_service_account);
        debug_struct.field("key", &self.key);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Entry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Entry");
        debug_struct.field("key", &self.key);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Metadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Metadata");
        debug_struct.field("items", &self.items);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NetworkInterface {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkInterface");
        debug_struct.field("network", &self.network);
        debug_struct.field("subnetwork", &self.subnetwork);
        debug_struct.field("ip_address", &self.ip_address);
        debug_struct.field("ipv6_address", &self.ipv6_address);
        debug_struct.field(
            "internal_ipv6_prefix_length",
            &self.internal_ipv6_prefix_length,
        );
        debug_struct.field("name", &self.name);
        debug_struct.field("access_configs", &self.access_configs);
        debug_struct.field("ipv6_access_configs", &self.ipv6_access_configs);
        debug_struct.field("alias_ip_ranges", &self.alias_ip_ranges);
        debug_struct.field("stack_type", &self.stack_type);
        debug_struct.field("ipv6_access_type", &self.ipv6_access_type);
        debug_struct.field("queue_count", &self.queue_count);
        debug_struct.field("nic_type", &self.nic_type);
        debug_struct.field("network_attachment", &self.network_attachment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NetworkPerformanceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkPerformanceConfig");
        debug_struct.field(
            "total_egress_bandwidth_tier",
            &self.total_egress_bandwidth_tier,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AccessConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AccessConfig");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("name", &self.name);
        debug_struct.field("external_ip", &self.external_ip);
        debug_struct.field("external_ipv6", &self.external_ipv6);
        debug_struct.field(
            "external_ipv6_prefix_length",
            &self.external_ipv6_prefix_length,
        );
        debug_struct.field("set_public_ptr", &self.set_public_ptr);
        debug_struct.field("public_ptr_domain_name", &self.public_ptr_domain_name);
        debug_struct.field("network_tier", &self.network_tier);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AliasIpRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AliasIpRange");
        debug_struct.field("ip_cidr_range", &self.ip_cidr_range);
        debug_struct.field("subnetwork_range_name", &self.subnetwork_range_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstanceParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstanceParams");
        debug_struct.field("resource_manager_tags", &self.resource_manager_tags);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AllocationAffinity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AllocationAffinity");
        debug_struct.field("consume_allocation_type", &self.consume_allocation_type);
        debug_struct.field("key", &self.key);
        debug_struct.field("values", &self.values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Scheduling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Scheduling");
        debug_struct.field("on_host_maintenance", &self.on_host_maintenance);
        debug_struct.field("automatic_restart", &self.automatic_restart);
        debug_struct.field("preemptible", &self.preemptible);
        debug_struct.field("node_affinities", &self.node_affinities);
        debug_struct.field("min_node_cpus", &self.min_node_cpus);
        debug_struct.field("provisioning_model", &self.provisioning_model);
        debug_struct.field(
            "instance_termination_action",
            &self.instance_termination_action,
        );
        debug_struct.field(
            "local_ssd_recovery_timeout",
            &self.local_ssd_recovery_timeout,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::scheduling::NodeAffinity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeAffinity");
        debug_struct.field("key", &self.key);
        debug_struct.field("operator", &self.operator);
        debug_struct.field("values", &self.values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SchedulingDuration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SchedulingDuration");
        debug_struct.field("seconds", &self.seconds);
        debug_struct.field("nanos", &self.nanos);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ServiceAccount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ServiceAccount");
        debug_struct.field("email", &self.email);
        debug_struct.field("scopes", &self.scopes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Tags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Tags");
        debug_struct.field("items", &self.items);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AttachedDisk {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AttachedDisk");
        debug_struct.field("initialize_params", &self.initialize_params);
        debug_struct.field("device_name", &self.device_name);
        debug_struct.field("kind", &self.kind);
        debug_struct.field("disk_type_deprecated", &self.disk_type_deprecated);
        debug_struct.field("mode", &self.mode);
        debug_struct.field("source", &self.source);
        debug_struct.field("index", &self.index);
        debug_struct.field("boot", &self.boot);
        debug_struct.field("auto_delete", &self.auto_delete);
        debug_struct.field("license", &self.license);
        debug_struct.field("disk_interface", &self.disk_interface);
        debug_struct.field("guest_os_feature", &self.guest_os_feature);
        debug_struct.field("disk_encryption_key", &self.disk_encryption_key);
        debug_struct.field("disk_size_gb", &self.disk_size_gb);
        debug_struct.field("saved_state", &self.saved_state);
        debug_struct.field("disk_type", &self.disk_type);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::attached_disk::InitializeParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InitializeParams");
        debug_struct.field("disk_name", &self.disk_name);
        debug_struct.field("replica_zones", &self.replica_zones);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GuestOsFeature {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GuestOsFeature");
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DataSourceReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataSourceReference");
        debug_struct.field("name", &self.name);
        debug_struct.field("data_source", &self.data_source);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field(
            "data_source_backup_config_state",
            &self.data_source_backup_config_state,
        );
        debug_struct.field("data_source_backup_count", &self.data_source_backup_count);
        debug_struct.field(
            "data_source_backup_config_info",
            &self.data_source_backup_config_info,
        );
        debug_struct.field(
            "data_source_gcp_resource_info",
            &self.data_source_gcp_resource_info,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DataSourceBackupConfigInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataSourceBackupConfigInfo");
        debug_struct.field("last_backup_state", &self.last_backup_state);
        debug_struct.field(
            "last_successful_backup_consistency_time",
            &self.last_successful_backup_consistency_time,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DataSourceGcpResourceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataSourceGcpResourceInfo");
        debug_struct.field("gcp_resourcename", &self.gcp_resourcename);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("location", &self.location);
        debug_struct.field("resource_properties", &self.resource_properties);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetDataSourceReferenceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDataSourceReferenceRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchDataSourceReferencesForResourceTypeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchDataSourceReferencesForResourceTypeRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("resource_type", &self.resource_type);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchDataSourceReferencesForResourceTypeResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchDataSourceReferencesForResourceTypeResponse");
        debug_struct.field("data_source_references", &self.data_source_references);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
