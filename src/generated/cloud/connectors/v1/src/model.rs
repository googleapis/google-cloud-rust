// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// AuthConfig defines details of a authentication type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AuthConfig {
    /// The type of authentication configured.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub auth_type: crate::model::AuthType,

    /// List containing additional auth configs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub additional_variables: std::vec::Vec<crate::model::ConfigVariable>,

    /// Supported auth types.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::auth_config::Type>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuthConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auth_type][crate::model::AuthConfig::auth_type].
    pub fn set_auth_type<T: std::convert::Into<crate::model::AuthType>>(mut self, v: T) -> Self {
        self.auth_type = v.into();
        self
    }

    /// Sets the value of [additional_variables][crate::model::AuthConfig::additional_variables].
    pub fn set_additional_variables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConfigVariable>,
    {
        use std::iter::Iterator;
        self.additional_variables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [r#type][crate::model::AuthConfig::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<T: std::convert::Into<std::option::Option<crate::model::auth_config::Type>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::AuthConfig::r#type]
    /// if it holds a `UserPassword`, `None` if the field is not set or
    /// holds a different branch.
    pub fn user_password(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::auth_config::UserPassword>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::auth_config::Type::UserPassword(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::AuthConfig::r#type]
    /// to hold a `UserPassword`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_user_password<
        T: std::convert::Into<std::boxed::Box<crate::model::auth_config::UserPassword>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::auth_config::Type::UserPassword(v.into()));
        self
    }

    /// The value of [r#type][crate::model::AuthConfig::r#type]
    /// if it holds a `Oauth2JwtBearer`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oauth2_jwt_bearer(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::auth_config::Oauth2JwtBearer>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::auth_config::Type::Oauth2JwtBearer(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::AuthConfig::r#type]
    /// to hold a `Oauth2JwtBearer`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_oauth2_jwt_bearer<
        T: std::convert::Into<std::boxed::Box<crate::model::auth_config::Oauth2JwtBearer>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::auth_config::Type::Oauth2JwtBearer(v.into()));
        self
    }

    /// The value of [r#type][crate::model::AuthConfig::r#type]
    /// if it holds a `Oauth2ClientCredentials`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oauth2_client_credentials(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::auth_config::Oauth2ClientCredentials>>
    {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::auth_config::Type::Oauth2ClientCredentials(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::AuthConfig::r#type]
    /// to hold a `Oauth2ClientCredentials`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_oauth2_client_credentials<
        T: std::convert::Into<std::boxed::Box<crate::model::auth_config::Oauth2ClientCredentials>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::auth_config::Type::Oauth2ClientCredentials(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::AuthConfig::r#type]
    /// if it holds a `SshPublicKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ssh_public_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::auth_config::SshPublicKey>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::auth_config::Type::SshPublicKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::AuthConfig::r#type]
    /// to hold a `SshPublicKey`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_ssh_public_key<
        T: std::convert::Into<std::boxed::Box<crate::model::auth_config::SshPublicKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::auth_config::Type::SshPublicKey(v.into()));
        self
    }
}

impl wkt::message::Message for AuthConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.AuthConfig"
    }
}

/// Defines additional types related to [AuthConfig].
pub mod auth_config {
    #[allow(unused_imports)]
    use super::*;

    /// Parameters to support Username and Password Authentication.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UserPassword {
        /// Username.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub username: std::string::String,

        /// Secret version reference containing the password.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub password: std::option::Option<crate::model::Secret>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UserPassword {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [username][crate::model::auth_config::UserPassword::username].
        pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.username = v.into();
            self
        }

        /// Sets the value of [password][crate::model::auth_config::UserPassword::password].
        pub fn set_password<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.password = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [password][crate::model::auth_config::UserPassword::password].
        pub fn set_or_clear_password<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.password = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for UserPassword {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.connectors.v1.AuthConfig.UserPassword"
        }
    }

    /// Parameters to support JSON Web Token (JWT) Profile for Oauth 2.0
    /// Authorization Grant based authentication.
    /// See <https://tools.ietf.org/html/rfc7523> for more details.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Oauth2JwtBearer {
        /// Secret version reference containing a PKCS#8 PEM-encoded private
        /// key associated with the Client Certificate. This private key will be
        /// used to sign JWTs used for the jwt-bearer authorization grant.
        /// Specified in the form as: `projects/*/secrets/*/versions/*`.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub client_key: std::option::Option<crate::model::Secret>,

        /// JwtClaims providers fields to generate the token.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub jwt_claims:
            std::option::Option<crate::model::auth_config::oauth_2_jwt_bearer::JwtClaims>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Oauth2JwtBearer {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [client_key][crate::model::auth_config::Oauth2JwtBearer::client_key].
        pub fn set_client_key<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.client_key = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [client_key][crate::model::auth_config::Oauth2JwtBearer::client_key].
        pub fn set_or_clear_client_key<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.client_key = v.map(|x| x.into());
            self
        }

        /// Sets the value of [jwt_claims][crate::model::auth_config::Oauth2JwtBearer::jwt_claims].
        pub fn set_jwt_claims<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::auth_config::oauth_2_jwt_bearer::JwtClaims>,
        {
            self.jwt_claims = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [jwt_claims][crate::model::auth_config::Oauth2JwtBearer::jwt_claims].
        pub fn set_or_clear_jwt_claims<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::auth_config::oauth_2_jwt_bearer::JwtClaims>,
        {
            self.jwt_claims = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Oauth2JwtBearer {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.connectors.v1.AuthConfig.Oauth2JwtBearer"
        }
    }

    /// Defines additional types related to [Oauth2JwtBearer].
    pub mod oauth_2_jwt_bearer {
        #[allow(unused_imports)]
        use super::*;

        /// JWT claims used for the jwt-bearer authorization grant.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct JwtClaims {
            /// Value for the "iss" claim.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            #[serde_as(as = "serde_with::DefaultOnNull<_>")]
            pub issuer: std::string::String,

            /// Value for the "sub" claim.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            #[serde_as(as = "serde_with::DefaultOnNull<_>")]
            pub subject: std::string::String,

            /// Value for the "aud" claim.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            #[serde_as(as = "serde_with::DefaultOnNull<_>")]
            pub audience: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl JwtClaims {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [issuer][crate::model::auth_config::oauth_2_jwt_bearer::JwtClaims::issuer].
            pub fn set_issuer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.issuer = v.into();
                self
            }

            /// Sets the value of [subject][crate::model::auth_config::oauth_2_jwt_bearer::JwtClaims::subject].
            pub fn set_subject<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.subject = v.into();
                self
            }

            /// Sets the value of [audience][crate::model::auth_config::oauth_2_jwt_bearer::JwtClaims::audience].
            pub fn set_audience<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.audience = v.into();
                self
            }
        }

        impl wkt::message::Message for JwtClaims {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.connectors.v1.AuthConfig.Oauth2JwtBearer.JwtClaims"
            }
        }
    }

    /// Parameters to support Oauth 2.0 Client Credentials Grant Authentication.
    /// See <https://tools.ietf.org/html/rfc6749#section-1.3.4> for more details.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Oauth2ClientCredentials {
        /// The client identifier.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub client_id: std::string::String,

        /// Secret version reference containing the client secret.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub client_secret: std::option::Option<crate::model::Secret>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Oauth2ClientCredentials {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [client_id][crate::model::auth_config::Oauth2ClientCredentials::client_id].
        pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client_id = v.into();
            self
        }

        /// Sets the value of [client_secret][crate::model::auth_config::Oauth2ClientCredentials::client_secret].
        pub fn set_client_secret<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.client_secret = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [client_secret][crate::model::auth_config::Oauth2ClientCredentials::client_secret].
        pub fn set_or_clear_client_secret<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.client_secret = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Oauth2ClientCredentials {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.connectors.v1.AuthConfig.Oauth2ClientCredentials"
        }
    }

    /// Parameters to support Ssh public key Authentication.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SshPublicKey {
        /// The user account used to authenticate.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub username: std::string::String,

        /// SSH Client Cert. It should contain both public and private key.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub ssh_client_cert: std::option::Option<crate::model::Secret>,

        /// Format of SSH Client cert.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub cert_type: std::string::String,

        /// Password (passphrase) for ssh client certificate if it has one.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub ssh_client_cert_pass: std::option::Option<crate::model::Secret>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SshPublicKey {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [username][crate::model::auth_config::SshPublicKey::username].
        pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.username = v.into();
            self
        }

        /// Sets the value of [ssh_client_cert][crate::model::auth_config::SshPublicKey::ssh_client_cert].
        pub fn set_ssh_client_cert<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.ssh_client_cert = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [ssh_client_cert][crate::model::auth_config::SshPublicKey::ssh_client_cert].
        pub fn set_or_clear_ssh_client_cert<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.ssh_client_cert = v.map(|x| x.into());
            self
        }

        /// Sets the value of [cert_type][crate::model::auth_config::SshPublicKey::cert_type].
        pub fn set_cert_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cert_type = v.into();
            self
        }

        /// Sets the value of [ssh_client_cert_pass][crate::model::auth_config::SshPublicKey::ssh_client_cert_pass].
        pub fn set_ssh_client_cert_pass<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.ssh_client_cert_pass = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [ssh_client_cert_pass][crate::model::auth_config::SshPublicKey::ssh_client_cert_pass].
        pub fn set_or_clear_ssh_client_cert_pass<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.ssh_client_cert_pass = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SshPublicKey {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.connectors.v1.AuthConfig.SshPublicKey"
        }
    }

    /// Supported auth types.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// UserPassword.
        UserPassword(std::boxed::Box<crate::model::auth_config::UserPassword>),
        /// Oauth2JwtBearer.
        Oauth2JwtBearer(std::boxed::Box<crate::model::auth_config::Oauth2JwtBearer>),
        /// Oauth2ClientCredentials.
        Oauth2ClientCredentials(
            std::boxed::Box<crate::model::auth_config::Oauth2ClientCredentials>,
        ),
        /// SSH Public Key.
        SshPublicKey(std::boxed::Box<crate::model::auth_config::SshPublicKey>),
    }
}

/// AuthConfigTemplate defines required field over an authentication type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AuthConfigTemplate {
    /// The type of authentication configured.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub auth_type: crate::model::AuthType,

    /// Config variables to describe an `AuthConfig` for a `Connection`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub config_variable_templates: std::vec::Vec<crate::model::ConfigVariableTemplate>,

    /// Display name for authentication template.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    /// Connector specific description for an authentication template.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub description: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuthConfigTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auth_type][crate::model::AuthConfigTemplate::auth_type].
    pub fn set_auth_type<T: std::convert::Into<crate::model::AuthType>>(mut self, v: T) -> Self {
        self.auth_type = v.into();
        self
    }

    /// Sets the value of [config_variable_templates][crate::model::AuthConfigTemplate::config_variable_templates].
    pub fn set_config_variable_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConfigVariableTemplate>,
    {
        use std::iter::Iterator;
        self.config_variable_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::AuthConfigTemplate::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::AuthConfigTemplate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for AuthConfigTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.AuthConfigTemplate"
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub api_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.OperationMetadata"
    }
}

/// ConfigVariableTemplate provides metadata about a `ConfigVariable` that is
/// used in a Connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConfigVariableTemplate {
    /// Key of the config variable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub key: std::string::String,

    /// Type of the parameter: string, int, bool etc.
    /// consider custom type for the benefit for the validation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub value_type: crate::model::config_variable_template::ValueType,

    /// Display name of the parameter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    /// Description.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub description: std::string::String,

    /// Regular expression in RE2 syntax used for validating the `value` of a
    /// `ConfigVariable`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validation_regex: std::string::String,

    /// Flag represents that this `ConfigVariable` must be provided for a
    /// connection.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub required: bool,

    /// Role grant configuration for the config variable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub role_grant: std::option::Option<crate::model::RoleGrant>,

    /// Enum options. To be populated if `ValueType` is `ENUM`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub enum_options: std::vec::Vec<crate::model::EnumOption>,

    /// Authorization code link options. To be populated if `ValueType` is
    /// `AUTHORIZATION_CODE`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authorization_code_link: std::option::Option<crate::model::AuthorizationCodeLink>,

    /// State of the config variable.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::config_variable_template::State,

    /// Indicates if current template is part of advanced settings
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub is_advanced: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigVariableTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::ConfigVariableTemplate::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [value_type][crate::model::ConfigVariableTemplate::value_type].
    pub fn set_value_type<
        T: std::convert::Into<crate::model::config_variable_template::ValueType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value_type = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ConfigVariableTemplate::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ConfigVariableTemplate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [validation_regex][crate::model::ConfigVariableTemplate::validation_regex].
    pub fn set_validation_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.validation_regex = v.into();
        self
    }

    /// Sets the value of [required][crate::model::ConfigVariableTemplate::required].
    pub fn set_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.required = v.into();
        self
    }

    /// Sets the value of [role_grant][crate::model::ConfigVariableTemplate::role_grant].
    pub fn set_role_grant<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RoleGrant>,
    {
        self.role_grant = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [role_grant][crate::model::ConfigVariableTemplate::role_grant].
    pub fn set_or_clear_role_grant<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RoleGrant>,
    {
        self.role_grant = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enum_options][crate::model::ConfigVariableTemplate::enum_options].
    pub fn set_enum_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnumOption>,
    {
        use std::iter::Iterator;
        self.enum_options = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [authorization_code_link][crate::model::ConfigVariableTemplate::authorization_code_link].
    pub fn set_authorization_code_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AuthorizationCodeLink>,
    {
        self.authorization_code_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorization_code_link][crate::model::ConfigVariableTemplate::authorization_code_link].
    pub fn set_or_clear_authorization_code_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AuthorizationCodeLink>,
    {
        self.authorization_code_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::ConfigVariableTemplate::state].
    pub fn set_state<T: std::convert::Into<crate::model::config_variable_template::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [is_advanced][crate::model::ConfigVariableTemplate::is_advanced].
    pub fn set_is_advanced<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_advanced = v.into();
        self
    }
}

impl wkt::message::Message for ConfigVariableTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ConfigVariableTemplate"
    }
}

/// Defines additional types related to [ConfigVariableTemplate].
pub mod config_variable_template {
    #[allow(unused_imports)]
    use super::*;

    /// ValueType indicates the data type of the value.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ValueType {
        /// Value type is not specified.
        Unspecified,
        /// Value type is string.
        String,
        /// Value type is integer.
        Int,
        /// Value type is boolean.
        Bool,
        /// Value type is secret.
        Secret,
        /// Value type is enum.
        Enum,
        /// Value type is authorization code.
        AuthorizationCode,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ValueType::value] or
        /// [ValueType::name].
        UnknownValue(value_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod value_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ValueType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::String => std::option::Option::Some(1),
                Self::Int => std::option::Option::Some(2),
                Self::Bool => std::option::Option::Some(3),
                Self::Secret => std::option::Option::Some(4),
                Self::Enum => std::option::Option::Some(5),
                Self::AuthorizationCode => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VALUE_TYPE_UNSPECIFIED"),
                Self::String => std::option::Option::Some("STRING"),
                Self::Int => std::option::Option::Some("INT"),
                Self::Bool => std::option::Option::Some("BOOL"),
                Self::Secret => std::option::Option::Some("SECRET"),
                Self::Enum => std::option::Option::Some("ENUM"),
                Self::AuthorizationCode => std::option::Option::Some("AUTHORIZATION_CODE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ValueType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ValueType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ValueType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::String,
                2 => Self::Int,
                3 => Self::Bool,
                4 => Self::Secret,
                5 => Self::Enum,
                6 => Self::AuthorizationCode,
                _ => Self::UnknownValue(value_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ValueType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VALUE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "STRING" => Self::String,
                "INT" => Self::Int,
                "BOOL" => Self::Bool,
                "SECRET" => Self::Secret,
                "ENUM" => Self::Enum,
                "AUTHORIZATION_CODE" => Self::AuthorizationCode,
                _ => Self::UnknownValue(value_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ValueType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::String => serializer.serialize_i32(1),
                Self::Int => serializer.serialize_i32(2),
                Self::Bool => serializer.serialize_i32(3),
                Self::Secret => serializer.serialize_i32(4),
                Self::Enum => serializer.serialize_i32(5),
                Self::AuthorizationCode => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ValueType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ValueType>::new(
                ".google.cloud.connectors.v1.ConfigVariableTemplate.ValueType",
            ))
        }
    }

    /// Indicates the state of the config variable.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Status is unspecified.
        Unspecified,
        /// Config variable is active
        Active,
        /// Config variable is deprecated.
        Deprecated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Deprecated => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deprecated => std::option::Option::Some("DEPRECATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Deprecated,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "DEPRECATED" => Self::Deprecated,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Deprecated => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.connectors.v1.ConfigVariableTemplate.State",
            ))
        }
    }
}

/// Secret provides a reference to entries in Secret Manager.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Secret {
    /// The resource name of the secret version in the format,
    /// format as: `projects/*/secrets/*/versions/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub secret_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Secret {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secret_version][crate::model::Secret::secret_version].
    pub fn set_secret_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret_version = v.into();
        self
    }
}

impl wkt::message::Message for Secret {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.Secret"
    }
}

/// EnumOption definition
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnumOption {
    /// Id of the option.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub id: std::string::String,

    /// Display name of the option.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnumOption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::EnumOption::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::EnumOption::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for EnumOption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.EnumOption"
    }
}

/// ConfigVariable represents a configuration variable present in a Connection.
/// or AuthConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConfigVariable {
    /// Key of the config variable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub key: std::string::String,

    /// Value type of the config variable.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::config_variable::Value>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigVariable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::ConfigVariable::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::config_variable::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::ConfigVariable::value]
    /// if it holds a `IntValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn int_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::config_variable::Value::IntValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value]
    /// to hold a `IntValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::config_variable::Value::IntValue(v.into()));
        self
    }

    /// The value of [value][crate::model::ConfigVariable::value]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::config_variable::Value::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::config_variable::Value::BoolValue(v.into()));
        self
    }

    /// The value of [value][crate::model::ConfigVariable::value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::config_variable::Value::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::config_variable::Value::StringValue(v.into()));
        self
    }

    /// The value of [value][crate::model::ConfigVariable::value]
    /// if it holds a `SecretValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn secret_value(&self) -> std::option::Option<&std::boxed::Box<crate::model::Secret>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::config_variable::Value::SecretValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value]
    /// to hold a `SecretValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_secret_value<T: std::convert::Into<std::boxed::Box<crate::model::Secret>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value =
            std::option::Option::Some(crate::model::config_variable::Value::SecretValue(v.into()));
        self
    }
}

impl wkt::message::Message for ConfigVariable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ConfigVariable"
    }
}

/// Defines additional types related to [ConfigVariable].
pub mod config_variable {
    #[allow(unused_imports)]
    use super::*;

    /// Value type of the config variable.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Value {
        /// Value is an integer
        IntValue(#[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")] i64),
        /// Value is a bool.
        BoolValue(#[serde_as(as = "serde_with::DefaultOnNull<_>")] bool),
        /// Value is a string.
        StringValue(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
        /// Value is a secret.
        SecretValue(std::boxed::Box<crate::model::Secret>),
    }
}

/// This configuration defines all the Cloud IAM roles that needs to be granted
/// to a particular GCP resource for the selected prinicpal like service
/// account. These configurations will let UI display to customers what
/// IAM roles need to be granted by them. Or these configurations can be used
/// by the UI to render a 'grant' button to do the same on behalf of the user.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RoleGrant {
    /// Prinicipal/Identity for whom the role need to assigned.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub principal: crate::model::role_grant::Principal,

    /// List of roles that need to be granted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub roles: std::vec::Vec<std::string::String>,

    /// Resource on which the roles needs to be granted for the principal.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource: std::option::Option<crate::model::role_grant::Resource>,

    /// Template that UI can use to provide helper text to customers.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub helper_text_template: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RoleGrant {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [principal][crate::model::RoleGrant::principal].
    pub fn set_principal<T: std::convert::Into<crate::model::role_grant::Principal>>(
        mut self,
        v: T,
    ) -> Self {
        self.principal = v.into();
        self
    }

    /// Sets the value of [roles][crate::model::RoleGrant::roles].
    pub fn set_roles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.roles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource][crate::model::RoleGrant::resource].
    pub fn set_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::role_grant::Resource>,
    {
        self.resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource][crate::model::RoleGrant::resource].
    pub fn set_or_clear_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::role_grant::Resource>,
    {
        self.resource = v.map(|x| x.into());
        self
    }

    /// Sets the value of [helper_text_template][crate::model::RoleGrant::helper_text_template].
    pub fn set_helper_text_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.helper_text_template = v.into();
        self
    }
}

impl wkt::message::Message for RoleGrant {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.RoleGrant"
    }
}

/// Defines additional types related to [RoleGrant].
pub mod role_grant {
    #[allow(unused_imports)]
    use super::*;

    /// Resource definition
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Resource {
        /// Different types of resource supported.
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub r#type: crate::model::role_grant::resource::Type,

        /// Template to uniquely represent a GCP resource in a format IAM expects
        /// This is a template that can have references to other values provided in
        /// the config variable template.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub path_template: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Resource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::role_grant::Resource::type].
        pub fn set_type<T: std::convert::Into<crate::model::role_grant::resource::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [path_template][crate::model::role_grant::Resource::path_template].
        pub fn set_path_template<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.path_template = v.into();
            self
        }
    }

    impl wkt::message::Message for Resource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.connectors.v1.RoleGrant.Resource"
        }
    }

    /// Defines additional types related to [Resource].
    pub mod resource {
        #[allow(unused_imports)]
        use super::*;

        /// Resource Type definition.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// Value type is not specified.
            Unspecified,
            /// GCP Project Resource.
            GcpProject,
            /// Any GCP Resource which is identified uniquely by IAM.
            GcpResource,
            /// GCP Secret Resource.
            GcpSecretmanagerSecret,
            /// GCP Secret Version Resource.
            GcpSecretmanagerSecretVersion,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Type::value] or
            /// [Type::name].
            UnknownValue(r#type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod r#type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Type {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::GcpProject => std::option::Option::Some(1),
                    Self::GcpResource => std::option::Option::Some(2),
                    Self::GcpSecretmanagerSecret => std::option::Option::Some(3),
                    Self::GcpSecretmanagerSecretVersion => std::option::Option::Some(4),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                    Self::GcpProject => std::option::Option::Some("GCP_PROJECT"),
                    Self::GcpResource => std::option::Option::Some("GCP_RESOURCE"),
                    Self::GcpSecretmanagerSecret => {
                        std::option::Option::Some("GCP_SECRETMANAGER_SECRET")
                    }
                    Self::GcpSecretmanagerSecretVersion => {
                        std::option::Option::Some("GCP_SECRETMANAGER_SECRET_VERSION")
                    }
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Type {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::GcpProject,
                    2 => Self::GcpResource,
                    3 => Self::GcpSecretmanagerSecret,
                    4 => Self::GcpSecretmanagerSecretVersion,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Type {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TYPE_UNSPECIFIED" => Self::Unspecified,
                    "GCP_PROJECT" => Self::GcpProject,
                    "GCP_RESOURCE" => Self::GcpResource,
                    "GCP_SECRETMANAGER_SECRET" => Self::GcpSecretmanagerSecret,
                    "GCP_SECRETMANAGER_SECRET_VERSION" => Self::GcpSecretmanagerSecretVersion,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::GcpProject => serializer.serialize_i32(1),
                    Self::GcpResource => serializer.serialize_i32(2),
                    Self::GcpSecretmanagerSecret => serializer.serialize_i32(3),
                    Self::GcpSecretmanagerSecretVersion => serializer.serialize_i32(4),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                    ".google.cloud.connectors.v1.RoleGrant.Resource.Type",
                ))
            }
        }
    }

    /// Supported Principal values.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Principal {
        /// Value type is not specified.
        Unspecified,
        /// Service Account used for Connector workload identity
        /// This is either the default service account if unspecified or Service
        /// Account provided by Customers through BYOSA.
        ConnectorSa,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Principal::value] or
        /// [Principal::name].
        UnknownValue(principal::UnknownValue),
    }

    #[doc(hidden)]
    pub mod principal {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Principal {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ConnectorSa => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PRINCIPAL_UNSPECIFIED"),
                Self::ConnectorSa => std::option::Option::Some("CONNECTOR_SA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Principal {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Principal {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Principal {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ConnectorSa,
                _ => Self::UnknownValue(principal::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Principal {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRINCIPAL_UNSPECIFIED" => Self::Unspecified,
                "CONNECTOR_SA" => Self::ConnectorSa,
                _ => Self::UnknownValue(principal::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Principal {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ConnectorSa => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Principal {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Principal>::new(
                ".google.cloud.connectors.v1.RoleGrant.Principal",
            ))
        }
    }
}

/// This configuration captures the details required to render an authorization
/// link for the OAuth Authorization Code Flow.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AuthorizationCodeLink {
    /// The base URI the user must click to trigger the authorization code login
    /// flow.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uri: std::string::String,

    /// The scopes for which the user will authorize GCP Connectors on the
    /// connector data source.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub scopes: std::vec::Vec<std::string::String>,

    /// The client ID assigned to the GCP Connectors OAuth app for the connector
    /// data source.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub client_id: std::string::String,

    /// Whether to enable PKCE for the auth code flow.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub enable_pkce: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuthorizationCodeLink {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::AuthorizationCodeLink::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [scopes][crate::model::AuthorizationCodeLink::scopes].
    pub fn set_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [client_id][crate::model::AuthorizationCodeLink::client_id].
    pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_id = v.into();
        self
    }

    /// Sets the value of [enable_pkce][crate::model::AuthorizationCodeLink::enable_pkce].
    pub fn set_enable_pkce<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_pkce = v.into();
        self
    }
}

impl wkt::message::Message for AuthorizationCodeLink {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.AuthorizationCodeLink"
    }
}

/// Connection represents an instance of connector.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Connection {
    /// Output only. Resource name of the Connection.
    /// Format: projects/{project}/locations/{location}/connections/{connection}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. Created time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Updated time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Resource labels to represent user-provided metadata.
    /// Refer to cloud documentation on labels for more details.
    /// <https://cloud.google.com/compute/docs/labeling-resources>
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Description of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub description: std::string::String,

    /// Required. Connector version on which the connection is created.
    /// The format is:
    /// projects/*/locations/*/providers/*/connectors/*/versions/*
    /// Only global location is supported for ConnectorVersion resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub connector_version: std::string::String,

    /// Output only. Current status of the connection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<crate::model::ConnectionStatus>,

    /// Optional. Configuration for configuring the connection with an external
    /// system.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub config_variables: std::vec::Vec<crate::model::ConfigVariable>,

    /// Optional. Configuration for establishing the connection's authentication
    /// with an external system.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub auth_config: std::option::Option<crate::model::AuthConfig>,

    /// Optional. Configuration that indicates whether or not the Connection can be
    /// edited.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub lock_config: std::option::Option<crate::model::LockConfig>,

    /// Optional. Configuration of the Connector's destination. Only accepted for
    /// Connectors that accepts user defined destination(s).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub destination_configs: std::vec::Vec<crate::model::DestinationConfig>,

    /// Output only. GCR location where the runtime image is stored.
    /// formatted like: gcr.io/{bucketName}/{imageName}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub image_location: std::string::String,

    /// Optional. Service account needed for runtime plane to access GCP resources.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub service_account: std::string::String,

    /// Output only. The name of the Service Directory service name. Used for
    /// Private Harpoon to resolve the ILB address.
    /// e.g.
    /// "projects/cloud-connectors-e2e-testing/locations/us-central1/namespaces/istio-system/services/istio-ingressgateway-connectors"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub service_directory: std::string::String,

    /// Output only. GCR location where the envoy image is stored.
    /// formatted like: gcr.io/{bucketName}/{imageName}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub envoy_image_location: std::string::String,

    /// Optional. Suspended indicates if a user has suspended a connection or not.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub suspended: bool,

    /// Optional. Node configuration for the connection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_config: std::option::Option<crate::model::NodeConfig>,

    /// Optional. Ssl config of a connection
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ssl_config: std::option::Option<crate::model::SslConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Connection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Connection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Connection::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Connection::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Connection::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Connection::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Connection::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Connection::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [connector_version][crate::model::Connection::connector_version].
    pub fn set_connector_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.connector_version = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Connection::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConnectionStatus>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::Connection::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConnectionStatus>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config_variables][crate::model::Connection::config_variables].
    pub fn set_config_variables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConfigVariable>,
    {
        use std::iter::Iterator;
        self.config_variables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [auth_config][crate::model::Connection::auth_config].
    pub fn set_auth_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AuthConfig>,
    {
        self.auth_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [auth_config][crate::model::Connection::auth_config].
    pub fn set_or_clear_auth_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AuthConfig>,
    {
        self.auth_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lock_config][crate::model::Connection::lock_config].
    pub fn set_lock_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LockConfig>,
    {
        self.lock_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lock_config][crate::model::Connection::lock_config].
    pub fn set_or_clear_lock_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LockConfig>,
    {
        self.lock_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination_configs][crate::model::Connection::destination_configs].
    pub fn set_destination_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DestinationConfig>,
    {
        use std::iter::Iterator;
        self.destination_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [image_location][crate::model::Connection::image_location].
    pub fn set_image_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_location = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::Connection::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [service_directory][crate::model::Connection::service_directory].
    pub fn set_service_directory<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_directory = v.into();
        self
    }

    /// Sets the value of [envoy_image_location][crate::model::Connection::envoy_image_location].
    pub fn set_envoy_image_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.envoy_image_location = v.into();
        self
    }

    /// Sets the value of [suspended][crate::model::Connection::suspended].
    pub fn set_suspended<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.suspended = v.into();
        self
    }

    /// Sets the value of [node_config][crate::model::Connection::node_config].
    pub fn set_node_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeConfig>,
    {
        self.node_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_config][crate::model::Connection::node_config].
    pub fn set_or_clear_node_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeConfig>,
    {
        self.node_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ssl_config][crate::model::Connection::ssl_config].
    pub fn set_ssl_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslConfig>,
    {
        self.ssl_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssl_config][crate::model::Connection::ssl_config].
    pub fn set_or_clear_ssl_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslConfig>,
    {
        self.ssl_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Connection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.Connection"
    }
}

/// Node configuration for the connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeConfig {
    /// Minimum number of nodes in the runtime nodes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub min_node_count: i32,

    /// Maximum number of nodes in the runtime nodes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub max_node_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_node_count][crate::model::NodeConfig::min_node_count].
    pub fn set_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_node_count = v.into();
        self
    }

    /// Sets the value of [max_node_count][crate::model::NodeConfig::max_node_count].
    pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_node_count = v.into();
        self
    }
}

impl wkt::message::Message for NodeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.NodeConfig"
    }
}

/// ConnectionSchemaMetadata is the singleton resource of each connection.
/// It includes the entity and action names of runtime resources exposed
/// by a connection backend.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConnectionSchemaMetadata {
    /// Output only. List of entity names.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub entities: std::vec::Vec<std::string::String>,

    /// Output only. List of actions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub actions: std::vec::Vec<std::string::String>,

    /// Output only. Resource name.
    /// Format:
    /// projects/{project}/locations/{location}/connections/{connection}/connectionSchemaMetadata
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. Timestamp when the connection runtime schema was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when the connection runtime schema refresh was
    /// triggered.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub refresh_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of runtime schema.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::connection_schema_metadata::State,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectionSchemaMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entities][crate::model::ConnectionSchemaMetadata::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [actions][crate::model::ConnectionSchemaMetadata::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [name][crate::model::ConnectionSchemaMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ConnectionSchemaMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ConnectionSchemaMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [refresh_time][crate::model::ConnectionSchemaMetadata::refresh_time].
    pub fn set_refresh_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.refresh_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [refresh_time][crate::model::ConnectionSchemaMetadata::refresh_time].
    pub fn set_or_clear_refresh_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.refresh_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::ConnectionSchemaMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::connection_schema_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for ConnectionSchemaMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ConnectionSchemaMetadata"
    }
}

/// Defines additional types related to [ConnectionSchemaMetadata].
pub mod connection_schema_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// State of connection runtime schema.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default state.
        Unspecified,
        /// Schema refresh is in progress.
        Refreshing,
        /// Schema has been updated.
        Updated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Refreshing => std::option::Option::Some(1),
                Self::Updated => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Refreshing => std::option::Option::Some("REFRESHING"),
                Self::Updated => std::option::Option::Some("UPDATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Refreshing,
                2 => Self::Updated,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "REFRESHING" => Self::Refreshing,
                "UPDATED" => Self::Updated,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Refreshing => serializer.serialize_i32(1),
                Self::Updated => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.connectors.v1.ConnectionSchemaMetadata.State",
            ))
        }
    }
}

/// Schema of a runtime entity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RuntimeEntitySchema {
    /// Output only. Name of the entity.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub entity: std::string::String,

    /// Output only. List of fields in the entity.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub fields: std::vec::Vec<crate::model::runtime_entity_schema::Field>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuntimeEntitySchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity][crate::model::RuntimeEntitySchema::entity].
    pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::RuntimeEntitySchema::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::runtime_entity_schema::Field>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RuntimeEntitySchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.RuntimeEntitySchema"
    }
}

/// Defines additional types related to [RuntimeEntitySchema].
pub mod runtime_entity_schema {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata of an entity field.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Field {
        /// Name of the Field.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub field: std::string::String,

        /// A brief description of the Field.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub description: std::string::String,

        /// The data type of the Field.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub data_type: crate::model::DataType,

        /// The following boolean field specifies if the current Field acts
        /// as a primary key or id if the parent is of type entity.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub key: bool,

        /// Specifies if the Field is readonly.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub readonly: bool,

        /// Specifies whether a null value is allowed.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub nullable: bool,

        /// The following field specifies the default value of the Field provided
        /// by the external system if a value is not provided.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub default_value: std::option::Option<wkt::Value>,

        /// The following map contains fields that are not explicitly mentioned
        /// above,this give connectors the flexibility to add new metadata
        /// fields.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub additional_details: std::option::Option<wkt::Struct>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Field {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::runtime_entity_schema::Field::field].
        pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.field = v.into();
            self
        }

        /// Sets the value of [description][crate::model::runtime_entity_schema::Field::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [data_type][crate::model::runtime_entity_schema::Field::data_type].
        pub fn set_data_type<T: std::convert::Into<crate::model::DataType>>(
            mut self,
            v: T,
        ) -> Self {
            self.data_type = v.into();
            self
        }

        /// Sets the value of [key][crate::model::runtime_entity_schema::Field::key].
        pub fn set_key<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [readonly][crate::model::runtime_entity_schema::Field::readonly].
        pub fn set_readonly<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.readonly = v.into();
            self
        }

        /// Sets the value of [nullable][crate::model::runtime_entity_schema::Field::nullable].
        pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.nullable = v.into();
            self
        }

        /// Sets the value of [default_value][crate::model::runtime_entity_schema::Field::default_value].
        pub fn set_default_value<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Value>,
        {
            self.default_value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [default_value][crate::model::runtime_entity_schema::Field::default_value].
        pub fn set_or_clear_default_value<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Value>,
        {
            self.default_value = v.map(|x| x.into());
            self
        }

        /// Sets the value of [additional_details][crate::model::runtime_entity_schema::Field::additional_details].
        pub fn set_additional_details<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.additional_details = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [additional_details][crate::model::runtime_entity_schema::Field::additional_details].
        pub fn set_or_clear_additional_details<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.additional_details = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Field {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.connectors.v1.RuntimeEntitySchema.Field"
        }
    }
}

/// Schema of a runtime action.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RuntimeActionSchema {
    /// Output only. Name of the action.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub action: std::string::String,

    /// Output only. List of input parameter metadata for the action.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub input_parameters: std::vec::Vec<crate::model::runtime_action_schema::InputParameter>,

    /// Output only. List of result field metadata.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub result_metadata: std::vec::Vec<crate::model::runtime_action_schema::ResultMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuntimeActionSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [action][crate::model::RuntimeActionSchema::action].
    pub fn set_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [input_parameters][crate::model::RuntimeActionSchema::input_parameters].
    pub fn set_input_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::runtime_action_schema::InputParameter>,
    {
        use std::iter::Iterator;
        self.input_parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [result_metadata][crate::model::RuntimeActionSchema::result_metadata].
    pub fn set_result_metadata<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::runtime_action_schema::ResultMetadata>,
    {
        use std::iter::Iterator;
        self.result_metadata = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RuntimeActionSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.RuntimeActionSchema"
    }
}

/// Defines additional types related to [RuntimeActionSchema].
pub mod runtime_action_schema {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata of an input parameter.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InputParameter {
        /// Name of the Parameter.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub parameter: std::string::String,

        /// A brief description of the Parameter.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub description: std::string::String,

        /// The data type of the Parameter.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub data_type: crate::model::DataType,

        /// Specifies whether a null value is allowed.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub nullable: bool,

        /// The following field specifies the default value of the Parameter
        /// provided by the external system if a value is not provided.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub default_value: std::option::Option<wkt::Value>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InputParameter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [parameter][crate::model::runtime_action_schema::InputParameter::parameter].
        pub fn set_parameter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.parameter = v.into();
            self
        }

        /// Sets the value of [description][crate::model::runtime_action_schema::InputParameter::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [data_type][crate::model::runtime_action_schema::InputParameter::data_type].
        pub fn set_data_type<T: std::convert::Into<crate::model::DataType>>(
            mut self,
            v: T,
        ) -> Self {
            self.data_type = v.into();
            self
        }

        /// Sets the value of [nullable][crate::model::runtime_action_schema::InputParameter::nullable].
        pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.nullable = v.into();
            self
        }

        /// Sets the value of [default_value][crate::model::runtime_action_schema::InputParameter::default_value].
        pub fn set_default_value<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Value>,
        {
            self.default_value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [default_value][crate::model::runtime_action_schema::InputParameter::default_value].
        pub fn set_or_clear_default_value<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Value>,
        {
            self.default_value = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for InputParameter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.connectors.v1.RuntimeActionSchema.InputParameter"
        }
    }

    /// Metadata of result field.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ResultMetadata {
        /// Name of the result field.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub field: std::string::String,

        /// A brief description of the field.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub description: std::string::String,

        /// The data type of the field.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub data_type: crate::model::DataType,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResultMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::runtime_action_schema::ResultMetadata::field].
        pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.field = v.into();
            self
        }

        /// Sets the value of [description][crate::model::runtime_action_schema::ResultMetadata::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [data_type][crate::model::runtime_action_schema::ResultMetadata::data_type].
        pub fn set_data_type<T: std::convert::Into<crate::model::DataType>>(
            mut self,
            v: T,
        ) -> Self {
            self.data_type = v.into();
            self
        }
    }

    impl wkt::message::Message for ResultMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.connectors.v1.RuntimeActionSchema.ResultMetadata"
        }
    }
}

/// Determines whether or no a connection is locked. If locked, a reason must be
/// specified.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LockConfig {
    /// Indicates whether or not the connection is locked.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub locked: bool,

    /// Describes why a connection is locked.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub reason: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LockConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [locked][crate::model::LockConfig::locked].
    pub fn set_locked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.locked = v.into();
        self
    }

    /// Sets the value of [reason][crate::model::LockConfig::reason].
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }
}

impl wkt::message::Message for LockConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.LockConfig"
    }
}

/// Request message for ConnectorsService.ListConnections
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionsRequest {
    /// Required. Parent resource of the Connection, of the form:
    /// `projects/*/locations/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Order by parameters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    /// Specifies which fields of the Connection are returned in the response.
    /// Defaults to `BASIC` view.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub view: crate::model::ConnectionView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListConnectionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListConnectionsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ConnectionView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListConnectionsRequest"
    }
}

/// Response message for ConnectorsService.ListConnections
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionsResponse {
    /// Connections.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub connections: std::vec::Vec<crate::model::Connection>,

    /// Next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connections][crate::model::ListConnectionsResponse::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connection>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConnectionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectionsResponse {
    type PageItem = crate::model::Connection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for ConnectorsService.GetConnection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConnectionRequest {
    /// Required. Resource name of the form:
    /// `projects/*/locations/*/connections/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Specifies which fields of the Connection are returned in the response.
    /// Defaults to `BASIC` view.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub view: crate::model::ConnectionView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetConnectionRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ConnectionView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.GetConnectionRequest"
    }
}

/// Request message for ConnectorsService.CreateConnection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateConnectionRequest {
    /// Required. Parent resource of the Connection, of the form:
    /// `projects/*/locations/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. Identifier to assign to the Connection. Must be unique within
    /// scope of the parent resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub connection_id: std::string::String,

    /// Required. Connection resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection: std::option::Option<crate::model::Connection>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [connection_id][crate::model::CreateConnectionRequest::connection_id].
    pub fn set_connection_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_id = v.into();
        self
    }

    /// Sets the value of [connection][crate::model::CreateConnectionRequest::connection].
    pub fn set_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection][crate::model::CreateConnectionRequest::connection].
    pub fn set_or_clear_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.CreateConnectionRequest"
    }
}

/// Request message for ConnectorsService.UpdateConnection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateConnectionRequest {
    /// Required. Connection resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection: std::option::Option<crate::model::Connection>,

    /// Required. You can modify only the fields listed below.
    ///
    /// To lock/unlock a connection:
    ///
    /// * `lock_config`
    ///
    /// To suspend/resume a connection:
    ///
    /// * `suspended`
    ///
    /// To update the connection details:
    ///
    /// * `description`
    /// * `labels`
    /// * `connector_version`
    /// * `config_variables`
    /// * `auth_config`
    /// * `destination_configs`
    /// * `node_config`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection][crate::model::UpdateConnectionRequest::connection].
    pub fn set_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection][crate::model::UpdateConnectionRequest::connection].
    pub fn set_or_clear_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConnectionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.UpdateConnectionRequest"
    }
}

/// Request message for ConnectorsService.DeleteConnection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteConnectionRequest {
    /// Required. Resource name of the form:
    /// `projects/*/locations/*/connections/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.DeleteConnectionRequest"
    }
}

/// Request message for ConnectorsService.GetConnectionSchemaMetadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConnectionSchemaMetadataRequest {
    /// Required. Connection name
    /// Format:
    /// projects/{project}/locations/{location}/connections/{connection}/connectionSchemaMetadata
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectionSchemaMetadataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectionSchemaMetadataRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionSchemaMetadataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.GetConnectionSchemaMetadataRequest"
    }
}

/// Request message for ConnectorsService.RefreshConnectionSchemaMetadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RefreshConnectionSchemaMetadataRequest {
    /// Required. Resource name.
    /// Format:
    /// projects/{project}/locations/{location}/connections/{connection}/connectionSchemaMetadata
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RefreshConnectionSchemaMetadataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RefreshConnectionSchemaMetadataRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RefreshConnectionSchemaMetadataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.RefreshConnectionSchemaMetadataRequest"
    }
}

/// Request message for ConnectorsService.ListRuntimeEntitySchemas.
/// For filter, only entity field is supported with literal equality operator.
/// Accepted filter example: entity="Order"
/// Wildcards are not supported in the filter currently.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRuntimeEntitySchemasRequest {
    /// Required. Parent resource of RuntimeEntitySchema
    /// Format:
    /// projects/{project}/locations/{location}/connections/{connection}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Required. Filter
    /// Format:
    /// entity="{entityId}"
    /// Only entity field is supported with literal equality operator.
    /// Accepted filter example: entity="Order"
    /// Wildcards are not supported in the filter currently.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRuntimeEntitySchemasRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRuntimeEntitySchemasRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRuntimeEntitySchemasRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRuntimeEntitySchemasRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRuntimeEntitySchemasRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListRuntimeEntitySchemasRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListRuntimeEntitySchemasRequest"
    }
}

/// Response message for ConnectorsService.ListRuntimeEntitySchemas.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRuntimeEntitySchemasResponse {
    /// Runtime entity schemas.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub runtime_entity_schemas: std::vec::Vec<crate::model::RuntimeEntitySchema>,

    /// Next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRuntimeEntitySchemasResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [runtime_entity_schemas][crate::model::ListRuntimeEntitySchemasResponse::runtime_entity_schemas].
    pub fn set_runtime_entity_schemas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RuntimeEntitySchema>,
    {
        use std::iter::Iterator;
        self.runtime_entity_schemas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRuntimeEntitySchemasResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRuntimeEntitySchemasResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListRuntimeEntitySchemasResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRuntimeEntitySchemasResponse {
    type PageItem = crate::model::RuntimeEntitySchema;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.runtime_entity_schemas
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for ConnectorsService.ListRuntimeActionSchemas.
/// For filter, only action field is supported with literal equality operator.
/// Accepted filter example: action="approveOrder"
/// Wildcards are not supported in the filter currently.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRuntimeActionSchemasRequest {
    /// Required. Parent resource of RuntimeActionSchema
    /// Format:
    /// projects/{project}/locations/{location}/connections/{connection}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Required. Filter
    /// Format:
    /// action="{actionId}"
    /// Only action field is supported with literal equality operator.
    /// Accepted filter example: action="CancelOrder"
    /// Wildcards are not supported in the filter currently.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRuntimeActionSchemasRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRuntimeActionSchemasRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRuntimeActionSchemasRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRuntimeActionSchemasRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRuntimeActionSchemasRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListRuntimeActionSchemasRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListRuntimeActionSchemasRequest"
    }
}

/// Response message for ConnectorsService.ListRuntimeActionSchemas.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRuntimeActionSchemasResponse {
    /// Runtime action schemas.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub runtime_action_schemas: std::vec::Vec<crate::model::RuntimeActionSchema>,

    /// Next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRuntimeActionSchemasResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [runtime_action_schemas][crate::model::ListRuntimeActionSchemasResponse::runtime_action_schemas].
    pub fn set_runtime_action_schemas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RuntimeActionSchema>,
    {
        use std::iter::Iterator;
        self.runtime_action_schemas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRuntimeActionSchemasResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRuntimeActionSchemasResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListRuntimeActionSchemasResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRuntimeActionSchemasResponse {
    type PageItem = crate::model::RuntimeActionSchema;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.runtime_action_schemas
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// ConnectionStatus indicates the state of the connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConnectionStatus {
    /// State.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::connection_status::State,

    /// Description.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub description: std::string::String,

    /// Status provides detailed information for the state.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub status: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectionStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::ConnectionStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::connection_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ConnectionStatus::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [status][crate::model::ConnectionStatus::status].
    pub fn set_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }
}

impl wkt::message::Message for ConnectionStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ConnectionStatus"
    }
}

/// Defines additional types related to [ConnectionStatus].
pub mod connection_status {
    #[allow(unused_imports)]
    use super::*;

    /// All the possible Connection State.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Connection does not have a state yet.
        Unspecified,
        /// Connection is being created.
        Creating,
        /// Connection is running and ready for requests.
        Active,
        /// Connection is stopped.
        Inactive,
        /// Connection is being deleted.
        Deleting,
        /// Connection is being updated.
        Updating,
        /// Connection is not running due to an error.
        Error,
        /// Connection is not running due to an auth error for the Oauth2 Auth Code
        /// based connector.
        AuthorizationRequired,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Inactive => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Updating => std::option::Option::Some(5),
                Self::Error => std::option::Option::Some(6),
                Self::AuthorizationRequired => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::AuthorizationRequired => std::option::Option::Some("AUTHORIZATION_REQUIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Inactive,
                4 => Self::Deleting,
                5 => Self::Updating,
                6 => Self::Error,
                7 => Self::AuthorizationRequired,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "INACTIVE" => Self::Inactive,
                "DELETING" => Self::Deleting,
                "UPDATING" => Self::Updating,
                "ERROR" => Self::Error,
                "AUTHORIZATION_REQUIRED" => Self::AuthorizationRequired,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Inactive => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Updating => serializer.serialize_i32(5),
                Self::Error => serializer.serialize_i32(6),
                Self::AuthorizationRequired => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.connectors.v1.ConnectionStatus.State",
            ))
        }
    }
}

/// Connectors indicates a specific connector type, e.x. Salesforce, SAP etc.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Connector {
    /// Output only. Resource name of the Connector.
    /// Format:
    /// projects/{project}/locations/{location}/providers/{provider}/connectors/{connector}
    /// Only global location is supported for Connector resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. Created time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Updated time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Resource labels to represent user-provided metadata.
    /// Refer to cloud documentation on labels for more details.
    /// <https://cloud.google.com/compute/docs/labeling-resources>
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Link to documentation page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub documentation_uri: std::string::String,

    /// Output only. Link to external page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub external_uri: std::string::String,

    /// Output only. Description of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub description: std::string::String,

    /// Output only. Cloud storage location of icons etc consumed by UI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub web_assets_location: std::string::String,

    /// Output only. Display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    /// Output only. Flag to mark the version indicating the launch stage.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub launch_stage: crate::model::LaunchStage,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Connector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Connector::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Connector::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Connector::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Connector::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Connector::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Connector::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [documentation_uri][crate::model::Connector::documentation_uri].
    pub fn set_documentation_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.documentation_uri = v.into();
        self
    }

    /// Sets the value of [external_uri][crate::model::Connector::external_uri].
    pub fn set_external_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_uri = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Connector::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [web_assets_location][crate::model::Connector::web_assets_location].
    pub fn set_web_assets_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.web_assets_location = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Connector::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [launch_stage][crate::model::Connector::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<crate::model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }
}

impl wkt::message::Message for Connector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.Connector"
    }
}

/// Request message for Connectors.GetConnector.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConnectorRequest {
    /// Required. Resource name of the form:
    /// `projects/*/locations/*/providers/*/connectors/*`
    /// Only global location is supported for Connector resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.GetConnectorRequest"
    }
}

/// Request message for Connectors.ListConnectors.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectorsRequest {
    /// Required. Parent resource of the connectors, of the form:
    /// `projects/*/locations/*/providers/*`
    /// Only global location is supported for Connector resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectorsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectorsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListConnectorsRequest"
    }
}

/// Response message for Connectors.ListConnectors.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectorsResponse {
    /// A list of connectors.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub connectors: std::vec::Vec<crate::model::Connector>,

    /// Next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectorsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connectors][crate::model::ListConnectorsResponse::connectors].
    pub fn set_connectors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connector>,
    {
        use std::iter::Iterator;
        self.connectors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConnectorsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListConnectorsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectorsResponse {
    type PageItem = crate::model::Connector;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connectors
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// ConnectorVersion indicates a specific version of a connector.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConnectorVersion {
    /// Output only. Resource name of the Version.
    /// Format:
    /// projects/{project}/locations/{location}/providers/{provider}/connectors/{connector}/versions/{version}
    /// Only global location is supported for Connector resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. Created time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Updated time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Resource labels to represent user-provided metadata.
    /// Refer to cloud documentation on labels for more details.
    /// <https://cloud.google.com/compute/docs/labeling-resources>
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Flag to mark the version indicating the launch stage.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub launch_stage: crate::model::LaunchStage,

    /// Output only. ReleaseVersion of the connector, for example: "1.0.1-alpha".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub release_version: std::string::String,

    /// Output only. List of auth configs supported by the Connector Version.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub auth_config_templates: std::vec::Vec<crate::model::AuthConfigTemplate>,

    /// Output only. List of config variables needed to create a connection.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub config_variable_templates: std::vec::Vec<crate::model::ConfigVariableTemplate>,

    /// Output only. Information about the runtime features supported by the
    /// Connector.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub supported_runtime_features: std::option::Option<crate::model::SupportedRuntimeFeatures>,

    /// Output only. Display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    /// Output only. Configuration for Egress Control.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub egress_control_config: std::option::Option<crate::model::EgressControlConfig>,

    /// Output only. Role grant configurations for this connector version.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub role_grants: std::vec::Vec<crate::model::RoleGrant>,

    /// Output only. Role grant configuration for this config variable. It will be
    /// DEPRECATED soon.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub role_grant: std::option::Option<crate::model::RoleGrant>,

    /// Output only. Ssl configuration supported by the Connector.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ssl_config_template: std::option::Option<crate::model::SslConfigTemplate>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectorVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConnectorVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ConnectorVersion::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ConnectorVersion::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ConnectorVersion::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ConnectorVersion::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::ConnectorVersion::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [launch_stage][crate::model::ConnectorVersion::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<crate::model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }

    /// Sets the value of [release_version][crate::model::ConnectorVersion::release_version].
    pub fn set_release_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release_version = v.into();
        self
    }

    /// Sets the value of [auth_config_templates][crate::model::ConnectorVersion::auth_config_templates].
    pub fn set_auth_config_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AuthConfigTemplate>,
    {
        use std::iter::Iterator;
        self.auth_config_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [config_variable_templates][crate::model::ConnectorVersion::config_variable_templates].
    pub fn set_config_variable_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConfigVariableTemplate>,
    {
        use std::iter::Iterator;
        self.config_variable_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_runtime_features][crate::model::ConnectorVersion::supported_runtime_features].
    pub fn set_supported_runtime_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SupportedRuntimeFeatures>,
    {
        self.supported_runtime_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [supported_runtime_features][crate::model::ConnectorVersion::supported_runtime_features].
    pub fn set_or_clear_supported_runtime_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SupportedRuntimeFeatures>,
    {
        self.supported_runtime_features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [display_name][crate::model::ConnectorVersion::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [egress_control_config][crate::model::ConnectorVersion::egress_control_config].
    pub fn set_egress_control_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EgressControlConfig>,
    {
        self.egress_control_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [egress_control_config][crate::model::ConnectorVersion::egress_control_config].
    pub fn set_or_clear_egress_control_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EgressControlConfig>,
    {
        self.egress_control_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [role_grants][crate::model::ConnectorVersion::role_grants].
    pub fn set_role_grants<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RoleGrant>,
    {
        use std::iter::Iterator;
        self.role_grants = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [role_grant][crate::model::ConnectorVersion::role_grant].
    pub fn set_role_grant<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RoleGrant>,
    {
        self.role_grant = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [role_grant][crate::model::ConnectorVersion::role_grant].
    pub fn set_or_clear_role_grant<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RoleGrant>,
    {
        self.role_grant = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ssl_config_template][crate::model::ConnectorVersion::ssl_config_template].
    pub fn set_ssl_config_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslConfigTemplate>,
    {
        self.ssl_config_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssl_config_template][crate::model::ConnectorVersion::ssl_config_template].
    pub fn set_or_clear_ssl_config_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslConfigTemplate>,
    {
        self.ssl_config_template = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ConnectorVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ConnectorVersion"
    }
}

/// Request message for Connectors.GetConnectorVersion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConnectorVersionRequest {
    /// Required. Resource name of the form:
    /// `projects/*/locations/*/providers/*/connectors/*/versions/*`
    /// Only global location is supported for ConnectorVersion resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Specifies which fields of the ConnectorVersion are returned in the
    /// response. Defaults to `CUSTOMER` view.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub view: crate::model::ConnectorVersionView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectorVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectorVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetConnectorVersionRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ConnectorVersionView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectorVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.GetConnectorVersionRequest"
    }
}

/// Request message for Connectors.ListConnectorVersions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectorVersionsRequest {
    /// Required. Parent resource of the connectors, of the form:
    /// `projects/*/locations/*/providers/*/connectors/*`
    /// Only global location is supported for ConnectorVersion resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Specifies which fields of the ConnectorVersion are returned in the
    /// response. Defaults to `BASIC` view.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub view: crate::model::ConnectorVersionView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectorVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectorVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectorVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectorVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListConnectorVersionsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ConnectorVersionView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectorVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListConnectorVersionsRequest"
    }
}

/// Response message for Connectors.ListConnectorVersions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectorVersionsResponse {
    /// A list of connector versions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub connector_versions: std::vec::Vec<crate::model::ConnectorVersion>,

    /// Next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectorVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connector_versions][crate::model::ListConnectorVersionsResponse::connector_versions].
    pub fn set_connector_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConnectorVersion>,
    {
        use std::iter::Iterator;
        self.connector_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectorVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConnectorVersionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectorVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListConnectorVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectorVersionsResponse {
    type PageItem = crate::model::ConnectorVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connector_versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Supported runtime features of a connector version. This is passed to the
/// management layer to add a new connector version by the connector developer.
/// Details about how this proto is passed to the management layer is covered in
/// this doc - go/runtime-manifest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SupportedRuntimeFeatures {
    /// Specifies if the connector supports entity apis like 'createEntity'.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub entity_apis: bool,

    /// Specifies if the connector supports action apis like 'executeAction'.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub action_apis: bool,

    /// Specifies if the connector supports 'ExecuteSqlQuery' operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub sql_query: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SupportedRuntimeFeatures {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_apis][crate::model::SupportedRuntimeFeatures::entity_apis].
    pub fn set_entity_apis<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.entity_apis = v.into();
        self
    }

    /// Sets the value of [action_apis][crate::model::SupportedRuntimeFeatures::action_apis].
    pub fn set_action_apis<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.action_apis = v.into();
        self
    }

    /// Sets the value of [sql_query][crate::model::SupportedRuntimeFeatures::sql_query].
    pub fn set_sql_query<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.sql_query = v.into();
        self
    }
}

impl wkt::message::Message for SupportedRuntimeFeatures {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.SupportedRuntimeFeatures"
    }
}

/// Egress control config for connector runtime. These configurations define the
/// rules to identify which outbound domains/hosts needs to be whitelisted. It
/// may be a static information for a particular connector version or it is
/// derived from the configurations provided by the customer in Connection
/// resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EgressControlConfig {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub oneof_backends: std::option::Option<crate::model::egress_control_config::OneofBackends>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EgressControlConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [oneof_backends][crate::model::EgressControlConfig::oneof_backends].
    ///
    /// Note that all the setters affecting `oneof_backends` are mutually
    /// exclusive.
    pub fn set_oneof_backends<
        T: std::convert::Into<std::option::Option<crate::model::egress_control_config::OneofBackends>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.oneof_backends = v.into();
        self
    }

    /// The value of [oneof_backends][crate::model::EgressControlConfig::oneof_backends]
    /// if it holds a `Backends`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backends(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.oneof_backends.as_ref().and_then(|v| match v {
            crate::model::egress_control_config::OneofBackends::Backends(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [oneof_backends][crate::model::EgressControlConfig::oneof_backends]
    /// to hold a `Backends`.
    ///
    /// Note that all the setters affecting `oneof_backends` are
    /// mutually exclusive.
    pub fn set_backends<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oneof_backends = std::option::Option::Some(
            crate::model::egress_control_config::OneofBackends::Backends(v.into()),
        );
        self
    }

    /// The value of [oneof_backends][crate::model::EgressControlConfig::oneof_backends]
    /// if it holds a `ExtractionRules`, `None` if the field is not set or
    /// holds a different branch.
    pub fn extraction_rules(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExtractionRules>> {
        #[allow(unreachable_patterns)]
        self.oneof_backends.as_ref().and_then(|v| match v {
            crate::model::egress_control_config::OneofBackends::ExtractionRules(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [oneof_backends][crate::model::EgressControlConfig::oneof_backends]
    /// to hold a `ExtractionRules`.
    ///
    /// Note that all the setters affecting `oneof_backends` are
    /// mutually exclusive.
    pub fn set_extraction_rules<
        T: std::convert::Into<std::boxed::Box<crate::model::ExtractionRules>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.oneof_backends = std::option::Option::Some(
            crate::model::egress_control_config::OneofBackends::ExtractionRules(v.into()),
        );
        self
    }
}

impl wkt::message::Message for EgressControlConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.EgressControlConfig"
    }
}

/// Defines additional types related to [EgressControlConfig].
pub mod egress_control_config {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum OneofBackends {
        /// Static Comma separated backends which are common for all Connection
        /// resources. Supported formats for each backend are host:port or just
        /// host (host can be ip address or domain name).
        Backends(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
        /// Extractions Rules to extract the backends from customer provided
        /// configuration.
        ExtractionRules(std::boxed::Box<crate::model::ExtractionRules>),
    }
}

/// Extraction Rules to identity the backends from customer provided
/// configuration in Connection resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExtractionRules {
    /// Collection of Extraction Rule.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub extraction_rule: std::vec::Vec<crate::model::ExtractionRule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExtractionRules {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [extraction_rule][crate::model::ExtractionRules::extraction_rule].
    pub fn set_extraction_rule<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExtractionRule>,
    {
        use std::iter::Iterator;
        self.extraction_rule = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExtractionRules {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ExtractionRules"
    }
}

/// Extraction Rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExtractionRule {
    /// Source on which the rule is applied.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::extraction_rule::Source>,

    /// Regex used to extract backend details from source. If empty, whole source
    /// value will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub extraction_regex: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExtractionRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::ExtractionRule::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::extraction_rule::Source>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::ExtractionRule::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::extraction_rule::Source>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [extraction_regex][crate::model::ExtractionRule::extraction_regex].
    pub fn set_extraction_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.extraction_regex = v.into();
        self
    }
}

impl wkt::message::Message for ExtractionRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ExtractionRule"
    }
}

/// Defines additional types related to [ExtractionRule].
pub mod extraction_rule {
    #[allow(unused_imports)]
    use super::*;

    /// Source to extract the backend from.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Source {
        /// Type of the source.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub source_type: crate::model::extraction_rule::SourceType,

        /// Field identifier. For example config vaiable name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub field_id: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Source {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_type][crate::model::extraction_rule::Source::source_type].
        pub fn set_source_type<T: std::convert::Into<crate::model::extraction_rule::SourceType>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_type = v.into();
            self
        }

        /// Sets the value of [field_id][crate::model::extraction_rule::Source::field_id].
        pub fn set_field_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.field_id = v.into();
            self
        }
    }

    impl wkt::message::Message for Source {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.connectors.v1.ExtractionRule.Source"
        }
    }

    /// Supported Source types for extraction.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceType {
        /// Default SOURCE.
        Unspecified,
        /// Config Variable source type.
        ConfigVariable,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SourceType::value] or
        /// [SourceType::name].
        UnknownValue(source_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod source_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SourceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ConfigVariable => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SOURCE_TYPE_UNSPECIFIED"),
                Self::ConfigVariable => std::option::Option::Some("CONFIG_VARIABLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SourceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SourceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SourceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ConfigVariable,
                _ => Self::UnknownValue(source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SourceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CONFIG_VARIABLE" => Self::ConfigVariable,
                _ => Self::UnknownValue(source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SourceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ConfigVariable => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SourceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SourceType>::new(
                ".google.cloud.connectors.v1.ExtractionRule.SourceType",
            ))
        }
    }
}

/// Define the Connectors target endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DestinationConfig {
    /// The key is the destination identifier that is supported by the Connector.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub key: std::string::String,

    /// The destinations for the key.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub destinations: std::vec::Vec<crate::model::Destination>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DestinationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::DestinationConfig::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [destinations][crate::model::DestinationConfig::destinations].
    pub fn set_destinations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Destination>,
    {
        use std::iter::Iterator;
        self.destinations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DestinationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.DestinationConfig"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Destination {
    /// The port is the target port number that is accepted by the destination.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub port: i32,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::destination::Destination>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Destination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [port][crate::model::Destination::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::Destination::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::destination::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::Destination::destination]
    /// if it holds a `ServiceAttachment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn service_attachment(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::destination::Destination::ServiceAttachment(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::Destination::destination]
    /// to hold a `ServiceAttachment`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::destination::Destination::ServiceAttachment(v.into()),
        );
        self
    }

    /// The value of [destination][crate::model::Destination::destination]
    /// if it holds a `Host`, `None` if the field is not set or
    /// holds a different branch.
    pub fn host(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::destination::Destination::Host(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::Destination::destination]
    /// to hold a `Host`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination =
            std::option::Option::Some(crate::model::destination::Destination::Host(v.into()));
        self
    }
}

impl wkt::message::Message for Destination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.Destination"
    }
}

/// Defines additional types related to [Destination].
pub mod destination {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// PSC service attachments.
        /// Format: projects/*/regions/*/serviceAttachments/*
        ServiceAttachment(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
        /// For publicly routable host.
        Host(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
    }
}

/// Provider indicates the owner who provides the connectors.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Provider {
    /// Output only. Resource name of the Provider.
    /// Format: projects/{project}/locations/{location}/providers/{provider}
    /// Only global location is supported for Provider resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. Created time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Updated time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Resource labels to represent user-provided metadata.
    /// Refer to cloud documentation on labels for more details.
    /// <https://cloud.google.com/compute/docs/labeling-resources>
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Link to documentation page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub documentation_uri: std::string::String,

    /// Output only. Link to external page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub external_uri: std::string::String,

    /// Output only. Description of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub description: std::string::String,

    /// Output only. Cloud storage location of icons etc consumed by UI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub web_assets_location: std::string::String,

    /// Output only. Display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    /// Output only. Flag to mark the version indicating the launch stage.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub launch_stage: crate::model::LaunchStage,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Provider {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Provider::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Provider::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Provider::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Provider::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Provider::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Provider::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [documentation_uri][crate::model::Provider::documentation_uri].
    pub fn set_documentation_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.documentation_uri = v.into();
        self
    }

    /// Sets the value of [external_uri][crate::model::Provider::external_uri].
    pub fn set_external_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_uri = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Provider::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [web_assets_location][crate::model::Provider::web_assets_location].
    pub fn set_web_assets_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.web_assets_location = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Provider::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [launch_stage][crate::model::Provider::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<crate::model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }
}

impl wkt::message::Message for Provider {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.Provider"
    }
}

/// Request message for Connectors.GetProvider.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetProviderRequest {
    /// Required. Resource name of the form:
    /// `projects/*/locations/*/providers/*`
    /// Only global location is supported for Provider resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProviderRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProviderRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProviderRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.GetProviderRequest"
    }
}

/// Request message for Connectors.ListProviders.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProvidersRequest {
    /// Required. Parent resource of the API, of the form:
    /// `projects/*/locations/*`
    /// Only global location is supported for Provider resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProvidersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProvidersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProvidersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProvidersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProvidersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListProvidersRequest"
    }
}

/// Response message for Connectors.ListProviders.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProvidersResponse {
    /// A list of providers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub providers: std::vec::Vec<crate::model::Provider>,

    /// Next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProvidersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [providers][crate::model::ListProvidersResponse::providers].
    pub fn set_providers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Provider>,
    {
        use std::iter::Iterator;
        self.providers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListProvidersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListProvidersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListProvidersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListProvidersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProvidersResponse {
    type PageItem = crate::model::Provider;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.providers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for Connectors.GetRuntimeConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetRuntimeConfigRequest {
    /// Required. Resource name of the form:
    /// `projects/*/locations/*/runtimeConfig`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRuntimeConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRuntimeConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRuntimeConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.GetRuntimeConfigRequest"
    }
}

/// RuntimeConfig is the singleton resource of each location.
/// It includes generic resource configs consumed by control plane and runtime
/// plane like: pub/sub topic/subscription resource name, Cloud Storage location
/// storing schema etc.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RuntimeConfig {
    /// Output only. location_id of the runtime location. E.g. "us-west1".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub location_id: std::string::String,

    /// Output only. Pub/Sub topic for connd to send message.
    /// E.g. projects/{project-id}/topics/{topic-id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub connd_topic: std::string::String,

    /// Output only. Pub/Sub subscription for connd to receive message.
    /// E.g. projects/{project-id}/subscriptions/{topic-id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub connd_subscription: std::string::String,

    /// Output only. Pub/Sub topic for control plne to send message.
    /// communication.
    /// E.g. projects/{project-id}/topics/{topic-id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub control_plane_topic: std::string::String,

    /// Output only. Pub/Sub subscription for control plane to receive message.
    /// E.g. projects/{project-id}/subscriptions/{topic-id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub control_plane_subscription: std::string::String,

    /// Output only. The endpoint of the connectors runtime ingress.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub runtime_endpoint: std::string::String,

    /// Output only. The state of the location.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::runtime_config::State,

    /// Output only. The Cloud Storage bucket that stores connector's schema
    /// reports.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub schema_gcs_bucket: std::string::String,

    /// Output only. The name of the Service Directory service name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub service_directory: std::string::String,

    /// Output only. Name of the runtimeConfig resource.
    /// Format: projects/{project}/locations/{location}/runtimeConfig
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuntimeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location_id][crate::model::RuntimeConfig::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }

    /// Sets the value of [connd_topic][crate::model::RuntimeConfig::connd_topic].
    pub fn set_connd_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connd_topic = v.into();
        self
    }

    /// Sets the value of [connd_subscription][crate::model::RuntimeConfig::connd_subscription].
    pub fn set_connd_subscription<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.connd_subscription = v.into();
        self
    }

    /// Sets the value of [control_plane_topic][crate::model::RuntimeConfig::control_plane_topic].
    pub fn set_control_plane_topic<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.control_plane_topic = v.into();
        self
    }

    /// Sets the value of [control_plane_subscription][crate::model::RuntimeConfig::control_plane_subscription].
    pub fn set_control_plane_subscription<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.control_plane_subscription = v.into();
        self
    }

    /// Sets the value of [runtime_endpoint][crate::model::RuntimeConfig::runtime_endpoint].
    pub fn set_runtime_endpoint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_endpoint = v.into();
        self
    }

    /// Sets the value of [state][crate::model::RuntimeConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::runtime_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [schema_gcs_bucket][crate::model::RuntimeConfig::schema_gcs_bucket].
    pub fn set_schema_gcs_bucket<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.schema_gcs_bucket = v.into();
        self
    }

    /// Sets the value of [service_directory][crate::model::RuntimeConfig::service_directory].
    pub fn set_service_directory<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_directory = v.into();
        self
    }

    /// Sets the value of [name][crate::model::RuntimeConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RuntimeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.RuntimeConfig"
    }
}

/// Defines additional types related to [RuntimeConfig].
pub mod runtime_config {
    #[allow(unused_imports)]
    use super::*;

    /// State of the location.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// STATE_UNSPECIFIED.
        Unspecified,
        /// INACTIVE.
        #[deprecated]
        Inactive,
        /// ACTIVATING.
        #[deprecated]
        Activating,
        /// ACTIVE.
        Active,
        /// CREATING.
        Creating,
        /// DELETING.
        Deleting,
        /// UPDATING.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Inactive => std::option::Option::Some(1),
                Self::Activating => std::option::Option::Some(2),
                Self::Active => std::option::Option::Some(3),
                Self::Creating => std::option::Option::Some(4),
                Self::Deleting => std::option::Option::Some(5),
                Self::Updating => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::Activating => std::option::Option::Some("ACTIVATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Inactive,
                2 => Self::Activating,
                3 => Self::Active,
                4 => Self::Creating,
                5 => Self::Deleting,
                6 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "INACTIVE" => Self::Inactive,
                "ACTIVATING" => Self::Activating,
                "ACTIVE" => Self::Active,
                "CREATING" => Self::Creating,
                "DELETING" => Self::Deleting,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Inactive => serializer.serialize_i32(1),
                Self::Activating => serializer.serialize_i32(2),
                Self::Active => serializer.serialize_i32(3),
                Self::Creating => serializer.serialize_i32(4),
                Self::Deleting => serializer.serialize_i32(5),
                Self::Updating => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.connectors.v1.RuntimeConfig.State",
            ))
        }
    }
}

/// Request for [GetGlobalSettingsRequest].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetGlobalSettingsRequest {
    /// Required. The resource name of the Settings.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGlobalSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGlobalSettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGlobalSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.GetGlobalSettingsRequest"
    }
}

/// Global Settings details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Settings {
    /// Output only. Resource name of the Connection.
    /// Format: projects/{project}/locations/global/settings}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. Flag indicates whether vpc-sc is enabled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub vpcsc: bool,

    /// Output only. Flag indicates if user is in PayG model
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub payg: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Settings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Settings::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [vpcsc][crate::model::Settings::vpcsc].
    pub fn set_vpcsc<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.vpcsc = v.into();
        self
    }

    /// Sets the value of [payg][crate::model::Settings::payg].
    pub fn set_payg<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.payg = v.into();
        self
    }
}

impl wkt::message::Message for Settings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.Settings"
    }
}

/// Ssl config details of a connector version
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslConfigTemplate {
    /// Controls the ssl type for the given connector version
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub ssl_type: crate::model::SslType,

    /// Boolean for determining if the connector version mandates TLS.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub is_tls_mandatory: bool,

    /// List of supported Server Cert Types
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub server_cert_type: std::vec::Vec<crate::model::CertType>,

    /// List of supported Client Cert Types
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub client_cert_type: std::vec::Vec<crate::model::CertType>,

    /// Any additional fields that need to be rendered
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub additional_variables: std::vec::Vec<crate::model::ConfigVariableTemplate>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslConfigTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ssl_type][crate::model::SslConfigTemplate::ssl_type].
    pub fn set_ssl_type<T: std::convert::Into<crate::model::SslType>>(mut self, v: T) -> Self {
        self.ssl_type = v.into();
        self
    }

    /// Sets the value of [is_tls_mandatory][crate::model::SslConfigTemplate::is_tls_mandatory].
    pub fn set_is_tls_mandatory<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_tls_mandatory = v.into();
        self
    }

    /// Sets the value of [server_cert_type][crate::model::SslConfigTemplate::server_cert_type].
    pub fn set_server_cert_type<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CertType>,
    {
        use std::iter::Iterator;
        self.server_cert_type = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [client_cert_type][crate::model::SslConfigTemplate::client_cert_type].
    pub fn set_client_cert_type<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CertType>,
    {
        use std::iter::Iterator;
        self.client_cert_type = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [additional_variables][crate::model::SslConfigTemplate::additional_variables].
    pub fn set_additional_variables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConfigVariableTemplate>,
    {
        use std::iter::Iterator;
        self.additional_variables = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SslConfigTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.SslConfigTemplate"
    }
}

/// SSL Configuration of a connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslConfig {
    /// Controls the ssl type for the given connector version.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::SslType,

    /// Trust Model of the SSL connection
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub trust_model: crate::model::ssl_config::TrustModel,

    /// Private Server Certificate. Needs to be specified if trust model is
    /// `PRIVATE`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_server_certificate: std::option::Option<crate::model::Secret>,

    /// Client Certificate
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub client_certificate: std::option::Option<crate::model::Secret>,

    /// Client Private Key
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub client_private_key: std::option::Option<crate::model::Secret>,

    /// Secret containing the passphrase protecting the Client Private Key
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub client_private_key_pass: std::option::Option<crate::model::Secret>,

    /// Type of Server Cert (PEM/JKS/.. etc.)
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub server_cert_type: crate::model::CertType,

    /// Type of Client Cert (PEM/JKS/.. etc.)
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub client_cert_type: crate::model::CertType,

    /// Bool for enabling SSL
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub use_ssl: bool,

    /// Additional SSL related field values
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub additional_variables: std::vec::Vec<crate::model::ConfigVariable>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::SslConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::SslType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [trust_model][crate::model::SslConfig::trust_model].
    pub fn set_trust_model<T: std::convert::Into<crate::model::ssl_config::TrustModel>>(
        mut self,
        v: T,
    ) -> Self {
        self.trust_model = v.into();
        self
    }

    /// Sets the value of [private_server_certificate][crate::model::SslConfig::private_server_certificate].
    pub fn set_private_server_certificate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.private_server_certificate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_server_certificate][crate::model::SslConfig::private_server_certificate].
    pub fn set_or_clear_private_server_certificate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.private_server_certificate = v.map(|x| x.into());
        self
    }

    /// Sets the value of [client_certificate][crate::model::SslConfig::client_certificate].
    pub fn set_client_certificate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.client_certificate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_certificate][crate::model::SslConfig::client_certificate].
    pub fn set_or_clear_client_certificate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.client_certificate = v.map(|x| x.into());
        self
    }

    /// Sets the value of [client_private_key][crate::model::SslConfig::client_private_key].
    pub fn set_client_private_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.client_private_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_private_key][crate::model::SslConfig::client_private_key].
    pub fn set_or_clear_client_private_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.client_private_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [client_private_key_pass][crate::model::SslConfig::client_private_key_pass].
    pub fn set_client_private_key_pass<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.client_private_key_pass = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_private_key_pass][crate::model::SslConfig::client_private_key_pass].
    pub fn set_or_clear_client_private_key_pass<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.client_private_key_pass = v.map(|x| x.into());
        self
    }

    /// Sets the value of [server_cert_type][crate::model::SslConfig::server_cert_type].
    pub fn set_server_cert_type<T: std::convert::Into<crate::model::CertType>>(
        mut self,
        v: T,
    ) -> Self {
        self.server_cert_type = v.into();
        self
    }

    /// Sets the value of [client_cert_type][crate::model::SslConfig::client_cert_type].
    pub fn set_client_cert_type<T: std::convert::Into<crate::model::CertType>>(
        mut self,
        v: T,
    ) -> Self {
        self.client_cert_type = v.into();
        self
    }

    /// Sets the value of [use_ssl][crate::model::SslConfig::use_ssl].
    pub fn set_use_ssl<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_ssl = v.into();
        self
    }

    /// Sets the value of [additional_variables][crate::model::SslConfig::additional_variables].
    pub fn set_additional_variables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConfigVariable>,
    {
        use std::iter::Iterator;
        self.additional_variables = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SslConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.SslConfig"
    }
}

/// Defines additional types related to [SslConfig].
pub mod ssl_config {
    #[allow(unused_imports)]
    use super::*;

    /// Enum for Ttust Model
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TrustModel {
        /// Public Trust Model. Takes the Default Java trust store.
        Public,
        /// Private Trust Model. Takes custom/private trust store.
        Private,
        /// Insecure Trust Model. Accept all certificates.
        Insecure,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TrustModel::value] or
        /// [TrustModel::name].
        UnknownValue(trust_model::UnknownValue),
    }

    #[doc(hidden)]
    pub mod trust_model {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TrustModel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Public => std::option::Option::Some(0),
                Self::Private => std::option::Option::Some(1),
                Self::Insecure => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Public => std::option::Option::Some("PUBLIC"),
                Self::Private => std::option::Option::Some("PRIVATE"),
                Self::Insecure => std::option::Option::Some("INSECURE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TrustModel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TrustModel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TrustModel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Public,
                1 => Self::Private,
                2 => Self::Insecure,
                _ => Self::UnknownValue(trust_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TrustModel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PUBLIC" => Self::Public,
                "PRIVATE" => Self::Private,
                "INSECURE" => Self::Insecure,
                _ => Self::UnknownValue(trust_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TrustModel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Public => serializer.serialize_i32(0),
                Self::Private => serializer.serialize_i32(1),
                Self::Insecure => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TrustModel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TrustModel>::new(
                ".google.cloud.connectors.v1.SslConfig.TrustModel",
            ))
        }
    }
}

/// AuthType defines different authentication types.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AuthType {
    /// Authentication type not specified.
    Unspecified,
    /// Username and Password Authentication.
    UserPassword,
    /// JSON Web Token (JWT) Profile for Oauth 2.0
    /// Authorization Grant based authentication
    Oauth2JwtBearer,
    /// Oauth 2.0 Client Credentials Grant Authentication
    Oauth2ClientCredentials,
    /// SSH Public Key Authentication
    SshPublicKey,
    /// Oauth 2.0 Authorization Code Flow
    Oauth2AuthCodeFlow,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AuthType::value] or
    /// [AuthType::name].
    UnknownValue(auth_type::UnknownValue),
}

#[doc(hidden)]
pub mod auth_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl AuthType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::UserPassword => std::option::Option::Some(1),
            Self::Oauth2JwtBearer => std::option::Option::Some(2),
            Self::Oauth2ClientCredentials => std::option::Option::Some(3),
            Self::SshPublicKey => std::option::Option::Some(4),
            Self::Oauth2AuthCodeFlow => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("AUTH_TYPE_UNSPECIFIED"),
            Self::UserPassword => std::option::Option::Some("USER_PASSWORD"),
            Self::Oauth2JwtBearer => std::option::Option::Some("OAUTH2_JWT_BEARER"),
            Self::Oauth2ClientCredentials => std::option::Option::Some("OAUTH2_CLIENT_CREDENTIALS"),
            Self::SshPublicKey => std::option::Option::Some("SSH_PUBLIC_KEY"),
            Self::Oauth2AuthCodeFlow => std::option::Option::Some("OAUTH2_AUTH_CODE_FLOW"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for AuthType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for AuthType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for AuthType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::UserPassword,
            2 => Self::Oauth2JwtBearer,
            3 => Self::Oauth2ClientCredentials,
            4 => Self::SshPublicKey,
            5 => Self::Oauth2AuthCodeFlow,
            _ => Self::UnknownValue(auth_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for AuthType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "AUTH_TYPE_UNSPECIFIED" => Self::Unspecified,
            "USER_PASSWORD" => Self::UserPassword,
            "OAUTH2_JWT_BEARER" => Self::Oauth2JwtBearer,
            "OAUTH2_CLIENT_CREDENTIALS" => Self::Oauth2ClientCredentials,
            "SSH_PUBLIC_KEY" => Self::SshPublicKey,
            "OAUTH2_AUTH_CODE_FLOW" => Self::Oauth2AuthCodeFlow,
            _ => Self::UnknownValue(auth_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for AuthType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::UserPassword => serializer.serialize_i32(1),
            Self::Oauth2JwtBearer => serializer.serialize_i32(2),
            Self::Oauth2ClientCredentials => serializer.serialize_i32(3),
            Self::SshPublicKey => serializer.serialize_i32(4),
            Self::Oauth2AuthCodeFlow => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for AuthType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AuthType>::new(
            ".google.cloud.connectors.v1.AuthType",
        ))
    }
}

/// LaunchStage is a enum to indicate launch stage:
/// PREVIEW, GA, DEPRECATED, PRIVATE_PREVIEW.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum LaunchStage {
    /// LAUNCH_STAGE_UNSPECIFIED.
    Unspecified,
    /// PREVIEW.
    Preview,
    /// GA.
    Ga,
    /// DEPRECATED.
    Deprecated,
    /// PRIVATE_PREVIEW.
    PrivatePreview,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [LaunchStage::value] or
    /// [LaunchStage::name].
    UnknownValue(launch_stage::UnknownValue),
}

#[doc(hidden)]
pub mod launch_stage {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl LaunchStage {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Preview => std::option::Option::Some(1),
            Self::Ga => std::option::Option::Some(2),
            Self::Deprecated => std::option::Option::Some(3),
            Self::PrivatePreview => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("LAUNCH_STAGE_UNSPECIFIED"),
            Self::Preview => std::option::Option::Some("PREVIEW"),
            Self::Ga => std::option::Option::Some("GA"),
            Self::Deprecated => std::option::Option::Some("DEPRECATED"),
            Self::PrivatePreview => std::option::Option::Some("PRIVATE_PREVIEW"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for LaunchStage {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for LaunchStage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for LaunchStage {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Preview,
            2 => Self::Ga,
            3 => Self::Deprecated,
            5 => Self::PrivatePreview,
            _ => Self::UnknownValue(launch_stage::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for LaunchStage {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "LAUNCH_STAGE_UNSPECIFIED" => Self::Unspecified,
            "PREVIEW" => Self::Preview,
            "GA" => Self::Ga,
            "DEPRECATED" => Self::Deprecated,
            "PRIVATE_PREVIEW" => Self::PrivatePreview,
            _ => Self::UnknownValue(launch_stage::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for LaunchStage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Preview => serializer.serialize_i32(1),
            Self::Ga => serializer.serialize_i32(2),
            Self::Deprecated => serializer.serialize_i32(3),
            Self::PrivatePreview => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for LaunchStage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<LaunchStage>::new(
            ".google.cloud.connectors.v1.LaunchStage",
        ))
    }
}

/// All possible data types of a entity or action field.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DataType {
    /// Data type is not specified.
    Unspecified,
    /// DEPRECATED! Use DATA_TYPE_INTEGER.
    #[deprecated]
    Int,
    /// Short integer(int16) data type.
    Smallint,
    /// Double data type.
    Double,
    /// Date data type.
    Date,
    /// DEPRECATED! Use DATA_TYPE_TIMESTAMP.
    #[deprecated]
    Datetime,
    /// Time data type.
    Time,
    /// DEPRECATED! Use DATA_TYPE_VARCHAR.
    #[deprecated]
    String,
    /// DEPRECATED! Use DATA_TYPE_BIGINT.
    #[deprecated]
    Long,
    /// Boolean data type.
    Boolean,
    /// Decimal data type.
    Decimal,
    /// DEPRECATED! Use DATA_TYPE_VARCHAR.
    #[deprecated]
    Uuid,
    /// UNSUPPORTED! Binary data type.
    Blob,
    /// Bit data type.
    Bit,
    /// Small integer(int8) data type.
    Tinyint,
    /// Integer(int32) data type.
    Integer,
    /// Long integer(int64) data type.
    Bigint,
    /// Float data type.
    Float,
    /// Real data type.
    Real,
    /// Numeric data type.
    Numeric,
    /// Char data type.
    Char,
    /// Varchar data type.
    Varchar,
    /// Longvarchar data type.
    Longvarchar,
    /// Timestamp data type.
    Timestamp,
    /// Nchar data type.
    Nchar,
    /// Nvarchar data type.
    Nvarchar,
    /// Longnvarchar data type.
    Longnvarchar,
    /// Null data type.
    Null,
    /// UNSUPPORTED! Binary data type.
    Other,
    /// UNSUPPORTED! Binary data type.
    JavaObject,
    /// UNSUPPORTED! Binary data type.
    Distinct,
    /// UNSUPPORTED! Binary data type.
    Struct,
    /// UNSUPPORTED! Binary data type.
    Array,
    /// UNSUPPORTED! Binary data type.
    Clob,
    /// UNSUPPORTED! Binary data type.
    Ref,
    /// UNSUPPORTED! Binary data type.
    Datalink,
    /// UNSUPPORTED! Row id data type.
    Rowid,
    /// UNSUPPORTED! Binary data type.
    Binary,
    /// UNSUPPORTED! Variable binary data type.
    Varbinary,
    /// UNSUPPORTED! Long variable binary data type.
    Longvarbinary,
    /// UNSUPPORTED! NCLOB data type.
    Nclob,
    /// UNSUPPORTED! SQL XML data type is not supported.
    Sqlxml,
    /// UNSUPPORTED! Cursor reference type is not supported.
    RefCursor,
    /// UNSUPPORTED! Use TIME or TIMESTAMP instead.
    TimeWithTimezone,
    /// UNSUPPORTED! Use TIMESTAMP instead.
    TimestampWithTimezone,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DataType::value] or
    /// [DataType::name].
    UnknownValue(data_type::UnknownValue),
}

#[doc(hidden)]
pub mod data_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DataType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Int => std::option::Option::Some(1),
            Self::Smallint => std::option::Option::Some(2),
            Self::Double => std::option::Option::Some(3),
            Self::Date => std::option::Option::Some(4),
            Self::Datetime => std::option::Option::Some(5),
            Self::Time => std::option::Option::Some(6),
            Self::String => std::option::Option::Some(7),
            Self::Long => std::option::Option::Some(8),
            Self::Boolean => std::option::Option::Some(9),
            Self::Decimal => std::option::Option::Some(10),
            Self::Uuid => std::option::Option::Some(11),
            Self::Blob => std::option::Option::Some(12),
            Self::Bit => std::option::Option::Some(13),
            Self::Tinyint => std::option::Option::Some(14),
            Self::Integer => std::option::Option::Some(15),
            Self::Bigint => std::option::Option::Some(16),
            Self::Float => std::option::Option::Some(17),
            Self::Real => std::option::Option::Some(18),
            Self::Numeric => std::option::Option::Some(19),
            Self::Char => std::option::Option::Some(20),
            Self::Varchar => std::option::Option::Some(21),
            Self::Longvarchar => std::option::Option::Some(22),
            Self::Timestamp => std::option::Option::Some(23),
            Self::Nchar => std::option::Option::Some(24),
            Self::Nvarchar => std::option::Option::Some(25),
            Self::Longnvarchar => std::option::Option::Some(26),
            Self::Null => std::option::Option::Some(27),
            Self::Other => std::option::Option::Some(28),
            Self::JavaObject => std::option::Option::Some(29),
            Self::Distinct => std::option::Option::Some(30),
            Self::Struct => std::option::Option::Some(31),
            Self::Array => std::option::Option::Some(32),
            Self::Clob => std::option::Option::Some(33),
            Self::Ref => std::option::Option::Some(34),
            Self::Datalink => std::option::Option::Some(35),
            Self::Rowid => std::option::Option::Some(36),
            Self::Binary => std::option::Option::Some(37),
            Self::Varbinary => std::option::Option::Some(38),
            Self::Longvarbinary => std::option::Option::Some(39),
            Self::Nclob => std::option::Option::Some(40),
            Self::Sqlxml => std::option::Option::Some(41),
            Self::RefCursor => std::option::Option::Some(42),
            Self::TimeWithTimezone => std::option::Option::Some(43),
            Self::TimestampWithTimezone => std::option::Option::Some(44),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DATA_TYPE_UNSPECIFIED"),
            Self::Int => std::option::Option::Some("DATA_TYPE_INT"),
            Self::Smallint => std::option::Option::Some("DATA_TYPE_SMALLINT"),
            Self::Double => std::option::Option::Some("DATA_TYPE_DOUBLE"),
            Self::Date => std::option::Option::Some("DATA_TYPE_DATE"),
            Self::Datetime => std::option::Option::Some("DATA_TYPE_DATETIME"),
            Self::Time => std::option::Option::Some("DATA_TYPE_TIME"),
            Self::String => std::option::Option::Some("DATA_TYPE_STRING"),
            Self::Long => std::option::Option::Some("DATA_TYPE_LONG"),
            Self::Boolean => std::option::Option::Some("DATA_TYPE_BOOLEAN"),
            Self::Decimal => std::option::Option::Some("DATA_TYPE_DECIMAL"),
            Self::Uuid => std::option::Option::Some("DATA_TYPE_UUID"),
            Self::Blob => std::option::Option::Some("DATA_TYPE_BLOB"),
            Self::Bit => std::option::Option::Some("DATA_TYPE_BIT"),
            Self::Tinyint => std::option::Option::Some("DATA_TYPE_TINYINT"),
            Self::Integer => std::option::Option::Some("DATA_TYPE_INTEGER"),
            Self::Bigint => std::option::Option::Some("DATA_TYPE_BIGINT"),
            Self::Float => std::option::Option::Some("DATA_TYPE_FLOAT"),
            Self::Real => std::option::Option::Some("DATA_TYPE_REAL"),
            Self::Numeric => std::option::Option::Some("DATA_TYPE_NUMERIC"),
            Self::Char => std::option::Option::Some("DATA_TYPE_CHAR"),
            Self::Varchar => std::option::Option::Some("DATA_TYPE_VARCHAR"),
            Self::Longvarchar => std::option::Option::Some("DATA_TYPE_LONGVARCHAR"),
            Self::Timestamp => std::option::Option::Some("DATA_TYPE_TIMESTAMP"),
            Self::Nchar => std::option::Option::Some("DATA_TYPE_NCHAR"),
            Self::Nvarchar => std::option::Option::Some("DATA_TYPE_NVARCHAR"),
            Self::Longnvarchar => std::option::Option::Some("DATA_TYPE_LONGNVARCHAR"),
            Self::Null => std::option::Option::Some("DATA_TYPE_NULL"),
            Self::Other => std::option::Option::Some("DATA_TYPE_OTHER"),
            Self::JavaObject => std::option::Option::Some("DATA_TYPE_JAVA_OBJECT"),
            Self::Distinct => std::option::Option::Some("DATA_TYPE_DISTINCT"),
            Self::Struct => std::option::Option::Some("DATA_TYPE_STRUCT"),
            Self::Array => std::option::Option::Some("DATA_TYPE_ARRAY"),
            Self::Clob => std::option::Option::Some("DATA_TYPE_CLOB"),
            Self::Ref => std::option::Option::Some("DATA_TYPE_REF"),
            Self::Datalink => std::option::Option::Some("DATA_TYPE_DATALINK"),
            Self::Rowid => std::option::Option::Some("DATA_TYPE_ROWID"),
            Self::Binary => std::option::Option::Some("DATA_TYPE_BINARY"),
            Self::Varbinary => std::option::Option::Some("DATA_TYPE_VARBINARY"),
            Self::Longvarbinary => std::option::Option::Some("DATA_TYPE_LONGVARBINARY"),
            Self::Nclob => std::option::Option::Some("DATA_TYPE_NCLOB"),
            Self::Sqlxml => std::option::Option::Some("DATA_TYPE_SQLXML"),
            Self::RefCursor => std::option::Option::Some("DATA_TYPE_REF_CURSOR"),
            Self::TimeWithTimezone => std::option::Option::Some("DATA_TYPE_TIME_WITH_TIMEZONE"),
            Self::TimestampWithTimezone => {
                std::option::Option::Some("DATA_TYPE_TIMESTAMP_WITH_TIMEZONE")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DataType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DataType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DataType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Int,
            2 => Self::Smallint,
            3 => Self::Double,
            4 => Self::Date,
            5 => Self::Datetime,
            6 => Self::Time,
            7 => Self::String,
            8 => Self::Long,
            9 => Self::Boolean,
            10 => Self::Decimal,
            11 => Self::Uuid,
            12 => Self::Blob,
            13 => Self::Bit,
            14 => Self::Tinyint,
            15 => Self::Integer,
            16 => Self::Bigint,
            17 => Self::Float,
            18 => Self::Real,
            19 => Self::Numeric,
            20 => Self::Char,
            21 => Self::Varchar,
            22 => Self::Longvarchar,
            23 => Self::Timestamp,
            24 => Self::Nchar,
            25 => Self::Nvarchar,
            26 => Self::Longnvarchar,
            27 => Self::Null,
            28 => Self::Other,
            29 => Self::JavaObject,
            30 => Self::Distinct,
            31 => Self::Struct,
            32 => Self::Array,
            33 => Self::Clob,
            34 => Self::Ref,
            35 => Self::Datalink,
            36 => Self::Rowid,
            37 => Self::Binary,
            38 => Self::Varbinary,
            39 => Self::Longvarbinary,
            40 => Self::Nclob,
            41 => Self::Sqlxml,
            42 => Self::RefCursor,
            43 => Self::TimeWithTimezone,
            44 => Self::TimestampWithTimezone,
            _ => Self::UnknownValue(data_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DataType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATA_TYPE_UNSPECIFIED" => Self::Unspecified,
            "DATA_TYPE_INT" => Self::Int,
            "DATA_TYPE_SMALLINT" => Self::Smallint,
            "DATA_TYPE_DOUBLE" => Self::Double,
            "DATA_TYPE_DATE" => Self::Date,
            "DATA_TYPE_DATETIME" => Self::Datetime,
            "DATA_TYPE_TIME" => Self::Time,
            "DATA_TYPE_STRING" => Self::String,
            "DATA_TYPE_LONG" => Self::Long,
            "DATA_TYPE_BOOLEAN" => Self::Boolean,
            "DATA_TYPE_DECIMAL" => Self::Decimal,
            "DATA_TYPE_UUID" => Self::Uuid,
            "DATA_TYPE_BLOB" => Self::Blob,
            "DATA_TYPE_BIT" => Self::Bit,
            "DATA_TYPE_TINYINT" => Self::Tinyint,
            "DATA_TYPE_INTEGER" => Self::Integer,
            "DATA_TYPE_BIGINT" => Self::Bigint,
            "DATA_TYPE_FLOAT" => Self::Float,
            "DATA_TYPE_REAL" => Self::Real,
            "DATA_TYPE_NUMERIC" => Self::Numeric,
            "DATA_TYPE_CHAR" => Self::Char,
            "DATA_TYPE_VARCHAR" => Self::Varchar,
            "DATA_TYPE_LONGVARCHAR" => Self::Longvarchar,
            "DATA_TYPE_TIMESTAMP" => Self::Timestamp,
            "DATA_TYPE_NCHAR" => Self::Nchar,
            "DATA_TYPE_NVARCHAR" => Self::Nvarchar,
            "DATA_TYPE_LONGNVARCHAR" => Self::Longnvarchar,
            "DATA_TYPE_NULL" => Self::Null,
            "DATA_TYPE_OTHER" => Self::Other,
            "DATA_TYPE_JAVA_OBJECT" => Self::JavaObject,
            "DATA_TYPE_DISTINCT" => Self::Distinct,
            "DATA_TYPE_STRUCT" => Self::Struct,
            "DATA_TYPE_ARRAY" => Self::Array,
            "DATA_TYPE_CLOB" => Self::Clob,
            "DATA_TYPE_REF" => Self::Ref,
            "DATA_TYPE_DATALINK" => Self::Datalink,
            "DATA_TYPE_ROWID" => Self::Rowid,
            "DATA_TYPE_BINARY" => Self::Binary,
            "DATA_TYPE_VARBINARY" => Self::Varbinary,
            "DATA_TYPE_LONGVARBINARY" => Self::Longvarbinary,
            "DATA_TYPE_NCLOB" => Self::Nclob,
            "DATA_TYPE_SQLXML" => Self::Sqlxml,
            "DATA_TYPE_REF_CURSOR" => Self::RefCursor,
            "DATA_TYPE_TIME_WITH_TIMEZONE" => Self::TimeWithTimezone,
            "DATA_TYPE_TIMESTAMP_WITH_TIMEZONE" => Self::TimestampWithTimezone,
            _ => Self::UnknownValue(data_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DataType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Int => serializer.serialize_i32(1),
            Self::Smallint => serializer.serialize_i32(2),
            Self::Double => serializer.serialize_i32(3),
            Self::Date => serializer.serialize_i32(4),
            Self::Datetime => serializer.serialize_i32(5),
            Self::Time => serializer.serialize_i32(6),
            Self::String => serializer.serialize_i32(7),
            Self::Long => serializer.serialize_i32(8),
            Self::Boolean => serializer.serialize_i32(9),
            Self::Decimal => serializer.serialize_i32(10),
            Self::Uuid => serializer.serialize_i32(11),
            Self::Blob => serializer.serialize_i32(12),
            Self::Bit => serializer.serialize_i32(13),
            Self::Tinyint => serializer.serialize_i32(14),
            Self::Integer => serializer.serialize_i32(15),
            Self::Bigint => serializer.serialize_i32(16),
            Self::Float => serializer.serialize_i32(17),
            Self::Real => serializer.serialize_i32(18),
            Self::Numeric => serializer.serialize_i32(19),
            Self::Char => serializer.serialize_i32(20),
            Self::Varchar => serializer.serialize_i32(21),
            Self::Longvarchar => serializer.serialize_i32(22),
            Self::Timestamp => serializer.serialize_i32(23),
            Self::Nchar => serializer.serialize_i32(24),
            Self::Nvarchar => serializer.serialize_i32(25),
            Self::Longnvarchar => serializer.serialize_i32(26),
            Self::Null => serializer.serialize_i32(27),
            Self::Other => serializer.serialize_i32(28),
            Self::JavaObject => serializer.serialize_i32(29),
            Self::Distinct => serializer.serialize_i32(30),
            Self::Struct => serializer.serialize_i32(31),
            Self::Array => serializer.serialize_i32(32),
            Self::Clob => serializer.serialize_i32(33),
            Self::Ref => serializer.serialize_i32(34),
            Self::Datalink => serializer.serialize_i32(35),
            Self::Rowid => serializer.serialize_i32(36),
            Self::Binary => serializer.serialize_i32(37),
            Self::Varbinary => serializer.serialize_i32(38),
            Self::Longvarbinary => serializer.serialize_i32(39),
            Self::Nclob => serializer.serialize_i32(40),
            Self::Sqlxml => serializer.serialize_i32(41),
            Self::RefCursor => serializer.serialize_i32(42),
            Self::TimeWithTimezone => serializer.serialize_i32(43),
            Self::TimestampWithTimezone => serializer.serialize_i32(44),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DataType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataType>::new(
            ".google.cloud.connectors.v1.DataType",
        ))
    }
}

/// Enum to control which fields should be included in the response.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ConnectionView {
    /// CONNECTION_UNSPECIFIED.
    Unspecified,
    /// Do not include runtime required configs.
    Basic,
    /// Include runtime required configs.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ConnectionView::value] or
    /// [ConnectionView::name].
    UnknownValue(connection_view::UnknownValue),
}

#[doc(hidden)]
pub mod connection_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ConnectionView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CONNECTION_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("BASIC"),
            Self::Full => std::option::Option::Some("FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ConnectionView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ConnectionView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ConnectionView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(connection_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ConnectionView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CONNECTION_VIEW_UNSPECIFIED" => Self::Unspecified,
            "BASIC" => Self::Basic,
            "FULL" => Self::Full,
            _ => Self::UnknownValue(connection_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ConnectionView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ConnectionView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConnectionView>::new(
            ".google.cloud.connectors.v1.ConnectionView",
        ))
    }
}

/// Enum to control which fields should be included in the response.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ConnectorVersionView {
    /// CONNECTOR_VERSION_VIEW_UNSPECIFIED.
    Unspecified,
    /// Do not include role grant configs.
    Basic,
    /// Include role grant configs.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ConnectorVersionView::value] or
    /// [ConnectorVersionView::name].
    UnknownValue(connector_version_view::UnknownValue),
}

#[doc(hidden)]
pub mod connector_version_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ConnectorVersionView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CONNECTOR_VERSION_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("CONNECTOR_VERSION_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("CONNECTOR_VERSION_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ConnectorVersionView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ConnectorVersionView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ConnectorVersionView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(connector_version_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ConnectorVersionView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CONNECTOR_VERSION_VIEW_UNSPECIFIED" => Self::Unspecified,
            "CONNECTOR_VERSION_VIEW_BASIC" => Self::Basic,
            "CONNECTOR_VERSION_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(connector_version_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ConnectorVersionView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ConnectorVersionView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConnectorVersionView>::new(
            ".google.cloud.connectors.v1.ConnectorVersionView",
        ))
    }
}

/// Enum for controlling the SSL Type (TLS/MTLS)
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SslType {
    /// No SSL configuration required.
    Unspecified,
    /// TLS Handshake
    Tls,
    /// mutual TLS (MTLS) Handshake
    Mtls,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SslType::value] or
    /// [SslType::name].
    UnknownValue(ssl_type::UnknownValue),
}

#[doc(hidden)]
pub mod ssl_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SslType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Tls => std::option::Option::Some(1),
            Self::Mtls => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SSL_TYPE_UNSPECIFIED"),
            Self::Tls => std::option::Option::Some("TLS"),
            Self::Mtls => std::option::Option::Some("MTLS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SslType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SslType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SslType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Tls,
            2 => Self::Mtls,
            _ => Self::UnknownValue(ssl_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SslType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SSL_TYPE_UNSPECIFIED" => Self::Unspecified,
            "TLS" => Self::Tls,
            "MTLS" => Self::Mtls,
            _ => Self::UnknownValue(ssl_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SslType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Tls => serializer.serialize_i32(1),
            Self::Mtls => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SslType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SslType>::new(
            ".google.cloud.connectors.v1.SslType",
        ))
    }
}

/// Enum for Cert Types
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CertType {
    /// Cert type unspecified.
    Unspecified,
    /// Privacy Enhanced Mail (PEM) Type
    Pem,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CertType::value] or
    /// [CertType::name].
    UnknownValue(cert_type::UnknownValue),
}

#[doc(hidden)]
pub mod cert_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CertType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Pem => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CERT_TYPE_UNSPECIFIED"),
            Self::Pem => std::option::Option::Some("PEM"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CertType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CertType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CertType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Pem,
            _ => Self::UnknownValue(cert_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for CertType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CERT_TYPE_UNSPECIFIED" => Self::Unspecified,
            "PEM" => Self::Pem,
            _ => Self::UnknownValue(cert_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for CertType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Pem => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CertType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CertType>::new(
            ".google.cloud.connectors.v1.CertType",
        ))
    }
}
