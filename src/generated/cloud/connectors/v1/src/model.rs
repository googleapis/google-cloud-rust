// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// AuthConfig defines details of a authentication type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AuthConfig {
    /// The type of authentication configured.
    pub auth_type: crate::model::AuthType,

    /// List containing additional auth configs.
    pub additional_variables: std::vec::Vec<crate::model::ConfigVariable>,

    /// Supported auth types.
    pub r#type: std::option::Option<crate::model::auth_config::Type>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuthConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auth_type][crate::model::AuthConfig::auth_type].
    pub fn set_auth_type<T: std::convert::Into<crate::model::AuthType>>(mut self, v: T) -> Self {
        self.auth_type = v.into();
        self
    }

    /// Sets the value of [additional_variables][crate::model::AuthConfig::additional_variables].
    pub fn set_additional_variables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConfigVariable>,
    {
        use std::iter::Iterator;
        self.additional_variables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [r#type][crate::model::AuthConfig::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<T: std::convert::Into<std::option::Option<crate::model::auth_config::Type>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::AuthConfig::r#type]
    /// if it holds a `UserPassword`, `None` if the field is not set or
    /// holds a different branch.
    pub fn user_password(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::auth_config::UserPassword>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::auth_config::Type::UserPassword(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::AuthConfig::r#type]
    /// to hold a `UserPassword`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_user_password<
        T: std::convert::Into<std::boxed::Box<crate::model::auth_config::UserPassword>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::auth_config::Type::UserPassword(v.into()));
        self
    }

    /// The value of [r#type][crate::model::AuthConfig::r#type]
    /// if it holds a `Oauth2JwtBearer`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oauth2_jwt_bearer(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::auth_config::Oauth2JwtBearer>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::auth_config::Type::Oauth2JwtBearer(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::AuthConfig::r#type]
    /// to hold a `Oauth2JwtBearer`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_oauth2_jwt_bearer<
        T: std::convert::Into<std::boxed::Box<crate::model::auth_config::Oauth2JwtBearer>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::auth_config::Type::Oauth2JwtBearer(v.into()));
        self
    }

    /// The value of [r#type][crate::model::AuthConfig::r#type]
    /// if it holds a `Oauth2ClientCredentials`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oauth2_client_credentials(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::auth_config::Oauth2ClientCredentials>>
    {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::auth_config::Type::Oauth2ClientCredentials(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::AuthConfig::r#type]
    /// to hold a `Oauth2ClientCredentials`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_oauth2_client_credentials<
        T: std::convert::Into<std::boxed::Box<crate::model::auth_config::Oauth2ClientCredentials>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::auth_config::Type::Oauth2ClientCredentials(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::AuthConfig::r#type]
    /// if it holds a `SshPublicKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ssh_public_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::auth_config::SshPublicKey>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::auth_config::Type::SshPublicKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::AuthConfig::r#type]
    /// to hold a `SshPublicKey`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_ssh_public_key<
        T: std::convert::Into<std::boxed::Box<crate::model::auth_config::SshPublicKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::auth_config::Type::SshPublicKey(v.into()));
        self
    }
}

impl wkt::message::Message for AuthConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.AuthConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AuthConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __auth_type,
            __user_password,
            __oauth2_jwt_bearer,
            __oauth2_client_credentials,
            __ssh_public_key,
            __additional_variables,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AuthConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "authType" => Ok(__FieldTag::__auth_type),
                            "auth_type" => Ok(__FieldTag::__auth_type),
                            "userPassword" => Ok(__FieldTag::__user_password),
                            "user_password" => Ok(__FieldTag::__user_password),
                            "oauth2JwtBearer" => Ok(__FieldTag::__oauth2_jwt_bearer),
                            "oauth2_jwt_bearer" => Ok(__FieldTag::__oauth2_jwt_bearer),
                            "oauth2ClientCredentials" => {
                                Ok(__FieldTag::__oauth2_client_credentials)
                            }
                            "oauth2_client_credentials" => {
                                Ok(__FieldTag::__oauth2_client_credentials)
                            }
                            "sshPublicKey" => Ok(__FieldTag::__ssh_public_key),
                            "ssh_public_key" => Ok(__FieldTag::__ssh_public_key),
                            "additionalVariables" => Ok(__FieldTag::__additional_variables),
                            "additional_variables" => Ok(__FieldTag::__additional_variables),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AuthConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AuthConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__auth_type => {
                            if !fields.insert(__FieldTag::__auth_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auth_type",
                                ));
                            }
                            result.auth_type = map
                                .next_value::<std::option::Option<crate::model::AuthType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_password => {
                            if !fields.insert(__FieldTag::__user_password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_password",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.cloud.connectors.v1.AuthConfig.user_password, latest field was userPassword",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::auth_config::Type::UserPassword(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::auth_config::UserPassword>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__oauth2_jwt_bearer => {
                            if !fields.insert(__FieldTag::__oauth2_jwt_bearer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth2_jwt_bearer",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.cloud.connectors.v1.AuthConfig.oauth2_jwt_bearer, latest field was oauth2JwtBearer",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::auth_config::Type::Oauth2JwtBearer(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::auth_config::Oauth2JwtBearer>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__oauth2_client_credentials => {
                            if !fields.insert(__FieldTag::__oauth2_client_credentials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth2_client_credentials",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.cloud.connectors.v1.AuthConfig.oauth2_client_credentials, latest field was oauth2ClientCredentials",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::auth_config::Type::Oauth2ClientCredentials(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::auth_config::Oauth2ClientCredentials,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__ssh_public_key => {
                            if !fields.insert(__FieldTag::__ssh_public_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssh_public_key",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.cloud.connectors.v1.AuthConfig.ssh_public_key, latest field was sshPublicKey",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::auth_config::Type::SshPublicKey(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::auth_config::SshPublicKey>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__additional_variables => {
                            if !fields.insert(__FieldTag::__additional_variables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_variables",
                                ));
                            }
                            result.additional_variables =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConfigVariable>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AuthConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.auth_type) {
            state.serialize_entry("authType", &self.auth_type)?;
        }
        if let Some(value) = self.user_password() {
            state.serialize_entry("userPassword", value)?;
        }
        if let Some(value) = self.oauth2_jwt_bearer() {
            state.serialize_entry("oauth2JwtBearer", value)?;
        }
        if let Some(value) = self.oauth2_client_credentials() {
            state.serialize_entry("oauth2ClientCredentials", value)?;
        }
        if let Some(value) = self.ssh_public_key() {
            state.serialize_entry("sshPublicKey", value)?;
        }
        if !self.additional_variables.is_empty() {
            state.serialize_entry("additionalVariables", &self.additional_variables)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AuthConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AuthConfig");
        debug_struct.field("auth_type", &self.auth_type);
        debug_struct.field("additional_variables", &self.additional_variables);
        debug_struct.field("r#type", &self.r#type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AuthConfig].
pub mod auth_config {
    #[allow(unused_imports)]
    use super::*;

    /// Parameters to support Username and Password Authentication.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UserPassword {
        /// Username.
        pub username: std::string::String,

        /// Secret version reference containing the password.
        pub password: std::option::Option<crate::model::Secret>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UserPassword {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [username][crate::model::auth_config::UserPassword::username].
        pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.username = v.into();
            self
        }

        /// Sets the value of [password][crate::model::auth_config::UserPassword::password].
        pub fn set_password<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.password = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [password][crate::model::auth_config::UserPassword::password].
        pub fn set_or_clear_password<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.password = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for UserPassword {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.connectors.v1.AuthConfig.UserPassword"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for UserPassword {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __username,
                __password,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for UserPassword")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "username" => Ok(__FieldTag::__username),
                                "password" => Ok(__FieldTag::__password),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = UserPassword;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct UserPassword")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__username => {
                                if !fields.insert(__FieldTag::__username) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for username",
                                    ));
                                }
                                result.username = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__password => {
                                if !fields.insert(__FieldTag::__password) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for password",
                                    ));
                                }
                                result.password =
                                    map.next_value::<std::option::Option<crate::model::Secret>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for UserPassword {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.username.is_empty() {
                state.serialize_entry("username", &self.username)?;
            }
            if self.password.is_some() {
                state.serialize_entry("password", &self.password)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for UserPassword {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("UserPassword");
            debug_struct.field("username", &self.username);
            debug_struct.field("password", &self.password);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Parameters to support JSON Web Token (JWT) Profile for Oauth 2.0
    /// Authorization Grant based authentication.
    /// See <https://tools.ietf.org/html/rfc7523> for more details.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Oauth2JwtBearer {
        /// Secret version reference containing a PKCS#8 PEM-encoded private
        /// key associated with the Client Certificate. This private key will be
        /// used to sign JWTs used for the jwt-bearer authorization grant.
        /// Specified in the form as: `projects/*/secrets/*/versions/*`.
        pub client_key: std::option::Option<crate::model::Secret>,

        /// JwtClaims providers fields to generate the token.
        pub jwt_claims:
            std::option::Option<crate::model::auth_config::oauth_2_jwt_bearer::JwtClaims>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Oauth2JwtBearer {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [client_key][crate::model::auth_config::Oauth2JwtBearer::client_key].
        pub fn set_client_key<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.client_key = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [client_key][crate::model::auth_config::Oauth2JwtBearer::client_key].
        pub fn set_or_clear_client_key<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.client_key = v.map(|x| x.into());
            self
        }

        /// Sets the value of [jwt_claims][crate::model::auth_config::Oauth2JwtBearer::jwt_claims].
        pub fn set_jwt_claims<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::auth_config::oauth_2_jwt_bearer::JwtClaims>,
        {
            self.jwt_claims = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [jwt_claims][crate::model::auth_config::Oauth2JwtBearer::jwt_claims].
        pub fn set_or_clear_jwt_claims<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::auth_config::oauth_2_jwt_bearer::JwtClaims>,
        {
            self.jwt_claims = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Oauth2JwtBearer {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.connectors.v1.AuthConfig.Oauth2JwtBearer"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Oauth2JwtBearer {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __client_key,
                __jwt_claims,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Oauth2JwtBearer")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "clientKey" => Ok(__FieldTag::__client_key),
                                "client_key" => Ok(__FieldTag::__client_key),
                                "jwtClaims" => Ok(__FieldTag::__jwt_claims),
                                "jwt_claims" => Ok(__FieldTag::__jwt_claims),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Oauth2JwtBearer;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Oauth2JwtBearer")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__client_key => {
                                if !fields.insert(__FieldTag::__client_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for client_key",
                                    ));
                                }
                                result.client_key =
                                    map.next_value::<std::option::Option<crate::model::Secret>>()?;
                            }
                            __FieldTag::__jwt_claims => {
                                if !fields.insert(__FieldTag::__jwt_claims) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for jwt_claims",
                                    ));
                                }
                                result.jwt_claims = map.next_value::<std::option::Option<
                                    crate::model::auth_config::oauth_2_jwt_bearer::JwtClaims,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Oauth2JwtBearer {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.client_key.is_some() {
                state.serialize_entry("clientKey", &self.client_key)?;
            }
            if self.jwt_claims.is_some() {
                state.serialize_entry("jwtClaims", &self.jwt_claims)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Oauth2JwtBearer {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Oauth2JwtBearer");
            debug_struct.field("client_key", &self.client_key);
            debug_struct.field("jwt_claims", &self.jwt_claims);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Oauth2JwtBearer].
    pub mod oauth_2_jwt_bearer {
        #[allow(unused_imports)]
        use super::*;

        /// JWT claims used for the jwt-bearer authorization grant.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct JwtClaims {
            /// Value for the "iss" claim.
            pub issuer: std::string::String,

            /// Value for the "sub" claim.
            pub subject: std::string::String,

            /// Value for the "aud" claim.
            pub audience: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl JwtClaims {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [issuer][crate::model::auth_config::oauth_2_jwt_bearer::JwtClaims::issuer].
            pub fn set_issuer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.issuer = v.into();
                self
            }

            /// Sets the value of [subject][crate::model::auth_config::oauth_2_jwt_bearer::JwtClaims::subject].
            pub fn set_subject<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.subject = v.into();
                self
            }

            /// Sets the value of [audience][crate::model::auth_config::oauth_2_jwt_bearer::JwtClaims::audience].
            pub fn set_audience<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.audience = v.into();
                self
            }
        }

        impl wkt::message::Message for JwtClaims {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.connectors.v1.AuthConfig.Oauth2JwtBearer.JwtClaims"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for JwtClaims {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __issuer,
                    __subject,
                    __audience,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for JwtClaims")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "issuer" => Ok(__FieldTag::__issuer),
                                    "subject" => Ok(__FieldTag::__subject),
                                    "audience" => Ok(__FieldTag::__audience),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = JwtClaims;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct JwtClaims")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__issuer => {
                                    if !fields.insert(__FieldTag::__issuer) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for issuer"),
                                        );
                                    }
                                    result.issuer = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__subject => {
                                    if !fields.insert(__FieldTag::__subject) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for subject",
                                            ),
                                        );
                                    }
                                    result.subject = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__audience => {
                                    if !fields.insert(__FieldTag::__audience) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for audience",
                                            ),
                                        );
                                    }
                                    result.audience = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for JwtClaims {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.issuer.is_empty() {
                    state.serialize_entry("issuer", &self.issuer)?;
                }
                if !self.subject.is_empty() {
                    state.serialize_entry("subject", &self.subject)?;
                }
                if !self.audience.is_empty() {
                    state.serialize_entry("audience", &self.audience)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for JwtClaims {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("JwtClaims");
                debug_struct.field("issuer", &self.issuer);
                debug_struct.field("subject", &self.subject);
                debug_struct.field("audience", &self.audience);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// Parameters to support Oauth 2.0 Client Credentials Grant Authentication.
    /// See <https://tools.ietf.org/html/rfc6749#section-1.3.4> for more details.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Oauth2ClientCredentials {
        /// The client identifier.
        pub client_id: std::string::String,

        /// Secret version reference containing the client secret.
        pub client_secret: std::option::Option<crate::model::Secret>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Oauth2ClientCredentials {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [client_id][crate::model::auth_config::Oauth2ClientCredentials::client_id].
        pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client_id = v.into();
            self
        }

        /// Sets the value of [client_secret][crate::model::auth_config::Oauth2ClientCredentials::client_secret].
        pub fn set_client_secret<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.client_secret = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [client_secret][crate::model::auth_config::Oauth2ClientCredentials::client_secret].
        pub fn set_or_clear_client_secret<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.client_secret = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Oauth2ClientCredentials {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.connectors.v1.AuthConfig.Oauth2ClientCredentials"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Oauth2ClientCredentials {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __client_id,
                __client_secret,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Oauth2ClientCredentials")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "clientId" => Ok(__FieldTag::__client_id),
                                "client_id" => Ok(__FieldTag::__client_id),
                                "clientSecret" => Ok(__FieldTag::__client_secret),
                                "client_secret" => Ok(__FieldTag::__client_secret),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Oauth2ClientCredentials;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Oauth2ClientCredentials")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__client_id => {
                                if !fields.insert(__FieldTag::__client_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for client_id",
                                    ));
                                }
                                result.client_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__client_secret => {
                                if !fields.insert(__FieldTag::__client_secret) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for client_secret",
                                    ));
                                }
                                result.client_secret =
                                    map.next_value::<std::option::Option<crate::model::Secret>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Oauth2ClientCredentials {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.client_id.is_empty() {
                state.serialize_entry("clientId", &self.client_id)?;
            }
            if self.client_secret.is_some() {
                state.serialize_entry("clientSecret", &self.client_secret)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Oauth2ClientCredentials {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Oauth2ClientCredentials");
            debug_struct.field("client_id", &self.client_id);
            debug_struct.field("client_secret", &self.client_secret);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Parameters to support Ssh public key Authentication.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SshPublicKey {
        /// The user account used to authenticate.
        pub username: std::string::String,

        /// SSH Client Cert. It should contain both public and private key.
        pub ssh_client_cert: std::option::Option<crate::model::Secret>,

        /// Format of SSH Client cert.
        pub cert_type: std::string::String,

        /// Password (passphrase) for ssh client certificate if it has one.
        pub ssh_client_cert_pass: std::option::Option<crate::model::Secret>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SshPublicKey {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [username][crate::model::auth_config::SshPublicKey::username].
        pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.username = v.into();
            self
        }

        /// Sets the value of [ssh_client_cert][crate::model::auth_config::SshPublicKey::ssh_client_cert].
        pub fn set_ssh_client_cert<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.ssh_client_cert = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [ssh_client_cert][crate::model::auth_config::SshPublicKey::ssh_client_cert].
        pub fn set_or_clear_ssh_client_cert<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.ssh_client_cert = v.map(|x| x.into());
            self
        }

        /// Sets the value of [cert_type][crate::model::auth_config::SshPublicKey::cert_type].
        pub fn set_cert_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cert_type = v.into();
            self
        }

        /// Sets the value of [ssh_client_cert_pass][crate::model::auth_config::SshPublicKey::ssh_client_cert_pass].
        pub fn set_ssh_client_cert_pass<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.ssh_client_cert_pass = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [ssh_client_cert_pass][crate::model::auth_config::SshPublicKey::ssh_client_cert_pass].
        pub fn set_or_clear_ssh_client_cert_pass<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.ssh_client_cert_pass = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SshPublicKey {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.connectors.v1.AuthConfig.SshPublicKey"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SshPublicKey {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __username,
                __ssh_client_cert,
                __cert_type,
                __ssh_client_cert_pass,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SshPublicKey")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "username" => Ok(__FieldTag::__username),
                                "sshClientCert" => Ok(__FieldTag::__ssh_client_cert),
                                "ssh_client_cert" => Ok(__FieldTag::__ssh_client_cert),
                                "certType" => Ok(__FieldTag::__cert_type),
                                "cert_type" => Ok(__FieldTag::__cert_type),
                                "sshClientCertPass" => Ok(__FieldTag::__ssh_client_cert_pass),
                                "ssh_client_cert_pass" => Ok(__FieldTag::__ssh_client_cert_pass),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SshPublicKey;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SshPublicKey")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__username => {
                                if !fields.insert(__FieldTag::__username) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for username",
                                    ));
                                }
                                result.username = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__ssh_client_cert => {
                                if !fields.insert(__FieldTag::__ssh_client_cert) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ssh_client_cert",
                                    ));
                                }
                                result.ssh_client_cert =
                                    map.next_value::<std::option::Option<crate::model::Secret>>()?;
                            }
                            __FieldTag::__cert_type => {
                                if !fields.insert(__FieldTag::__cert_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cert_type",
                                    ));
                                }
                                result.cert_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__ssh_client_cert_pass => {
                                if !fields.insert(__FieldTag::__ssh_client_cert_pass) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ssh_client_cert_pass",
                                    ));
                                }
                                result.ssh_client_cert_pass =
                                    map.next_value::<std::option::Option<crate::model::Secret>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SshPublicKey {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.username.is_empty() {
                state.serialize_entry("username", &self.username)?;
            }
            if self.ssh_client_cert.is_some() {
                state.serialize_entry("sshClientCert", &self.ssh_client_cert)?;
            }
            if !self.cert_type.is_empty() {
                state.serialize_entry("certType", &self.cert_type)?;
            }
            if self.ssh_client_cert_pass.is_some() {
                state.serialize_entry("sshClientCertPass", &self.ssh_client_cert_pass)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SshPublicKey {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SshPublicKey");
            debug_struct.field("username", &self.username);
            debug_struct.field("ssh_client_cert", &self.ssh_client_cert);
            debug_struct.field("cert_type", &self.cert_type);
            debug_struct.field("ssh_client_cert_pass", &self.ssh_client_cert_pass);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Supported auth types.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// UserPassword.
        UserPassword(std::boxed::Box<crate::model::auth_config::UserPassword>),
        /// Oauth2JwtBearer.
        Oauth2JwtBearer(std::boxed::Box<crate::model::auth_config::Oauth2JwtBearer>),
        /// Oauth2ClientCredentials.
        Oauth2ClientCredentials(
            std::boxed::Box<crate::model::auth_config::Oauth2ClientCredentials>,
        ),
        /// SSH Public Key.
        SshPublicKey(std::boxed::Box<crate::model::auth_config::SshPublicKey>),
    }
}

/// AuthConfigTemplate defines required field over an authentication type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AuthConfigTemplate {
    /// The type of authentication configured.
    pub auth_type: crate::model::AuthType,

    /// Config variables to describe an `AuthConfig` for a `Connection`.
    pub config_variable_templates: std::vec::Vec<crate::model::ConfigVariableTemplate>,

    /// Display name for authentication template.
    pub display_name: std::string::String,

    /// Connector specific description for an authentication template.
    pub description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuthConfigTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auth_type][crate::model::AuthConfigTemplate::auth_type].
    pub fn set_auth_type<T: std::convert::Into<crate::model::AuthType>>(mut self, v: T) -> Self {
        self.auth_type = v.into();
        self
    }

    /// Sets the value of [config_variable_templates][crate::model::AuthConfigTemplate::config_variable_templates].
    pub fn set_config_variable_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConfigVariableTemplate>,
    {
        use std::iter::Iterator;
        self.config_variable_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::AuthConfigTemplate::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::AuthConfigTemplate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for AuthConfigTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.AuthConfigTemplate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AuthConfigTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __auth_type,
            __config_variable_templates,
            __display_name,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AuthConfigTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "authType" => Ok(__FieldTag::__auth_type),
                            "auth_type" => Ok(__FieldTag::__auth_type),
                            "configVariableTemplates" => {
                                Ok(__FieldTag::__config_variable_templates)
                            }
                            "config_variable_templates" => {
                                Ok(__FieldTag::__config_variable_templates)
                            }
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AuthConfigTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AuthConfigTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__auth_type => {
                            if !fields.insert(__FieldTag::__auth_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auth_type",
                                ));
                            }
                            result.auth_type = map
                                .next_value::<std::option::Option<crate::model::AuthType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config_variable_templates => {
                            if !fields.insert(__FieldTag::__config_variable_templates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_variable_templates",
                                ));
                            }
                            result.config_variable_templates = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConfigVariableTemplate>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AuthConfigTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.auth_type) {
            state.serialize_entry("authType", &self.auth_type)?;
        }
        if !self.config_variable_templates.is_empty() {
            state.serialize_entry("configVariableTemplates", &self.config_variable_templates)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AuthConfigTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AuthConfigTemplate");
        debug_struct.field("auth_type", &self.auth_type);
        debug_struct.field("config_variable_templates", &self.config_variable_templates);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("requested_cancellation", &self.requested_cancellation);
        debug_struct.field("api_version", &self.api_version);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ConfigVariableTemplate provides metadata about a `ConfigVariable` that is
/// used in a Connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConfigVariableTemplate {
    /// Key of the config variable.
    pub key: std::string::String,

    /// Type of the parameter: string, int, bool etc.
    /// consider custom type for the benefit for the validation.
    pub value_type: crate::model::config_variable_template::ValueType,

    /// Display name of the parameter.
    pub display_name: std::string::String,

    /// Description.
    pub description: std::string::String,

    /// Regular expression in RE2 syntax used for validating the `value` of a
    /// `ConfigVariable`.
    pub validation_regex: std::string::String,

    /// Flag represents that this `ConfigVariable` must be provided for a
    /// connection.
    pub required: bool,

    /// Role grant configuration for the config variable.
    pub role_grant: std::option::Option<crate::model::RoleGrant>,

    /// Enum options. To be populated if `ValueType` is `ENUM`
    pub enum_options: std::vec::Vec<crate::model::EnumOption>,

    /// Authorization code link options. To be populated if `ValueType` is
    /// `AUTHORIZATION_CODE`
    pub authorization_code_link: std::option::Option<crate::model::AuthorizationCodeLink>,

    /// State of the config variable.
    pub state: crate::model::config_variable_template::State,

    /// Indicates if current template is part of advanced settings
    pub is_advanced: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigVariableTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::ConfigVariableTemplate::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [value_type][crate::model::ConfigVariableTemplate::value_type].
    pub fn set_value_type<
        T: std::convert::Into<crate::model::config_variable_template::ValueType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value_type = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ConfigVariableTemplate::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ConfigVariableTemplate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [validation_regex][crate::model::ConfigVariableTemplate::validation_regex].
    pub fn set_validation_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.validation_regex = v.into();
        self
    }

    /// Sets the value of [required][crate::model::ConfigVariableTemplate::required].
    pub fn set_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.required = v.into();
        self
    }

    /// Sets the value of [role_grant][crate::model::ConfigVariableTemplate::role_grant].
    pub fn set_role_grant<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RoleGrant>,
    {
        self.role_grant = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [role_grant][crate::model::ConfigVariableTemplate::role_grant].
    pub fn set_or_clear_role_grant<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RoleGrant>,
    {
        self.role_grant = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enum_options][crate::model::ConfigVariableTemplate::enum_options].
    pub fn set_enum_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnumOption>,
    {
        use std::iter::Iterator;
        self.enum_options = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [authorization_code_link][crate::model::ConfigVariableTemplate::authorization_code_link].
    pub fn set_authorization_code_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AuthorizationCodeLink>,
    {
        self.authorization_code_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorization_code_link][crate::model::ConfigVariableTemplate::authorization_code_link].
    pub fn set_or_clear_authorization_code_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AuthorizationCodeLink>,
    {
        self.authorization_code_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::ConfigVariableTemplate::state].
    pub fn set_state<T: std::convert::Into<crate::model::config_variable_template::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [is_advanced][crate::model::ConfigVariableTemplate::is_advanced].
    pub fn set_is_advanced<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_advanced = v.into();
        self
    }
}

impl wkt::message::Message for ConfigVariableTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ConfigVariableTemplate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConfigVariableTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __value_type,
            __display_name,
            __description,
            __validation_regex,
            __required,
            __role_grant,
            __enum_options,
            __authorization_code_link,
            __state,
            __is_advanced,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfigVariableTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "valueType" => Ok(__FieldTag::__value_type),
                            "value_type" => Ok(__FieldTag::__value_type),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "validationRegex" => Ok(__FieldTag::__validation_regex),
                            "validation_regex" => Ok(__FieldTag::__validation_regex),
                            "required" => Ok(__FieldTag::__required),
                            "roleGrant" => Ok(__FieldTag::__role_grant),
                            "role_grant" => Ok(__FieldTag::__role_grant),
                            "enumOptions" => Ok(__FieldTag::__enum_options),
                            "enum_options" => Ok(__FieldTag::__enum_options),
                            "authorizationCodeLink" => Ok(__FieldTag::__authorization_code_link),
                            "authorization_code_link" => Ok(__FieldTag::__authorization_code_link),
                            "state" => Ok(__FieldTag::__state),
                            "isAdvanced" => Ok(__FieldTag::__is_advanced),
                            "is_advanced" => Ok(__FieldTag::__is_advanced),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConfigVariableTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfigVariableTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value_type => {
                            if !fields.insert(__FieldTag::__value_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value_type",
                                ));
                            }
                            result.value_type = map
                                .next_value::<std::option::Option<
                                    crate::model::config_variable_template::ValueType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validation_regex => {
                            if !fields.insert(__FieldTag::__validation_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validation_regex",
                                ));
                            }
                            result.validation_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__required => {
                            if !fields.insert(__FieldTag::__required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for required",
                                ));
                            }
                            result.required = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__role_grant => {
                            if !fields.insert(__FieldTag::__role_grant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role_grant",
                                ));
                            }
                            result.role_grant =
                                map.next_value::<std::option::Option<crate::model::RoleGrant>>()?;
                        }
                        __FieldTag::__enum_options => {
                            if !fields.insert(__FieldTag::__enum_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enum_options",
                                ));
                            }
                            result.enum_options = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EnumOption>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__authorization_code_link => {
                            if !fields.insert(__FieldTag::__authorization_code_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorization_code_link",
                                ));
                            }
                            result.authorization_code_link = map.next_value::<std::option::Option<crate::model::AuthorizationCodeLink>>()?
                                ;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state =
                                map.next_value::<std::option::Option<
                                    crate::model::config_variable_template::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_advanced => {
                            if !fields.insert(__FieldTag::__is_advanced) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_advanced",
                                ));
                            }
                            result.is_advanced = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConfigVariableTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !wkt::internal::is_default(&self.value_type) {
            state.serialize_entry("valueType", &self.value_type)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.validation_regex.is_empty() {
            state.serialize_entry("validationRegex", &self.validation_regex)?;
        }
        if !wkt::internal::is_default(&self.required) {
            state.serialize_entry("required", &self.required)?;
        }
        if self.role_grant.is_some() {
            state.serialize_entry("roleGrant", &self.role_grant)?;
        }
        if !self.enum_options.is_empty() {
            state.serialize_entry("enumOptions", &self.enum_options)?;
        }
        if self.authorization_code_link.is_some() {
            state.serialize_entry("authorizationCodeLink", &self.authorization_code_link)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.is_advanced) {
            state.serialize_entry("isAdvanced", &self.is_advanced)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConfigVariableTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfigVariableTemplate");
        debug_struct.field("key", &self.key);
        debug_struct.field("value_type", &self.value_type);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("validation_regex", &self.validation_regex);
        debug_struct.field("required", &self.required);
        debug_struct.field("role_grant", &self.role_grant);
        debug_struct.field("enum_options", &self.enum_options);
        debug_struct.field("authorization_code_link", &self.authorization_code_link);
        debug_struct.field("state", &self.state);
        debug_struct.field("is_advanced", &self.is_advanced);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ConfigVariableTemplate].
pub mod config_variable_template {
    #[allow(unused_imports)]
    use super::*;

    /// ValueType indicates the data type of the value.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ValueType {
        /// Value type is not specified.
        Unspecified,
        /// Value type is string.
        String,
        /// Value type is integer.
        Int,
        /// Value type is boolean.
        Bool,
        /// Value type is secret.
        Secret,
        /// Value type is enum.
        Enum,
        /// Value type is authorization code.
        AuthorizationCode,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ValueType::value] or
        /// [ValueType::name].
        UnknownValue(value_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod value_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ValueType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::String => std::option::Option::Some(1),
                Self::Int => std::option::Option::Some(2),
                Self::Bool => std::option::Option::Some(3),
                Self::Secret => std::option::Option::Some(4),
                Self::Enum => std::option::Option::Some(5),
                Self::AuthorizationCode => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VALUE_TYPE_UNSPECIFIED"),
                Self::String => std::option::Option::Some("STRING"),
                Self::Int => std::option::Option::Some("INT"),
                Self::Bool => std::option::Option::Some("BOOL"),
                Self::Secret => std::option::Option::Some("SECRET"),
                Self::Enum => std::option::Option::Some("ENUM"),
                Self::AuthorizationCode => std::option::Option::Some("AUTHORIZATION_CODE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ValueType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ValueType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ValueType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::String,
                2 => Self::Int,
                3 => Self::Bool,
                4 => Self::Secret,
                5 => Self::Enum,
                6 => Self::AuthorizationCode,
                _ => Self::UnknownValue(value_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ValueType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VALUE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "STRING" => Self::String,
                "INT" => Self::Int,
                "BOOL" => Self::Bool,
                "SECRET" => Self::Secret,
                "ENUM" => Self::Enum,
                "AUTHORIZATION_CODE" => Self::AuthorizationCode,
                _ => Self::UnknownValue(value_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ValueType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::String => serializer.serialize_i32(1),
                Self::Int => serializer.serialize_i32(2),
                Self::Bool => serializer.serialize_i32(3),
                Self::Secret => serializer.serialize_i32(4),
                Self::Enum => serializer.serialize_i32(5),
                Self::AuthorizationCode => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ValueType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ValueType>::new(
                ".google.cloud.connectors.v1.ConfigVariableTemplate.ValueType",
            ))
        }
    }

    /// Indicates the state of the config variable.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Status is unspecified.
        Unspecified,
        /// Config variable is active
        Active,
        /// Config variable is deprecated.
        Deprecated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Deprecated => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deprecated => std::option::Option::Some("DEPRECATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Deprecated,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "DEPRECATED" => Self::Deprecated,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Deprecated => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.connectors.v1.ConfigVariableTemplate.State",
            ))
        }
    }
}

/// Secret provides a reference to entries in Secret Manager.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Secret {
    /// The resource name of the secret version in the format,
    /// format as: `projects/*/secrets/*/versions/*`.
    pub secret_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Secret {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secret_version][crate::model::Secret::secret_version].
    pub fn set_secret_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret_version = v.into();
        self
    }
}

impl wkt::message::Message for Secret {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.Secret"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Secret {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __secret_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Secret")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "secretVersion" => Ok(__FieldTag::__secret_version),
                            "secret_version" => Ok(__FieldTag::__secret_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Secret;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Secret")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__secret_version => {
                            if !fields.insert(__FieldTag::__secret_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_version",
                                ));
                            }
                            result.secret_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Secret {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.secret_version.is_empty() {
            state.serialize_entry("secretVersion", &self.secret_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Secret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Secret");
        debug_struct.field("secret_version", &self.secret_version);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// EnumOption definition
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EnumOption {
    /// Id of the option.
    pub id: std::string::String,

    /// Display name of the option.
    pub display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnumOption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::EnumOption::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::EnumOption::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for EnumOption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.EnumOption"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnumOption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnumOption")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnumOption;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnumOption")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnumOption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EnumOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnumOption");
        debug_struct.field("id", &self.id);
        debug_struct.field("display_name", &self.display_name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ConfigVariable represents a configuration variable present in a Connection.
/// or AuthConfig.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConfigVariable {
    /// Key of the config variable.
    pub key: std::string::String,

    /// Value type of the config variable.
    pub value: std::option::Option<crate::model::config_variable::Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigVariable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::ConfigVariable::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::config_variable::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::ConfigVariable::value]
    /// if it holds a `IntValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn int_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::config_variable::Value::IntValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value]
    /// to hold a `IntValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::config_variable::Value::IntValue(v.into()));
        self
    }

    /// The value of [value][crate::model::ConfigVariable::value]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::config_variable::Value::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::config_variable::Value::BoolValue(v.into()));
        self
    }

    /// The value of [value][crate::model::ConfigVariable::value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::config_variable::Value::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::config_variable::Value::StringValue(v.into()));
        self
    }

    /// The value of [value][crate::model::ConfigVariable::value]
    /// if it holds a `SecretValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn secret_value(&self) -> std::option::Option<&std::boxed::Box<crate::model::Secret>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::config_variable::Value::SecretValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value]
    /// to hold a `SecretValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_secret_value<T: std::convert::Into<std::boxed::Box<crate::model::Secret>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value =
            std::option::Option::Some(crate::model::config_variable::Value::SecretValue(v.into()));
        self
    }
}

impl wkt::message::Message for ConfigVariable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ConfigVariable"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConfigVariable {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __int_value,
            __bool_value,
            __string_value,
            __secret_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfigVariable")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "intValue" => Ok(__FieldTag::__int_value),
                            "int_value" => Ok(__FieldTag::__int_value),
                            "boolValue" => Ok(__FieldTag::__bool_value),
                            "bool_value" => Ok(__FieldTag::__bool_value),
                            "stringValue" => Ok(__FieldTag::__string_value),
                            "string_value" => Ok(__FieldTag::__string_value),
                            "secretValue" => Ok(__FieldTag::__secret_value),
                            "secret_value" => Ok(__FieldTag::__secret_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConfigVariable;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfigVariable")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__int_value => {
                            if !fields.insert(__FieldTag::__int_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for int_value",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.connectors.v1.ConfigVariable.int_value, latest field was intValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::config_variable::Value::IntValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__bool_value => {
                            if !fields.insert(__FieldTag::__bool_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bool_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.connectors.v1.ConfigVariable.bool_value, latest field was boolValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::config_variable::Value::BoolValue(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__string_value => {
                            if !fields.insert(__FieldTag::__string_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.connectors.v1.ConfigVariable.string_value, latest field was stringValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::config_variable::Value::StringValue(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__secret_value => {
                            if !fields.insert(__FieldTag::__secret_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.connectors.v1.ConfigVariable.secret_value, latest field was secretValue",
                                ));
                            }
                            result.value =
                                std::option::Option::Some(
                                    crate::model::config_variable::Value::SecretValue(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Secret>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConfigVariable {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if let Some(value) = self.int_value() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("intValue", &__With(value))?;
        }
        if let Some(value) = self.bool_value() {
            state.serialize_entry("boolValue", value)?;
        }
        if let Some(value) = self.string_value() {
            state.serialize_entry("stringValue", value)?;
        }
        if let Some(value) = self.secret_value() {
            state.serialize_entry("secretValue", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConfigVariable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfigVariable");
        debug_struct.field("key", &self.key);
        debug_struct.field("value", &self.value);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ConfigVariable].
pub mod config_variable {
    #[allow(unused_imports)]
    use super::*;

    /// Value type of the config variable.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Value {
        /// Value is an integer
        IntValue(i64),
        /// Value is a bool.
        BoolValue(bool),
        /// Value is a string.
        StringValue(std::string::String),
        /// Value is a secret.
        SecretValue(std::boxed::Box<crate::model::Secret>),
    }
}

/// This configuration defines all the Cloud IAM roles that needs to be granted
/// to a particular GCP resource for the selected prinicpal like service
/// account. These configurations will let UI display to customers what
/// IAM roles need to be granted by them. Or these configurations can be used
/// by the UI to render a 'grant' button to do the same on behalf of the user.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RoleGrant {
    /// Prinicipal/Identity for whom the role need to assigned.
    pub principal: crate::model::role_grant::Principal,

    /// List of roles that need to be granted.
    pub roles: std::vec::Vec<std::string::String>,

    /// Resource on which the roles needs to be granted for the principal.
    pub resource: std::option::Option<crate::model::role_grant::Resource>,

    /// Template that UI can use to provide helper text to customers.
    pub helper_text_template: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RoleGrant {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [principal][crate::model::RoleGrant::principal].
    pub fn set_principal<T: std::convert::Into<crate::model::role_grant::Principal>>(
        mut self,
        v: T,
    ) -> Self {
        self.principal = v.into();
        self
    }

    /// Sets the value of [roles][crate::model::RoleGrant::roles].
    pub fn set_roles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.roles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource][crate::model::RoleGrant::resource].
    pub fn set_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::role_grant::Resource>,
    {
        self.resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource][crate::model::RoleGrant::resource].
    pub fn set_or_clear_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::role_grant::Resource>,
    {
        self.resource = v.map(|x| x.into());
        self
    }

    /// Sets the value of [helper_text_template][crate::model::RoleGrant::helper_text_template].
    pub fn set_helper_text_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.helper_text_template = v.into();
        self
    }
}

impl wkt::message::Message for RoleGrant {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.RoleGrant"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RoleGrant {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __principal,
            __roles,
            __resource,
            __helper_text_template,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RoleGrant")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "principal" => Ok(__FieldTag::__principal),
                            "roles" => Ok(__FieldTag::__roles),
                            "resource" => Ok(__FieldTag::__resource),
                            "helperTextTemplate" => Ok(__FieldTag::__helper_text_template),
                            "helper_text_template" => Ok(__FieldTag::__helper_text_template),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RoleGrant;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RoleGrant")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__principal => {
                            if !fields.insert(__FieldTag::__principal) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for principal",
                                ));
                            }
                            result.principal = map.next_value::<std::option::Option<crate::model::role_grant::Principal>>()?.unwrap_or_default();
                        }
                        __FieldTag::__roles => {
                            if !fields.insert(__FieldTag::__roles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for roles",
                                ));
                            }
                            result.roles = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map.next_value::<std::option::Option<crate::model::role_grant::Resource>>()?
                                ;
                        }
                        __FieldTag::__helper_text_template => {
                            if !fields.insert(__FieldTag::__helper_text_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for helper_text_template",
                                ));
                            }
                            result.helper_text_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RoleGrant {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.principal) {
            state.serialize_entry("principal", &self.principal)?;
        }
        if !self.roles.is_empty() {
            state.serialize_entry("roles", &self.roles)?;
        }
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self.helper_text_template.is_empty() {
            state.serialize_entry("helperTextTemplate", &self.helper_text_template)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RoleGrant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RoleGrant");
        debug_struct.field("principal", &self.principal);
        debug_struct.field("roles", &self.roles);
        debug_struct.field("resource", &self.resource);
        debug_struct.field("helper_text_template", &self.helper_text_template);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RoleGrant].
pub mod role_grant {
    #[allow(unused_imports)]
    use super::*;

    /// Resource definition
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Resource {
        /// Different types of resource supported.
        pub r#type: crate::model::role_grant::resource::Type,

        /// Template to uniquely represent a GCP resource in a format IAM expects
        /// This is a template that can have references to other values provided in
        /// the config variable template.
        pub path_template: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Resource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::role_grant::Resource::type].
        pub fn set_type<T: std::convert::Into<crate::model::role_grant::resource::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [path_template][crate::model::role_grant::Resource::path_template].
        pub fn set_path_template<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.path_template = v.into();
            self
        }
    }

    impl wkt::message::Message for Resource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.connectors.v1.RoleGrant.Resource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Resource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __type,
                __path_template,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Resource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "type" => Ok(__FieldTag::__type),
                                "pathTemplate" => Ok(__FieldTag::__path_template),
                                "path_template" => Ok(__FieldTag::__path_template),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Resource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Resource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type =
                                    map.next_value::<std::option::Option<
                                        crate::model::role_grant::resource::Type,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__path_template => {
                                if !fields.insert(__FieldTag::__path_template) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for path_template",
                                    ));
                                }
                                result.path_template = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Resource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self.path_template.is_empty() {
                state.serialize_entry("pathTemplate", &self.path_template)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Resource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Resource");
            debug_struct.field("r#type", &self.r#type);
            debug_struct.field("path_template", &self.path_template);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Resource].
    pub mod resource {
        #[allow(unused_imports)]
        use super::*;

        /// Resource Type definition.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// Value type is not specified.
            Unspecified,
            /// GCP Project Resource.
            GcpProject,
            /// Any GCP Resource which is identified uniquely by IAM.
            GcpResource,
            /// GCP Secret Resource.
            GcpSecretmanagerSecret,
            /// GCP Secret Version Resource.
            GcpSecretmanagerSecretVersion,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Type::value] or
            /// [Type::name].
            UnknownValue(r#type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod r#type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Type {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::GcpProject => std::option::Option::Some(1),
                    Self::GcpResource => std::option::Option::Some(2),
                    Self::GcpSecretmanagerSecret => std::option::Option::Some(3),
                    Self::GcpSecretmanagerSecretVersion => std::option::Option::Some(4),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                    Self::GcpProject => std::option::Option::Some("GCP_PROJECT"),
                    Self::GcpResource => std::option::Option::Some("GCP_RESOURCE"),
                    Self::GcpSecretmanagerSecret => {
                        std::option::Option::Some("GCP_SECRETMANAGER_SECRET")
                    }
                    Self::GcpSecretmanagerSecretVersion => {
                        std::option::Option::Some("GCP_SECRETMANAGER_SECRET_VERSION")
                    }
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Type {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::GcpProject,
                    2 => Self::GcpResource,
                    3 => Self::GcpSecretmanagerSecret,
                    4 => Self::GcpSecretmanagerSecretVersion,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Type {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TYPE_UNSPECIFIED" => Self::Unspecified,
                    "GCP_PROJECT" => Self::GcpProject,
                    "GCP_RESOURCE" => Self::GcpResource,
                    "GCP_SECRETMANAGER_SECRET" => Self::GcpSecretmanagerSecret,
                    "GCP_SECRETMANAGER_SECRET_VERSION" => Self::GcpSecretmanagerSecretVersion,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::GcpProject => serializer.serialize_i32(1),
                    Self::GcpResource => serializer.serialize_i32(2),
                    Self::GcpSecretmanagerSecret => serializer.serialize_i32(3),
                    Self::GcpSecretmanagerSecretVersion => serializer.serialize_i32(4),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                    ".google.cloud.connectors.v1.RoleGrant.Resource.Type",
                ))
            }
        }
    }

    /// Supported Principal values.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Principal {
        /// Value type is not specified.
        Unspecified,
        /// Service Account used for Connector workload identity
        /// This is either the default service account if unspecified or Service
        /// Account provided by Customers through BYOSA.
        ConnectorSa,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Principal::value] or
        /// [Principal::name].
        UnknownValue(principal::UnknownValue),
    }

    #[doc(hidden)]
    pub mod principal {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Principal {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ConnectorSa => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PRINCIPAL_UNSPECIFIED"),
                Self::ConnectorSa => std::option::Option::Some("CONNECTOR_SA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Principal {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Principal {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Principal {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ConnectorSa,
                _ => Self::UnknownValue(principal::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Principal {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRINCIPAL_UNSPECIFIED" => Self::Unspecified,
                "CONNECTOR_SA" => Self::ConnectorSa,
                _ => Self::UnknownValue(principal::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Principal {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ConnectorSa => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Principal {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Principal>::new(
                ".google.cloud.connectors.v1.RoleGrant.Principal",
            ))
        }
    }
}

/// This configuration captures the details required to render an authorization
/// link for the OAuth Authorization Code Flow.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AuthorizationCodeLink {
    /// The base URI the user must click to trigger the authorization code login
    /// flow.
    pub uri: std::string::String,

    /// The scopes for which the user will authorize GCP Connectors on the
    /// connector data source.
    pub scopes: std::vec::Vec<std::string::String>,

    /// The client ID assigned to the GCP Connectors OAuth app for the connector
    /// data source.
    pub client_id: std::string::String,

    /// Whether to enable PKCE for the auth code flow.
    pub enable_pkce: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuthorizationCodeLink {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::AuthorizationCodeLink::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [scopes][crate::model::AuthorizationCodeLink::scopes].
    pub fn set_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [client_id][crate::model::AuthorizationCodeLink::client_id].
    pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_id = v.into();
        self
    }

    /// Sets the value of [enable_pkce][crate::model::AuthorizationCodeLink::enable_pkce].
    pub fn set_enable_pkce<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_pkce = v.into();
        self
    }
}

impl wkt::message::Message for AuthorizationCodeLink {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.AuthorizationCodeLink"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AuthorizationCodeLink {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __scopes,
            __client_id,
            __enable_pkce,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AuthorizationCodeLink")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "scopes" => Ok(__FieldTag::__scopes),
                            "clientId" => Ok(__FieldTag::__client_id),
                            "client_id" => Ok(__FieldTag::__client_id),
                            "enablePkce" => Ok(__FieldTag::__enable_pkce),
                            "enable_pkce" => Ok(__FieldTag::__enable_pkce),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AuthorizationCodeLink;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AuthorizationCodeLink")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scopes => {
                            if !fields.insert(__FieldTag::__scopes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scopes",
                                ));
                            }
                            result.scopes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__client_id => {
                            if !fields.insert(__FieldTag::__client_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_id",
                                ));
                            }
                            result.client_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_pkce => {
                            if !fields.insert(__FieldTag::__enable_pkce) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_pkce",
                                ));
                            }
                            result.enable_pkce = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AuthorizationCodeLink {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.scopes.is_empty() {
            state.serialize_entry("scopes", &self.scopes)?;
        }
        if !self.client_id.is_empty() {
            state.serialize_entry("clientId", &self.client_id)?;
        }
        if !wkt::internal::is_default(&self.enable_pkce) {
            state.serialize_entry("enablePkce", &self.enable_pkce)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AuthorizationCodeLink {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AuthorizationCodeLink");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("scopes", &self.scopes);
        debug_struct.field("client_id", &self.client_id);
        debug_struct.field("enable_pkce", &self.enable_pkce);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Connection represents an instance of connector.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Connection {
    /// Output only. Resource name of the Connection.
    /// Format: projects/{project}/locations/{location}/connections/{connection}
    pub name: std::string::String,

    /// Output only. Created time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Updated time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Resource labels to represent user-provided metadata.
    /// Refer to cloud documentation on labels for more details.
    /// <https://cloud.google.com/compute/docs/labeling-resources>
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Description of the resource.
    pub description: std::string::String,

    /// Required. Connector version on which the connection is created.
    /// The format is:
    /// projects/*/locations/*/providers/*/connectors/*/versions/*
    /// Only global location is supported for ConnectorVersion resource.
    pub connector_version: std::string::String,

    /// Output only. Current status of the connection.
    pub status: std::option::Option<crate::model::ConnectionStatus>,

    /// Optional. Configuration for configuring the connection with an external
    /// system.
    pub config_variables: std::vec::Vec<crate::model::ConfigVariable>,

    /// Optional. Configuration for establishing the connection's authentication
    /// with an external system.
    pub auth_config: std::option::Option<crate::model::AuthConfig>,

    /// Optional. Configuration that indicates whether or not the Connection can be
    /// edited.
    pub lock_config: std::option::Option<crate::model::LockConfig>,

    /// Optional. Configuration of the Connector's destination. Only accepted for
    /// Connectors that accepts user defined destination(s).
    pub destination_configs: std::vec::Vec<crate::model::DestinationConfig>,

    /// Output only. GCR location where the runtime image is stored.
    /// formatted like: gcr.io/{bucketName}/{imageName}
    pub image_location: std::string::String,

    /// Optional. Service account needed for runtime plane to access GCP resources.
    pub service_account: std::string::String,

    /// Output only. The name of the Service Directory service name. Used for
    /// Private Harpoon to resolve the ILB address.
    /// e.g.
    /// "projects/cloud-connectors-e2e-testing/locations/us-central1/namespaces/istio-system/services/istio-ingressgateway-connectors"
    pub service_directory: std::string::String,

    /// Output only. GCR location where the envoy image is stored.
    /// formatted like: gcr.io/{bucketName}/{imageName}
    pub envoy_image_location: std::string::String,

    /// Optional. Suspended indicates if a user has suspended a connection or not.
    pub suspended: bool,

    /// Optional. Node configuration for the connection.
    pub node_config: std::option::Option<crate::model::NodeConfig>,

    /// Optional. Ssl config of a connection
    pub ssl_config: std::option::Option<crate::model::SslConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Connection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Connection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Connection::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Connection::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Connection::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Connection::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Connection::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Connection::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [connector_version][crate::model::Connection::connector_version].
    pub fn set_connector_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.connector_version = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Connection::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConnectionStatus>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::Connection::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConnectionStatus>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config_variables][crate::model::Connection::config_variables].
    pub fn set_config_variables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConfigVariable>,
    {
        use std::iter::Iterator;
        self.config_variables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [auth_config][crate::model::Connection::auth_config].
    pub fn set_auth_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AuthConfig>,
    {
        self.auth_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [auth_config][crate::model::Connection::auth_config].
    pub fn set_or_clear_auth_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AuthConfig>,
    {
        self.auth_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lock_config][crate::model::Connection::lock_config].
    pub fn set_lock_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LockConfig>,
    {
        self.lock_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lock_config][crate::model::Connection::lock_config].
    pub fn set_or_clear_lock_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LockConfig>,
    {
        self.lock_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination_configs][crate::model::Connection::destination_configs].
    pub fn set_destination_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DestinationConfig>,
    {
        use std::iter::Iterator;
        self.destination_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [image_location][crate::model::Connection::image_location].
    pub fn set_image_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_location = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::Connection::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [service_directory][crate::model::Connection::service_directory].
    pub fn set_service_directory<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_directory = v.into();
        self
    }

    /// Sets the value of [envoy_image_location][crate::model::Connection::envoy_image_location].
    pub fn set_envoy_image_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.envoy_image_location = v.into();
        self
    }

    /// Sets the value of [suspended][crate::model::Connection::suspended].
    pub fn set_suspended<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.suspended = v.into();
        self
    }

    /// Sets the value of [node_config][crate::model::Connection::node_config].
    pub fn set_node_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeConfig>,
    {
        self.node_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_config][crate::model::Connection::node_config].
    pub fn set_or_clear_node_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeConfig>,
    {
        self.node_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ssl_config][crate::model::Connection::ssl_config].
    pub fn set_ssl_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslConfig>,
    {
        self.ssl_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssl_config][crate::model::Connection::ssl_config].
    pub fn set_or_clear_ssl_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslConfig>,
    {
        self.ssl_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Connection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.Connection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Connection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __description,
            __connector_version,
            __status,
            __config_variables,
            __auth_config,
            __lock_config,
            __destination_configs,
            __image_location,
            __service_account,
            __service_directory,
            __envoy_image_location,
            __suspended,
            __node_config,
            __ssl_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Connection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "description" => Ok(__FieldTag::__description),
                            "connectorVersion" => Ok(__FieldTag::__connector_version),
                            "connector_version" => Ok(__FieldTag::__connector_version),
                            "status" => Ok(__FieldTag::__status),
                            "configVariables" => Ok(__FieldTag::__config_variables),
                            "config_variables" => Ok(__FieldTag::__config_variables),
                            "authConfig" => Ok(__FieldTag::__auth_config),
                            "auth_config" => Ok(__FieldTag::__auth_config),
                            "lockConfig" => Ok(__FieldTag::__lock_config),
                            "lock_config" => Ok(__FieldTag::__lock_config),
                            "destinationConfigs" => Ok(__FieldTag::__destination_configs),
                            "destination_configs" => Ok(__FieldTag::__destination_configs),
                            "imageLocation" => Ok(__FieldTag::__image_location),
                            "image_location" => Ok(__FieldTag::__image_location),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "serviceDirectory" => Ok(__FieldTag::__service_directory),
                            "service_directory" => Ok(__FieldTag::__service_directory),
                            "envoyImageLocation" => Ok(__FieldTag::__envoy_image_location),
                            "envoy_image_location" => Ok(__FieldTag::__envoy_image_location),
                            "suspended" => Ok(__FieldTag::__suspended),
                            "nodeConfig" => Ok(__FieldTag::__node_config),
                            "node_config" => Ok(__FieldTag::__node_config),
                            "sslConfig" => Ok(__FieldTag::__ssl_config),
                            "ssl_config" => Ok(__FieldTag::__ssl_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Connection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Connection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connector_version => {
                            if !fields.insert(__FieldTag::__connector_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connector_version",
                                ));
                            }
                            result.connector_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::ConnectionStatus>>(
                                )?;
                        }
                        __FieldTag::__config_variables => {
                            if !fields.insert(__FieldTag::__config_variables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_variables",
                                ));
                            }
                            result.config_variables =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConfigVariable>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auth_config => {
                            if !fields.insert(__FieldTag::__auth_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auth_config",
                                ));
                            }
                            result.auth_config =
                                map.next_value::<std::option::Option<crate::model::AuthConfig>>()?;
                        }
                        __FieldTag::__lock_config => {
                            if !fields.insert(__FieldTag::__lock_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lock_config",
                                ));
                            }
                            result.lock_config =
                                map.next_value::<std::option::Option<crate::model::LockConfig>>()?;
                        }
                        __FieldTag::__destination_configs => {
                            if !fields.insert(__FieldTag::__destination_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_configs",
                                ));
                            }
                            result.destination_configs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DestinationConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_location => {
                            if !fields.insert(__FieldTag::__image_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_location",
                                ));
                            }
                            result.image_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_directory => {
                            if !fields.insert(__FieldTag::__service_directory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_directory",
                                ));
                            }
                            result.service_directory = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__envoy_image_location => {
                            if !fields.insert(__FieldTag::__envoy_image_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for envoy_image_location",
                                ));
                            }
                            result.envoy_image_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__suspended => {
                            if !fields.insert(__FieldTag::__suspended) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suspended",
                                ));
                            }
                            result.suspended = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_config => {
                            if !fields.insert(__FieldTag::__node_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_config",
                                ));
                            }
                            result.node_config =
                                map.next_value::<std::option::Option<crate::model::NodeConfig>>()?;
                        }
                        __FieldTag::__ssl_config => {
                            if !fields.insert(__FieldTag::__ssl_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl_config",
                                ));
                            }
                            result.ssl_config =
                                map.next_value::<std::option::Option<crate::model::SslConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Connection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.connector_version.is_empty() {
            state.serialize_entry("connectorVersion", &self.connector_version)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.config_variables.is_empty() {
            state.serialize_entry("configVariables", &self.config_variables)?;
        }
        if self.auth_config.is_some() {
            state.serialize_entry("authConfig", &self.auth_config)?;
        }
        if self.lock_config.is_some() {
            state.serialize_entry("lockConfig", &self.lock_config)?;
        }
        if !self.destination_configs.is_empty() {
            state.serialize_entry("destinationConfigs", &self.destination_configs)?;
        }
        if !self.image_location.is_empty() {
            state.serialize_entry("imageLocation", &self.image_location)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.service_directory.is_empty() {
            state.serialize_entry("serviceDirectory", &self.service_directory)?;
        }
        if !self.envoy_image_location.is_empty() {
            state.serialize_entry("envoyImageLocation", &self.envoy_image_location)?;
        }
        if !wkt::internal::is_default(&self.suspended) {
            state.serialize_entry("suspended", &self.suspended)?;
        }
        if self.node_config.is_some() {
            state.serialize_entry("nodeConfig", &self.node_config)?;
        }
        if self.ssl_config.is_some() {
            state.serialize_entry("sslConfig", &self.ssl_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Connection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Connection");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("description", &self.description);
        debug_struct.field("connector_version", &self.connector_version);
        debug_struct.field("status", &self.status);
        debug_struct.field("config_variables", &self.config_variables);
        debug_struct.field("auth_config", &self.auth_config);
        debug_struct.field("lock_config", &self.lock_config);
        debug_struct.field("destination_configs", &self.destination_configs);
        debug_struct.field("image_location", &self.image_location);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("service_directory", &self.service_directory);
        debug_struct.field("envoy_image_location", &self.envoy_image_location);
        debug_struct.field("suspended", &self.suspended);
        debug_struct.field("node_config", &self.node_config);
        debug_struct.field("ssl_config", &self.ssl_config);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Node configuration for the connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NodeConfig {
    /// Minimum number of nodes in the runtime nodes.
    pub min_node_count: i32,

    /// Maximum number of nodes in the runtime nodes.
    pub max_node_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_node_count][crate::model::NodeConfig::min_node_count].
    pub fn set_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_node_count = v.into();
        self
    }

    /// Sets the value of [max_node_count][crate::model::NodeConfig::max_node_count].
    pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_node_count = v.into();
        self
    }
}

impl wkt::message::Message for NodeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.NodeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min_node_count,
            __max_node_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minNodeCount" => Ok(__FieldTag::__min_node_count),
                            "min_node_count" => Ok(__FieldTag::__min_node_count),
                            "maxNodeCount" => Ok(__FieldTag::__max_node_count),
                            "max_node_count" => Ok(__FieldTag::__max_node_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min_node_count => {
                            if !fields.insert(__FieldTag::__min_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_node_count => {
                            if !fields.insert(__FieldTag::__max_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.min_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minNodeCount", &__With(&self.min_node_count))?;
        }
        if !wkt::internal::is_default(&self.max_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxNodeCount", &__With(&self.max_node_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NodeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeConfig");
        debug_struct.field("min_node_count", &self.min_node_count);
        debug_struct.field("max_node_count", &self.max_node_count);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ConnectionSchemaMetadata is the singleton resource of each connection.
/// It includes the entity and action names of runtime resources exposed
/// by a connection backend.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConnectionSchemaMetadata {
    /// Output only. List of entity names.
    pub entities: std::vec::Vec<std::string::String>,

    /// Output only. List of actions.
    pub actions: std::vec::Vec<std::string::String>,

    /// Output only. Resource name.
    /// Format:
    /// projects/{project}/locations/{location}/connections/{connection}/connectionSchemaMetadata
    pub name: std::string::String,

    /// Output only. Timestamp when the connection runtime schema was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when the connection runtime schema refresh was
    /// triggered.
    pub refresh_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of runtime schema.
    pub state: crate::model::connection_schema_metadata::State,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectionSchemaMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entities][crate::model::ConnectionSchemaMetadata::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [actions][crate::model::ConnectionSchemaMetadata::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [name][crate::model::ConnectionSchemaMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ConnectionSchemaMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ConnectionSchemaMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [refresh_time][crate::model::ConnectionSchemaMetadata::refresh_time].
    pub fn set_refresh_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.refresh_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [refresh_time][crate::model::ConnectionSchemaMetadata::refresh_time].
    pub fn set_or_clear_refresh_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.refresh_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::ConnectionSchemaMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::connection_schema_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for ConnectionSchemaMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ConnectionSchemaMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConnectionSchemaMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entities,
            __actions,
            __name,
            __update_time,
            __refresh_time,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConnectionSchemaMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entities" => Ok(__FieldTag::__entities),
                            "actions" => Ok(__FieldTag::__actions),
                            "name" => Ok(__FieldTag::__name),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "refreshTime" => Ok(__FieldTag::__refresh_time),
                            "refresh_time" => Ok(__FieldTag::__refresh_time),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConnectionSchemaMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConnectionSchemaMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entities => {
                            if !fields.insert(__FieldTag::__entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entities",
                                ));
                            }
                            result.entities = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__actions => {
                            if !fields.insert(__FieldTag::__actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for actions",
                                ));
                            }
                            result.actions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__refresh_time => {
                            if !fields.insert(__FieldTag::__refresh_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for refresh_time",
                                ));
                            }
                            result.refresh_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<
                                    crate::model::connection_schema_metadata::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConnectionSchemaMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entities.is_empty() {
            state.serialize_entry("entities", &self.entities)?;
        }
        if !self.actions.is_empty() {
            state.serialize_entry("actions", &self.actions)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.refresh_time.is_some() {
            state.serialize_entry("refreshTime", &self.refresh_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConnectionSchemaMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConnectionSchemaMetadata");
        debug_struct.field("entities", &self.entities);
        debug_struct.field("actions", &self.actions);
        debug_struct.field("name", &self.name);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("refresh_time", &self.refresh_time);
        debug_struct.field("state", &self.state);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ConnectionSchemaMetadata].
pub mod connection_schema_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// State of connection runtime schema.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default state.
        Unspecified,
        /// Schema refresh is in progress.
        Refreshing,
        /// Schema has been updated.
        Updated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Refreshing => std::option::Option::Some(1),
                Self::Updated => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Refreshing => std::option::Option::Some("REFRESHING"),
                Self::Updated => std::option::Option::Some("UPDATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Refreshing,
                2 => Self::Updated,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "REFRESHING" => Self::Refreshing,
                "UPDATED" => Self::Updated,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Refreshing => serializer.serialize_i32(1),
                Self::Updated => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.connectors.v1.ConnectionSchemaMetadata.State",
            ))
        }
    }
}

/// Schema of a runtime entity.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RuntimeEntitySchema {
    /// Output only. Name of the entity.
    pub entity: std::string::String,

    /// Output only. List of fields in the entity.
    pub fields: std::vec::Vec<crate::model::runtime_entity_schema::Field>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuntimeEntitySchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity][crate::model::RuntimeEntitySchema::entity].
    pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::RuntimeEntitySchema::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::runtime_entity_schema::Field>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RuntimeEntitySchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.RuntimeEntitySchema"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RuntimeEntitySchema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity,
            __fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RuntimeEntitySchema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entity" => Ok(__FieldTag::__entity),
                            "fields" => Ok(__FieldTag::__fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RuntimeEntitySchema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RuntimeEntitySchema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity => {
                            if !fields.insert(__FieldTag::__entity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity",
                                ));
                            }
                            result.entity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::runtime_entity_schema::Field>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RuntimeEntitySchema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entity.is_empty() {
            state.serialize_entry("entity", &self.entity)?;
        }
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RuntimeEntitySchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RuntimeEntitySchema");
        debug_struct.field("entity", &self.entity);
        debug_struct.field("fields", &self.fields);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RuntimeEntitySchema].
pub mod runtime_entity_schema {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata of an entity field.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Field {
        /// Name of the Field.
        pub field: std::string::String,

        /// A brief description of the Field.
        pub description: std::string::String,

        /// The data type of the Field.
        pub data_type: crate::model::DataType,

        /// The following boolean field specifies if the current Field acts
        /// as a primary key or id if the parent is of type entity.
        pub key: bool,

        /// Specifies if the Field is readonly.
        pub readonly: bool,

        /// Specifies whether a null value is allowed.
        pub nullable: bool,

        /// The following field specifies the default value of the Field provided
        /// by the external system if a value is not provided.
        pub default_value: std::option::Option<wkt::Value>,

        /// The following map contains fields that are not explicitly mentioned
        /// above,this give connectors the flexibility to add new metadata
        /// fields.
        pub additional_details: std::option::Option<wkt::Struct>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Field {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::runtime_entity_schema::Field::field].
        pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.field = v.into();
            self
        }

        /// Sets the value of [description][crate::model::runtime_entity_schema::Field::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [data_type][crate::model::runtime_entity_schema::Field::data_type].
        pub fn set_data_type<T: std::convert::Into<crate::model::DataType>>(
            mut self,
            v: T,
        ) -> Self {
            self.data_type = v.into();
            self
        }

        /// Sets the value of [key][crate::model::runtime_entity_schema::Field::key].
        pub fn set_key<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [readonly][crate::model::runtime_entity_schema::Field::readonly].
        pub fn set_readonly<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.readonly = v.into();
            self
        }

        /// Sets the value of [nullable][crate::model::runtime_entity_schema::Field::nullable].
        pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.nullable = v.into();
            self
        }

        /// Sets the value of [default_value][crate::model::runtime_entity_schema::Field::default_value].
        pub fn set_default_value<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Value>,
        {
            self.default_value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [default_value][crate::model::runtime_entity_schema::Field::default_value].
        pub fn set_or_clear_default_value<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Value>,
        {
            self.default_value = v.map(|x| x.into());
            self
        }

        /// Sets the value of [additional_details][crate::model::runtime_entity_schema::Field::additional_details].
        pub fn set_additional_details<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.additional_details = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [additional_details][crate::model::runtime_entity_schema::Field::additional_details].
        pub fn set_or_clear_additional_details<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.additional_details = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Field {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.connectors.v1.RuntimeEntitySchema.Field"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Field {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __field,
                __description,
                __data_type,
                __key,
                __readonly,
                __nullable,
                __default_value,
                __additional_details,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Field")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "field" => Ok(__FieldTag::__field),
                                "description" => Ok(__FieldTag::__description),
                                "dataType" => Ok(__FieldTag::__data_type),
                                "data_type" => Ok(__FieldTag::__data_type),
                                "key" => Ok(__FieldTag::__key),
                                "readonly" => Ok(__FieldTag::__readonly),
                                "nullable" => Ok(__FieldTag::__nullable),
                                "defaultValue" => Ok(__FieldTag::__default_value),
                                "default_value" => Ok(__FieldTag::__default_value),
                                "additionalDetails" => Ok(__FieldTag::__additional_details),
                                "additional_details" => Ok(__FieldTag::__additional_details),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Field;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Field")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__field => {
                                if !fields.insert(__FieldTag::__field) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for field",
                                    ));
                                }
                                result.field = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__data_type => {
                                if !fields.insert(__FieldTag::__data_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for data_type",
                                    ));
                                }
                                result.data_type = map
                                    .next_value::<std::option::Option<crate::model::DataType>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__key => {
                                if !fields.insert(__FieldTag::__key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for key",
                                    ));
                                }
                                result.key = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__readonly => {
                                if !fields.insert(__FieldTag::__readonly) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for readonly",
                                    ));
                                }
                                result.readonly = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__nullable => {
                                if !fields.insert(__FieldTag::__nullable) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for nullable",
                                    ));
                                }
                                result.nullable = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__default_value => {
                                if !fields.insert(__FieldTag::__default_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for default_value",
                                    ));
                                }
                                result.default_value = map
                                    .next_value::<std::option::Option<wkt::Value>>()?
                                    .or(Some(wkt::Value::Null));
                            }
                            __FieldTag::__additional_details => {
                                if !fields.insert(__FieldTag::__additional_details) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for additional_details",
                                    ));
                                }
                                result.additional_details =
                                    map.next_value::<std::option::Option<wkt::Struct>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Field {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.field.is_empty() {
                state.serialize_entry("field", &self.field)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if !wkt::internal::is_default(&self.data_type) {
                state.serialize_entry("dataType", &self.data_type)?;
            }
            if !wkt::internal::is_default(&self.key) {
                state.serialize_entry("key", &self.key)?;
            }
            if !wkt::internal::is_default(&self.readonly) {
                state.serialize_entry("readonly", &self.readonly)?;
            }
            if !wkt::internal::is_default(&self.nullable) {
                state.serialize_entry("nullable", &self.nullable)?;
            }
            if self.default_value.is_some() {
                state.serialize_entry("defaultValue", &self.default_value)?;
            }
            if self.additional_details.is_some() {
                state.serialize_entry("additionalDetails", &self.additional_details)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Field {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Field");
            debug_struct.field("field", &self.field);
            debug_struct.field("description", &self.description);
            debug_struct.field("data_type", &self.data_type);
            debug_struct.field("key", &self.key);
            debug_struct.field("readonly", &self.readonly);
            debug_struct.field("nullable", &self.nullable);
            debug_struct.field("default_value", &self.default_value);
            debug_struct.field("additional_details", &self.additional_details);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Schema of a runtime action.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RuntimeActionSchema {
    /// Output only. Name of the action.
    pub action: std::string::String,

    /// Output only. List of input parameter metadata for the action.
    pub input_parameters: std::vec::Vec<crate::model::runtime_action_schema::InputParameter>,

    /// Output only. List of result field metadata.
    pub result_metadata: std::vec::Vec<crate::model::runtime_action_schema::ResultMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuntimeActionSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [action][crate::model::RuntimeActionSchema::action].
    pub fn set_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [input_parameters][crate::model::RuntimeActionSchema::input_parameters].
    pub fn set_input_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::runtime_action_schema::InputParameter>,
    {
        use std::iter::Iterator;
        self.input_parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [result_metadata][crate::model::RuntimeActionSchema::result_metadata].
    pub fn set_result_metadata<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::runtime_action_schema::ResultMetadata>,
    {
        use std::iter::Iterator;
        self.result_metadata = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RuntimeActionSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.RuntimeActionSchema"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RuntimeActionSchema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __action,
            __input_parameters,
            __result_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RuntimeActionSchema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "action" => Ok(__FieldTag::__action),
                            "inputParameters" => Ok(__FieldTag::__input_parameters),
                            "input_parameters" => Ok(__FieldTag::__input_parameters),
                            "resultMetadata" => Ok(__FieldTag::__result_metadata),
                            "result_metadata" => Ok(__FieldTag::__result_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RuntimeActionSchema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RuntimeActionSchema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            result.action = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input_parameters => {
                            if !fields.insert(__FieldTag::__input_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_parameters",
                                ));
                            }
                            result.input_parameters = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::runtime_action_schema::InputParameter,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__result_metadata => {
                            if !fields.insert(__FieldTag::__result_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result_metadata",
                                ));
                            }
                            result.result_metadata = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::runtime_action_schema::ResultMetadata,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RuntimeActionSchema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.action.is_empty() {
            state.serialize_entry("action", &self.action)?;
        }
        if !self.input_parameters.is_empty() {
            state.serialize_entry("inputParameters", &self.input_parameters)?;
        }
        if !self.result_metadata.is_empty() {
            state.serialize_entry("resultMetadata", &self.result_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RuntimeActionSchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RuntimeActionSchema");
        debug_struct.field("action", &self.action);
        debug_struct.field("input_parameters", &self.input_parameters);
        debug_struct.field("result_metadata", &self.result_metadata);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RuntimeActionSchema].
pub mod runtime_action_schema {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata of an input parameter.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InputParameter {
        /// Name of the Parameter.
        pub parameter: std::string::String,

        /// A brief description of the Parameter.
        pub description: std::string::String,

        /// The data type of the Parameter.
        pub data_type: crate::model::DataType,

        /// Specifies whether a null value is allowed.
        pub nullable: bool,

        /// The following field specifies the default value of the Parameter
        /// provided by the external system if a value is not provided.
        pub default_value: std::option::Option<wkt::Value>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InputParameter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [parameter][crate::model::runtime_action_schema::InputParameter::parameter].
        pub fn set_parameter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.parameter = v.into();
            self
        }

        /// Sets the value of [description][crate::model::runtime_action_schema::InputParameter::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [data_type][crate::model::runtime_action_schema::InputParameter::data_type].
        pub fn set_data_type<T: std::convert::Into<crate::model::DataType>>(
            mut self,
            v: T,
        ) -> Self {
            self.data_type = v.into();
            self
        }

        /// Sets the value of [nullable][crate::model::runtime_action_schema::InputParameter::nullable].
        pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.nullable = v.into();
            self
        }

        /// Sets the value of [default_value][crate::model::runtime_action_schema::InputParameter::default_value].
        pub fn set_default_value<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Value>,
        {
            self.default_value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [default_value][crate::model::runtime_action_schema::InputParameter::default_value].
        pub fn set_or_clear_default_value<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Value>,
        {
            self.default_value = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for InputParameter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.connectors.v1.RuntimeActionSchema.InputParameter"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InputParameter {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __parameter,
                __description,
                __data_type,
                __nullable,
                __default_value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InputParameter")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "parameter" => Ok(__FieldTag::__parameter),
                                "description" => Ok(__FieldTag::__description),
                                "dataType" => Ok(__FieldTag::__data_type),
                                "data_type" => Ok(__FieldTag::__data_type),
                                "nullable" => Ok(__FieldTag::__nullable),
                                "defaultValue" => Ok(__FieldTag::__default_value),
                                "default_value" => Ok(__FieldTag::__default_value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InputParameter;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InputParameter")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__parameter => {
                                if !fields.insert(__FieldTag::__parameter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parameter",
                                    ));
                                }
                                result.parameter = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__data_type => {
                                if !fields.insert(__FieldTag::__data_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for data_type",
                                    ));
                                }
                                result.data_type = map
                                    .next_value::<std::option::Option<crate::model::DataType>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__nullable => {
                                if !fields.insert(__FieldTag::__nullable) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for nullable",
                                    ));
                                }
                                result.nullable = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__default_value => {
                                if !fields.insert(__FieldTag::__default_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for default_value",
                                    ));
                                }
                                result.default_value = map
                                    .next_value::<std::option::Option<wkt::Value>>()?
                                    .or(Some(wkt::Value::Null));
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InputParameter {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.parameter.is_empty() {
                state.serialize_entry("parameter", &self.parameter)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if !wkt::internal::is_default(&self.data_type) {
                state.serialize_entry("dataType", &self.data_type)?;
            }
            if !wkt::internal::is_default(&self.nullable) {
                state.serialize_entry("nullable", &self.nullable)?;
            }
            if self.default_value.is_some() {
                state.serialize_entry("defaultValue", &self.default_value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for InputParameter {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("InputParameter");
            debug_struct.field("parameter", &self.parameter);
            debug_struct.field("description", &self.description);
            debug_struct.field("data_type", &self.data_type);
            debug_struct.field("nullable", &self.nullable);
            debug_struct.field("default_value", &self.default_value);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Metadata of result field.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResultMetadata {
        /// Name of the result field.
        pub field: std::string::String,

        /// A brief description of the field.
        pub description: std::string::String,

        /// The data type of the field.
        pub data_type: crate::model::DataType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResultMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::runtime_action_schema::ResultMetadata::field].
        pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.field = v.into();
            self
        }

        /// Sets the value of [description][crate::model::runtime_action_schema::ResultMetadata::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [data_type][crate::model::runtime_action_schema::ResultMetadata::data_type].
        pub fn set_data_type<T: std::convert::Into<crate::model::DataType>>(
            mut self,
            v: T,
        ) -> Self {
            self.data_type = v.into();
            self
        }
    }

    impl wkt::message::Message for ResultMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.connectors.v1.RuntimeActionSchema.ResultMetadata"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ResultMetadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __field,
                __description,
                __data_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ResultMetadata")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "field" => Ok(__FieldTag::__field),
                                "description" => Ok(__FieldTag::__description),
                                "dataType" => Ok(__FieldTag::__data_type),
                                "data_type" => Ok(__FieldTag::__data_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ResultMetadata;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ResultMetadata")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__field => {
                                if !fields.insert(__FieldTag::__field) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for field",
                                    ));
                                }
                                result.field = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__data_type => {
                                if !fields.insert(__FieldTag::__data_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for data_type",
                                    ));
                                }
                                result.data_type = map
                                    .next_value::<std::option::Option<crate::model::DataType>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ResultMetadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.field.is_empty() {
                state.serialize_entry("field", &self.field)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if !wkt::internal::is_default(&self.data_type) {
                state.serialize_entry("dataType", &self.data_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ResultMetadata {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ResultMetadata");
            debug_struct.field("field", &self.field);
            debug_struct.field("description", &self.description);
            debug_struct.field("data_type", &self.data_type);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Determines whether or no a connection is locked. If locked, a reason must be
/// specified.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LockConfig {
    /// Indicates whether or not the connection is locked.
    pub locked: bool,

    /// Describes why a connection is locked.
    pub reason: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LockConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [locked][crate::model::LockConfig::locked].
    pub fn set_locked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.locked = v.into();
        self
    }

    /// Sets the value of [reason][crate::model::LockConfig::reason].
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }
}

impl wkt::message::Message for LockConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.LockConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LockConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __locked,
            __reason,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LockConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "locked" => Ok(__FieldTag::__locked),
                            "reason" => Ok(__FieldTag::__reason),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LockConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LockConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__locked => {
                            if !fields.insert(__FieldTag::__locked) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locked",
                                ));
                            }
                            result.locked = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reason => {
                            if !fields.insert(__FieldTag::__reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reason",
                                ));
                            }
                            result.reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LockConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.locked) {
            state.serialize_entry("locked", &self.locked)?;
        }
        if !self.reason.is_empty() {
            state.serialize_entry("reason", &self.reason)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LockConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LockConfig");
        debug_struct.field("locked", &self.locked);
        debug_struct.field("reason", &self.reason);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for ConnectorsService.ListConnections
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectionsRequest {
    /// Required. Parent resource of the Connection, of the form:
    /// `projects/*/locations/*`
    pub parent: std::string::String,

    /// Page size.
    pub page_size: i32,

    /// Page token.
    pub page_token: std::string::String,

    /// Filter.
    pub filter: std::string::String,

    /// Order by parameters.
    pub order_by: std::string::String,

    /// Specifies which fields of the Connection are returned in the response.
    /// Defaults to `BASIC` view.
    pub view: crate::model::ConnectionView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListConnectionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListConnectionsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ConnectionView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListConnectionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::ConnectionView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConnectionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for ConnectorsService.ListConnections
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectionsResponse {
    /// Connections.
    pub connections: std::vec::Vec<crate::model::Connection>,

    /// Next page token.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connections][crate::model::ListConnectionsResponse::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connection>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConnectionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectionsResponse {
    type PageItem = crate::model::Connection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connections,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connections" => Ok(__FieldTag::__connections),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connections => {
                            if !fields.insert(__FieldTag::__connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connections",
                                ));
                            }
                            result.connections = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Connection>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connections.is_empty() {
            state.serialize_entry("connections", &self.connections)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConnectionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectionsResponse");
        debug_struct.field("connections", &self.connections);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for ConnectorsService.GetConnection
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConnectionRequest {
    /// Required. Resource name of the form:
    /// `projects/*/locations/*/connections/*`
    pub name: std::string::String,

    /// Specifies which fields of the Connection are returned in the response.
    /// Defaults to `BASIC` view.
    pub view: crate::model::ConnectionView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetConnectionRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ConnectionView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.GetConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::ConnectionView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConnectionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for ConnectorsService.CreateConnection
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateConnectionRequest {
    /// Required. Parent resource of the Connection, of the form:
    /// `projects/*/locations/*`
    pub parent: std::string::String,

    /// Required. Identifier to assign to the Connection. Must be unique within
    /// scope of the parent resource.
    pub connection_id: std::string::String,

    /// Required. Connection resource.
    pub connection: std::option::Option<crate::model::Connection>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [connection_id][crate::model::CreateConnectionRequest::connection_id].
    pub fn set_connection_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_id = v.into();
        self
    }

    /// Sets the value of [connection][crate::model::CreateConnectionRequest::connection].
    pub fn set_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection][crate::model::CreateConnectionRequest::connection].
    pub fn set_or_clear_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.CreateConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __connection_id,
            __connection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "connectionId" => Ok(__FieldTag::__connection_id),
                            "connection_id" => Ok(__FieldTag::__connection_id),
                            "connection" => Ok(__FieldTag::__connection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection_id => {
                            if !fields.insert(__FieldTag::__connection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_id",
                                ));
                            }
                            result.connection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection => {
                            if !fields.insert(__FieldTag::__connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection",
                                ));
                            }
                            result.connection =
                                map.next_value::<std::option::Option<crate::model::Connection>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.connection_id.is_empty() {
            state.serialize_entry("connectionId", &self.connection_id)?;
        }
        if self.connection.is_some() {
            state.serialize_entry("connection", &self.connection)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateConnectionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("connection_id", &self.connection_id);
        debug_struct.field("connection", &self.connection);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for ConnectorsService.UpdateConnection
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateConnectionRequest {
    /// Required. Connection resource.
    pub connection: std::option::Option<crate::model::Connection>,

    /// Required. You can modify only the fields listed below.
    ///
    /// To lock/unlock a connection:
    ///
    /// * `lock_config`
    ///
    /// To suspend/resume a connection:
    ///
    /// * `suspended`
    ///
    /// To update the connection details:
    ///
    /// * `description`
    /// * `labels`
    /// * `connector_version`
    /// * `config_variables`
    /// * `auth_config`
    /// * `destination_configs`
    /// * `node_config`
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection][crate::model::UpdateConnectionRequest::connection].
    pub fn set_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection][crate::model::UpdateConnectionRequest::connection].
    pub fn set_or_clear_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConnectionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.UpdateConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connection,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connection" => Ok(__FieldTag::__connection),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connection => {
                            if !fields.insert(__FieldTag::__connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection",
                                ));
                            }
                            result.connection =
                                map.next_value::<std::option::Option<crate::model::Connection>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.connection.is_some() {
            state.serialize_entry("connection", &self.connection)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateConnectionRequest");
        debug_struct.field("connection", &self.connection);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for ConnectorsService.DeleteConnection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteConnectionRequest {
    /// Required. Resource name of the form:
    /// `projects/*/locations/*/connections/*`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.DeleteConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteConnectionRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for ConnectorsService.GetConnectionSchemaMetadata.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConnectionSchemaMetadataRequest {
    /// Required. Connection name
    /// Format:
    /// projects/{project}/locations/{location}/connections/{connection}/connectionSchemaMetadata
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectionSchemaMetadataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectionSchemaMetadataRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionSchemaMetadataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.GetConnectionSchemaMetadataRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConnectionSchemaMetadataRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConnectionSchemaMetadataRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConnectionSchemaMetadataRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConnectionSchemaMetadataRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetConnectionSchemaMetadataRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetConnectionSchemaMetadataRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConnectionSchemaMetadataRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for ConnectorsService.RefreshConnectionSchemaMetadata.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RefreshConnectionSchemaMetadataRequest {
    /// Required. Resource name.
    /// Format:
    /// projects/{project}/locations/{location}/connections/{connection}/connectionSchemaMetadata
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RefreshConnectionSchemaMetadataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RefreshConnectionSchemaMetadataRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RefreshConnectionSchemaMetadataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.RefreshConnectionSchemaMetadataRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RefreshConnectionSchemaMetadataRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for RefreshConnectionSchemaMetadataRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RefreshConnectionSchemaMetadataRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RefreshConnectionSchemaMetadataRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RefreshConnectionSchemaMetadataRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RefreshConnectionSchemaMetadataRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RefreshConnectionSchemaMetadataRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for ConnectorsService.ListRuntimeEntitySchemas.
/// For filter, only entity field is supported with literal equality operator.
/// Accepted filter example: entity="Order"
/// Wildcards are not supported in the filter currently.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRuntimeEntitySchemasRequest {
    /// Required. Parent resource of RuntimeEntitySchema
    /// Format:
    /// projects/{project}/locations/{location}/connections/{connection}
    pub parent: std::string::String,

    /// Page size.
    pub page_size: i32,

    /// Page token.
    pub page_token: std::string::String,

    /// Required. Filter
    /// Format:
    /// entity="{entityId}"
    /// Only entity field is supported with literal equality operator.
    /// Accepted filter example: entity="Order"
    /// Wildcards are not supported in the filter currently.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRuntimeEntitySchemasRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRuntimeEntitySchemasRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRuntimeEntitySchemasRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRuntimeEntitySchemasRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRuntimeEntitySchemasRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListRuntimeEntitySchemasRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListRuntimeEntitySchemasRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRuntimeEntitySchemasRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRuntimeEntitySchemasRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRuntimeEntitySchemasRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRuntimeEntitySchemasRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRuntimeEntitySchemasRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListRuntimeEntitySchemasRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRuntimeEntitySchemasRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for ConnectorsService.ListRuntimeEntitySchemas.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRuntimeEntitySchemasResponse {
    /// Runtime entity schemas.
    pub runtime_entity_schemas: std::vec::Vec<crate::model::RuntimeEntitySchema>,

    /// Next page token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRuntimeEntitySchemasResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [runtime_entity_schemas][crate::model::ListRuntimeEntitySchemasResponse::runtime_entity_schemas].
    pub fn set_runtime_entity_schemas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RuntimeEntitySchema>,
    {
        use std::iter::Iterator;
        self.runtime_entity_schemas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRuntimeEntitySchemasResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRuntimeEntitySchemasResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListRuntimeEntitySchemasResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRuntimeEntitySchemasResponse {
    type PageItem = crate::model::RuntimeEntitySchema;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.runtime_entity_schemas
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRuntimeEntitySchemasResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __runtime_entity_schemas,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRuntimeEntitySchemasResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "runtimeEntitySchemas" => Ok(__FieldTag::__runtime_entity_schemas),
                            "runtime_entity_schemas" => Ok(__FieldTag::__runtime_entity_schemas),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRuntimeEntitySchemasResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRuntimeEntitySchemasResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__runtime_entity_schemas => {
                            if !fields.insert(__FieldTag::__runtime_entity_schemas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_entity_schemas",
                                ));
                            }
                            result.runtime_entity_schemas = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RuntimeEntitySchema>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRuntimeEntitySchemasResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.runtime_entity_schemas.is_empty() {
            state.serialize_entry("runtimeEntitySchemas", &self.runtime_entity_schemas)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListRuntimeEntitySchemasResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRuntimeEntitySchemasResponse");
        debug_struct.field("runtime_entity_schemas", &self.runtime_entity_schemas);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for ConnectorsService.ListRuntimeActionSchemas.
/// For filter, only action field is supported with literal equality operator.
/// Accepted filter example: action="approveOrder"
/// Wildcards are not supported in the filter currently.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRuntimeActionSchemasRequest {
    /// Required. Parent resource of RuntimeActionSchema
    /// Format:
    /// projects/{project}/locations/{location}/connections/{connection}
    pub parent: std::string::String,

    /// Page size.
    pub page_size: i32,

    /// Page token.
    pub page_token: std::string::String,

    /// Required. Filter
    /// Format:
    /// action="{actionId}"
    /// Only action field is supported with literal equality operator.
    /// Accepted filter example: action="CancelOrder"
    /// Wildcards are not supported in the filter currently.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRuntimeActionSchemasRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRuntimeActionSchemasRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRuntimeActionSchemasRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRuntimeActionSchemasRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRuntimeActionSchemasRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListRuntimeActionSchemasRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListRuntimeActionSchemasRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRuntimeActionSchemasRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRuntimeActionSchemasRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRuntimeActionSchemasRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRuntimeActionSchemasRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRuntimeActionSchemasRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListRuntimeActionSchemasRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRuntimeActionSchemasRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for ConnectorsService.ListRuntimeActionSchemas.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRuntimeActionSchemasResponse {
    /// Runtime action schemas.
    pub runtime_action_schemas: std::vec::Vec<crate::model::RuntimeActionSchema>,

    /// Next page token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRuntimeActionSchemasResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [runtime_action_schemas][crate::model::ListRuntimeActionSchemasResponse::runtime_action_schemas].
    pub fn set_runtime_action_schemas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RuntimeActionSchema>,
    {
        use std::iter::Iterator;
        self.runtime_action_schemas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRuntimeActionSchemasResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRuntimeActionSchemasResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListRuntimeActionSchemasResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRuntimeActionSchemasResponse {
    type PageItem = crate::model::RuntimeActionSchema;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.runtime_action_schemas
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRuntimeActionSchemasResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __runtime_action_schemas,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRuntimeActionSchemasResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "runtimeActionSchemas" => Ok(__FieldTag::__runtime_action_schemas),
                            "runtime_action_schemas" => Ok(__FieldTag::__runtime_action_schemas),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRuntimeActionSchemasResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRuntimeActionSchemasResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__runtime_action_schemas => {
                            if !fields.insert(__FieldTag::__runtime_action_schemas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_action_schemas",
                                ));
                            }
                            result.runtime_action_schemas = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RuntimeActionSchema>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRuntimeActionSchemasResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.runtime_action_schemas.is_empty() {
            state.serialize_entry("runtimeActionSchemas", &self.runtime_action_schemas)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListRuntimeActionSchemasResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRuntimeActionSchemasResponse");
        debug_struct.field("runtime_action_schemas", &self.runtime_action_schemas);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ConnectionStatus indicates the state of the connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConnectionStatus {
    /// State.
    pub state: crate::model::connection_status::State,

    /// Description.
    pub description: std::string::String,

    /// Status provides detailed information for the state.
    pub status: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectionStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::ConnectionStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::connection_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ConnectionStatus::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [status][crate::model::ConnectionStatus::status].
    pub fn set_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }
}

impl wkt::message::Message for ConnectionStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ConnectionStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConnectionStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __description,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConnectionStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "description" => Ok(__FieldTag::__description),
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConnectionStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConnectionStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::connection_status::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConnectionStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.status.is_empty() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConnectionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConnectionStatus");
        debug_struct.field("state", &self.state);
        debug_struct.field("description", &self.description);
        debug_struct.field("status", &self.status);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ConnectionStatus].
pub mod connection_status {
    #[allow(unused_imports)]
    use super::*;

    /// All the possible Connection State.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Connection does not have a state yet.
        Unspecified,
        /// Connection is being created.
        Creating,
        /// Connection is running and ready for requests.
        Active,
        /// Connection is stopped.
        Inactive,
        /// Connection is being deleted.
        Deleting,
        /// Connection is being updated.
        Updating,
        /// Connection is not running due to an error.
        Error,
        /// Connection is not running due to an auth error for the Oauth2 Auth Code
        /// based connector.
        AuthorizationRequired,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Inactive => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Updating => std::option::Option::Some(5),
                Self::Error => std::option::Option::Some(6),
                Self::AuthorizationRequired => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::AuthorizationRequired => std::option::Option::Some("AUTHORIZATION_REQUIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Inactive,
                4 => Self::Deleting,
                5 => Self::Updating,
                6 => Self::Error,
                7 => Self::AuthorizationRequired,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "INACTIVE" => Self::Inactive,
                "DELETING" => Self::Deleting,
                "UPDATING" => Self::Updating,
                "ERROR" => Self::Error,
                "AUTHORIZATION_REQUIRED" => Self::AuthorizationRequired,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Inactive => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Updating => serializer.serialize_i32(5),
                Self::Error => serializer.serialize_i32(6),
                Self::AuthorizationRequired => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.connectors.v1.ConnectionStatus.State",
            ))
        }
    }
}

/// Connectors indicates a specific connector type, e.x. Salesforce, SAP etc.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Connector {
    /// Output only. Resource name of the Connector.
    /// Format:
    /// projects/{project}/locations/{location}/providers/{provider}/connectors/{connector}
    /// Only global location is supported for Connector resource.
    pub name: std::string::String,

    /// Output only. Created time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Updated time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Resource labels to represent user-provided metadata.
    /// Refer to cloud documentation on labels for more details.
    /// <https://cloud.google.com/compute/docs/labeling-resources>
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Link to documentation page.
    pub documentation_uri: std::string::String,

    /// Output only. Link to external page.
    pub external_uri: std::string::String,

    /// Output only. Description of the resource.
    pub description: std::string::String,

    /// Output only. Cloud storage location of icons etc consumed by UI.
    pub web_assets_location: std::string::String,

    /// Output only. Display name.
    pub display_name: std::string::String,

    /// Output only. Flag to mark the version indicating the launch stage.
    pub launch_stage: crate::model::LaunchStage,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Connector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Connector::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Connector::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Connector::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Connector::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Connector::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Connector::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [documentation_uri][crate::model::Connector::documentation_uri].
    pub fn set_documentation_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.documentation_uri = v.into();
        self
    }

    /// Sets the value of [external_uri][crate::model::Connector::external_uri].
    pub fn set_external_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_uri = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Connector::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [web_assets_location][crate::model::Connector::web_assets_location].
    pub fn set_web_assets_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.web_assets_location = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Connector::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [launch_stage][crate::model::Connector::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<crate::model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }
}

impl wkt::message::Message for Connector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.Connector"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Connector {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __documentation_uri,
            __external_uri,
            __description,
            __web_assets_location,
            __display_name,
            __launch_stage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Connector")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "documentationUri" => Ok(__FieldTag::__documentation_uri),
                            "documentation_uri" => Ok(__FieldTag::__documentation_uri),
                            "externalUri" => Ok(__FieldTag::__external_uri),
                            "external_uri" => Ok(__FieldTag::__external_uri),
                            "description" => Ok(__FieldTag::__description),
                            "webAssetsLocation" => Ok(__FieldTag::__web_assets_location),
                            "web_assets_location" => Ok(__FieldTag::__web_assets_location),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "launchStage" => Ok(__FieldTag::__launch_stage),
                            "launch_stage" => Ok(__FieldTag::__launch_stage),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Connector;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Connector")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__documentation_uri => {
                            if !fields.insert(__FieldTag::__documentation_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documentation_uri",
                                ));
                            }
                            result.documentation_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_uri => {
                            if !fields.insert(__FieldTag::__external_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_uri",
                                ));
                            }
                            result.external_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__web_assets_location => {
                            if !fields.insert(__FieldTag::__web_assets_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for web_assets_location",
                                ));
                            }
                            result.web_assets_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__launch_stage => {
                            if !fields.insert(__FieldTag::__launch_stage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for launch_stage",
                                ));
                            }
                            result.launch_stage = map
                                .next_value::<std::option::Option<crate::model::LaunchStage>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Connector {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.documentation_uri.is_empty() {
            state.serialize_entry("documentationUri", &self.documentation_uri)?;
        }
        if !self.external_uri.is_empty() {
            state.serialize_entry("externalUri", &self.external_uri)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.web_assets_location.is_empty() {
            state.serialize_entry("webAssetsLocation", &self.web_assets_location)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.launch_stage) {
            state.serialize_entry("launchStage", &self.launch_stage)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Connector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Connector");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("documentation_uri", &self.documentation_uri);
        debug_struct.field("external_uri", &self.external_uri);
        debug_struct.field("description", &self.description);
        debug_struct.field("web_assets_location", &self.web_assets_location);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("launch_stage", &self.launch_stage);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for Connectors.GetConnector.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConnectorRequest {
    /// Required. Resource name of the form:
    /// `projects/*/locations/*/providers/*/connectors/*`
    /// Only global location is supported for Connector resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.GetConnectorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConnectorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConnectorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConnectorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConnectorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetConnectorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetConnectorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConnectorRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for Connectors.ListConnectors.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectorsRequest {
    /// Required. Parent resource of the connectors, of the form:
    /// `projects/*/locations/*/providers/*`
    /// Only global location is supported for Connector resource.
    pub parent: std::string::String,

    /// Page size.
    pub page_size: i32,

    /// Page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectorsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectorsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListConnectorsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectorsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectorsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectorsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectorsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectorsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConnectorsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectorsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for Connectors.ListConnectors.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectorsResponse {
    /// A list of connectors.
    pub connectors: std::vec::Vec<crate::model::Connector>,

    /// Next page token.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectorsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connectors][crate::model::ListConnectorsResponse::connectors].
    pub fn set_connectors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connector>,
    {
        use std::iter::Iterator;
        self.connectors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConnectorsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListConnectorsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectorsResponse {
    type PageItem = crate::model::Connector;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connectors
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectorsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connectors,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectorsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connectors" => Ok(__FieldTag::__connectors),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectorsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectorsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connectors => {
                            if !fields.insert(__FieldTag::__connectors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connectors",
                                ));
                            }
                            result.connectors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Connector>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectorsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connectors.is_empty() {
            state.serialize_entry("connectors", &self.connectors)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConnectorsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectorsResponse");
        debug_struct.field("connectors", &self.connectors);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ConnectorVersion indicates a specific version of a connector.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConnectorVersion {
    /// Output only. Resource name of the Version.
    /// Format:
    /// projects/{project}/locations/{location}/providers/{provider}/connectors/{connector}/versions/{version}
    /// Only global location is supported for Connector resource.
    pub name: std::string::String,

    /// Output only. Created time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Updated time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Resource labels to represent user-provided metadata.
    /// Refer to cloud documentation on labels for more details.
    /// <https://cloud.google.com/compute/docs/labeling-resources>
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Flag to mark the version indicating the launch stage.
    pub launch_stage: crate::model::LaunchStage,

    /// Output only. ReleaseVersion of the connector, for example: "1.0.1-alpha".
    pub release_version: std::string::String,

    /// Output only. List of auth configs supported by the Connector Version.
    pub auth_config_templates: std::vec::Vec<crate::model::AuthConfigTemplate>,

    /// Output only. List of config variables needed to create a connection.
    pub config_variable_templates: std::vec::Vec<crate::model::ConfigVariableTemplate>,

    /// Output only. Information about the runtime features supported by the
    /// Connector.
    pub supported_runtime_features: std::option::Option<crate::model::SupportedRuntimeFeatures>,

    /// Output only. Display name.
    pub display_name: std::string::String,

    /// Output only. Configuration for Egress Control.
    pub egress_control_config: std::option::Option<crate::model::EgressControlConfig>,

    /// Output only. Role grant configurations for this connector version.
    pub role_grants: std::vec::Vec<crate::model::RoleGrant>,

    /// Output only. Role grant configuration for this config variable. It will be
    /// DEPRECATED soon.
    pub role_grant: std::option::Option<crate::model::RoleGrant>,

    /// Output only. Ssl configuration supported by the Connector.
    pub ssl_config_template: std::option::Option<crate::model::SslConfigTemplate>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectorVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConnectorVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ConnectorVersion::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ConnectorVersion::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ConnectorVersion::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ConnectorVersion::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::ConnectorVersion::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [launch_stage][crate::model::ConnectorVersion::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<crate::model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }

    /// Sets the value of [release_version][crate::model::ConnectorVersion::release_version].
    pub fn set_release_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release_version = v.into();
        self
    }

    /// Sets the value of [auth_config_templates][crate::model::ConnectorVersion::auth_config_templates].
    pub fn set_auth_config_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AuthConfigTemplate>,
    {
        use std::iter::Iterator;
        self.auth_config_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [config_variable_templates][crate::model::ConnectorVersion::config_variable_templates].
    pub fn set_config_variable_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConfigVariableTemplate>,
    {
        use std::iter::Iterator;
        self.config_variable_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_runtime_features][crate::model::ConnectorVersion::supported_runtime_features].
    pub fn set_supported_runtime_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SupportedRuntimeFeatures>,
    {
        self.supported_runtime_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [supported_runtime_features][crate::model::ConnectorVersion::supported_runtime_features].
    pub fn set_or_clear_supported_runtime_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SupportedRuntimeFeatures>,
    {
        self.supported_runtime_features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [display_name][crate::model::ConnectorVersion::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [egress_control_config][crate::model::ConnectorVersion::egress_control_config].
    pub fn set_egress_control_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EgressControlConfig>,
    {
        self.egress_control_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [egress_control_config][crate::model::ConnectorVersion::egress_control_config].
    pub fn set_or_clear_egress_control_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EgressControlConfig>,
    {
        self.egress_control_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [role_grants][crate::model::ConnectorVersion::role_grants].
    pub fn set_role_grants<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RoleGrant>,
    {
        use std::iter::Iterator;
        self.role_grants = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [role_grant][crate::model::ConnectorVersion::role_grant].
    pub fn set_role_grant<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RoleGrant>,
    {
        self.role_grant = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [role_grant][crate::model::ConnectorVersion::role_grant].
    pub fn set_or_clear_role_grant<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RoleGrant>,
    {
        self.role_grant = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ssl_config_template][crate::model::ConnectorVersion::ssl_config_template].
    pub fn set_ssl_config_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslConfigTemplate>,
    {
        self.ssl_config_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssl_config_template][crate::model::ConnectorVersion::ssl_config_template].
    pub fn set_or_clear_ssl_config_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslConfigTemplate>,
    {
        self.ssl_config_template = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ConnectorVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ConnectorVersion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConnectorVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __launch_stage,
            __release_version,
            __auth_config_templates,
            __config_variable_templates,
            __supported_runtime_features,
            __display_name,
            __egress_control_config,
            __role_grants,
            __role_grant,
            __ssl_config_template,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConnectorVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "launchStage" => Ok(__FieldTag::__launch_stage),
                            "launch_stage" => Ok(__FieldTag::__launch_stage),
                            "releaseVersion" => Ok(__FieldTag::__release_version),
                            "release_version" => Ok(__FieldTag::__release_version),
                            "authConfigTemplates" => Ok(__FieldTag::__auth_config_templates),
                            "auth_config_templates" => Ok(__FieldTag::__auth_config_templates),
                            "configVariableTemplates" => {
                                Ok(__FieldTag::__config_variable_templates)
                            }
                            "config_variable_templates" => {
                                Ok(__FieldTag::__config_variable_templates)
                            }
                            "supportedRuntimeFeatures" => {
                                Ok(__FieldTag::__supported_runtime_features)
                            }
                            "supported_runtime_features" => {
                                Ok(__FieldTag::__supported_runtime_features)
                            }
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "egressControlConfig" => Ok(__FieldTag::__egress_control_config),
                            "egress_control_config" => Ok(__FieldTag::__egress_control_config),
                            "roleGrants" => Ok(__FieldTag::__role_grants),
                            "role_grants" => Ok(__FieldTag::__role_grants),
                            "roleGrant" => Ok(__FieldTag::__role_grant),
                            "role_grant" => Ok(__FieldTag::__role_grant),
                            "sslConfigTemplate" => Ok(__FieldTag::__ssl_config_template),
                            "ssl_config_template" => Ok(__FieldTag::__ssl_config_template),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConnectorVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConnectorVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__launch_stage => {
                            if !fields.insert(__FieldTag::__launch_stage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for launch_stage",
                                ));
                            }
                            result.launch_stage = map
                                .next_value::<std::option::Option<crate::model::LaunchStage>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release_version => {
                            if !fields.insert(__FieldTag::__release_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_version",
                                ));
                            }
                            result.release_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auth_config_templates => {
                            if !fields.insert(__FieldTag::__auth_config_templates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auth_config_templates",
                                ));
                            }
                            result.auth_config_templates = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AuthConfigTemplate>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config_variable_templates => {
                            if !fields.insert(__FieldTag::__config_variable_templates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_variable_templates",
                                ));
                            }
                            result.config_variable_templates = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConfigVariableTemplate>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__supported_runtime_features => {
                            if !fields.insert(__FieldTag::__supported_runtime_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_runtime_features",
                                ));
                            }
                            result.supported_runtime_features = map.next_value::<std::option::Option<crate::model::SupportedRuntimeFeatures>>()?
                                ;
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__egress_control_config => {
                            if !fields.insert(__FieldTag::__egress_control_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for egress_control_config",
                                ));
                            }
                            result.egress_control_config = map.next_value::<std::option::Option<crate::model::EgressControlConfig>>()?
                                ;
                        }
                        __FieldTag::__role_grants => {
                            if !fields.insert(__FieldTag::__role_grants) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role_grants",
                                ));
                            }
                            result.role_grants = map.next_value::<std::option::Option<std::vec::Vec<crate::model::RoleGrant>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__role_grant => {
                            if !fields.insert(__FieldTag::__role_grant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role_grant",
                                ));
                            }
                            result.role_grant =
                                map.next_value::<std::option::Option<crate::model::RoleGrant>>()?;
                        }
                        __FieldTag::__ssl_config_template => {
                            if !fields.insert(__FieldTag::__ssl_config_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl_config_template",
                                ));
                            }
                            result.ssl_config_template = map
                                .next_value::<std::option::Option<crate::model::SslConfigTemplate>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConnectorVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.launch_stage) {
            state.serialize_entry("launchStage", &self.launch_stage)?;
        }
        if !self.release_version.is_empty() {
            state.serialize_entry("releaseVersion", &self.release_version)?;
        }
        if !self.auth_config_templates.is_empty() {
            state.serialize_entry("authConfigTemplates", &self.auth_config_templates)?;
        }
        if !self.config_variable_templates.is_empty() {
            state.serialize_entry("configVariableTemplates", &self.config_variable_templates)?;
        }
        if self.supported_runtime_features.is_some() {
            state.serialize_entry("supportedRuntimeFeatures", &self.supported_runtime_features)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.egress_control_config.is_some() {
            state.serialize_entry("egressControlConfig", &self.egress_control_config)?;
        }
        if !self.role_grants.is_empty() {
            state.serialize_entry("roleGrants", &self.role_grants)?;
        }
        if self.role_grant.is_some() {
            state.serialize_entry("roleGrant", &self.role_grant)?;
        }
        if self.ssl_config_template.is_some() {
            state.serialize_entry("sslConfigTemplate", &self.ssl_config_template)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConnectorVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConnectorVersion");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("launch_stage", &self.launch_stage);
        debug_struct.field("release_version", &self.release_version);
        debug_struct.field("auth_config_templates", &self.auth_config_templates);
        debug_struct.field("config_variable_templates", &self.config_variable_templates);
        debug_struct.field(
            "supported_runtime_features",
            &self.supported_runtime_features,
        );
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("egress_control_config", &self.egress_control_config);
        debug_struct.field("role_grants", &self.role_grants);
        debug_struct.field("role_grant", &self.role_grant);
        debug_struct.field("ssl_config_template", &self.ssl_config_template);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for Connectors.GetConnectorVersion.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConnectorVersionRequest {
    /// Required. Resource name of the form:
    /// `projects/*/locations/*/providers/*/connectors/*/versions/*`
    /// Only global location is supported for ConnectorVersion resource.
    pub name: std::string::String,

    /// Specifies which fields of the ConnectorVersion are returned in the
    /// response. Defaults to `CUSTOMER` view.
    pub view: crate::model::ConnectorVersionView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectorVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectorVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetConnectorVersionRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ConnectorVersionView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectorVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.GetConnectorVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConnectorVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConnectorVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConnectorVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConnectorVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map.next_value::<std::option::Option<crate::model::ConnectorVersionView>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetConnectorVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetConnectorVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConnectorVersionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for Connectors.ListConnectorVersions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectorVersionsRequest {
    /// Required. Parent resource of the connectors, of the form:
    /// `projects/*/locations/*/providers/*/connectors/*`
    /// Only global location is supported for ConnectorVersion resource.
    pub parent: std::string::String,

    /// Page size.
    pub page_size: i32,

    /// Page token.
    pub page_token: std::string::String,

    /// Specifies which fields of the ConnectorVersion are returned in the
    /// response. Defaults to `BASIC` view.
    pub view: crate::model::ConnectorVersionView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectorVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectorVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectorVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectorVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListConnectorVersionsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ConnectorVersionView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectorVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListConnectorVersionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectorVersionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectorVersionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectorVersionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectorVersionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map.next_value::<std::option::Option<crate::model::ConnectorVersionView>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectorVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConnectorVersionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectorVersionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for Connectors.ListConnectorVersions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectorVersionsResponse {
    /// A list of connector versions.
    pub connector_versions: std::vec::Vec<crate::model::ConnectorVersion>,

    /// Next page token.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectorVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connector_versions][crate::model::ListConnectorVersionsResponse::connector_versions].
    pub fn set_connector_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConnectorVersion>,
    {
        use std::iter::Iterator;
        self.connector_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectorVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConnectorVersionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectorVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListConnectorVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectorVersionsResponse {
    type PageItem = crate::model::ConnectorVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connector_versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectorVersionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connector_versions,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectorVersionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connectorVersions" => Ok(__FieldTag::__connector_versions),
                            "connector_versions" => Ok(__FieldTag::__connector_versions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectorVersionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectorVersionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connector_versions => {
                            if !fields.insert(__FieldTag::__connector_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connector_versions",
                                ));
                            }
                            result.connector_versions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConnectorVersion>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectorVersionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connector_versions.is_empty() {
            state.serialize_entry("connectorVersions", &self.connector_versions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConnectorVersionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectorVersionsResponse");
        debug_struct.field("connector_versions", &self.connector_versions);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Supported runtime features of a connector version. This is passed to the
/// management layer to add a new connector version by the connector developer.
/// Details about how this proto is passed to the management layer is covered in
/// this doc - go/runtime-manifest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SupportedRuntimeFeatures {
    /// Specifies if the connector supports entity apis like 'createEntity'.
    pub entity_apis: bool,

    /// Specifies if the connector supports action apis like 'executeAction'.
    pub action_apis: bool,

    /// Specifies if the connector supports 'ExecuteSqlQuery' operation.
    pub sql_query: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SupportedRuntimeFeatures {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_apis][crate::model::SupportedRuntimeFeatures::entity_apis].
    pub fn set_entity_apis<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.entity_apis = v.into();
        self
    }

    /// Sets the value of [action_apis][crate::model::SupportedRuntimeFeatures::action_apis].
    pub fn set_action_apis<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.action_apis = v.into();
        self
    }

    /// Sets the value of [sql_query][crate::model::SupportedRuntimeFeatures::sql_query].
    pub fn set_sql_query<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.sql_query = v.into();
        self
    }
}

impl wkt::message::Message for SupportedRuntimeFeatures {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.SupportedRuntimeFeatures"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SupportedRuntimeFeatures {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity_apis,
            __action_apis,
            __sql_query,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SupportedRuntimeFeatures")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entityApis" => Ok(__FieldTag::__entity_apis),
                            "entity_apis" => Ok(__FieldTag::__entity_apis),
                            "actionApis" => Ok(__FieldTag::__action_apis),
                            "action_apis" => Ok(__FieldTag::__action_apis),
                            "sqlQuery" => Ok(__FieldTag::__sql_query),
                            "sql_query" => Ok(__FieldTag::__sql_query),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SupportedRuntimeFeatures;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SupportedRuntimeFeatures")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity_apis => {
                            if !fields.insert(__FieldTag::__entity_apis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_apis",
                                ));
                            }
                            result.entity_apis = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__action_apis => {
                            if !fields.insert(__FieldTag::__action_apis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action_apis",
                                ));
                            }
                            result.action_apis = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sql_query => {
                            if !fields.insert(__FieldTag::__sql_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_query",
                                ));
                            }
                            result.sql_query = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SupportedRuntimeFeatures {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.entity_apis) {
            state.serialize_entry("entityApis", &self.entity_apis)?;
        }
        if !wkt::internal::is_default(&self.action_apis) {
            state.serialize_entry("actionApis", &self.action_apis)?;
        }
        if !wkt::internal::is_default(&self.sql_query) {
            state.serialize_entry("sqlQuery", &self.sql_query)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SupportedRuntimeFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SupportedRuntimeFeatures");
        debug_struct.field("entity_apis", &self.entity_apis);
        debug_struct.field("action_apis", &self.action_apis);
        debug_struct.field("sql_query", &self.sql_query);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Egress control config for connector runtime. These configurations define the
/// rules to identify which outbound domains/hosts needs to be whitelisted. It
/// may be a static information for a particular connector version or it is
/// derived from the configurations provided by the customer in Connection
/// resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EgressControlConfig {
    pub oneof_backends: std::option::Option<crate::model::egress_control_config::OneofBackends>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EgressControlConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [oneof_backends][crate::model::EgressControlConfig::oneof_backends].
    ///
    /// Note that all the setters affecting `oneof_backends` are mutually
    /// exclusive.
    pub fn set_oneof_backends<
        T: std::convert::Into<std::option::Option<crate::model::egress_control_config::OneofBackends>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.oneof_backends = v.into();
        self
    }

    /// The value of [oneof_backends][crate::model::EgressControlConfig::oneof_backends]
    /// if it holds a `Backends`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backends(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.oneof_backends.as_ref().and_then(|v| match v {
            crate::model::egress_control_config::OneofBackends::Backends(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [oneof_backends][crate::model::EgressControlConfig::oneof_backends]
    /// to hold a `Backends`.
    ///
    /// Note that all the setters affecting `oneof_backends` are
    /// mutually exclusive.
    pub fn set_backends<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oneof_backends = std::option::Option::Some(
            crate::model::egress_control_config::OneofBackends::Backends(v.into()),
        );
        self
    }

    /// The value of [oneof_backends][crate::model::EgressControlConfig::oneof_backends]
    /// if it holds a `ExtractionRules`, `None` if the field is not set or
    /// holds a different branch.
    pub fn extraction_rules(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExtractionRules>> {
        #[allow(unreachable_patterns)]
        self.oneof_backends.as_ref().and_then(|v| match v {
            crate::model::egress_control_config::OneofBackends::ExtractionRules(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [oneof_backends][crate::model::EgressControlConfig::oneof_backends]
    /// to hold a `ExtractionRules`.
    ///
    /// Note that all the setters affecting `oneof_backends` are
    /// mutually exclusive.
    pub fn set_extraction_rules<
        T: std::convert::Into<std::boxed::Box<crate::model::ExtractionRules>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.oneof_backends = std::option::Option::Some(
            crate::model::egress_control_config::OneofBackends::ExtractionRules(v.into()),
        );
        self
    }
}

impl wkt::message::Message for EgressControlConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.EgressControlConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EgressControlConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backends,
            __extraction_rules,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EgressControlConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backends" => Ok(__FieldTag::__backends),
                            "extractionRules" => Ok(__FieldTag::__extraction_rules),
                            "extraction_rules" => Ok(__FieldTag::__extraction_rules),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EgressControlConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EgressControlConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backends => {
                            if !fields.insert(__FieldTag::__backends) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backends",
                                ));
                            }
                            if result.oneof_backends.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `oneof_backends`, a oneof with full ID .google.cloud.connectors.v1.EgressControlConfig.backends, latest field was backends",
                                ));
                            }
                            result.oneof_backends = std::option::Option::Some(
                                crate::model::egress_control_config::OneofBackends::Backends(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__extraction_rules => {
                            if !fields.insert(__FieldTag::__extraction_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extraction_rules",
                                ));
                            }
                            if result.oneof_backends.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `oneof_backends`, a oneof with full ID .google.cloud.connectors.v1.EgressControlConfig.extraction_rules, latest field was extractionRules",
                                ));
                            }
                            result.oneof_backends = std::option::Option::Some(
                                crate::model::egress_control_config::OneofBackends::ExtractionRules(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ExtractionRules>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EgressControlConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.backends() {
            state.serialize_entry("backends", value)?;
        }
        if let Some(value) = self.extraction_rules() {
            state.serialize_entry("extractionRules", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EgressControlConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EgressControlConfig");
        debug_struct.field("oneof_backends", &self.oneof_backends);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [EgressControlConfig].
pub mod egress_control_config {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OneofBackends {
        /// Static Comma separated backends which are common for all Connection
        /// resources. Supported formats for each backend are host:port or just
        /// host (host can be ip address or domain name).
        Backends(std::string::String),
        /// Extractions Rules to extract the backends from customer provided
        /// configuration.
        ExtractionRules(std::boxed::Box<crate::model::ExtractionRules>),
    }
}

/// Extraction Rules to identity the backends from customer provided
/// configuration in Connection resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExtractionRules {
    /// Collection of Extraction Rule.
    pub extraction_rule: std::vec::Vec<crate::model::ExtractionRule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExtractionRules {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [extraction_rule][crate::model::ExtractionRules::extraction_rule].
    pub fn set_extraction_rule<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExtractionRule>,
    {
        use std::iter::Iterator;
        self.extraction_rule = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExtractionRules {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ExtractionRules"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExtractionRules {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __extraction_rule,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExtractionRules")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "extractionRule" => Ok(__FieldTag::__extraction_rule),
                            "extraction_rule" => Ok(__FieldTag::__extraction_rule),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExtractionRules;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExtractionRules")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__extraction_rule => {
                            if !fields.insert(__FieldTag::__extraction_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extraction_rule",
                                ));
                            }
                            result.extraction_rule =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ExtractionRule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExtractionRules {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.extraction_rule.is_empty() {
            state.serialize_entry("extractionRule", &self.extraction_rule)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExtractionRules {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExtractionRules");
        debug_struct.field("extraction_rule", &self.extraction_rule);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Extraction Rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExtractionRule {
    /// Source on which the rule is applied.
    pub source: std::option::Option<crate::model::extraction_rule::Source>,

    /// Regex used to extract backend details from source. If empty, whole source
    /// value will be used.
    pub extraction_regex: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExtractionRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::ExtractionRule::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::extraction_rule::Source>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::ExtractionRule::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::extraction_rule::Source>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [extraction_regex][crate::model::ExtractionRule::extraction_regex].
    pub fn set_extraction_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.extraction_regex = v.into();
        self
    }
}

impl wkt::message::Message for ExtractionRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ExtractionRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExtractionRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source,
            __extraction_regex,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExtractionRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "source" => Ok(__FieldTag::__source),
                            "extractionRegex" => Ok(__FieldTag::__extraction_regex),
                            "extraction_regex" => Ok(__FieldTag::__extraction_regex),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExtractionRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExtractionRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map.next_value::<std::option::Option<crate::model::extraction_rule::Source>>()?
                                ;
                        }
                        __FieldTag::__extraction_regex => {
                            if !fields.insert(__FieldTag::__extraction_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extraction_regex",
                                ));
                            }
                            result.extraction_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExtractionRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self.extraction_regex.is_empty() {
            state.serialize_entry("extractionRegex", &self.extraction_regex)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExtractionRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExtractionRule");
        debug_struct.field("source", &self.source);
        debug_struct.field("extraction_regex", &self.extraction_regex);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ExtractionRule].
pub mod extraction_rule {
    #[allow(unused_imports)]
    use super::*;

    /// Source to extract the backend from.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Source {
        /// Type of the source.
        pub source_type: crate::model::extraction_rule::SourceType,

        /// Field identifier. For example config vaiable name.
        pub field_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Source {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_type][crate::model::extraction_rule::Source::source_type].
        pub fn set_source_type<T: std::convert::Into<crate::model::extraction_rule::SourceType>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_type = v.into();
            self
        }

        /// Sets the value of [field_id][crate::model::extraction_rule::Source::field_id].
        pub fn set_field_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.field_id = v.into();
            self
        }
    }

    impl wkt::message::Message for Source {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.connectors.v1.ExtractionRule.Source"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Source {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __source_type,
                __field_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Source")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sourceType" => Ok(__FieldTag::__source_type),
                                "source_type" => Ok(__FieldTag::__source_type),
                                "fieldId" => Ok(__FieldTag::__field_id),
                                "field_id" => Ok(__FieldTag::__field_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Source;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Source")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__source_type => {
                                if !fields.insert(__FieldTag::__source_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source_type",
                                    ));
                                }
                                result.source_type =
                                    map.next_value::<std::option::Option<
                                        crate::model::extraction_rule::SourceType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__field_id => {
                                if !fields.insert(__FieldTag::__field_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for field_id",
                                    ));
                                }
                                result.field_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Source {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.source_type) {
                state.serialize_entry("sourceType", &self.source_type)?;
            }
            if !self.field_id.is_empty() {
                state.serialize_entry("fieldId", &self.field_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Source {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Source");
            debug_struct.field("source_type", &self.source_type);
            debug_struct.field("field_id", &self.field_id);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Supported Source types for extraction.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceType {
        /// Default SOURCE.
        Unspecified,
        /// Config Variable source type.
        ConfigVariable,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SourceType::value] or
        /// [SourceType::name].
        UnknownValue(source_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod source_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SourceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ConfigVariable => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SOURCE_TYPE_UNSPECIFIED"),
                Self::ConfigVariable => std::option::Option::Some("CONFIG_VARIABLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SourceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SourceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SourceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ConfigVariable,
                _ => Self::UnknownValue(source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SourceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CONFIG_VARIABLE" => Self::ConfigVariable,
                _ => Self::UnknownValue(source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SourceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ConfigVariable => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SourceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SourceType>::new(
                ".google.cloud.connectors.v1.ExtractionRule.SourceType",
            ))
        }
    }
}

/// Define the Connectors target endpoint.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DestinationConfig {
    /// The key is the destination identifier that is supported by the Connector.
    pub key: std::string::String,

    /// The destinations for the key.
    pub destinations: std::vec::Vec<crate::model::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DestinationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::DestinationConfig::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [destinations][crate::model::DestinationConfig::destinations].
    pub fn set_destinations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Destination>,
    {
        use std::iter::Iterator;
        self.destinations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DestinationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.DestinationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DestinationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __destinations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DestinationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "destinations" => Ok(__FieldTag::__destinations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DestinationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DestinationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destinations => {
                            if !fields.insert(__FieldTag::__destinations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destinations",
                                ));
                            }
                            result.destinations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Destination>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DestinationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self.destinations.is_empty() {
            state.serialize_entry("destinations", &self.destinations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DestinationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DestinationConfig");
        debug_struct.field("key", &self.key);
        debug_struct.field("destinations", &self.destinations);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Destination {
    /// The port is the target port number that is accepted by the destination.
    pub port: i32,

    pub destination: std::option::Option<crate::model::destination::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Destination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [port][crate::model::Destination::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::Destination::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::destination::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::Destination::destination]
    /// if it holds a `ServiceAttachment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn service_attachment(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::destination::Destination::ServiceAttachment(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::Destination::destination]
    /// to hold a `ServiceAttachment`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::destination::Destination::ServiceAttachment(v.into()),
        );
        self
    }

    /// The value of [destination][crate::model::Destination::destination]
    /// if it holds a `Host`, `None` if the field is not set or
    /// holds a different branch.
    pub fn host(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::destination::Destination::Host(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::Destination::destination]
    /// to hold a `Host`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination =
            std::option::Option::Some(crate::model::destination::Destination::Host(v.into()));
        self
    }
}

impl wkt::message::Message for Destination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.Destination"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Destination {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_attachment,
            __host,
            __port,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Destination")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceAttachment" => Ok(__FieldTag::__service_attachment),
                            "service_attachment" => Ok(__FieldTag::__service_attachment),
                            "host" => Ok(__FieldTag::__host),
                            "port" => Ok(__FieldTag::__port),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Destination;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Destination")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_attachment => {
                            if !fields.insert(__FieldTag::__service_attachment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_attachment",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.connectors.v1.Destination.service_attachment, latest field was serviceAttachment",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::destination::Destination::ServiceAttachment(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__host => {
                            if !fields.insert(__FieldTag::__host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.connectors.v1.Destination.host, latest field was host",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::destination::Destination::Host(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Destination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.service_attachment() {
            state.serialize_entry("serviceAttachment", value)?;
        }
        if let Some(value) = self.host() {
            state.serialize_entry("host", value)?;
        }
        if !wkt::internal::is_default(&self.port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Destination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Destination");
        debug_struct.field("port", &self.port);
        debug_struct.field("destination", &self.destination);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Destination].
pub mod destination {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// PSC service attachments.
        /// Format: projects/*/regions/*/serviceAttachments/*
        ServiceAttachment(std::string::String),
        /// For publicly routable host.
        Host(std::string::String),
    }
}

/// Provider indicates the owner who provides the connectors.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Provider {
    /// Output only. Resource name of the Provider.
    /// Format: projects/{project}/locations/{location}/providers/{provider}
    /// Only global location is supported for Provider resource.
    pub name: std::string::String,

    /// Output only. Created time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Updated time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Resource labels to represent user-provided metadata.
    /// Refer to cloud documentation on labels for more details.
    /// <https://cloud.google.com/compute/docs/labeling-resources>
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Link to documentation page.
    pub documentation_uri: std::string::String,

    /// Output only. Link to external page.
    pub external_uri: std::string::String,

    /// Output only. Description of the resource.
    pub description: std::string::String,

    /// Output only. Cloud storage location of icons etc consumed by UI.
    pub web_assets_location: std::string::String,

    /// Output only. Display name.
    pub display_name: std::string::String,

    /// Output only. Flag to mark the version indicating the launch stage.
    pub launch_stage: crate::model::LaunchStage,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Provider {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Provider::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Provider::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Provider::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Provider::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Provider::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Provider::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [documentation_uri][crate::model::Provider::documentation_uri].
    pub fn set_documentation_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.documentation_uri = v.into();
        self
    }

    /// Sets the value of [external_uri][crate::model::Provider::external_uri].
    pub fn set_external_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_uri = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Provider::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [web_assets_location][crate::model::Provider::web_assets_location].
    pub fn set_web_assets_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.web_assets_location = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Provider::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [launch_stage][crate::model::Provider::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<crate::model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }
}

impl wkt::message::Message for Provider {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.Provider"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Provider {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __documentation_uri,
            __external_uri,
            __description,
            __web_assets_location,
            __display_name,
            __launch_stage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Provider")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "documentationUri" => Ok(__FieldTag::__documentation_uri),
                            "documentation_uri" => Ok(__FieldTag::__documentation_uri),
                            "externalUri" => Ok(__FieldTag::__external_uri),
                            "external_uri" => Ok(__FieldTag::__external_uri),
                            "description" => Ok(__FieldTag::__description),
                            "webAssetsLocation" => Ok(__FieldTag::__web_assets_location),
                            "web_assets_location" => Ok(__FieldTag::__web_assets_location),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "launchStage" => Ok(__FieldTag::__launch_stage),
                            "launch_stage" => Ok(__FieldTag::__launch_stage),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Provider;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Provider")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__documentation_uri => {
                            if !fields.insert(__FieldTag::__documentation_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documentation_uri",
                                ));
                            }
                            result.documentation_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_uri => {
                            if !fields.insert(__FieldTag::__external_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_uri",
                                ));
                            }
                            result.external_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__web_assets_location => {
                            if !fields.insert(__FieldTag::__web_assets_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for web_assets_location",
                                ));
                            }
                            result.web_assets_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__launch_stage => {
                            if !fields.insert(__FieldTag::__launch_stage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for launch_stage",
                                ));
                            }
                            result.launch_stage = map
                                .next_value::<std::option::Option<crate::model::LaunchStage>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Provider {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.documentation_uri.is_empty() {
            state.serialize_entry("documentationUri", &self.documentation_uri)?;
        }
        if !self.external_uri.is_empty() {
            state.serialize_entry("externalUri", &self.external_uri)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.web_assets_location.is_empty() {
            state.serialize_entry("webAssetsLocation", &self.web_assets_location)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.launch_stage) {
            state.serialize_entry("launchStage", &self.launch_stage)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Provider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Provider");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("documentation_uri", &self.documentation_uri);
        debug_struct.field("external_uri", &self.external_uri);
        debug_struct.field("description", &self.description);
        debug_struct.field("web_assets_location", &self.web_assets_location);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("launch_stage", &self.launch_stage);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for Connectors.GetProvider.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetProviderRequest {
    /// Required. Resource name of the form:
    /// `projects/*/locations/*/providers/*`
    /// Only global location is supported for Provider resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProviderRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProviderRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProviderRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.GetProviderRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetProviderRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetProviderRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetProviderRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetProviderRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetProviderRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetProviderRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetProviderRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for Connectors.ListProviders.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProvidersRequest {
    /// Required. Parent resource of the API, of the form:
    /// `projects/*/locations/*`
    /// Only global location is supported for Provider resource.
    pub parent: std::string::String,

    /// Page size.
    pub page_size: i32,

    /// Page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProvidersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProvidersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProvidersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProvidersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProvidersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListProvidersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProvidersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProvidersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProvidersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProvidersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProvidersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListProvidersRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProvidersRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for Connectors.ListProviders.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProvidersResponse {
    /// A list of providers.
    pub providers: std::vec::Vec<crate::model::Provider>,

    /// Next page token.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProvidersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [providers][crate::model::ListProvidersResponse::providers].
    pub fn set_providers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Provider>,
    {
        use std::iter::Iterator;
        self.providers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListProvidersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListProvidersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListProvidersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.ListProvidersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProvidersResponse {
    type PageItem = crate::model::Provider;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.providers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProvidersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __providers,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProvidersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "providers" => Ok(__FieldTag::__providers),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProvidersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProvidersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__providers => {
                            if !fields.insert(__FieldTag::__providers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for providers",
                                ));
                            }
                            result.providers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Provider>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProvidersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.providers.is_empty() {
            state.serialize_entry("providers", &self.providers)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListProvidersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProvidersResponse");
        debug_struct.field("providers", &self.providers);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for Connectors.GetRuntimeConfig.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetRuntimeConfigRequest {
    /// Required. Resource name of the form:
    /// `projects/*/locations/*/runtimeConfig`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRuntimeConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRuntimeConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRuntimeConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.GetRuntimeConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetRuntimeConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetRuntimeConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetRuntimeConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetRuntimeConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetRuntimeConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetRuntimeConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetRuntimeConfigRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// RuntimeConfig is the singleton resource of each location.
/// It includes generic resource configs consumed by control plane and runtime
/// plane like: pub/sub topic/subscription resource name, Cloud Storage location
/// storing schema etc.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RuntimeConfig {
    /// Output only. location_id of the runtime location. E.g. "us-west1".
    pub location_id: std::string::String,

    /// Output only. Pub/Sub topic for connd to send message.
    /// E.g. projects/{project-id}/topics/{topic-id}
    pub connd_topic: std::string::String,

    /// Output only. Pub/Sub subscription for connd to receive message.
    /// E.g. projects/{project-id}/subscriptions/{topic-id}
    pub connd_subscription: std::string::String,

    /// Output only. Pub/Sub topic for control plne to send message.
    /// communication.
    /// E.g. projects/{project-id}/topics/{topic-id}
    pub control_plane_topic: std::string::String,

    /// Output only. Pub/Sub subscription for control plane to receive message.
    /// E.g. projects/{project-id}/subscriptions/{topic-id}
    pub control_plane_subscription: std::string::String,

    /// Output only. The endpoint of the connectors runtime ingress.
    pub runtime_endpoint: std::string::String,

    /// Output only. The state of the location.
    pub state: crate::model::runtime_config::State,

    /// Output only. The Cloud Storage bucket that stores connector's schema
    /// reports.
    pub schema_gcs_bucket: std::string::String,

    /// Output only. The name of the Service Directory service name.
    pub service_directory: std::string::String,

    /// Output only. Name of the runtimeConfig resource.
    /// Format: projects/{project}/locations/{location}/runtimeConfig
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuntimeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location_id][crate::model::RuntimeConfig::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }

    /// Sets the value of [connd_topic][crate::model::RuntimeConfig::connd_topic].
    pub fn set_connd_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connd_topic = v.into();
        self
    }

    /// Sets the value of [connd_subscription][crate::model::RuntimeConfig::connd_subscription].
    pub fn set_connd_subscription<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.connd_subscription = v.into();
        self
    }

    /// Sets the value of [control_plane_topic][crate::model::RuntimeConfig::control_plane_topic].
    pub fn set_control_plane_topic<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.control_plane_topic = v.into();
        self
    }

    /// Sets the value of [control_plane_subscription][crate::model::RuntimeConfig::control_plane_subscription].
    pub fn set_control_plane_subscription<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.control_plane_subscription = v.into();
        self
    }

    /// Sets the value of [runtime_endpoint][crate::model::RuntimeConfig::runtime_endpoint].
    pub fn set_runtime_endpoint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_endpoint = v.into();
        self
    }

    /// Sets the value of [state][crate::model::RuntimeConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::runtime_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [schema_gcs_bucket][crate::model::RuntimeConfig::schema_gcs_bucket].
    pub fn set_schema_gcs_bucket<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.schema_gcs_bucket = v.into();
        self
    }

    /// Sets the value of [service_directory][crate::model::RuntimeConfig::service_directory].
    pub fn set_service_directory<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_directory = v.into();
        self
    }

    /// Sets the value of [name][crate::model::RuntimeConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RuntimeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.RuntimeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RuntimeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location_id,
            __connd_topic,
            __connd_subscription,
            __control_plane_topic,
            __control_plane_subscription,
            __runtime_endpoint,
            __state,
            __schema_gcs_bucket,
            __service_directory,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RuntimeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "locationId" => Ok(__FieldTag::__location_id),
                            "location_id" => Ok(__FieldTag::__location_id),
                            "conndTopic" => Ok(__FieldTag::__connd_topic),
                            "connd_topic" => Ok(__FieldTag::__connd_topic),
                            "conndSubscription" => Ok(__FieldTag::__connd_subscription),
                            "connd_subscription" => Ok(__FieldTag::__connd_subscription),
                            "controlPlaneTopic" => Ok(__FieldTag::__control_plane_topic),
                            "control_plane_topic" => Ok(__FieldTag::__control_plane_topic),
                            "controlPlaneSubscription" => {
                                Ok(__FieldTag::__control_plane_subscription)
                            }
                            "control_plane_subscription" => {
                                Ok(__FieldTag::__control_plane_subscription)
                            }
                            "runtimeEndpoint" => Ok(__FieldTag::__runtime_endpoint),
                            "runtime_endpoint" => Ok(__FieldTag::__runtime_endpoint),
                            "state" => Ok(__FieldTag::__state),
                            "schemaGcsBucket" => Ok(__FieldTag::__schema_gcs_bucket),
                            "schema_gcs_bucket" => Ok(__FieldTag::__schema_gcs_bucket),
                            "serviceDirectory" => Ok(__FieldTag::__service_directory),
                            "service_directory" => Ok(__FieldTag::__service_directory),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RuntimeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RuntimeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location_id => {
                            if !fields.insert(__FieldTag::__location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_id",
                                ));
                            }
                            result.location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connd_topic => {
                            if !fields.insert(__FieldTag::__connd_topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connd_topic",
                                ));
                            }
                            result.connd_topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connd_subscription => {
                            if !fields.insert(__FieldTag::__connd_subscription) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connd_subscription",
                                ));
                            }
                            result.connd_subscription = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__control_plane_topic => {
                            if !fields.insert(__FieldTag::__control_plane_topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control_plane_topic",
                                ));
                            }
                            result.control_plane_topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__control_plane_subscription => {
                            if !fields.insert(__FieldTag::__control_plane_subscription) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control_plane_subscription",
                                ));
                            }
                            result.control_plane_subscription = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__runtime_endpoint => {
                            if !fields.insert(__FieldTag::__runtime_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_endpoint",
                                ));
                            }
                            result.runtime_endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::runtime_config::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__schema_gcs_bucket => {
                            if !fields.insert(__FieldTag::__schema_gcs_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_gcs_bucket",
                                ));
                            }
                            result.schema_gcs_bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_directory => {
                            if !fields.insert(__FieldTag::__service_directory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_directory",
                                ));
                            }
                            result.service_directory = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RuntimeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if !self.connd_topic.is_empty() {
            state.serialize_entry("conndTopic", &self.connd_topic)?;
        }
        if !self.connd_subscription.is_empty() {
            state.serialize_entry("conndSubscription", &self.connd_subscription)?;
        }
        if !self.control_plane_topic.is_empty() {
            state.serialize_entry("controlPlaneTopic", &self.control_plane_topic)?;
        }
        if !self.control_plane_subscription.is_empty() {
            state.serialize_entry("controlPlaneSubscription", &self.control_plane_subscription)?;
        }
        if !self.runtime_endpoint.is_empty() {
            state.serialize_entry("runtimeEndpoint", &self.runtime_endpoint)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.schema_gcs_bucket.is_empty() {
            state.serialize_entry("schemaGcsBucket", &self.schema_gcs_bucket)?;
        }
        if !self.service_directory.is_empty() {
            state.serialize_entry("serviceDirectory", &self.service_directory)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RuntimeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RuntimeConfig");
        debug_struct.field("location_id", &self.location_id);
        debug_struct.field("connd_topic", &self.connd_topic);
        debug_struct.field("connd_subscription", &self.connd_subscription);
        debug_struct.field("control_plane_topic", &self.control_plane_topic);
        debug_struct.field(
            "control_plane_subscription",
            &self.control_plane_subscription,
        );
        debug_struct.field("runtime_endpoint", &self.runtime_endpoint);
        debug_struct.field("state", &self.state);
        debug_struct.field("schema_gcs_bucket", &self.schema_gcs_bucket);
        debug_struct.field("service_directory", &self.service_directory);
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RuntimeConfig].
pub mod runtime_config {
    #[allow(unused_imports)]
    use super::*;

    /// State of the location.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// STATE_UNSPECIFIED.
        Unspecified,
        /// INACTIVE.
        #[deprecated]
        Inactive,
        /// ACTIVATING.
        #[deprecated]
        Activating,
        /// ACTIVE.
        Active,
        /// CREATING.
        Creating,
        /// DELETING.
        Deleting,
        /// UPDATING.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Inactive => std::option::Option::Some(1),
                Self::Activating => std::option::Option::Some(2),
                Self::Active => std::option::Option::Some(3),
                Self::Creating => std::option::Option::Some(4),
                Self::Deleting => std::option::Option::Some(5),
                Self::Updating => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::Activating => std::option::Option::Some("ACTIVATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Inactive,
                2 => Self::Activating,
                3 => Self::Active,
                4 => Self::Creating,
                5 => Self::Deleting,
                6 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "INACTIVE" => Self::Inactive,
                "ACTIVATING" => Self::Activating,
                "ACTIVE" => Self::Active,
                "CREATING" => Self::Creating,
                "DELETING" => Self::Deleting,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Inactive => serializer.serialize_i32(1),
                Self::Activating => serializer.serialize_i32(2),
                Self::Active => serializer.serialize_i32(3),
                Self::Creating => serializer.serialize_i32(4),
                Self::Deleting => serializer.serialize_i32(5),
                Self::Updating => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.connectors.v1.RuntimeConfig.State",
            ))
        }
    }
}

/// Request for [GetGlobalSettingsRequest].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetGlobalSettingsRequest {
    /// Required. The resource name of the Settings.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGlobalSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGlobalSettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGlobalSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.GetGlobalSettingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetGlobalSettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetGlobalSettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetGlobalSettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGlobalSettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetGlobalSettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetGlobalSettingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetGlobalSettingsRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Global Settings details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Settings {
    /// Output only. Resource name of the Connection.
    /// Format: projects/{project}/locations/global/settings}
    pub name: std::string::String,

    /// Optional. Flag indicates whether vpc-sc is enabled.
    pub vpcsc: bool,

    /// Output only. Flag indicates if user is in PayG model
    pub payg: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Settings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Settings::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [vpcsc][crate::model::Settings::vpcsc].
    pub fn set_vpcsc<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.vpcsc = v.into();
        self
    }

    /// Sets the value of [payg][crate::model::Settings::payg].
    pub fn set_payg<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.payg = v.into();
        self
    }
}

impl wkt::message::Message for Settings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.Settings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Settings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __vpcsc,
            __payg,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Settings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "vpcsc" => Ok(__FieldTag::__vpcsc),
                            "payg" => Ok(__FieldTag::__payg),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Settings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Settings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vpcsc => {
                            if !fields.insert(__FieldTag::__vpcsc) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpcsc",
                                ));
                            }
                            result.vpcsc = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__payg => {
                            if !fields.insert(__FieldTag::__payg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payg",
                                ));
                            }
                            result.payg = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Settings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.vpcsc) {
            state.serialize_entry("vpcsc", &self.vpcsc)?;
        }
        if !wkt::internal::is_default(&self.payg) {
            state.serialize_entry("payg", &self.payg)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Settings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Settings");
        debug_struct.field("name", &self.name);
        debug_struct.field("vpcsc", &self.vpcsc);
        debug_struct.field("payg", &self.payg);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Ssl config details of a connector version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SslConfigTemplate {
    /// Controls the ssl type for the given connector version
    pub ssl_type: crate::model::SslType,

    /// Boolean for determining if the connector version mandates TLS.
    pub is_tls_mandatory: bool,

    /// List of supported Server Cert Types
    pub server_cert_type: std::vec::Vec<crate::model::CertType>,

    /// List of supported Client Cert Types
    pub client_cert_type: std::vec::Vec<crate::model::CertType>,

    /// Any additional fields that need to be rendered
    pub additional_variables: std::vec::Vec<crate::model::ConfigVariableTemplate>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslConfigTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ssl_type][crate::model::SslConfigTemplate::ssl_type].
    pub fn set_ssl_type<T: std::convert::Into<crate::model::SslType>>(mut self, v: T) -> Self {
        self.ssl_type = v.into();
        self
    }

    /// Sets the value of [is_tls_mandatory][crate::model::SslConfigTemplate::is_tls_mandatory].
    pub fn set_is_tls_mandatory<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_tls_mandatory = v.into();
        self
    }

    /// Sets the value of [server_cert_type][crate::model::SslConfigTemplate::server_cert_type].
    pub fn set_server_cert_type<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CertType>,
    {
        use std::iter::Iterator;
        self.server_cert_type = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [client_cert_type][crate::model::SslConfigTemplate::client_cert_type].
    pub fn set_client_cert_type<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CertType>,
    {
        use std::iter::Iterator;
        self.client_cert_type = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [additional_variables][crate::model::SslConfigTemplate::additional_variables].
    pub fn set_additional_variables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConfigVariableTemplate>,
    {
        use std::iter::Iterator;
        self.additional_variables = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SslConfigTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.SslConfigTemplate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SslConfigTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ssl_type,
            __is_tls_mandatory,
            __server_cert_type,
            __client_cert_type,
            __additional_variables,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SslConfigTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sslType" => Ok(__FieldTag::__ssl_type),
                            "ssl_type" => Ok(__FieldTag::__ssl_type),
                            "isTlsMandatory" => Ok(__FieldTag::__is_tls_mandatory),
                            "is_tls_mandatory" => Ok(__FieldTag::__is_tls_mandatory),
                            "serverCertType" => Ok(__FieldTag::__server_cert_type),
                            "server_cert_type" => Ok(__FieldTag::__server_cert_type),
                            "clientCertType" => Ok(__FieldTag::__client_cert_type),
                            "client_cert_type" => Ok(__FieldTag::__client_cert_type),
                            "additionalVariables" => Ok(__FieldTag::__additional_variables),
                            "additional_variables" => Ok(__FieldTag::__additional_variables),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SslConfigTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SslConfigTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ssl_type => {
                            if !fields.insert(__FieldTag::__ssl_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl_type",
                                ));
                            }
                            result.ssl_type = map
                                .next_value::<std::option::Option<crate::model::SslType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_tls_mandatory => {
                            if !fields.insert(__FieldTag::__is_tls_mandatory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_tls_mandatory",
                                ));
                            }
                            result.is_tls_mandatory = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__server_cert_type => {
                            if !fields.insert(__FieldTag::__server_cert_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server_cert_type",
                                ));
                            }
                            result.server_cert_type = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CertType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__client_cert_type => {
                            if !fields.insert(__FieldTag::__client_cert_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_cert_type",
                                ));
                            }
                            result.client_cert_type = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CertType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__additional_variables => {
                            if !fields.insert(__FieldTag::__additional_variables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_variables",
                                ));
                            }
                            result.additional_variables = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConfigVariableTemplate>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SslConfigTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.ssl_type) {
            state.serialize_entry("sslType", &self.ssl_type)?;
        }
        if !wkt::internal::is_default(&self.is_tls_mandatory) {
            state.serialize_entry("isTlsMandatory", &self.is_tls_mandatory)?;
        }
        if !self.server_cert_type.is_empty() {
            state.serialize_entry("serverCertType", &self.server_cert_type)?;
        }
        if !self.client_cert_type.is_empty() {
            state.serialize_entry("clientCertType", &self.client_cert_type)?;
        }
        if !self.additional_variables.is_empty() {
            state.serialize_entry("additionalVariables", &self.additional_variables)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SslConfigTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SslConfigTemplate");
        debug_struct.field("ssl_type", &self.ssl_type);
        debug_struct.field("is_tls_mandatory", &self.is_tls_mandatory);
        debug_struct.field("server_cert_type", &self.server_cert_type);
        debug_struct.field("client_cert_type", &self.client_cert_type);
        debug_struct.field("additional_variables", &self.additional_variables);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SSL Configuration of a connection
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SslConfig {
    /// Controls the ssl type for the given connector version.
    pub r#type: crate::model::SslType,

    /// Trust Model of the SSL connection
    pub trust_model: crate::model::ssl_config::TrustModel,

    /// Private Server Certificate. Needs to be specified if trust model is
    /// `PRIVATE`.
    pub private_server_certificate: std::option::Option<crate::model::Secret>,

    /// Client Certificate
    pub client_certificate: std::option::Option<crate::model::Secret>,

    /// Client Private Key
    pub client_private_key: std::option::Option<crate::model::Secret>,

    /// Secret containing the passphrase protecting the Client Private Key
    pub client_private_key_pass: std::option::Option<crate::model::Secret>,

    /// Type of Server Cert (PEM/JKS/.. etc.)
    pub server_cert_type: crate::model::CertType,

    /// Type of Client Cert (PEM/JKS/.. etc.)
    pub client_cert_type: crate::model::CertType,

    /// Bool for enabling SSL
    pub use_ssl: bool,

    /// Additional SSL related field values
    pub additional_variables: std::vec::Vec<crate::model::ConfigVariable>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::SslConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::SslType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [trust_model][crate::model::SslConfig::trust_model].
    pub fn set_trust_model<T: std::convert::Into<crate::model::ssl_config::TrustModel>>(
        mut self,
        v: T,
    ) -> Self {
        self.trust_model = v.into();
        self
    }

    /// Sets the value of [private_server_certificate][crate::model::SslConfig::private_server_certificate].
    pub fn set_private_server_certificate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.private_server_certificate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_server_certificate][crate::model::SslConfig::private_server_certificate].
    pub fn set_or_clear_private_server_certificate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.private_server_certificate = v.map(|x| x.into());
        self
    }

    /// Sets the value of [client_certificate][crate::model::SslConfig::client_certificate].
    pub fn set_client_certificate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.client_certificate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_certificate][crate::model::SslConfig::client_certificate].
    pub fn set_or_clear_client_certificate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.client_certificate = v.map(|x| x.into());
        self
    }

    /// Sets the value of [client_private_key][crate::model::SslConfig::client_private_key].
    pub fn set_client_private_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.client_private_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_private_key][crate::model::SslConfig::client_private_key].
    pub fn set_or_clear_client_private_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.client_private_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [client_private_key_pass][crate::model::SslConfig::client_private_key_pass].
    pub fn set_client_private_key_pass<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.client_private_key_pass = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_private_key_pass][crate::model::SslConfig::client_private_key_pass].
    pub fn set_or_clear_client_private_key_pass<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.client_private_key_pass = v.map(|x| x.into());
        self
    }

    /// Sets the value of [server_cert_type][crate::model::SslConfig::server_cert_type].
    pub fn set_server_cert_type<T: std::convert::Into<crate::model::CertType>>(
        mut self,
        v: T,
    ) -> Self {
        self.server_cert_type = v.into();
        self
    }

    /// Sets the value of [client_cert_type][crate::model::SslConfig::client_cert_type].
    pub fn set_client_cert_type<T: std::convert::Into<crate::model::CertType>>(
        mut self,
        v: T,
    ) -> Self {
        self.client_cert_type = v.into();
        self
    }

    /// Sets the value of [use_ssl][crate::model::SslConfig::use_ssl].
    pub fn set_use_ssl<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_ssl = v.into();
        self
    }

    /// Sets the value of [additional_variables][crate::model::SslConfig::additional_variables].
    pub fn set_additional_variables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConfigVariable>,
    {
        use std::iter::Iterator;
        self.additional_variables = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SslConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.connectors.v1.SslConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SslConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __trust_model,
            __private_server_certificate,
            __client_certificate,
            __client_private_key,
            __client_private_key_pass,
            __server_cert_type,
            __client_cert_type,
            __use_ssl,
            __additional_variables,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SslConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "trustModel" => Ok(__FieldTag::__trust_model),
                            "trust_model" => Ok(__FieldTag::__trust_model),
                            "privateServerCertificate" => {
                                Ok(__FieldTag::__private_server_certificate)
                            }
                            "private_server_certificate" => {
                                Ok(__FieldTag::__private_server_certificate)
                            }
                            "clientCertificate" => Ok(__FieldTag::__client_certificate),
                            "client_certificate" => Ok(__FieldTag::__client_certificate),
                            "clientPrivateKey" => Ok(__FieldTag::__client_private_key),
                            "client_private_key" => Ok(__FieldTag::__client_private_key),
                            "clientPrivateKeyPass" => Ok(__FieldTag::__client_private_key_pass),
                            "client_private_key_pass" => Ok(__FieldTag::__client_private_key_pass),
                            "serverCertType" => Ok(__FieldTag::__server_cert_type),
                            "server_cert_type" => Ok(__FieldTag::__server_cert_type),
                            "clientCertType" => Ok(__FieldTag::__client_cert_type),
                            "client_cert_type" => Ok(__FieldTag::__client_cert_type),
                            "useSsl" => Ok(__FieldTag::__use_ssl),
                            "use_ssl" => Ok(__FieldTag::__use_ssl),
                            "additionalVariables" => Ok(__FieldTag::__additional_variables),
                            "additional_variables" => Ok(__FieldTag::__additional_variables),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SslConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SslConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::SslType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trust_model => {
                            if !fields.insert(__FieldTag::__trust_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trust_model",
                                ));
                            }
                            result.trust_model = map.next_value::<std::option::Option<crate::model::ssl_config::TrustModel>>()?.unwrap_or_default();
                        }
                        __FieldTag::__private_server_certificate => {
                            if !fields.insert(__FieldTag::__private_server_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_server_certificate",
                                ));
                            }
                            result.private_server_certificate =
                                map.next_value::<std::option::Option<crate::model::Secret>>()?;
                        }
                        __FieldTag::__client_certificate => {
                            if !fields.insert(__FieldTag::__client_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_certificate",
                                ));
                            }
                            result.client_certificate =
                                map.next_value::<std::option::Option<crate::model::Secret>>()?;
                        }
                        __FieldTag::__client_private_key => {
                            if !fields.insert(__FieldTag::__client_private_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_private_key",
                                ));
                            }
                            result.client_private_key =
                                map.next_value::<std::option::Option<crate::model::Secret>>()?;
                        }
                        __FieldTag::__client_private_key_pass => {
                            if !fields.insert(__FieldTag::__client_private_key_pass) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_private_key_pass",
                                ));
                            }
                            result.client_private_key_pass =
                                map.next_value::<std::option::Option<crate::model::Secret>>()?;
                        }
                        __FieldTag::__server_cert_type => {
                            if !fields.insert(__FieldTag::__server_cert_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server_cert_type",
                                ));
                            }
                            result.server_cert_type = map
                                .next_value::<std::option::Option<crate::model::CertType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_cert_type => {
                            if !fields.insert(__FieldTag::__client_cert_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_cert_type",
                                ));
                            }
                            result.client_cert_type = map
                                .next_value::<std::option::Option<crate::model::CertType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__use_ssl => {
                            if !fields.insert(__FieldTag::__use_ssl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_ssl",
                                ));
                            }
                            result.use_ssl = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_variables => {
                            if !fields.insert(__FieldTag::__additional_variables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_variables",
                                ));
                            }
                            result.additional_variables =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConfigVariable>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SslConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.trust_model) {
            state.serialize_entry("trustModel", &self.trust_model)?;
        }
        if self.private_server_certificate.is_some() {
            state.serialize_entry("privateServerCertificate", &self.private_server_certificate)?;
        }
        if self.client_certificate.is_some() {
            state.serialize_entry("clientCertificate", &self.client_certificate)?;
        }
        if self.client_private_key.is_some() {
            state.serialize_entry("clientPrivateKey", &self.client_private_key)?;
        }
        if self.client_private_key_pass.is_some() {
            state.serialize_entry("clientPrivateKeyPass", &self.client_private_key_pass)?;
        }
        if !wkt::internal::is_default(&self.server_cert_type) {
            state.serialize_entry("serverCertType", &self.server_cert_type)?;
        }
        if !wkt::internal::is_default(&self.client_cert_type) {
            state.serialize_entry("clientCertType", &self.client_cert_type)?;
        }
        if !wkt::internal::is_default(&self.use_ssl) {
            state.serialize_entry("useSsl", &self.use_ssl)?;
        }
        if !self.additional_variables.is_empty() {
            state.serialize_entry("additionalVariables", &self.additional_variables)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SslConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SslConfig");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("trust_model", &self.trust_model);
        debug_struct.field(
            "private_server_certificate",
            &self.private_server_certificate,
        );
        debug_struct.field("client_certificate", &self.client_certificate);
        debug_struct.field("client_private_key", &self.client_private_key);
        debug_struct.field("client_private_key_pass", &self.client_private_key_pass);
        debug_struct.field("server_cert_type", &self.server_cert_type);
        debug_struct.field("client_cert_type", &self.client_cert_type);
        debug_struct.field("use_ssl", &self.use_ssl);
        debug_struct.field("additional_variables", &self.additional_variables);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SslConfig].
pub mod ssl_config {
    #[allow(unused_imports)]
    use super::*;

    /// Enum for Ttust Model
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TrustModel {
        /// Public Trust Model. Takes the Default Java trust store.
        Public,
        /// Private Trust Model. Takes custom/private trust store.
        Private,
        /// Insecure Trust Model. Accept all certificates.
        Insecure,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TrustModel::value] or
        /// [TrustModel::name].
        UnknownValue(trust_model::UnknownValue),
    }

    #[doc(hidden)]
    pub mod trust_model {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TrustModel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Public => std::option::Option::Some(0),
                Self::Private => std::option::Option::Some(1),
                Self::Insecure => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Public => std::option::Option::Some("PUBLIC"),
                Self::Private => std::option::Option::Some("PRIVATE"),
                Self::Insecure => std::option::Option::Some("INSECURE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TrustModel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TrustModel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TrustModel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Public,
                1 => Self::Private,
                2 => Self::Insecure,
                _ => Self::UnknownValue(trust_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TrustModel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PUBLIC" => Self::Public,
                "PRIVATE" => Self::Private,
                "INSECURE" => Self::Insecure,
                _ => Self::UnknownValue(trust_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TrustModel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Public => serializer.serialize_i32(0),
                Self::Private => serializer.serialize_i32(1),
                Self::Insecure => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TrustModel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TrustModel>::new(
                ".google.cloud.connectors.v1.SslConfig.TrustModel",
            ))
        }
    }
}

/// AuthType defines different authentication types.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AuthType {
    /// Authentication type not specified.
    Unspecified,
    /// Username and Password Authentication.
    UserPassword,
    /// JSON Web Token (JWT) Profile for Oauth 2.0
    /// Authorization Grant based authentication
    Oauth2JwtBearer,
    /// Oauth 2.0 Client Credentials Grant Authentication
    Oauth2ClientCredentials,
    /// SSH Public Key Authentication
    SshPublicKey,
    /// Oauth 2.0 Authorization Code Flow
    Oauth2AuthCodeFlow,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AuthType::value] or
    /// [AuthType::name].
    UnknownValue(auth_type::UnknownValue),
}

#[doc(hidden)]
pub mod auth_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl AuthType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::UserPassword => std::option::Option::Some(1),
            Self::Oauth2JwtBearer => std::option::Option::Some(2),
            Self::Oauth2ClientCredentials => std::option::Option::Some(3),
            Self::SshPublicKey => std::option::Option::Some(4),
            Self::Oauth2AuthCodeFlow => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("AUTH_TYPE_UNSPECIFIED"),
            Self::UserPassword => std::option::Option::Some("USER_PASSWORD"),
            Self::Oauth2JwtBearer => std::option::Option::Some("OAUTH2_JWT_BEARER"),
            Self::Oauth2ClientCredentials => std::option::Option::Some("OAUTH2_CLIENT_CREDENTIALS"),
            Self::SshPublicKey => std::option::Option::Some("SSH_PUBLIC_KEY"),
            Self::Oauth2AuthCodeFlow => std::option::Option::Some("OAUTH2_AUTH_CODE_FLOW"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for AuthType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for AuthType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for AuthType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::UserPassword,
            2 => Self::Oauth2JwtBearer,
            3 => Self::Oauth2ClientCredentials,
            4 => Self::SshPublicKey,
            5 => Self::Oauth2AuthCodeFlow,
            _ => Self::UnknownValue(auth_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for AuthType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "AUTH_TYPE_UNSPECIFIED" => Self::Unspecified,
            "USER_PASSWORD" => Self::UserPassword,
            "OAUTH2_JWT_BEARER" => Self::Oauth2JwtBearer,
            "OAUTH2_CLIENT_CREDENTIALS" => Self::Oauth2ClientCredentials,
            "SSH_PUBLIC_KEY" => Self::SshPublicKey,
            "OAUTH2_AUTH_CODE_FLOW" => Self::Oauth2AuthCodeFlow,
            _ => Self::UnknownValue(auth_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for AuthType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::UserPassword => serializer.serialize_i32(1),
            Self::Oauth2JwtBearer => serializer.serialize_i32(2),
            Self::Oauth2ClientCredentials => serializer.serialize_i32(3),
            Self::SshPublicKey => serializer.serialize_i32(4),
            Self::Oauth2AuthCodeFlow => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for AuthType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AuthType>::new(
            ".google.cloud.connectors.v1.AuthType",
        ))
    }
}

/// LaunchStage is a enum to indicate launch stage:
/// PREVIEW, GA, DEPRECATED, PRIVATE_PREVIEW.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum LaunchStage {
    /// LAUNCH_STAGE_UNSPECIFIED.
    Unspecified,
    /// PREVIEW.
    Preview,
    /// GA.
    Ga,
    /// DEPRECATED.
    Deprecated,
    /// PRIVATE_PREVIEW.
    PrivatePreview,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [LaunchStage::value] or
    /// [LaunchStage::name].
    UnknownValue(launch_stage::UnknownValue),
}

#[doc(hidden)]
pub mod launch_stage {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl LaunchStage {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Preview => std::option::Option::Some(1),
            Self::Ga => std::option::Option::Some(2),
            Self::Deprecated => std::option::Option::Some(3),
            Self::PrivatePreview => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("LAUNCH_STAGE_UNSPECIFIED"),
            Self::Preview => std::option::Option::Some("PREVIEW"),
            Self::Ga => std::option::Option::Some("GA"),
            Self::Deprecated => std::option::Option::Some("DEPRECATED"),
            Self::PrivatePreview => std::option::Option::Some("PRIVATE_PREVIEW"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for LaunchStage {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for LaunchStage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for LaunchStage {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Preview,
            2 => Self::Ga,
            3 => Self::Deprecated,
            5 => Self::PrivatePreview,
            _ => Self::UnknownValue(launch_stage::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for LaunchStage {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "LAUNCH_STAGE_UNSPECIFIED" => Self::Unspecified,
            "PREVIEW" => Self::Preview,
            "GA" => Self::Ga,
            "DEPRECATED" => Self::Deprecated,
            "PRIVATE_PREVIEW" => Self::PrivatePreview,
            _ => Self::UnknownValue(launch_stage::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for LaunchStage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Preview => serializer.serialize_i32(1),
            Self::Ga => serializer.serialize_i32(2),
            Self::Deprecated => serializer.serialize_i32(3),
            Self::PrivatePreview => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for LaunchStage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<LaunchStage>::new(
            ".google.cloud.connectors.v1.LaunchStage",
        ))
    }
}

/// All possible data types of a entity or action field.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DataType {
    /// Data type is not specified.
    Unspecified,
    /// DEPRECATED! Use DATA_TYPE_INTEGER.
    #[deprecated]
    Int,
    /// Short integer(int16) data type.
    Smallint,
    /// Double data type.
    Double,
    /// Date data type.
    Date,
    /// DEPRECATED! Use DATA_TYPE_TIMESTAMP.
    #[deprecated]
    Datetime,
    /// Time data type.
    Time,
    /// DEPRECATED! Use DATA_TYPE_VARCHAR.
    #[deprecated]
    String,
    /// DEPRECATED! Use DATA_TYPE_BIGINT.
    #[deprecated]
    Long,
    /// Boolean data type.
    Boolean,
    /// Decimal data type.
    Decimal,
    /// DEPRECATED! Use DATA_TYPE_VARCHAR.
    #[deprecated]
    Uuid,
    /// UNSUPPORTED! Binary data type.
    Blob,
    /// Bit data type.
    Bit,
    /// Small integer(int8) data type.
    Tinyint,
    /// Integer(int32) data type.
    Integer,
    /// Long integer(int64) data type.
    Bigint,
    /// Float data type.
    Float,
    /// Real data type.
    Real,
    /// Numeric data type.
    Numeric,
    /// Char data type.
    Char,
    /// Varchar data type.
    Varchar,
    /// Longvarchar data type.
    Longvarchar,
    /// Timestamp data type.
    Timestamp,
    /// Nchar data type.
    Nchar,
    /// Nvarchar data type.
    Nvarchar,
    /// Longnvarchar data type.
    Longnvarchar,
    /// Null data type.
    Null,
    /// UNSUPPORTED! Binary data type.
    Other,
    /// UNSUPPORTED! Binary data type.
    JavaObject,
    /// UNSUPPORTED! Binary data type.
    Distinct,
    /// UNSUPPORTED! Binary data type.
    Struct,
    /// UNSUPPORTED! Binary data type.
    Array,
    /// UNSUPPORTED! Binary data type.
    Clob,
    /// UNSUPPORTED! Binary data type.
    Ref,
    /// UNSUPPORTED! Binary data type.
    Datalink,
    /// UNSUPPORTED! Row id data type.
    Rowid,
    /// UNSUPPORTED! Binary data type.
    Binary,
    /// UNSUPPORTED! Variable binary data type.
    Varbinary,
    /// UNSUPPORTED! Long variable binary data type.
    Longvarbinary,
    /// UNSUPPORTED! NCLOB data type.
    Nclob,
    /// UNSUPPORTED! SQL XML data type is not supported.
    Sqlxml,
    /// UNSUPPORTED! Cursor reference type is not supported.
    RefCursor,
    /// UNSUPPORTED! Use TIME or TIMESTAMP instead.
    TimeWithTimezone,
    /// UNSUPPORTED! Use TIMESTAMP instead.
    TimestampWithTimezone,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DataType::value] or
    /// [DataType::name].
    UnknownValue(data_type::UnknownValue),
}

#[doc(hidden)]
pub mod data_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DataType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Int => std::option::Option::Some(1),
            Self::Smallint => std::option::Option::Some(2),
            Self::Double => std::option::Option::Some(3),
            Self::Date => std::option::Option::Some(4),
            Self::Datetime => std::option::Option::Some(5),
            Self::Time => std::option::Option::Some(6),
            Self::String => std::option::Option::Some(7),
            Self::Long => std::option::Option::Some(8),
            Self::Boolean => std::option::Option::Some(9),
            Self::Decimal => std::option::Option::Some(10),
            Self::Uuid => std::option::Option::Some(11),
            Self::Blob => std::option::Option::Some(12),
            Self::Bit => std::option::Option::Some(13),
            Self::Tinyint => std::option::Option::Some(14),
            Self::Integer => std::option::Option::Some(15),
            Self::Bigint => std::option::Option::Some(16),
            Self::Float => std::option::Option::Some(17),
            Self::Real => std::option::Option::Some(18),
            Self::Numeric => std::option::Option::Some(19),
            Self::Char => std::option::Option::Some(20),
            Self::Varchar => std::option::Option::Some(21),
            Self::Longvarchar => std::option::Option::Some(22),
            Self::Timestamp => std::option::Option::Some(23),
            Self::Nchar => std::option::Option::Some(24),
            Self::Nvarchar => std::option::Option::Some(25),
            Self::Longnvarchar => std::option::Option::Some(26),
            Self::Null => std::option::Option::Some(27),
            Self::Other => std::option::Option::Some(28),
            Self::JavaObject => std::option::Option::Some(29),
            Self::Distinct => std::option::Option::Some(30),
            Self::Struct => std::option::Option::Some(31),
            Self::Array => std::option::Option::Some(32),
            Self::Clob => std::option::Option::Some(33),
            Self::Ref => std::option::Option::Some(34),
            Self::Datalink => std::option::Option::Some(35),
            Self::Rowid => std::option::Option::Some(36),
            Self::Binary => std::option::Option::Some(37),
            Self::Varbinary => std::option::Option::Some(38),
            Self::Longvarbinary => std::option::Option::Some(39),
            Self::Nclob => std::option::Option::Some(40),
            Self::Sqlxml => std::option::Option::Some(41),
            Self::RefCursor => std::option::Option::Some(42),
            Self::TimeWithTimezone => std::option::Option::Some(43),
            Self::TimestampWithTimezone => std::option::Option::Some(44),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DATA_TYPE_UNSPECIFIED"),
            Self::Int => std::option::Option::Some("DATA_TYPE_INT"),
            Self::Smallint => std::option::Option::Some("DATA_TYPE_SMALLINT"),
            Self::Double => std::option::Option::Some("DATA_TYPE_DOUBLE"),
            Self::Date => std::option::Option::Some("DATA_TYPE_DATE"),
            Self::Datetime => std::option::Option::Some("DATA_TYPE_DATETIME"),
            Self::Time => std::option::Option::Some("DATA_TYPE_TIME"),
            Self::String => std::option::Option::Some("DATA_TYPE_STRING"),
            Self::Long => std::option::Option::Some("DATA_TYPE_LONG"),
            Self::Boolean => std::option::Option::Some("DATA_TYPE_BOOLEAN"),
            Self::Decimal => std::option::Option::Some("DATA_TYPE_DECIMAL"),
            Self::Uuid => std::option::Option::Some("DATA_TYPE_UUID"),
            Self::Blob => std::option::Option::Some("DATA_TYPE_BLOB"),
            Self::Bit => std::option::Option::Some("DATA_TYPE_BIT"),
            Self::Tinyint => std::option::Option::Some("DATA_TYPE_TINYINT"),
            Self::Integer => std::option::Option::Some("DATA_TYPE_INTEGER"),
            Self::Bigint => std::option::Option::Some("DATA_TYPE_BIGINT"),
            Self::Float => std::option::Option::Some("DATA_TYPE_FLOAT"),
            Self::Real => std::option::Option::Some("DATA_TYPE_REAL"),
            Self::Numeric => std::option::Option::Some("DATA_TYPE_NUMERIC"),
            Self::Char => std::option::Option::Some("DATA_TYPE_CHAR"),
            Self::Varchar => std::option::Option::Some("DATA_TYPE_VARCHAR"),
            Self::Longvarchar => std::option::Option::Some("DATA_TYPE_LONGVARCHAR"),
            Self::Timestamp => std::option::Option::Some("DATA_TYPE_TIMESTAMP"),
            Self::Nchar => std::option::Option::Some("DATA_TYPE_NCHAR"),
            Self::Nvarchar => std::option::Option::Some("DATA_TYPE_NVARCHAR"),
            Self::Longnvarchar => std::option::Option::Some("DATA_TYPE_LONGNVARCHAR"),
            Self::Null => std::option::Option::Some("DATA_TYPE_NULL"),
            Self::Other => std::option::Option::Some("DATA_TYPE_OTHER"),
            Self::JavaObject => std::option::Option::Some("DATA_TYPE_JAVA_OBJECT"),
            Self::Distinct => std::option::Option::Some("DATA_TYPE_DISTINCT"),
            Self::Struct => std::option::Option::Some("DATA_TYPE_STRUCT"),
            Self::Array => std::option::Option::Some("DATA_TYPE_ARRAY"),
            Self::Clob => std::option::Option::Some("DATA_TYPE_CLOB"),
            Self::Ref => std::option::Option::Some("DATA_TYPE_REF"),
            Self::Datalink => std::option::Option::Some("DATA_TYPE_DATALINK"),
            Self::Rowid => std::option::Option::Some("DATA_TYPE_ROWID"),
            Self::Binary => std::option::Option::Some("DATA_TYPE_BINARY"),
            Self::Varbinary => std::option::Option::Some("DATA_TYPE_VARBINARY"),
            Self::Longvarbinary => std::option::Option::Some("DATA_TYPE_LONGVARBINARY"),
            Self::Nclob => std::option::Option::Some("DATA_TYPE_NCLOB"),
            Self::Sqlxml => std::option::Option::Some("DATA_TYPE_SQLXML"),
            Self::RefCursor => std::option::Option::Some("DATA_TYPE_REF_CURSOR"),
            Self::TimeWithTimezone => std::option::Option::Some("DATA_TYPE_TIME_WITH_TIMEZONE"),
            Self::TimestampWithTimezone => {
                std::option::Option::Some("DATA_TYPE_TIMESTAMP_WITH_TIMEZONE")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DataType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DataType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DataType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Int,
            2 => Self::Smallint,
            3 => Self::Double,
            4 => Self::Date,
            5 => Self::Datetime,
            6 => Self::Time,
            7 => Self::String,
            8 => Self::Long,
            9 => Self::Boolean,
            10 => Self::Decimal,
            11 => Self::Uuid,
            12 => Self::Blob,
            13 => Self::Bit,
            14 => Self::Tinyint,
            15 => Self::Integer,
            16 => Self::Bigint,
            17 => Self::Float,
            18 => Self::Real,
            19 => Self::Numeric,
            20 => Self::Char,
            21 => Self::Varchar,
            22 => Self::Longvarchar,
            23 => Self::Timestamp,
            24 => Self::Nchar,
            25 => Self::Nvarchar,
            26 => Self::Longnvarchar,
            27 => Self::Null,
            28 => Self::Other,
            29 => Self::JavaObject,
            30 => Self::Distinct,
            31 => Self::Struct,
            32 => Self::Array,
            33 => Self::Clob,
            34 => Self::Ref,
            35 => Self::Datalink,
            36 => Self::Rowid,
            37 => Self::Binary,
            38 => Self::Varbinary,
            39 => Self::Longvarbinary,
            40 => Self::Nclob,
            41 => Self::Sqlxml,
            42 => Self::RefCursor,
            43 => Self::TimeWithTimezone,
            44 => Self::TimestampWithTimezone,
            _ => Self::UnknownValue(data_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DataType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATA_TYPE_UNSPECIFIED" => Self::Unspecified,
            "DATA_TYPE_INT" => Self::Int,
            "DATA_TYPE_SMALLINT" => Self::Smallint,
            "DATA_TYPE_DOUBLE" => Self::Double,
            "DATA_TYPE_DATE" => Self::Date,
            "DATA_TYPE_DATETIME" => Self::Datetime,
            "DATA_TYPE_TIME" => Self::Time,
            "DATA_TYPE_STRING" => Self::String,
            "DATA_TYPE_LONG" => Self::Long,
            "DATA_TYPE_BOOLEAN" => Self::Boolean,
            "DATA_TYPE_DECIMAL" => Self::Decimal,
            "DATA_TYPE_UUID" => Self::Uuid,
            "DATA_TYPE_BLOB" => Self::Blob,
            "DATA_TYPE_BIT" => Self::Bit,
            "DATA_TYPE_TINYINT" => Self::Tinyint,
            "DATA_TYPE_INTEGER" => Self::Integer,
            "DATA_TYPE_BIGINT" => Self::Bigint,
            "DATA_TYPE_FLOAT" => Self::Float,
            "DATA_TYPE_REAL" => Self::Real,
            "DATA_TYPE_NUMERIC" => Self::Numeric,
            "DATA_TYPE_CHAR" => Self::Char,
            "DATA_TYPE_VARCHAR" => Self::Varchar,
            "DATA_TYPE_LONGVARCHAR" => Self::Longvarchar,
            "DATA_TYPE_TIMESTAMP" => Self::Timestamp,
            "DATA_TYPE_NCHAR" => Self::Nchar,
            "DATA_TYPE_NVARCHAR" => Self::Nvarchar,
            "DATA_TYPE_LONGNVARCHAR" => Self::Longnvarchar,
            "DATA_TYPE_NULL" => Self::Null,
            "DATA_TYPE_OTHER" => Self::Other,
            "DATA_TYPE_JAVA_OBJECT" => Self::JavaObject,
            "DATA_TYPE_DISTINCT" => Self::Distinct,
            "DATA_TYPE_STRUCT" => Self::Struct,
            "DATA_TYPE_ARRAY" => Self::Array,
            "DATA_TYPE_CLOB" => Self::Clob,
            "DATA_TYPE_REF" => Self::Ref,
            "DATA_TYPE_DATALINK" => Self::Datalink,
            "DATA_TYPE_ROWID" => Self::Rowid,
            "DATA_TYPE_BINARY" => Self::Binary,
            "DATA_TYPE_VARBINARY" => Self::Varbinary,
            "DATA_TYPE_LONGVARBINARY" => Self::Longvarbinary,
            "DATA_TYPE_NCLOB" => Self::Nclob,
            "DATA_TYPE_SQLXML" => Self::Sqlxml,
            "DATA_TYPE_REF_CURSOR" => Self::RefCursor,
            "DATA_TYPE_TIME_WITH_TIMEZONE" => Self::TimeWithTimezone,
            "DATA_TYPE_TIMESTAMP_WITH_TIMEZONE" => Self::TimestampWithTimezone,
            _ => Self::UnknownValue(data_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DataType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Int => serializer.serialize_i32(1),
            Self::Smallint => serializer.serialize_i32(2),
            Self::Double => serializer.serialize_i32(3),
            Self::Date => serializer.serialize_i32(4),
            Self::Datetime => serializer.serialize_i32(5),
            Self::Time => serializer.serialize_i32(6),
            Self::String => serializer.serialize_i32(7),
            Self::Long => serializer.serialize_i32(8),
            Self::Boolean => serializer.serialize_i32(9),
            Self::Decimal => serializer.serialize_i32(10),
            Self::Uuid => serializer.serialize_i32(11),
            Self::Blob => serializer.serialize_i32(12),
            Self::Bit => serializer.serialize_i32(13),
            Self::Tinyint => serializer.serialize_i32(14),
            Self::Integer => serializer.serialize_i32(15),
            Self::Bigint => serializer.serialize_i32(16),
            Self::Float => serializer.serialize_i32(17),
            Self::Real => serializer.serialize_i32(18),
            Self::Numeric => serializer.serialize_i32(19),
            Self::Char => serializer.serialize_i32(20),
            Self::Varchar => serializer.serialize_i32(21),
            Self::Longvarchar => serializer.serialize_i32(22),
            Self::Timestamp => serializer.serialize_i32(23),
            Self::Nchar => serializer.serialize_i32(24),
            Self::Nvarchar => serializer.serialize_i32(25),
            Self::Longnvarchar => serializer.serialize_i32(26),
            Self::Null => serializer.serialize_i32(27),
            Self::Other => serializer.serialize_i32(28),
            Self::JavaObject => serializer.serialize_i32(29),
            Self::Distinct => serializer.serialize_i32(30),
            Self::Struct => serializer.serialize_i32(31),
            Self::Array => serializer.serialize_i32(32),
            Self::Clob => serializer.serialize_i32(33),
            Self::Ref => serializer.serialize_i32(34),
            Self::Datalink => serializer.serialize_i32(35),
            Self::Rowid => serializer.serialize_i32(36),
            Self::Binary => serializer.serialize_i32(37),
            Self::Varbinary => serializer.serialize_i32(38),
            Self::Longvarbinary => serializer.serialize_i32(39),
            Self::Nclob => serializer.serialize_i32(40),
            Self::Sqlxml => serializer.serialize_i32(41),
            Self::RefCursor => serializer.serialize_i32(42),
            Self::TimeWithTimezone => serializer.serialize_i32(43),
            Self::TimestampWithTimezone => serializer.serialize_i32(44),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DataType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataType>::new(
            ".google.cloud.connectors.v1.DataType",
        ))
    }
}

/// Enum to control which fields should be included in the response.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ConnectionView {
    /// CONNECTION_UNSPECIFIED.
    Unspecified,
    /// Do not include runtime required configs.
    Basic,
    /// Include runtime required configs.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ConnectionView::value] or
    /// [ConnectionView::name].
    UnknownValue(connection_view::UnknownValue),
}

#[doc(hidden)]
pub mod connection_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ConnectionView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CONNECTION_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("BASIC"),
            Self::Full => std::option::Option::Some("FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ConnectionView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ConnectionView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ConnectionView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(connection_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ConnectionView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CONNECTION_VIEW_UNSPECIFIED" => Self::Unspecified,
            "BASIC" => Self::Basic,
            "FULL" => Self::Full,
            _ => Self::UnknownValue(connection_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ConnectionView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ConnectionView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConnectionView>::new(
            ".google.cloud.connectors.v1.ConnectionView",
        ))
    }
}

/// Enum to control which fields should be included in the response.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ConnectorVersionView {
    /// CONNECTOR_VERSION_VIEW_UNSPECIFIED.
    Unspecified,
    /// Do not include role grant configs.
    Basic,
    /// Include role grant configs.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ConnectorVersionView::value] or
    /// [ConnectorVersionView::name].
    UnknownValue(connector_version_view::UnknownValue),
}

#[doc(hidden)]
pub mod connector_version_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ConnectorVersionView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CONNECTOR_VERSION_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("CONNECTOR_VERSION_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("CONNECTOR_VERSION_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ConnectorVersionView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ConnectorVersionView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ConnectorVersionView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(connector_version_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ConnectorVersionView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CONNECTOR_VERSION_VIEW_UNSPECIFIED" => Self::Unspecified,
            "CONNECTOR_VERSION_VIEW_BASIC" => Self::Basic,
            "CONNECTOR_VERSION_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(connector_version_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ConnectorVersionView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ConnectorVersionView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConnectorVersionView>::new(
            ".google.cloud.connectors.v1.ConnectorVersionView",
        ))
    }
}

/// Enum for controlling the SSL Type (TLS/MTLS)
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SslType {
    /// No SSL configuration required.
    Unspecified,
    /// TLS Handshake
    Tls,
    /// mutual TLS (MTLS) Handshake
    Mtls,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SslType::value] or
    /// [SslType::name].
    UnknownValue(ssl_type::UnknownValue),
}

#[doc(hidden)]
pub mod ssl_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SslType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Tls => std::option::Option::Some(1),
            Self::Mtls => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SSL_TYPE_UNSPECIFIED"),
            Self::Tls => std::option::Option::Some("TLS"),
            Self::Mtls => std::option::Option::Some("MTLS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SslType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SslType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SslType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Tls,
            2 => Self::Mtls,
            _ => Self::UnknownValue(ssl_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SslType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SSL_TYPE_UNSPECIFIED" => Self::Unspecified,
            "TLS" => Self::Tls,
            "MTLS" => Self::Mtls,
            _ => Self::UnknownValue(ssl_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SslType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Tls => serializer.serialize_i32(1),
            Self::Mtls => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SslType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SslType>::new(
            ".google.cloud.connectors.v1.SslType",
        ))
    }
}

/// Enum for Cert Types
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CertType {
    /// Cert type unspecified.
    Unspecified,
    /// Privacy Enhanced Mail (PEM) Type
    Pem,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CertType::value] or
    /// [CertType::name].
    UnknownValue(cert_type::UnknownValue),
}

#[doc(hidden)]
pub mod cert_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CertType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Pem => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CERT_TYPE_UNSPECIFIED"),
            Self::Pem => std::option::Option::Some("PEM"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CertType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CertType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CertType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Pem,
            _ => Self::UnknownValue(cert_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for CertType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CERT_TYPE_UNSPECIFIED" => Self::Unspecified,
            "PEM" => Self::Pem,
            _ => Self::UnknownValue(cert_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for CertType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Pem => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CertType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CertType>::new(
            ".google.cloud.connectors.v1.CertType",
        ))
    }
}
