// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::AuthConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AuthConfig");
        debug_struct.field("auth_type", &self.auth_type);
        debug_struct.field("additional_variables", &self.additional_variables);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::auth_config::UserPassword {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserPassword");
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::auth_config::Oauth2JwtBearer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Oauth2JwtBearer");
        debug_struct.field("client_key", &self.client_key);
        debug_struct.field("jwt_claims", &self.jwt_claims);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::auth_config::oauth_2_jwt_bearer::JwtClaims {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JwtClaims");
        debug_struct.field("issuer", &self.issuer);
        debug_struct.field("subject", &self.subject);
        debug_struct.field("audience", &self.audience);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::auth_config::Oauth2ClientCredentials {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Oauth2ClientCredentials");
        debug_struct.field("client_id", &self.client_id);
        debug_struct.field("client_secret", &self.client_secret);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::auth_config::SshPublicKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SshPublicKey");
        debug_struct.field("username", &self.username);
        debug_struct.field("ssh_client_cert", &self.ssh_client_cert);
        debug_struct.field("cert_type", &self.cert_type);
        debug_struct.field("ssh_client_cert_pass", &self.ssh_client_cert_pass);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AuthConfigTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AuthConfigTemplate");
        debug_struct.field("auth_type", &self.auth_type);
        debug_struct.field("config_variable_templates", &self.config_variable_templates);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("requested_cancellation", &self.requested_cancellation);
        debug_struct.field("api_version", &self.api_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConfigVariableTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfigVariableTemplate");
        debug_struct.field("key", &self.key);
        debug_struct.field("value_type", &self.value_type);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("validation_regex", &self.validation_regex);
        debug_struct.field("required", &self.required);
        debug_struct.field("role_grant", &self.role_grant);
        debug_struct.field("enum_options", &self.enum_options);
        debug_struct.field("authorization_code_link", &self.authorization_code_link);
        debug_struct.field("state", &self.state);
        debug_struct.field("is_advanced", &self.is_advanced);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Secret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Secret");
        debug_struct.field("secret_version", &self.secret_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EnumOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnumOption");
        debug_struct.field("id", &self.id);
        debug_struct.field("display_name", &self.display_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConfigVariable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfigVariable");
        debug_struct.field("key", &self.key);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RoleGrant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RoleGrant");
        debug_struct.field("principal", &self.principal);
        debug_struct.field("roles", &self.roles);
        debug_struct.field("resource", &self.resource);
        debug_struct.field("helper_text_template", &self.helper_text_template);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::role_grant::Resource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Resource");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("path_template", &self.path_template);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AuthorizationCodeLink {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AuthorizationCodeLink");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("scopes", &self.scopes);
        debug_struct.field("client_id", &self.client_id);
        debug_struct.field("enable_pkce", &self.enable_pkce);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Connection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Connection");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("description", &self.description);
        debug_struct.field("connector_version", &self.connector_version);
        debug_struct.field("status", &self.status);
        debug_struct.field("config_variables", &self.config_variables);
        debug_struct.field("auth_config", &self.auth_config);
        debug_struct.field("lock_config", &self.lock_config);
        debug_struct.field("destination_configs", &self.destination_configs);
        debug_struct.field("image_location", &self.image_location);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("service_directory", &self.service_directory);
        debug_struct.field("envoy_image_location", &self.envoy_image_location);
        debug_struct.field("suspended", &self.suspended);
        debug_struct.field("node_config", &self.node_config);
        debug_struct.field("ssl_config", &self.ssl_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeConfig");
        debug_struct.field("min_node_count", &self.min_node_count);
        debug_struct.field("max_node_count", &self.max_node_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConnectionSchemaMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConnectionSchemaMetadata");
        debug_struct.field("entities", &self.entities);
        debug_struct.field("actions", &self.actions);
        debug_struct.field("name", &self.name);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("refresh_time", &self.refresh_time);
        debug_struct.field("state", &self.state);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RuntimeEntitySchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RuntimeEntitySchema");
        debug_struct.field("entity", &self.entity);
        debug_struct.field("fields", &self.fields);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::runtime_entity_schema::Field {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Field");
        debug_struct.field("field", &self.field);
        debug_struct.field("description", &self.description);
        debug_struct.field("data_type", &self.data_type);
        debug_struct.field("key", &self.key);
        debug_struct.field("readonly", &self.readonly);
        debug_struct.field("nullable", &self.nullable);
        debug_struct.field("default_value", &self.default_value);
        debug_struct.field("additional_details", &self.additional_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RuntimeActionSchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RuntimeActionSchema");
        debug_struct.field("action", &self.action);
        debug_struct.field("input_parameters", &self.input_parameters);
        debug_struct.field("result_metadata", &self.result_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::runtime_action_schema::InputParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InputParameter");
        debug_struct.field("parameter", &self.parameter);
        debug_struct.field("description", &self.description);
        debug_struct.field("data_type", &self.data_type);
        debug_struct.field("nullable", &self.nullable);
        debug_struct.field("default_value", &self.default_value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::runtime_action_schema::ResultMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResultMetadata");
        debug_struct.field("field", &self.field);
        debug_struct.field("description", &self.description);
        debug_struct.field("data_type", &self.data_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LockConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LockConfig");
        debug_struct.field("locked", &self.locked);
        debug_struct.field("reason", &self.reason);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListConnectionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListConnectionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectionsResponse");
        debug_struct.field("connections", &self.connections);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConnectionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateConnectionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("connection_id", &self.connection_id);
        debug_struct.field("connection", &self.connection);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateConnectionRequest");
        debug_struct.field("connection", &self.connection);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteConnectionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetConnectionSchemaMetadataRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConnectionSchemaMetadataRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RefreshConnectionSchemaMetadataRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RefreshConnectionSchemaMetadataRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListRuntimeEntitySchemasRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRuntimeEntitySchemasRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListRuntimeEntitySchemasResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRuntimeEntitySchemasResponse");
        debug_struct.field("runtime_entity_schemas", &self.runtime_entity_schemas);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListRuntimeActionSchemasRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRuntimeActionSchemasRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListRuntimeActionSchemasResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRuntimeActionSchemasResponse");
        debug_struct.field("runtime_action_schemas", &self.runtime_action_schemas);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConnectionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConnectionStatus");
        debug_struct.field("state", &self.state);
        debug_struct.field("description", &self.description);
        debug_struct.field("status", &self.status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Connector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Connector");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("documentation_uri", &self.documentation_uri);
        debug_struct.field("external_uri", &self.external_uri);
        debug_struct.field("description", &self.description);
        debug_struct.field("web_assets_location", &self.web_assets_location);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("launch_stage", &self.launch_stage);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetConnectorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConnectorRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListConnectorsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectorsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListConnectorsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectorsResponse");
        debug_struct.field("connectors", &self.connectors);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConnectorVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConnectorVersion");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("launch_stage", &self.launch_stage);
        debug_struct.field("release_version", &self.release_version);
        debug_struct.field("auth_config_templates", &self.auth_config_templates);
        debug_struct.field("config_variable_templates", &self.config_variable_templates);
        debug_struct.field(
            "supported_runtime_features",
            &self.supported_runtime_features,
        );
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("egress_control_config", &self.egress_control_config);
        debug_struct.field("role_grants", &self.role_grants);
        debug_struct.field("role_grant", &self.role_grant);
        debug_struct.field("ssl_config_template", &self.ssl_config_template);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetConnectorVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConnectorVersionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListConnectorVersionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectorVersionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListConnectorVersionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectorVersionsResponse");
        debug_struct.field("connector_versions", &self.connector_versions);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SupportedRuntimeFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SupportedRuntimeFeatures");
        debug_struct.field("entity_apis", &self.entity_apis);
        debug_struct.field("action_apis", &self.action_apis);
        debug_struct.field("sql_query", &self.sql_query);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EgressControlConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EgressControlConfig");
        debug_struct.field("oneof_backends", &self.oneof_backends);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExtractionRules {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExtractionRules");
        debug_struct.field("extraction_rule", &self.extraction_rule);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExtractionRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExtractionRule");
        debug_struct.field("source", &self.source);
        debug_struct.field("extraction_regex", &self.extraction_regex);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::extraction_rule::Source {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Source");
        debug_struct.field("source_type", &self.source_type);
        debug_struct.field("field_id", &self.field_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DestinationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DestinationConfig");
        debug_struct.field("key", &self.key);
        debug_struct.field("destinations", &self.destinations);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Destination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Destination");
        debug_struct.field("port", &self.port);
        debug_struct.field("destination", &self.destination);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Provider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Provider");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("documentation_uri", &self.documentation_uri);
        debug_struct.field("external_uri", &self.external_uri);
        debug_struct.field("description", &self.description);
        debug_struct.field("web_assets_location", &self.web_assets_location);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("launch_stage", &self.launch_stage);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetProviderRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetProviderRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListProvidersRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProvidersRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListProvidersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProvidersResponse");
        debug_struct.field("providers", &self.providers);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetRuntimeConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetRuntimeConfigRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RuntimeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RuntimeConfig");
        debug_struct.field("location_id", &self.location_id);
        debug_struct.field("connd_topic", &self.connd_topic);
        debug_struct.field("connd_subscription", &self.connd_subscription);
        debug_struct.field("control_plane_topic", &self.control_plane_topic);
        debug_struct.field(
            "control_plane_subscription",
            &self.control_plane_subscription,
        );
        debug_struct.field("runtime_endpoint", &self.runtime_endpoint);
        debug_struct.field("state", &self.state);
        debug_struct.field("schema_gcs_bucket", &self.schema_gcs_bucket);
        debug_struct.field("service_directory", &self.service_directory);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetGlobalSettingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetGlobalSettingsRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Settings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Settings");
        debug_struct.field("name", &self.name);
        debug_struct.field("vpcsc", &self.vpcsc);
        debug_struct.field("payg", &self.payg);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SslConfigTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SslConfigTemplate");
        debug_struct.field("ssl_type", &self.ssl_type);
        debug_struct.field("is_tls_mandatory", &self.is_tls_mandatory);
        debug_struct.field("server_cert_type", &self.server_cert_type);
        debug_struct.field("client_cert_type", &self.client_cert_type);
        debug_struct.field("additional_variables", &self.additional_variables);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SslConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SslConfig");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("trust_model", &self.trust_model);
        debug_struct.field(
            "private_server_certificate",
            &self.private_server_certificate,
        );
        debug_struct.field("client_certificate", &self.client_certificate);
        debug_struct.field("client_private_key", &self.client_private_key);
        debug_struct.field("client_private_key_pass", &self.client_private_key_pass);
        debug_struct.field("server_cert_type", &self.server_cert_type);
        debug_struct.field("client_cert_type", &self.client_cert_type);
        debug_struct.field("use_ssl", &self.use_ssl);
        debug_struct.field("additional_variables", &self.additional_variables);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
