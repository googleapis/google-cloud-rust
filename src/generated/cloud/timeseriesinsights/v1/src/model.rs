// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Mapping of BigQuery columns to timestamp, group_id and dimensions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigqueryMapping {
    /// The column which should be used as the event timestamps. If not specified
    /// 'Timestamp' is used by default. The column may have TIMESTAMP or INT64
    /// type (the latter is interpreted as microseconds since the Unix epoch).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub timestamp_column: std::string::String,

    /// The column which should be used as the group ID (grouping events into
    /// sessions). If not specified 'GroupId' is used by default, if the input
    /// table does not have such a column, random unique group IDs are
    /// generated automatically (different group ID per input row).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub group_id_column: std::string::String,

    /// The list of columns that should be translated to dimensions. If empty,
    /// all columns are translated to dimensions. The timestamp and group_id
    /// columns should not be listed here again. Columns are expected to have
    /// primitive types (STRING, INT64, FLOAT64 or NUMERIC).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dimension_column: std::vec::Vec<std::string::String>,
}

impl BigqueryMapping {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [timestamp_column][crate::model::BigqueryMapping::timestamp_column].
    pub fn set_timestamp_column<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.timestamp_column = v.into();
        self
    }

    /// Sets the value of [group_id_column][crate::model::BigqueryMapping::group_id_column].
    pub fn set_group_id_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group_id_column = v.into();
        self
    }

    /// Sets the value of [dimension_column][crate::model::BigqueryMapping::dimension_column].
    pub fn set_dimension_column<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dimension_column = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BigqueryMapping {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.BigqueryMapping"
    }
}

/// A data source consists of multiple [Event][google.cloud.timeseriesinsights.v1.Event] objects stored on
/// Cloud Storage.  Each Event should be in JSON format, with one Event
/// per line, also known as JSON Lines format.
///
/// [google.cloud.timeseriesinsights.v1.Event]: crate::model::Event
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataSource {
    /// Data source URI.
    ///
    /// ) Google Cloud Storage files (JSON) are defined in the following form.
    ///   `gs://bucket_name/object_name`. For more information on Cloud Storage URIs,
    ///   please see <https://cloud.google.com/storage/docs/reference-uris>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// For BigQuery inputs defines the columns that should be used for dimensions
    /// (including time and group ID).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bq_mapping: std::option::Option<crate::model::BigqueryMapping>,
}

impl DataSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::DataSource::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [bq_mapping][crate::model::DataSource::bq_mapping].
    pub fn set_bq_mapping<
        T: std::convert::Into<std::option::Option<crate::model::BigqueryMapping>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bq_mapping = v.into();
        self
    }
}

impl wkt::message::Message for DataSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.DataSource"
    }
}

/// A collection of data sources sent for processing.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataSet {
    /// The dataset name, which will be used for querying, status and unload
    /// requests. This must be unique within a project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// [Data dimension names][google.cloud.timeseriesinsights.v1.EventDimension.name] allowed for this `DataSet`.
    ///
    /// If left empty, all dimension names are included. This field works as a
    /// filter to avoid regenerating the data.
    ///
    /// [google.cloud.timeseriesinsights.v1.EventDimension.name]: crate::model::EventDimension::name
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_names: std::vec::Vec<std::string::String>,

    /// Input data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_sources: std::vec::Vec<crate::model::DataSource>,

    /// Dataset state in the system.
    pub state: crate::model::data_set::State,

    /// Dataset processing status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<rpc::model::Status>,

    /// Periodically we discard dataset [Event][google.cloud.timeseriesinsights.v1.Event] objects that have
    /// timestamps older than 'ttl'.  Omitting this field or a zero value means no
    /// events are discarded.
    ///
    /// [google.cloud.timeseriesinsights.v1.Event]: crate::model::Event
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ttl: std::option::Option<wkt::Duration>,
}

impl DataSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataSet::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DataSet::state].
    pub fn set_state<T: std::convert::Into<crate::model::data_set::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [status][crate::model::DataSet::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [ttl][crate::model::DataSet::ttl].
    pub fn set_ttl<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ttl = v.into();
        self
    }

    /// Sets the value of [data_names][crate::model::DataSet::data_names].
    pub fn set_data_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_sources][crate::model::DataSet::data_sources].
    pub fn set_data_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataSource>,
    {
        use std::iter::Iterator;
        self.data_sources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DataSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.DataSet"
    }
}

/// Defines additional types related to DataSet
pub mod data_set {
    #[allow(unused_imports)]
    use super::*;

    /// DataSet state.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Unspecified / undefined state.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// Dataset is unknown to the system; we have never seen this dataset before
        /// or we have seen this dataset but have fully GC-ed it.
        pub const UNKNOWN: State = State::new("UNKNOWN");

        /// Dataset processing is pending.
        pub const PENDING: State = State::new("PENDING");

        /// Dataset is loading.
        pub const LOADING: State = State::new("LOADING");

        /// Dataset is loaded and can be queried.
        pub const LOADED: State = State::new("LOADED");

        /// Dataset is unloading.
        pub const UNLOADING: State = State::new("UNLOADING");

        /// Dataset is unloaded and is removed from the system.
        pub const UNLOADED: State = State::new("UNLOADED");

        /// Dataset processing failed.
        pub const FAILED: State = State::new("FAILED");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Represents an event dimension.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EventDimension {
    /// Dimension name.
    ///
    /// **NOTE**: `EventDimension` names must be composed of alphanumeric
    /// characters only, and are case insensitive. Unicode characters are *not*
    /// supported. The underscore '_' is also allowed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Dimension value.
    ///
    /// **NOTE**: All entries of the dimension `name` must have the same `value`
    /// type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::event_dimension::Value>,
}

impl EventDimension {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EventDimension::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of `value`.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::event_dimension::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::EventDimension::value]
    /// if it holds a `StringVal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_string_val(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::event_dimension::Value::StringVal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::EventDimension::value]
    /// if it holds a `LongVal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_long_val(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::event_dimension::Value::LongVal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::EventDimension::value]
    /// if it holds a `BoolVal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bool_val(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::event_dimension::Value::BoolVal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::EventDimension::value]
    /// if it holds a `DoubleVal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_double_val(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::event_dimension::Value::DoubleVal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::EventDimension::value]
    /// to hold a `StringVal`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_val<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::event_dimension::Value::StringVal(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::EventDimension::value]
    /// to hold a `LongVal`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_long_val<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::event_dimension::Value::LongVal(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::EventDimension::value]
    /// to hold a `BoolVal`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_val<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::event_dimension::Value::BoolVal(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::EventDimension::value]
    /// to hold a `DoubleVal`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_double_val<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::event_dimension::Value::DoubleVal(v.into()));
        self
    }
}

impl wkt::message::Message for EventDimension {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.EventDimension"
    }
}

/// Defines additional types related to EventDimension
pub mod event_dimension {
    #[allow(unused_imports)]
    use super::*;

    /// Dimension value.
    ///
    /// **NOTE**: All entries of the dimension `name` must have the same `value`
    /// type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Value {
        /// String representation.
        ///
        /// **NOTE**: String values are case insensitive. Unicode characters are
        /// supported.
        StringVal(std::string::String),
        /// Long representation.
        LongVal(i64),
        /// Bool representation.
        BoolVal(bool),
        /// Double representation.
        DoubleVal(f64),
    }
}

/// Represents an entry in a data source.
///
/// Each Event has:
///
/// * A timestamp at which the event occurs.
/// * One or multiple dimensions.
/// * Optionally, a group ID that allows clients to group logically related
///   events (for example, all events representing payments transactions done by
///   a user in a day have the same group ID).  If a group ID is not provided, an
///   internal one will be generated based on the content and `eventTime`.
///
/// **NOTE**:
///
/// * Internally, we discretize time in equal-sized chunks and we assume an
///   event has a 0
///   [TimeseriesPoint.value][google.cloud.timeseriesinsights.v1.TimeseriesPoint.value]
///   in a chunk that does not contain any occurrences of an event in the input.
/// * The number of Events with the same group ID should be limited.
/// * Group ID *cannot* be queried.
/// * Group ID does *not* correspond to a user ID or the like. If a user ID is of
///   interest to be queried, use a user ID `dimension` instead.
///
/// [google.cloud.timeseriesinsights.v1.TimeseriesPoint.value]: crate::model::TimeseriesPoint::value
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Event {
    /// Event dimensions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dimensions: std::vec::Vec<crate::model::EventDimension>,

    /// Event group ID.
    ///
    /// **NOTE**: JSON encoding should use a string to hold a 64-bit integer value,
    /// because a native JSON number holds only 53 binary bits for an integer.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub group_id: i64,

    /// Event timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub event_time: std::option::Option<wkt::Timestamp>,
}

impl Event {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group_id][crate::model::Event::group_id].
    pub fn set_group_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.group_id = v.into();
        self
    }

    /// Sets the value of [event_time][crate::model::Event::event_time].
    pub fn set_event_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.event_time = v.into();
        self
    }

    /// Sets the value of [dimensions][crate::model::Event::dimensions].
    pub fn set_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EventDimension>,
    {
        use std::iter::Iterator;
        self.dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Event {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.Event"
    }
}

/// Appends events to an existing DataSet.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AppendEventsRequest {
    /// Events to be appended.
    ///
    /// Note:
    ///
    /// . The [DataSet][google.cloud.timeseriesinsights.v1.DataSet] must be shown in a `LOADED` state
    ///   in the results of `list` method; otherwise, all events from
    ///   the append request will be dropped, and a `NOT_FOUND` status will be
    ///   returned.
    /// . All events in a single request must have the same
    ///   [groupId][google.cloud.timeseriesinsights.v1.Event.group_id] if set; otherwise, an
    ///   `INVALID_ARGUMENT` status will be returned.
    /// . If [groupId][google.cloud.timeseriesinsights.v1.Event.group_id] is not set (or 0), there
    ///   should be only 1 event; otherwise, an `INVALID_ARGUMENT` status will be
    ///   returned.
    /// . The events must be newer than the current time minus
    ///   [DataSet TTL][google.cloud.timeseriesinsights.v1.DataSet.ttl] or they will be dropped.
    ///
    /// [google.cloud.timeseriesinsights.v1.DataSet]: crate::model::DataSet
    /// [google.cloud.timeseriesinsights.v1.DataSet.ttl]: crate::model::DataSet::ttl
    /// [google.cloud.timeseriesinsights.v1.Event.group_id]: crate::model::Event::group_id
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub events: std::vec::Vec<crate::model::Event>,

    /// Required. The DataSet to which we want to append to in the format of
    /// "projects/{project}/datasets/{dataset}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset: std::string::String,
}

impl AppendEventsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::AppendEventsRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [events][crate::model::AppendEventsRequest::events].
    pub fn set_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Event>,
    {
        use std::iter::Iterator;
        self.events = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AppendEventsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.AppendEventsRequest"
    }
}

/// Response for an AppendEvents RPC.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AppendEventsResponse {
    /// Dropped events; empty if all events are successfully added.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dropped_events: std::vec::Vec<crate::model::Event>,
}

impl AppendEventsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dropped_events][crate::model::AppendEventsResponse::dropped_events].
    pub fn set_dropped_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Event>,
    {
        use std::iter::Iterator;
        self.dropped_events = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AppendEventsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.AppendEventsResponse"
    }
}

/// Create a DataSet request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDataSetRequest {
    /// Required. Client project name which will own this DataSet in the format of
    /// 'projects/{project}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Dataset to be loaded.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset: std::option::Option<crate::model::DataSet>,
}

impl CreateDataSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDataSetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::CreateDataSetRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::option::Option<crate::model::DataSet>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset = v.into();
        self
    }
}

impl wkt::message::Message for CreateDataSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.CreateDataSetRequest"
    }
}

/// Unload DataSet request from the serving system.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDataSetRequest {
    /// Required. Dataset name in the format of "projects/{project}/datasets/{dataset}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteDataSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDataSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDataSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.DeleteDataSetRequest"
    }
}

/// List the DataSets created by the current project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataSetsRequest {
    /// Required. Project owning the DataSet in the format of "projects/{project}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Number of results to return in the list.
    pub page_size: i32,

    /// Token to provide to skip to a particular spot in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListDataSetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataSetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataSetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataSetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDataSetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.ListDataSetsRequest"
    }
}

/// Created DataSets list response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataSetsResponse {
    /// The list of created DataSets.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub datasets: std::vec::Vec<crate::model::DataSet>,

    /// Token to receive the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListDataSetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDataSetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [datasets][crate::model::ListDataSetsResponse::datasets].
    pub fn set_datasets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataSet>,
    {
        use std::iter::Iterator;
        self.datasets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDataSetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.ListDataSetsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListDataSetsResponse {
    type PageItem = crate::model::DataSet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.datasets
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// A categorical dimension fixed to a certain value.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PinnedDimension {
    /// The name of the dimension for which we are fixing its value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Dimension value.
    ///
    /// **NOTE**: The `value` type must match that in the data with the same
    /// `dimension` as name.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::pinned_dimension::Value>,
}

impl PinnedDimension {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PinnedDimension::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of `value`.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::pinned_dimension::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::PinnedDimension::value]
    /// if it holds a `StringVal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_string_val(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::pinned_dimension::Value::StringVal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::PinnedDimension::value]
    /// if it holds a `BoolVal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bool_val(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::pinned_dimension::Value::BoolVal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::PinnedDimension::value]
    /// to hold a `StringVal`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_val<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::pinned_dimension::Value::StringVal(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::PinnedDimension::value]
    /// to hold a `BoolVal`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_val<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::pinned_dimension::Value::BoolVal(v.into()));
        self
    }
}

impl wkt::message::Message for PinnedDimension {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.PinnedDimension"
    }
}

/// Defines additional types related to PinnedDimension
pub mod pinned_dimension {
    #[allow(unused_imports)]
    use super::*;

    /// Dimension value.
    ///
    /// **NOTE**: The `value` type must match that in the data with the same
    /// `dimension` as name.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Value {
        /// A string value. This can be used for [dimensions][google.cloud.timeseriesinsights.v1.EventDimension], which
        /// have their value field set to [string_val][google.cloud.timeseriesinsights.v1.EventDimension.string_val].
        ///
        /// [google.cloud.timeseriesinsights.v1.EventDimension]: crate::model::EventDimension
        /// [google.cloud.timeseriesinsights.v1.EventDimension.string_val]: crate::model::EventDimension::value
        StringVal(std::string::String),
        /// A bool value. This can be used for [dimensions][google.cloud.timeseriesinsights.v1.EventDimension], which
        /// have their value field set to [bool_val][google.cloud.timeseriesinsights.v1.EventDimension.bool_val].
        ///
        /// [google.cloud.timeseriesinsights.v1.EventDimension]: crate::model::EventDimension
        /// [google.cloud.timeseriesinsights.v1.EventDimension.bool_val]: crate::model::EventDimension::value
        BoolVal(bool),
    }
}

/// Parameters that control the sensitivity and other options for the time series
/// forecast.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ForecastParams {
    /// Optional. Penalize variations between the actual and forecasted values smaller than
    /// this. For more information about how this parameter affects the score, see
    /// the [anomalyScore](EvaluatedSlice.anomaly_score) formula.
    ///
    /// Intuitively, anomaly scores summarize how statistically significant the
    /// change between the actual and forecasted value is compared with what we
    /// expect the change to be (see
    /// [expectedDeviation](EvaluatedSlice.expected_deviation)). However, in
    /// practice, depending on the application, changes smaller than certain
    /// absolute values, while statistically significant, may not be important.
    ///
    /// This parameter allows us to penalize such low absolute value changes.
    ///
    /// Must be in the (0.0, inf) range.
    ///
    /// If unspecified, it defaults to 0.000001.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub noise_threshold: std::option::Option<f64>,

    /// Optional. Specifying any known seasonality/periodicity in the time series
    /// for the slices we will analyze can improve the quality of the results.
    ///
    /// If unsure, simply leave it unspecified by not setting a value for this
    /// field.
    ///
    /// If your time series has multiple seasonal patterns, then set it to the most
    /// granular one (e.g. if it has daily and weekly patterns, set this to DAILY).
    pub seasonality_hint: crate::model::forecast_params::Period,

    /// Optional. The length of the returned [forecasted
    /// timeseries][EvaluatedSlice.forecast].
    ///
    /// This duration is currently capped at 100 x
    /// [granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity].
    ///
    /// Example: If the detection point is set to "2020-12-27T00:00:00Z", the
    /// [granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity] to "3600s" and the
    /// horizon_duration to "10800s", then we will generate 3 time
    /// series points (from "2020-12-27T01:00:00Z" to "2020-12-27T04:00:00Z"), for
    /// which we will return their forecasted values.
    ///
    /// Note: The horizon time is only used for forecasting not for anormaly
    /// detection. To detect anomalies for multiple points of time,
    /// simply send multiple queries with those as
    /// [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time].
    ///
    /// [EvaluatedSlice.forecast]: crate::model::EvaluatedSlice::forecast
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]: crate::model::TimeseriesParams::granularity
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub horizon_duration: std::option::Option<wkt::Duration>,
}

impl ForecastParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [noise_threshold][crate::model::ForecastParams::noise_threshold].
    pub fn set_noise_threshold<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.noise_threshold = v.into();
        self
    }

    /// Sets the value of [seasonality_hint][crate::model::ForecastParams::seasonality_hint].
    pub fn set_seasonality_hint<T: std::convert::Into<crate::model::forecast_params::Period>>(
        mut self,
        v: T,
    ) -> Self {
        self.seasonality_hint = v.into();
        self
    }

    /// Sets the value of [horizon_duration][crate::model::ForecastParams::horizon_duration].
    pub fn set_horizon_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.horizon_duration = v.into();
        self
    }
}

impl wkt::message::Message for ForecastParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.ForecastParams"
    }
}

/// Defines additional types related to ForecastParams
pub mod forecast_params {
    #[allow(unused_imports)]
    use super::*;

    /// A time period of a fixed interval.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Period(std::borrow::Cow<'static, str>);

    impl Period {
        /// Creates a new Period instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Period](Period)
    pub mod period {
        use super::Period;

        /// Unknown or simply not given.
        pub const PERIOD_UNSPECIFIED: Period = Period::new("PERIOD_UNSPECIFIED");

        /// 1 hour
        pub const HOURLY: Period = Period::new("HOURLY");

        /// 24 hours
        pub const DAILY: Period = Period::new("DAILY");

        /// 7 days
        pub const WEEKLY: Period = Period::new("WEEKLY");

        /// 30 days
        pub const MONTHLY: Period = Period::new("MONTHLY");

        /// 365 days
        pub const YEARLY: Period = Period::new("YEARLY");
    }

    impl std::convert::From<std::string::String> for Period {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// A point in a time series.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeseriesPoint {
    /// The timestamp of this point.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time: std::option::Option<wkt::Timestamp>,

    /// The value for this point.
    ///
    /// It is computed by aggregating all events in the associated slice that are
    /// in the `[time, time + granularity]` range (see
    /// [granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]) using the specified
    /// [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric].
    ///
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]: crate::model::TimeseriesParams::granularity
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric]: crate::model::TimeseriesParams::metric
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<f64>,
}

impl TimeseriesPoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time][crate::model::TimeseriesPoint::time].
    pub fn set_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.time = v.into();
        self
    }

    /// Sets the value of [value][crate::model::TimeseriesPoint::value].
    pub fn set_value<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for TimeseriesPoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.TimeseriesPoint"
    }
}

/// A time series.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Timeseries {
    /// The points in this time series, ordered by their timestamp.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub point: std::vec::Vec<crate::model::TimeseriesPoint>,
}

impl Timeseries {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [point][crate::model::Timeseries::point].
    pub fn set_point<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeseriesPoint>,
    {
        use std::iter::Iterator;
        self.point = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Timeseries {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.Timeseries"
    }
}

/// Forecast result for a given slice.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EvaluatedSlice {
    /// Values for all categorical dimensions that uniquely identify this slice.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dimensions: std::vec::Vec<crate::model::PinnedDimension>,

    /// The actual value at the detection time (see
    /// [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]).
    ///
    /// **NOTE**: This value can be an estimate, so it should not be used as a
    /// source of truth.
    ///
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub detection_point_actual: std::option::Option<f64>,

    /// The expected value at the detection time, which is obtained by forecasting
    /// on the historical time series.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub detection_point_forecast: std::option::Option<f64>,

    /// How much our forecast model expects the detection point actual will
    /// deviate from its forecasted value based on how well it fit the input time
    /// series.
    ///
    /// In general, we expect the `detectionPointActual` to
    /// be in the `[detectionPointForecast - expectedDeviation,
    /// detectionPointForecast + expectedDeviation]` range. The more the actual
    /// value is outside this range, the more statistically significant the
    /// anomaly is.
    ///
    /// The expected deviation is always positive.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expected_deviation: std::option::Option<f64>,

    /// Summarizes how significant the change between the actual and forecasted
    /// detection points are compared with the historical patterns observed on the
    /// [history][google.cloud.timeseriesinsights.v1.EvaluatedSlice.history] time series.
    ///
    /// Defined as *|a - f| / (e + nt)*, where:
    ///
    /// - *a* is the [detectionPointActual][google.cloud.timeseriesinsights.v1.EvaluatedSlice.detection_point_actual].
    /// - *f* is the [detectionPointForecast][google.cloud.timeseriesinsights.v1.EvaluatedSlice.detection_point_forecast].
    /// - *e* is the [expectedDeviation][google.cloud.timeseriesinsights.v1.EvaluatedSlice.expected_deviation].
    /// - *nt` is the [noiseThreshold][google.cloud.timeseriesinsights.v1.ForecastParams.noise_threshold].
    ///
    /// Anomaly scores between different requests and datasets are comparable. As
    /// a guideline, the risk of a slice being an anomaly based on the anomaly
    /// score is:
    ///
    /// - **Very High** if `anomalyScore` > 5.
    /// - **High** if the `anomalyScore` is in the [2, 5] range.
    /// - **Medium** if the `anomalyScore` is in the [1, 2) range.
    /// - **Low** if the `anomalyScore` is < 1.
    ///
    /// If there were issues evaluating this slice, then the anomaly score will be
    /// set to -1.0 and the [status][google.cloud.timeseriesinsights.v1.EvaluatedSlice.status] field will contain details on what
    /// went wrong.
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.detection_point_actual]: crate::model::EvaluatedSlice::detection_point_actual
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.detection_point_forecast]: crate::model::EvaluatedSlice::detection_point_forecast
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.expected_deviation]: crate::model::EvaluatedSlice::expected_deviation
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.history]: crate::model::EvaluatedSlice::history
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.status]: crate::model::EvaluatedSlice::status
    /// [google.cloud.timeseriesinsights.v1.ForecastParams.noise_threshold]: crate::model::ForecastParams::noise_threshold
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub anomaly_score: std::option::Option<f64>,

    /// The actual values in the `[`
    /// [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] `-`
    /// [forecastHistory][google.cloud.timeseriesinsights.v1.TimeseriesParams.forecast_history]`,`
    /// [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] `]` time
    /// range.
    ///
    /// **NOTE**: This field is only populated if
    /// [returnTimeseries][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.return_timeseries] is true.
    ///
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.return_timeseries]: crate::model::QueryDataSetRequest::return_timeseries
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.forecast_history]: crate::model::TimeseriesParams::forecast_history
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub history: std::option::Option<crate::model::Timeseries>,

    /// The forecasted values in the `[`
    /// [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] `+`
    /// [granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]`,`
    /// [forecastParams.horizonTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.forecast_params] `]` time
    /// range.
    ///
    /// **NOTE**: This field is only populated if
    /// [returnTimeseries][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.return_timeseries] is true.
    ///
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.forecast_params]: crate::model::QueryDataSetRequest::forecast_params
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.return_timeseries]: crate::model::QueryDataSetRequest::return_timeseries
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]: crate::model::TimeseriesParams::granularity
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub forecast: std::option::Option<crate::model::Timeseries>,

    /// Evaluation status. Contains an error message if the `anomalyScore` is < 0.
    ///
    /// Possible error messages:
    ///
    /// - **"Time series too sparse"**: The returned time series for this slice did
    ///   not contain enough data points (we require a minimum of 10).
    /// - **"Not enough recent time series points"**: The time series contains the
    ///   minimum of 10 points, but there are not enough close in time to the
    ///   detection point.
    /// - **"Missing detection point data"**: There were not events to be
    ///   aggregated within the `[detectionTime, detectionTime + granularity]` time
    ///   interval, so we don't have an actual value with which we can compare our
    ///   prediction.
    /// - **"Data retrieval error"**: We failed to retrieve the time series data
    ///   for this slice and could not evaluate it successfully. Should be a
    ///   transient error.
    /// - **"Internal server error"**: Internal unexpected error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<rpc::model::Status>,
}

impl EvaluatedSlice {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [detection_point_actual][crate::model::EvaluatedSlice::detection_point_actual].
    pub fn set_detection_point_actual<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.detection_point_actual = v.into();
        self
    }

    /// Sets the value of [detection_point_forecast][crate::model::EvaluatedSlice::detection_point_forecast].
    pub fn set_detection_point_forecast<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.detection_point_forecast = v.into();
        self
    }

    /// Sets the value of [expected_deviation][crate::model::EvaluatedSlice::expected_deviation].
    pub fn set_expected_deviation<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expected_deviation = v.into();
        self
    }

    /// Sets the value of [anomaly_score][crate::model::EvaluatedSlice::anomaly_score].
    pub fn set_anomaly_score<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.anomaly_score = v.into();
        self
    }

    /// Sets the value of [history][crate::model::EvaluatedSlice::history].
    pub fn set_history<T: std::convert::Into<std::option::Option<crate::model::Timeseries>>>(
        mut self,
        v: T,
    ) -> Self {
        self.history = v.into();
        self
    }

    /// Sets the value of [forecast][crate::model::EvaluatedSlice::forecast].
    pub fn set_forecast<T: std::convert::Into<std::option::Option<crate::model::Timeseries>>>(
        mut self,
        v: T,
    ) -> Self {
        self.forecast = v.into();
        self
    }

    /// Sets the value of [status][crate::model::EvaluatedSlice::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [dimensions][crate::model::EvaluatedSlice::dimensions].
    pub fn set_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PinnedDimension>,
    {
        use std::iter::Iterator;
        self.dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EvaluatedSlice {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.EvaluatedSlice"
    }
}

/// Parameters that control how we slice the dataset and, optionally, filter
/// slices that have some specific values on some dimensions (pinned dimensions).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SlicingParams {
    /// Required. Dimensions over which we will group the events in slices. The names
    /// specified here come from the
    /// [EventDimension.name][google.cloud.timeseriesinsights.v1.EventDimension.name] field. At least
    /// one dimension name must be specified. All dimension names that do not exist
    /// in the queried `DataSet` will be ignored.
    ///
    /// Currently only dimensions that hold string values can be specified here.
    ///
    /// [google.cloud.timeseriesinsights.v1.EventDimension.name]: crate::model::EventDimension::name
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dimension_names: std::vec::Vec<std::string::String>,

    /// Optional. We will only analyze slices for which
    /// [EvaluatedSlice.dimensions][google.cloud.timeseriesinsights.v1.EvaluatedSlice.dimensions] contain all of the
    /// following pinned dimensions. A query with a pinned dimension `{ name: "d3"
    /// stringVal: "v3" }` will only analyze events which contain the dimension `{
    /// name: "d3" stringVal: "v3" }`.
    /// The [pinnedDimensions][google.cloud.timeseriesinsights.v1.SlicingParams.pinned_dimensions] and
    /// [dimensionNames][google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names] fields can **not**
    /// share the same dimension names.
    ///
    /// Example a valid specification:
    ///
    /// ```norust
    /// {
    ///   dimensionNames: ["d1", "d2"],
    ///   pinnedDimensions: [
    ///     { name: "d3" stringVal: "v3" },
    ///     { name: "d4" stringVal: "v4" }
    ///   ]
    /// }
    /// ```
    ///
    /// In the previous example we will slice the dataset by dimensions "d1",
    /// "d2", "d3" and "d4", but we will only analyze slices for which "d3=v3" and
    /// "d4=v4".
    ///
    /// The following example is **invalid** as "d2" is present in both
    /// dimensionNames and pinnedDimensions:
    ///
    /// ```norust
    /// {
    ///   dimensionNames: ["d1", "d2"],
    ///   pinnedDimensions: [
    ///     { name: "d2" stringVal: "v2" },
    ///     { name: "d4" stringVal: "v4" }
    ///   ]
    /// }
    /// ```
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.dimensions]: crate::model::EvaluatedSlice::dimensions
    /// [google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names]: crate::model::SlicingParams::dimension_names
    /// [google.cloud.timeseriesinsights.v1.SlicingParams.pinned_dimensions]: crate::model::SlicingParams::pinned_dimensions
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pinned_dimensions: std::vec::Vec<crate::model::PinnedDimension>,
}

impl SlicingParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dimension_names][crate::model::SlicingParams::dimension_names].
    pub fn set_dimension_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dimension_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pinned_dimensions][crate::model::SlicingParams::pinned_dimensions].
    pub fn set_pinned_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PinnedDimension>,
    {
        use std::iter::Iterator;
        self.pinned_dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SlicingParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.SlicingParams"
    }
}

/// Parameters that control how we construct the time series for each slice.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeseriesParams {
    /// Required. How long should we go in the past when fetching the timeline used for
    /// forecasting each slice.
    ///
    /// This is used in combination with the
    /// [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] parameter.
    /// The time series we construct will have the following time range:
    /// `[detectionTime - forecastHistory, detectionTime + granularity]`.
    ///
    /// The forecast history might be rounded up, so that a multiple of
    /// `granularity` is used to process the query.
    ///
    /// Note: If there are not enough events in the
    /// `[detectionTime - forecastHistory, detectionTime + granularity]` time
    /// interval, the slice evaluation can fail. For more information, see
    /// [EvaluatedSlice.status][google.cloud.timeseriesinsights.v1.EvaluatedSlice.status].
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.status]: crate::model::EvaluatedSlice::status
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub forecast_history: std::option::Option<wkt::Duration>,

    /// Required. The time granularity of the time series (on the x-axis). Each time series
    /// point starting at time T will aggregate all events for a particular slice
    /// in *[T, T + granularity)* time windows.
    ///
    /// Note: The aggregation is decided based on the
    /// [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] parameter.
    ///
    /// This granularity defines the query-time aggregation windows and is not
    /// necessarily related to any event time granularity in the raw data (though
    /// we do recommend that the query-time granularity is not finer than the
    /// ingestion-time one).
    ///
    /// Currently, the minimal supported granularity is 10 seconds.
    ///
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric]: crate::model::TimeseriesParams::metric
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub granularity: std::option::Option<wkt::Duration>,

    /// Optional. Denotes the [name][google.cloud.timeseriesinsights.v1.EventDimension.name] of a numerical
    /// dimension that will have its values aggregated to compute the y-axis of the
    /// time series.
    ///
    /// The aggregation method must also be specified by setting the
    /// [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
    /// field.
    ///
    /// Note: Currently, if the aggregation method is unspecified, we will
    /// default to SUM for backward compatibility reasons, but new implementations
    /// should set the
    /// [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
    /// explicitly.
    ///
    /// If the metric is unspecified, we will use the number of events that each
    /// time series point contains as the point value.
    ///
    /// Example: Let's assume we have the following three events in our dataset:
    ///
    /// ```norust
    /// {
    ///   eventTime: "2020-12-27T00:00:00Z",
    ///   dimensions: [
    ///     { name: "d1" stringVal: "v1" },
    ///     { name: "d2" stringVal: "v2" }
    ///     { name: "m1" longVal: 100 }
    ///     { name: "m2" longVal: 11 }
    ///   ]
    /// },
    /// {
    ///   eventTime: "2020-12-27T00:10:00Z",
    ///   dimensions: [
    ///     { name: "d1" stringVal: "v1" },
    ///     { name: "d2" stringVal: "v2" }
    ///     { name: "m1" longVal: 200 }
    ///     { name: "m2" longVal: 22 }
    ///   ]
    /// },
    /// {
    ///   eventTime: "2020-12-27T00:20:00Z",
    ///   dimensions: [
    ///     { name: "d1" stringVal: "v1" },
    ///     { name: "d2" stringVal: "v2" }
    ///     { name: "m1" longVal: 300 }
    ///     { name: "m2" longVal: 33 }
    ///   ]
    /// }
    /// ```
    ///
    /// These events are all within the same hour, spaced 10 minutes between each
    /// of them. Assuming our [QueryDataSetRequest][google.cloud.timeseriesinsights.v1.QueryDataSetRequest] had set
    /// [slicingParams.dimensionNames][google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names] to ["d1",
    /// "d2"] and [timeseries_params.granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity] to
    /// "3600s", then all the previous events will be aggregated into the same
    /// [timeseries point][google.cloud.timeseriesinsights.v1.TimeseriesPoint].
    ///
    /// The time series point that they're all part of will have the
    /// [time][google.cloud.timeseriesinsights.v1.TimeseriesPoint.time] set to "2020-12-27T00:00:00Z" and the
    /// [value][google.cloud.timeseriesinsights.v1.TimeseriesPoint.value] populated based on this metric field:
    ///
    /// - If the metric is set to "m1" and metric_aggregation_method to SUM, then
    ///   the value of the point will be 600.
    /// - If the metric is set to "m2" and metric_aggregation_method to SUM, then
    ///   the value of the point will be 66.
    /// - If the metric is set to "m1" and metric_aggregation_method to AVERAGE,
    ///   then the value of the point will be 200.
    /// - If the metric is set to "m2" and metric_aggregation_method to AVERAGE,
    ///   then the value of the point will be 22.
    /// - If the metric field is "" or unspecified, then the value of the point
    ///   will be 3, as we will simply count the events.
    ///
    /// [google.cloud.timeseriesinsights.v1.EventDimension.name]: crate::model::EventDimension::name
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest]: crate::model::QueryDataSetRequest
    /// [google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names]: crate::model::SlicingParams::dimension_names
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]: crate::model::TimeseriesParams::granularity
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]: crate::model::TimeseriesParams::metric_aggregation_method
    /// [google.cloud.timeseriesinsights.v1.TimeseriesPoint]: crate::model::TimeseriesPoint
    /// [google.cloud.timeseriesinsights.v1.TimeseriesPoint.time]: crate::model::TimeseriesPoint::time
    /// [google.cloud.timeseriesinsights.v1.TimeseriesPoint.value]: crate::model::TimeseriesPoint::value
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric: std::option::Option<std::string::String>,

    /// Optional. Together with the [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] field, specifies how
    /// we will aggregate multiple events to obtain the value of a time series
    /// point. See the [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] documentation for more
    /// details.
    ///
    /// If the metric is not specified or "", then this field will be ignored.
    ///
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric]: crate::model::TimeseriesParams::metric
    pub metric_aggregation_method: crate::model::timeseries_params::AggregationMethod,
}

impl TimeseriesParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [forecast_history][crate::model::TimeseriesParams::forecast_history].
    pub fn set_forecast_history<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.forecast_history = v.into();
        self
    }

    /// Sets the value of [granularity][crate::model::TimeseriesParams::granularity].
    pub fn set_granularity<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.granularity = v.into();
        self
    }

    /// Sets the value of [metric][crate::model::TimeseriesParams::metric].
    pub fn set_metric<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric = v.into();
        self
    }

    /// Sets the value of [metric_aggregation_method][crate::model::TimeseriesParams::metric_aggregation_method].
    pub fn set_metric_aggregation_method<
        T: std::convert::Into<crate::model::timeseries_params::AggregationMethod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_aggregation_method = v.into();
        self
    }
}

impl wkt::message::Message for TimeseriesParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.TimeseriesParams"
    }
}

/// Defines additional types related to TimeseriesParams
pub mod timeseries_params {
    #[allow(unused_imports)]
    use super::*;

    /// Methods by which we can aggregate multiple events by a given
    /// [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric].
    ///
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric]: crate::model::TimeseriesParams::metric
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AggregationMethod(std::borrow::Cow<'static, str>);

    impl AggregationMethod {
        /// Creates a new AggregationMethod instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [AggregationMethod](AggregationMethod)
    pub mod aggregation_method {
        use super::AggregationMethod;

        /// Unspecified.
        pub const AGGREGATION_METHOD_UNSPECIFIED: AggregationMethod =
            AggregationMethod::new("AGGREGATION_METHOD_UNSPECIFIED");

        /// Aggregate multiple events by summing up the values found in the
        /// [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] dimension.
        ///
        /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric]: crate::model::TimeseriesParams::metric
        pub const SUM: AggregationMethod = AggregationMethod::new("SUM");

        /// Aggregate multiple events by averaging out the values found in the
        /// [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] dimension.
        ///
        /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric]: crate::model::TimeseriesParams::metric
        pub const AVERAGE: AggregationMethod = AggregationMethod::new("AVERAGE");
    }

    impl std::convert::From<std::string::String> for AggregationMethod {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Request for performing a query against a loaded DataSet.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryDataSetRequest {
    /// Required. Loaded DataSet to be queried in the format of
    /// "projects/{project}/datasets/{dataset}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. This is the point in time that we want to probe for anomalies.
    ///
    /// The corresponding [TimeseriesPoint][google.cloud.timeseriesinsights.v1.TimeseriesPoint] is referred to as the
    /// detection point.
    ///
    /// **NOTE**: As with any other time series point, the value is given by
    /// aggregating all events in the slice that are in the
    /// [detectionTime, detectionTime + granularity) time interval, where
    /// the granularity is specified in the
    /// [timeseriesParams.granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity] field.
    ///
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]: crate::model::TimeseriesParams::granularity
    /// [google.cloud.timeseriesinsights.v1.TimeseriesPoint]: crate::model::TimeseriesPoint
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub detection_time: std::option::Option<wkt::Timestamp>,

    /// How many slices are returned in
    /// [QueryDataSetResponse.slices][google.cloud.timeseriesinsights.v1.QueryDataSetResponse.slices].
    ///
    /// The returned slices are tentatively the ones with the highest
    /// [anomaly scores][google.cloud.timeseriesinsights.v1.EvaluatedSlice.anomaly_score] in the dataset that match
    /// the query, but it is not guaranteed.
    ///
    /// Reducing this number will improve query performance, both in terms of
    /// latency and resource usage.
    ///
    /// Defaults to 50.
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.anomaly_score]: crate::model::EvaluatedSlice::anomaly_score
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetResponse.slices]: crate::model::QueryDataSetResponse::slices
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub num_returned_slices: std::option::Option<i32>,

    /// Parameters controlling how we will split the dataset into the slices that
    /// we will analyze.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub slicing_params: std::option::Option<crate::model::SlicingParams>,

    /// Parameters controlling how we will build the time series used to predict
    /// the [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] value for each slice.
    ///
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeseries_params: std::option::Option<crate::model::TimeseriesParams>,

    /// Parameters that control the time series forecasting models, such as the
    /// sensitivity of the anomaly detection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub forecast_params: std::option::Option<crate::model::ForecastParams>,

    /// If specified, we will return the actual and forecasted time for all
    /// returned slices.
    ///
    /// The time series are returned in the
    /// [EvaluatedSlice.history][google.cloud.timeseriesinsights.v1.EvaluatedSlice.history] and
    /// [EvaluatedSlice.forecast][google.cloud.timeseriesinsights.v1.EvaluatedSlice.forecast] fields.
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.forecast]: crate::model::EvaluatedSlice::forecast
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.history]: crate::model::EvaluatedSlice::history
    pub return_timeseries: bool,
}

impl QueryDataSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QueryDataSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [detection_time][crate::model::QueryDataSetRequest::detection_time].
    pub fn set_detection_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.detection_time = v.into();
        self
    }

    /// Sets the value of [num_returned_slices][crate::model::QueryDataSetRequest::num_returned_slices].
    pub fn set_num_returned_slices<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.num_returned_slices = v.into();
        self
    }

    /// Sets the value of [slicing_params][crate::model::QueryDataSetRequest::slicing_params].
    pub fn set_slicing_params<
        T: std::convert::Into<std::option::Option<crate::model::SlicingParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.slicing_params = v.into();
        self
    }

    /// Sets the value of [timeseries_params][crate::model::QueryDataSetRequest::timeseries_params].
    pub fn set_timeseries_params<
        T: std::convert::Into<std::option::Option<crate::model::TimeseriesParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.timeseries_params = v.into();
        self
    }

    /// Sets the value of [forecast_params][crate::model::QueryDataSetRequest::forecast_params].
    pub fn set_forecast_params<
        T: std::convert::Into<std::option::Option<crate::model::ForecastParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.forecast_params = v.into();
        self
    }

    /// Sets the value of [return_timeseries][crate::model::QueryDataSetRequest::return_timeseries].
    pub fn set_return_timeseries<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.return_timeseries = v.into();
        self
    }
}

impl wkt::message::Message for QueryDataSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.QueryDataSetRequest"
    }
}

/// Response for a query executed by the system.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryDataSetResponse {
    /// Loaded DataSet that was queried.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Slices sorted in descending order by their
    /// [anomalyScore][google.cloud.timeseriesinsights.v1.EvaluatedSlice.anomaly_score].
    ///
    /// At most [numReturnedSlices][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.num_returned_slices]
    /// slices are present in this field.
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.anomaly_score]: crate::model::EvaluatedSlice::anomaly_score
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.num_returned_slices]: crate::model::QueryDataSetRequest::num_returned_slices
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub slices: std::vec::Vec<crate::model::EvaluatedSlice>,
}

impl QueryDataSetResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QueryDataSetResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [slices][crate::model::QueryDataSetResponse::slices].
    pub fn set_slices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EvaluatedSlice>,
    {
        use std::iter::Iterator;
        self.slices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for QueryDataSetResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.QueryDataSetResponse"
    }
}

/// Request for evaluateSlice.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EvaluateSliceRequest {
    /// Required. Loaded DataSet to be queried in the format of
    /// "projects/{project}/datasets/{dataset}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset: std::string::String,

    /// Required. Dimensions with pinned values that specify the slice for which we will
    /// fetch the time series.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pinned_dimensions: std::vec::Vec<crate::model::PinnedDimension>,

    /// Required. This is the point in time that we want to probe for anomalies.
    ///
    /// See documentation for
    /// [QueryDataSetRequest.detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time].
    ///
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub detection_time: std::option::Option<wkt::Timestamp>,

    /// Parameters controlling how we will build the time series used to predict
    /// the [detectionTime][google.cloud.timeseriesinsights.v1.EvaluateSliceRequest.detection_time] value for this slice.
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluateSliceRequest.detection_time]: crate::model::EvaluateSliceRequest::detection_time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeseries_params: std::option::Option<crate::model::TimeseriesParams>,

    /// Parameters that control the time series forecasting models, such as the
    /// sensitivity of the anomaly detection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub forecast_params: std::option::Option<crate::model::ForecastParams>,
}

impl EvaluateSliceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::EvaluateSliceRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [detection_time][crate::model::EvaluateSliceRequest::detection_time].
    pub fn set_detection_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.detection_time = v.into();
        self
    }

    /// Sets the value of [timeseries_params][crate::model::EvaluateSliceRequest::timeseries_params].
    pub fn set_timeseries_params<
        T: std::convert::Into<std::option::Option<crate::model::TimeseriesParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.timeseries_params = v.into();
        self
    }

    /// Sets the value of [forecast_params][crate::model::EvaluateSliceRequest::forecast_params].
    pub fn set_forecast_params<
        T: std::convert::Into<std::option::Option<crate::model::ForecastParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.forecast_params = v.into();
        self
    }

    /// Sets the value of [pinned_dimensions][crate::model::EvaluateSliceRequest::pinned_dimensions].
    pub fn set_pinned_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PinnedDimension>,
    {
        use std::iter::Iterator;
        self.pinned_dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EvaluateSliceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.EvaluateSliceRequest"
    }
}

/// Request for evaluateTimeseries.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EvaluateTimeseriesRequest {
    /// Required. Client project name in the format of 'projects/{project}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Evaluate this time series without requiring it was previously loaded in
    /// a data set.
    ///
    /// The evaluated time series point is the last one, analogous to calling
    /// evaluateSlice or query with
    /// [detectionTime][google.cloud.timeseriesinsights.v1.EvaluateSliceRequest.detection_time] set to
    /// `timeseries.point(timeseries.point_size() - 1).time`.
    ///
    /// The length of the time series must be at least 10.
    ///
    /// All points must have the same time offset relative to the granularity. For
    /// example, if the [granularity][google.cloud.timeseriesinsights.v1.EvaluateTimeseriesRequest.granularity] is "5s", then the following
    /// point.time sequences are valid:
    ///
    /// - "100s", "105s", "120s", "125s" (no offset)
    /// - "102s", "107s", "122s", "127s" (offset is "2s")
    ///   However, the following sequence is invalid as it has inconsistent offsets:
    /// - "100s", "105s", "122s", "127s" (offsets are either "0s" or "2s")
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluateSliceRequest.detection_time]: crate::model::EvaluateSliceRequest::detection_time
    /// [google.cloud.timeseriesinsights.v1.EvaluateTimeseriesRequest.granularity]: crate::model::EvaluateTimeseriesRequest::granularity
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeseries: std::option::Option<crate::model::Timeseries>,

    /// The granularity of the time series (time distance between two consecutive
    /// points).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub granularity: std::option::Option<wkt::Duration>,

    /// The forecast parameters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub forecast_params: std::option::Option<crate::model::ForecastParams>,
}

impl EvaluateTimeseriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::EvaluateTimeseriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [timeseries][crate::model::EvaluateTimeseriesRequest::timeseries].
    pub fn set_timeseries<T: std::convert::Into<std::option::Option<crate::model::Timeseries>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timeseries = v.into();
        self
    }

    /// Sets the value of [granularity][crate::model::EvaluateTimeseriesRequest::granularity].
    pub fn set_granularity<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.granularity = v.into();
        self
    }

    /// Sets the value of [forecast_params][crate::model::EvaluateTimeseriesRequest::forecast_params].
    pub fn set_forecast_params<
        T: std::convert::Into<std::option::Option<crate::model::ForecastParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.forecast_params = v.into();
        self
    }
}

impl wkt::message::Message for EvaluateTimeseriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.EvaluateTimeseriesRequest"
    }
}
