// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

mod debug;
mod deserialize;
mod serialize;

/// Mapping of BigQuery columns to timestamp, group_id and dimensions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BigqueryMapping {
    /// The column which should be used as the event timestamps. If not specified
    /// 'Timestamp' is used by default. The column may have TIMESTAMP or INT64
    /// type (the latter is interpreted as microseconds since the Unix epoch).
    pub timestamp_column: std::string::String,

    /// The column which should be used as the group ID (grouping events into
    /// sessions). If not specified 'GroupId' is used by default, if the input
    /// table does not have such a column, random unique group IDs are
    /// generated automatically (different group ID per input row).
    pub group_id_column: std::string::String,

    /// The list of columns that should be translated to dimensions. If empty,
    /// all columns are translated to dimensions. The timestamp and group_id
    /// columns should not be listed here again. Columns are expected to have
    /// primitive types (STRING, INT64, FLOAT64 or NUMERIC).
    pub dimension_column: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigqueryMapping {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [timestamp_column][crate::model::BigqueryMapping::timestamp_column].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::BigqueryMapping;
    /// let x = BigqueryMapping::new().set_timestamp_column("example");
    /// ```
    pub fn set_timestamp_column<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.timestamp_column = v.into();
        self
    }

    /// Sets the value of [group_id_column][crate::model::BigqueryMapping::group_id_column].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::BigqueryMapping;
    /// let x = BigqueryMapping::new().set_group_id_column("example");
    /// ```
    pub fn set_group_id_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group_id_column = v.into();
        self
    }

    /// Sets the value of [dimension_column][crate::model::BigqueryMapping::dimension_column].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::BigqueryMapping;
    /// let x = BigqueryMapping::new().set_dimension_column(["a", "b", "c"]);
    /// ```
    pub fn set_dimension_column<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dimension_column = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BigqueryMapping {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.BigqueryMapping"
    }
}

/// A data source consists of multiple [Event][google.cloud.timeseriesinsights.v1.Event] objects stored on
/// Cloud Storage.  Each Event should be in JSON format, with one Event
/// per line, also known as JSON Lines format.
///
/// [google.cloud.timeseriesinsights.v1.Event]: crate::model::Event
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataSource {
    /// Data source URI.
    ///
    /// 1. Google Cloud Storage files (JSON) are defined in the following form.
    ///    `gs://bucket_name/object_name`. For more information on Cloud Storage URIs,
    ///    please see <https://cloud.google.com/storage/docs/reference-uris>.
    pub uri: std::string::String,

    /// For BigQuery inputs defines the columns that should be used for dimensions
    /// (including time and group ID).
    pub bq_mapping: std::option::Option<crate::model::BigqueryMapping>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::DataSource::uri].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::DataSource;
    /// let x = DataSource::new().set_uri("example");
    /// ```
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [bq_mapping][crate::model::DataSource::bq_mapping].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::DataSource;
    /// use google_cloud_timeseriesinsights_v1::model::BigqueryMapping;
    /// let x = DataSource::new().set_bq_mapping(BigqueryMapping::default()/* use setters */);
    /// ```
    pub fn set_bq_mapping<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigqueryMapping>,
    {
        self.bq_mapping = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bq_mapping][crate::model::DataSource::bq_mapping].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::DataSource;
    /// use google_cloud_timeseriesinsights_v1::model::BigqueryMapping;
    /// let x = DataSource::new().set_or_clear_bq_mapping(Some(BigqueryMapping::default()/* use setters */));
    /// let x = DataSource::new().set_or_clear_bq_mapping(None::<BigqueryMapping>);
    /// ```
    pub fn set_or_clear_bq_mapping<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigqueryMapping>,
    {
        self.bq_mapping = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.DataSource"
    }
}

/// A collection of data sources sent for processing.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataSet {
    /// The dataset name, which will be used for querying, status and unload
    /// requests. This must be unique within a project.
    pub name: std::string::String,

    /// [Data dimension names][google.cloud.timeseriesinsights.v1.EventDimension.name] allowed for this `DataSet`.
    ///
    /// If left empty, all dimension names are included. This field works as a
    /// filter to avoid regenerating the data.
    ///
    /// [google.cloud.timeseriesinsights.v1.EventDimension.name]: crate::model::EventDimension::name
    pub data_names: std::vec::Vec<std::string::String>,

    /// Input data.
    pub data_sources: std::vec::Vec<crate::model::DataSource>,

    /// Dataset state in the system.
    pub state: crate::model::data_set::State,

    /// Dataset processing status.
    pub status: std::option::Option<rpc::model::Status>,

    /// Periodically we discard dataset [Event][google.cloud.timeseriesinsights.v1.Event] objects that have
    /// timestamps older than 'ttl'.  Omitting this field or a zero value means no
    /// events are discarded.
    ///
    /// [google.cloud.timeseriesinsights.v1.Event]: crate::model::Event
    pub ttl: std::option::Option<wkt::Duration>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataSet::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::DataSet;
    /// let x = DataSet::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data_names][crate::model::DataSet::data_names].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::DataSet;
    /// let x = DataSet::new().set_data_names(["a", "b", "c"]);
    /// ```
    pub fn set_data_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_sources][crate::model::DataSet::data_sources].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::DataSet;
    /// use google_cloud_timeseriesinsights_v1::model::DataSource;
    /// let x = DataSet::new()
    ///     .set_data_sources([
    ///         DataSource::default()/* use setters */,
    ///         DataSource::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_data_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataSource>,
    {
        use std::iter::Iterator;
        self.data_sources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::DataSet::state].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::DataSet;
    /// use google_cloud_timeseriesinsights_v1::model::data_set::State;
    /// let x0 = DataSet::new().set_state(State::Unknown);
    /// let x1 = DataSet::new().set_state(State::Pending);
    /// let x2 = DataSet::new().set_state(State::Loading);
    /// ```
    pub fn set_state<T: std::convert::Into<crate::model::data_set::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [status][crate::model::DataSet::status].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::DataSet;
    /// use rpc::model::Status;
    /// let x = DataSet::new().set_status(Status::default()/* use setters */);
    /// ```
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::DataSet::status].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::DataSet;
    /// use rpc::model::Status;
    /// let x = DataSet::new().set_or_clear_status(Some(Status::default()/* use setters */));
    /// let x = DataSet::new().set_or_clear_status(None::<Status>);
    /// ```
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ttl][crate::model::DataSet::ttl].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::DataSet;
    /// use wkt::Duration;
    /// let x = DataSet::new().set_ttl(Duration::default()/* use setters */);
    /// ```
    pub fn set_ttl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ttl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ttl][crate::model::DataSet::ttl].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::DataSet;
    /// use wkt::Duration;
    /// let x = DataSet::new().set_or_clear_ttl(Some(Duration::default()/* use setters */));
    /// let x = DataSet::new().set_or_clear_ttl(None::<Duration>);
    /// ```
    pub fn set_or_clear_ttl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ttl = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.DataSet"
    }
}

/// Defines additional types related to [DataSet].
pub mod data_set {
    #[allow(unused_imports)]
    use super::*;

    /// DataSet state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified / undefined state.
        Unspecified,
        /// Dataset is unknown to the system; we have never seen this dataset before
        /// or we have seen this dataset but have fully GC-ed it.
        Unknown,
        /// Dataset processing is pending.
        Pending,
        /// Dataset is loading.
        Loading,
        /// Dataset is loaded and can be queried.
        Loaded,
        /// Dataset is unloading.
        Unloading,
        /// Dataset is unloaded and is removed from the system.
        Unloaded,
        /// Dataset processing failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unknown => std::option::Option::Some(1),
                Self::Pending => std::option::Option::Some(2),
                Self::Loading => std::option::Option::Some(3),
                Self::Loaded => std::option::Option::Some(4),
                Self::Unloading => std::option::Option::Some(5),
                Self::Unloaded => std::option::Option::Some(6),
                Self::Failed => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Loading => std::option::Option::Some("LOADING"),
                Self::Loaded => std::option::Option::Some("LOADED"),
                Self::Unloading => std::option::Option::Some("UNLOADING"),
                Self::Unloaded => std::option::Option::Some("UNLOADED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unknown,
                2 => Self::Pending,
                3 => Self::Loading,
                4 => Self::Loaded,
                5 => Self::Unloading,
                6 => Self::Unloaded,
                7 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "UNKNOWN" => Self::Unknown,
                "PENDING" => Self::Pending,
                "LOADING" => Self::Loading,
                "LOADED" => Self::Loaded,
                "UNLOADING" => Self::Unloading,
                "UNLOADED" => Self::Unloaded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unknown => serializer.serialize_i32(1),
                Self::Pending => serializer.serialize_i32(2),
                Self::Loading => serializer.serialize_i32(3),
                Self::Loaded => serializer.serialize_i32(4),
                Self::Unloading => serializer.serialize_i32(5),
                Self::Unloaded => serializer.serialize_i32(6),
                Self::Failed => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.timeseriesinsights.v1.DataSet.State",
            ))
        }
    }
}

/// Represents an event dimension.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EventDimension {
    /// Dimension name.
    ///
    /// **NOTE**: `EventDimension` names must be composed of alphanumeric
    /// characters only, and are case insensitive. Unicode characters are *not*
    /// supported. The underscore '_' is also allowed.
    pub name: std::string::String,

    /// Dimension value.
    ///
    /// **NOTE**: All entries of the dimension `name` must have the same `value`
    /// type.
    pub value: std::option::Option<crate::model::event_dimension::Value>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EventDimension {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EventDimension::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EventDimension;
    /// let x = EventDimension::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::EventDimension::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EventDimension;
    /// use google_cloud_timeseriesinsights_v1::model::event_dimension::Value;
    /// let x = EventDimension::new().set_value(Some(Value::StringVal("example".to_string())));
    /// ```
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::event_dimension::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::EventDimension::value]
    /// if it holds a `StringVal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_val(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::event_dimension::Value::StringVal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::EventDimension::value]
    /// to hold a `StringVal`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EventDimension;
    /// let x = EventDimension::new().set_string_val("example");
    /// assert!(x.string_val().is_some());
    /// assert!(x.long_val().is_none());
    /// assert!(x.bool_val().is_none());
    /// assert!(x.double_val().is_none());
    /// ```
    pub fn set_string_val<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::event_dimension::Value::StringVal(v.into()));
        self
    }

    /// The value of [value][crate::model::EventDimension::value]
    /// if it holds a `LongVal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn long_val(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::event_dimension::Value::LongVal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::EventDimension::value]
    /// to hold a `LongVal`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EventDimension;
    /// let x = EventDimension::new().set_long_val(42);
    /// assert!(x.long_val().is_some());
    /// assert!(x.string_val().is_none());
    /// assert!(x.bool_val().is_none());
    /// assert!(x.double_val().is_none());
    /// ```
    pub fn set_long_val<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::event_dimension::Value::LongVal(v.into()));
        self
    }

    /// The value of [value][crate::model::EventDimension::value]
    /// if it holds a `BoolVal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_val(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::event_dimension::Value::BoolVal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::EventDimension::value]
    /// to hold a `BoolVal`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EventDimension;
    /// let x = EventDimension::new().set_bool_val(true);
    /// assert!(x.bool_val().is_some());
    /// assert!(x.string_val().is_none());
    /// assert!(x.long_val().is_none());
    /// assert!(x.double_val().is_none());
    /// ```
    pub fn set_bool_val<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::event_dimension::Value::BoolVal(v.into()));
        self
    }

    /// The value of [value][crate::model::EventDimension::value]
    /// if it holds a `DoubleVal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn double_val(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::event_dimension::Value::DoubleVal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::EventDimension::value]
    /// to hold a `DoubleVal`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EventDimension;
    /// let x = EventDimension::new().set_double_val(42.0);
    /// assert!(x.double_val().is_some());
    /// assert!(x.string_val().is_none());
    /// assert!(x.long_val().is_none());
    /// assert!(x.bool_val().is_none());
    /// ```
    pub fn set_double_val<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::event_dimension::Value::DoubleVal(v.into()));
        self
    }
}

impl wkt::message::Message for EventDimension {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.EventDimension"
    }
}

/// Defines additional types related to [EventDimension].
pub mod event_dimension {
    #[allow(unused_imports)]
    use super::*;

    /// Dimension value.
    ///
    /// **NOTE**: All entries of the dimension `name` must have the same `value`
    /// type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Value {
        /// String representation.
        ///
        /// **NOTE**: String values are case insensitive. Unicode characters are
        /// supported.
        StringVal(std::string::String),
        /// Long representation.
        LongVal(i64),
        /// Bool representation.
        BoolVal(bool),
        /// Double representation.
        DoubleVal(f64),
    }
}

/// Represents an entry in a data source.
///
/// Each Event has:
///
/// * A timestamp at which the event occurs.
/// * One or multiple dimensions.
/// * Optionally, a group ID that allows clients to group logically related
///   events (for example, all events representing payments transactions done by
///   a user in a day have the same group ID).  If a group ID is not provided, an
///   internal one will be generated based on the content and `eventTime`.
///
/// **NOTE**:
///
/// * Internally, we discretize time in equal-sized chunks and we assume an
///   event has a 0
///   [TimeseriesPoint.value][google.cloud.timeseriesinsights.v1.TimeseriesPoint.value]
///   in a chunk that does not contain any occurrences of an event in the input.
/// * The number of Events with the same group ID should be limited.
/// * Group ID *cannot* be queried.
/// * Group ID does *not* correspond to a user ID or the like. If a user ID is of
///   interest to be queried, use a user ID `dimension` instead.
///
/// [google.cloud.timeseriesinsights.v1.TimeseriesPoint.value]: crate::model::TimeseriesPoint::value
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Event {
    /// Event dimensions.
    pub dimensions: std::vec::Vec<crate::model::EventDimension>,

    /// Event group ID.
    ///
    /// **NOTE**: JSON encoding should use a string to hold a 64-bit integer value,
    /// because a native JSON number holds only 53 binary bits for an integer.
    pub group_id: i64,

    /// Event timestamp.
    pub event_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Event {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dimensions][crate::model::Event::dimensions].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::Event;
    /// use google_cloud_timeseriesinsights_v1::model::EventDimension;
    /// let x = Event::new()
    ///     .set_dimensions([
    ///         EventDimension::default()/* use setters */,
    ///         EventDimension::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EventDimension>,
    {
        use std::iter::Iterator;
        self.dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [group_id][crate::model::Event::group_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::Event;
    /// let x = Event::new().set_group_id(42);
    /// ```
    pub fn set_group_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.group_id = v.into();
        self
    }

    /// Sets the value of [event_time][crate::model::Event::event_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::Event;
    /// use wkt::Timestamp;
    /// let x = Event::new().set_event_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_event_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event_time][crate::model::Event::event_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::Event;
    /// use wkt::Timestamp;
    /// let x = Event::new().set_or_clear_event_time(Some(Timestamp::default()/* use setters */));
    /// let x = Event::new().set_or_clear_event_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_event_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Event {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.Event"
    }
}

/// Appends events to an existing DataSet.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AppendEventsRequest {
    /// Events to be appended.
    ///
    /// Note:
    ///
    /// 1. The [DataSet][google.cloud.timeseriesinsights.v1.DataSet] must be shown in a `LOADED` state
    ///    in the results of `list` method; otherwise, all events from
    ///    the append request will be dropped, and a `NOT_FOUND` status will be
    ///    returned.
    /// 1. All events in a single request must have the same
    ///    [groupId][google.cloud.timeseriesinsights.v1.Event.group_id] if set; otherwise, an
    ///    `INVALID_ARGUMENT` status will be returned.
    /// 1. If [groupId][google.cloud.timeseriesinsights.v1.Event.group_id] is not set (or 0), there
    ///    should be only 1 event; otherwise, an `INVALID_ARGUMENT` status will be
    ///    returned.
    /// 1. The events must be newer than the current time minus
    ///    [DataSet TTL][google.cloud.timeseriesinsights.v1.DataSet.ttl] or they will be dropped.
    ///
    /// [google.cloud.timeseriesinsights.v1.DataSet]: crate::model::DataSet
    /// [google.cloud.timeseriesinsights.v1.DataSet.ttl]: crate::model::DataSet::ttl
    /// [google.cloud.timeseriesinsights.v1.Event.group_id]: crate::model::Event::group_id
    pub events: std::vec::Vec<crate::model::Event>,

    /// Required. The DataSet to which we want to append to in the format of
    /// "projects/{project}/datasets/{dataset}"
    pub dataset: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AppendEventsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [events][crate::model::AppendEventsRequest::events].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::AppendEventsRequest;
    /// use google_cloud_timeseriesinsights_v1::model::Event;
    /// let x = AppendEventsRequest::new()
    ///     .set_events([
    ///         Event::default()/* use setters */,
    ///         Event::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Event>,
    {
        use std::iter::Iterator;
        self.events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dataset][crate::model::AppendEventsRequest::dataset].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::AppendEventsRequest;
    /// let x = AppendEventsRequest::new().set_dataset("example");
    /// ```
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }
}

impl wkt::message::Message for AppendEventsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.AppendEventsRequest"
    }
}

/// Response for an AppendEvents RPC.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AppendEventsResponse {
    /// Dropped events; empty if all events are successfully added.
    pub dropped_events: std::vec::Vec<crate::model::Event>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AppendEventsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dropped_events][crate::model::AppendEventsResponse::dropped_events].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::AppendEventsResponse;
    /// use google_cloud_timeseriesinsights_v1::model::Event;
    /// let x = AppendEventsResponse::new()
    ///     .set_dropped_events([
    ///         Event::default()/* use setters */,
    ///         Event::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_dropped_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Event>,
    {
        use std::iter::Iterator;
        self.dropped_events = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AppendEventsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.AppendEventsResponse"
    }
}

/// Create a DataSet request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDataSetRequest {
    /// Required. Client project name which will own this DataSet in the format of
    /// 'projects/{project}'.
    pub parent: std::string::String,

    /// Required. Dataset to be loaded.
    pub dataset: std::option::Option<crate::model::DataSet>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDataSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDataSetRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::CreateDataSetRequest;
    /// let x = CreateDataSetRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::CreateDataSetRequest::dataset].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::CreateDataSetRequest;
    /// use google_cloud_timeseriesinsights_v1::model::DataSet;
    /// let x = CreateDataSetRequest::new().set_dataset(DataSet::default()/* use setters */);
    /// ```
    pub fn set_dataset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataSet>,
    {
        self.dataset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataset][crate::model::CreateDataSetRequest::dataset].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::CreateDataSetRequest;
    /// use google_cloud_timeseriesinsights_v1::model::DataSet;
    /// let x = CreateDataSetRequest::new().set_or_clear_dataset(Some(DataSet::default()/* use setters */));
    /// let x = CreateDataSetRequest::new().set_or_clear_dataset(None::<DataSet>);
    /// ```
    pub fn set_or_clear_dataset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataSet>,
    {
        self.dataset = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateDataSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.CreateDataSetRequest"
    }
}

/// Unload DataSet request from the serving system.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDataSetRequest {
    /// Required. Dataset name in the format of "projects/{project}/datasets/{dataset}"
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDataSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDataSetRequest::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::DeleteDataSetRequest;
    /// let x = DeleteDataSetRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDataSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.DeleteDataSetRequest"
    }
}

/// List the DataSets created by the current project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDataSetsRequest {
    /// Required. Project owning the DataSet in the format of "projects/{project}".
    pub parent: std::string::String,

    /// Number of results to return in the list.
    pub page_size: i32,

    /// Token to provide to skip to a particular spot in the list.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataSetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataSetsRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::ListDataSetsRequest;
    /// let x = ListDataSetsRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataSetsRequest::page_size].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::ListDataSetsRequest;
    /// let x = ListDataSetsRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataSetsRequest::page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::ListDataSetsRequest;
    /// let x = ListDataSetsRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDataSetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.ListDataSetsRequest"
    }
}

/// Created DataSets list response.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDataSetsResponse {
    /// The list of created DataSets.
    pub datasets: std::vec::Vec<crate::model::DataSet>,

    /// Token to receive the next page of results.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataSetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [datasets][crate::model::ListDataSetsResponse::datasets].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::ListDataSetsResponse;
    /// use google_cloud_timeseriesinsights_v1::model::DataSet;
    /// let x = ListDataSetsResponse::new()
    ///     .set_datasets([
    ///         DataSet::default()/* use setters */,
    ///         DataSet::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_datasets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataSet>,
    {
        use std::iter::Iterator;
        self.datasets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDataSetsResponse::next_page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::ListDataSetsResponse;
    /// let x = ListDataSetsResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDataSetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.ListDataSetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDataSetsResponse {
    type PageItem = crate::model::DataSet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.datasets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A categorical dimension fixed to a certain value.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PinnedDimension {
    /// The name of the dimension for which we are fixing its value.
    pub name: std::string::String,

    /// Dimension value.
    ///
    /// **NOTE**: The `value` type must match that in the data with the same
    /// `dimension` as name.
    pub value: std::option::Option<crate::model::pinned_dimension::Value>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PinnedDimension {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PinnedDimension::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::PinnedDimension;
    /// let x = PinnedDimension::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::PinnedDimension::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::PinnedDimension;
    /// use google_cloud_timeseriesinsights_v1::model::pinned_dimension::Value;
    /// let x = PinnedDimension::new().set_value(Some(Value::StringVal("example".to_string())));
    /// ```
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::pinned_dimension::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::PinnedDimension::value]
    /// if it holds a `StringVal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_val(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::pinned_dimension::Value::StringVal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::PinnedDimension::value]
    /// to hold a `StringVal`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::PinnedDimension;
    /// let x = PinnedDimension::new().set_string_val("example");
    /// assert!(x.string_val().is_some());
    /// assert!(x.bool_val().is_none());
    /// ```
    pub fn set_string_val<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::pinned_dimension::Value::StringVal(v.into()));
        self
    }

    /// The value of [value][crate::model::PinnedDimension::value]
    /// if it holds a `BoolVal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_val(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::pinned_dimension::Value::BoolVal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::PinnedDimension::value]
    /// to hold a `BoolVal`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::PinnedDimension;
    /// let x = PinnedDimension::new().set_bool_val(true);
    /// assert!(x.bool_val().is_some());
    /// assert!(x.string_val().is_none());
    /// ```
    pub fn set_bool_val<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::pinned_dimension::Value::BoolVal(v.into()));
        self
    }
}

impl wkt::message::Message for PinnedDimension {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.PinnedDimension"
    }
}

/// Defines additional types related to [PinnedDimension].
pub mod pinned_dimension {
    #[allow(unused_imports)]
    use super::*;

    /// Dimension value.
    ///
    /// **NOTE**: The `value` type must match that in the data with the same
    /// `dimension` as name.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Value {
        /// A string value. This can be used for [dimensions][google.cloud.timeseriesinsights.v1.EventDimension], which
        /// have their value field set to [string_val][google.cloud.timeseriesinsights.v1.EventDimension.string_val].
        ///
        /// [google.cloud.timeseriesinsights.v1.EventDimension]: crate::model::EventDimension
        /// [google.cloud.timeseriesinsights.v1.EventDimension.string_val]: crate::model::EventDimension::value
        StringVal(std::string::String),
        /// A bool value. This can be used for [dimensions][google.cloud.timeseriesinsights.v1.EventDimension], which
        /// have their value field set to [bool_val][google.cloud.timeseriesinsights.v1.EventDimension.bool_val].
        ///
        /// [google.cloud.timeseriesinsights.v1.EventDimension]: crate::model::EventDimension
        /// [google.cloud.timeseriesinsights.v1.EventDimension.bool_val]: crate::model::EventDimension::value
        BoolVal(bool),
    }
}

/// Parameters that control the sensitivity and other options for the time series
/// forecast.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ForecastParams {
    /// Optional. Penalize variations between the actual and forecasted values smaller than
    /// this. For more information about how this parameter affects the score, see
    /// the [anomalyScore](EvaluatedSlice.anomaly_score) formula.
    ///
    /// Intuitively, anomaly scores summarize how statistically significant the
    /// change between the actual and forecasted value is compared with what we
    /// expect the change to be (see
    /// [expectedDeviation](EvaluatedSlice.expected_deviation)). However, in
    /// practice, depending on the application, changes smaller than certain
    /// absolute values, while statistically significant, may not be important.
    ///
    /// This parameter allows us to penalize such low absolute value changes.
    ///
    /// Must be in the (0.0, inf) range.
    ///
    /// If unspecified, it defaults to 0.000001.
    pub noise_threshold: std::option::Option<f64>,

    /// Optional. Specifying any known seasonality/periodicity in the time series
    /// for the slices we will analyze can improve the quality of the results.
    ///
    /// If unsure, simply leave it unspecified by not setting a value for this
    /// field.
    ///
    /// If your time series has multiple seasonal patterns, then set it to the most
    /// granular one (e.g. if it has daily and weekly patterns, set this to DAILY).
    pub seasonality_hint: crate::model::forecast_params::Period,

    /// Optional. The length of the returned [forecasted
    /// timeseries][EvaluatedSlice.forecast].
    ///
    /// This duration is currently capped at 100 x
    /// [granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity].
    ///
    /// Example: If the detection point is set to "2020-12-27T00:00:00Z", the
    /// [granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity] to "3600s" and the
    /// horizon_duration to "10800s", then we will generate 3 time
    /// series points (from "2020-12-27T01:00:00Z" to "2020-12-27T04:00:00Z"), for
    /// which we will return their forecasted values.
    ///
    /// Note: The horizon time is only used for forecasting not for anormaly
    /// detection. To detect anomalies for multiple points of time,
    /// simply send multiple queries with those as
    /// [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time].
    ///
    /// [EvaluatedSlice.forecast]: crate::model::EvaluatedSlice::forecast
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]: crate::model::TimeseriesParams::granularity
    pub horizon_duration: std::option::Option<wkt::Duration>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ForecastParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [noise_threshold][crate::model::ForecastParams::noise_threshold].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::ForecastParams;
    /// let x = ForecastParams::new().set_noise_threshold(42.0);
    /// ```
    pub fn set_noise_threshold<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.noise_threshold = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [noise_threshold][crate::model::ForecastParams::noise_threshold].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::ForecastParams;
    /// let x = ForecastParams::new().set_or_clear_noise_threshold(Some(42.0));
    /// let x = ForecastParams::new().set_or_clear_noise_threshold(None::<f32>);
    /// ```
    pub fn set_or_clear_noise_threshold<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.noise_threshold = v.map(|x| x.into());
        self
    }

    /// Sets the value of [seasonality_hint][crate::model::ForecastParams::seasonality_hint].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::ForecastParams;
    /// use google_cloud_timeseriesinsights_v1::model::forecast_params::Period;
    /// let x0 = ForecastParams::new().set_seasonality_hint(Period::Hourly);
    /// let x1 = ForecastParams::new().set_seasonality_hint(Period::Daily);
    /// let x2 = ForecastParams::new().set_seasonality_hint(Period::Weekly);
    /// ```
    pub fn set_seasonality_hint<T: std::convert::Into<crate::model::forecast_params::Period>>(
        mut self,
        v: T,
    ) -> Self {
        self.seasonality_hint = v.into();
        self
    }

    /// Sets the value of [horizon_duration][crate::model::ForecastParams::horizon_duration].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::ForecastParams;
    /// use wkt::Duration;
    /// let x = ForecastParams::new().set_horizon_duration(Duration::default()/* use setters */);
    /// ```
    pub fn set_horizon_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.horizon_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [horizon_duration][crate::model::ForecastParams::horizon_duration].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::ForecastParams;
    /// use wkt::Duration;
    /// let x = ForecastParams::new().set_or_clear_horizon_duration(Some(Duration::default()/* use setters */));
    /// let x = ForecastParams::new().set_or_clear_horizon_duration(None::<Duration>);
    /// ```
    pub fn set_or_clear_horizon_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.horizon_duration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ForecastParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.ForecastParams"
    }
}

/// Defines additional types related to [ForecastParams].
pub mod forecast_params {
    #[allow(unused_imports)]
    use super::*;

    /// A time period of a fixed interval.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Period {
        /// Unknown or simply not given.
        Unspecified,
        /// 1 hour
        Hourly,
        /// 24 hours
        Daily,
        /// 7 days
        Weekly,
        /// 30 days
        Monthly,
        /// 365 days
        Yearly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Period::value] or
        /// [Period::name].
        UnknownValue(period::UnknownValue),
    }

    #[doc(hidden)]
    pub mod period {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Period {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Hourly => std::option::Option::Some(5),
                Self::Daily => std::option::Option::Some(1),
                Self::Weekly => std::option::Option::Some(2),
                Self::Monthly => std::option::Option::Some(3),
                Self::Yearly => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PERIOD_UNSPECIFIED"),
                Self::Hourly => std::option::Option::Some("HOURLY"),
                Self::Daily => std::option::Option::Some("DAILY"),
                Self::Weekly => std::option::Option::Some("WEEKLY"),
                Self::Monthly => std::option::Option::Some("MONTHLY"),
                Self::Yearly => std::option::Option::Some("YEARLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Period {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Period {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Period {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Daily,
                2 => Self::Weekly,
                3 => Self::Monthly,
                4 => Self::Yearly,
                5 => Self::Hourly,
                _ => Self::UnknownValue(period::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Period {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PERIOD_UNSPECIFIED" => Self::Unspecified,
                "HOURLY" => Self::Hourly,
                "DAILY" => Self::Daily,
                "WEEKLY" => Self::Weekly,
                "MONTHLY" => Self::Monthly,
                "YEARLY" => Self::Yearly,
                _ => Self::UnknownValue(period::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Period {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Hourly => serializer.serialize_i32(5),
                Self::Daily => serializer.serialize_i32(1),
                Self::Weekly => serializer.serialize_i32(2),
                Self::Monthly => serializer.serialize_i32(3),
                Self::Yearly => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Period {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Period>::new(
                ".google.cloud.timeseriesinsights.v1.ForecastParams.Period",
            ))
        }
    }
}

/// A point in a time series.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeseriesPoint {
    /// The timestamp of this point.
    pub time: std::option::Option<wkt::Timestamp>,

    /// The value for this point.
    ///
    /// It is computed by aggregating all events in the associated slice that are
    /// in the `[time, time + granularity]` range (see
    /// [granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]) using the specified
    /// [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric].
    ///
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]: crate::model::TimeseriesParams::granularity
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric]: crate::model::TimeseriesParams::metric
    pub value: std::option::Option<f64>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeseriesPoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time][crate::model::TimeseriesPoint::time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::TimeseriesPoint;
    /// use wkt::Timestamp;
    /// let x = TimeseriesPoint::new().set_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time][crate::model::TimeseriesPoint::time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::TimeseriesPoint;
    /// use wkt::Timestamp;
    /// let x = TimeseriesPoint::new().set_or_clear_time(Some(Timestamp::default()/* use setters */));
    /// let x = TimeseriesPoint::new().set_or_clear_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [value][crate::model::TimeseriesPoint::value].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::TimeseriesPoint;
    /// let x = TimeseriesPoint::new().set_value(42.0);
    /// ```
    pub fn set_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [value][crate::model::TimeseriesPoint::value].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::TimeseriesPoint;
    /// let x = TimeseriesPoint::new().set_or_clear_value(Some(42.0));
    /// let x = TimeseriesPoint::new().set_or_clear_value(None::<f32>);
    /// ```
    pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.value = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TimeseriesPoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.TimeseriesPoint"
    }
}

/// A time series.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Timeseries {
    /// The points in this time series, ordered by their timestamp.
    pub point: std::vec::Vec<crate::model::TimeseriesPoint>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Timeseries {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [point][crate::model::Timeseries::point].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::Timeseries;
    /// use google_cloud_timeseriesinsights_v1::model::TimeseriesPoint;
    /// let x = Timeseries::new()
    ///     .set_point([
    ///         TimeseriesPoint::default()/* use setters */,
    ///         TimeseriesPoint::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_point<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeseriesPoint>,
    {
        use std::iter::Iterator;
        self.point = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Timeseries {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.Timeseries"
    }
}

/// Forecast result for a given slice.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EvaluatedSlice {
    /// Values for all categorical dimensions that uniquely identify this slice.
    pub dimensions: std::vec::Vec<crate::model::PinnedDimension>,

    /// The actual value at the detection time (see
    /// [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]).
    ///
    /// **NOTE**: This value can be an estimate, so it should not be used as a
    /// source of truth.
    ///
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    pub detection_point_actual: std::option::Option<f64>,

    /// The expected value at the detection time, which is obtained by forecasting
    /// on the historical time series.
    pub detection_point_forecast: std::option::Option<f64>,

    /// How much our forecast model expects the detection point actual will
    /// deviate from its forecasted value based on how well it fit the input time
    /// series.
    ///
    /// In general, we expect the `detectionPointActual` to
    /// be in the `[detectionPointForecast - expectedDeviation,
    /// detectionPointForecast + expectedDeviation]` range. The more the actual
    /// value is outside this range, the more statistically significant the
    /// anomaly is.
    ///
    /// The expected deviation is always positive.
    pub expected_deviation: std::option::Option<f64>,

    /// Summarizes how significant the change between the actual and forecasted
    /// detection points are compared with the historical patterns observed on the
    /// [history][google.cloud.timeseriesinsights.v1.EvaluatedSlice.history] time series.
    ///
    /// Defined as *|a - f| / (e + nt)*, where:
    ///
    /// - *a* is the [detectionPointActual][google.cloud.timeseriesinsights.v1.EvaluatedSlice.detection_point_actual].
    /// - *f* is the [detectionPointForecast][google.cloud.timeseriesinsights.v1.EvaluatedSlice.detection_point_forecast].
    /// - *e* is the [expectedDeviation][google.cloud.timeseriesinsights.v1.EvaluatedSlice.expected_deviation].
    /// - *nt` is the [noiseThreshold][google.cloud.timeseriesinsights.v1.ForecastParams.noise_threshold].
    ///
    /// Anomaly scores between different requests and datasets are comparable. As
    /// a guideline, the risk of a slice being an anomaly based on the anomaly
    /// score is:
    ///
    /// - **Very High** if `anomalyScore` > 5.
    /// - **High** if the `anomalyScore` is in the [2, 5] range.
    /// - **Medium** if the `anomalyScore` is in the [1, 2) range.
    /// - **Low** if the `anomalyScore` is < 1.
    ///
    /// If there were issues evaluating this slice, then the anomaly score will be
    /// set to -1.0 and the [status][google.cloud.timeseriesinsights.v1.EvaluatedSlice.status] field will contain details on what
    /// went wrong.
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.detection_point_actual]: crate::model::EvaluatedSlice::detection_point_actual
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.detection_point_forecast]: crate::model::EvaluatedSlice::detection_point_forecast
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.expected_deviation]: crate::model::EvaluatedSlice::expected_deviation
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.history]: crate::model::EvaluatedSlice::history
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.status]: crate::model::EvaluatedSlice::status
    /// [google.cloud.timeseriesinsights.v1.ForecastParams.noise_threshold]: crate::model::ForecastParams::noise_threshold
    pub anomaly_score: std::option::Option<f64>,

    /// The actual values in the `[`
    /// [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] `-`
    /// [forecastHistory][google.cloud.timeseriesinsights.v1.TimeseriesParams.forecast_history]`,`
    /// [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] `]` time
    /// range.
    ///
    /// **NOTE**: This field is only populated if
    /// [returnTimeseries][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.return_timeseries] is true.
    ///
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.return_timeseries]: crate::model::QueryDataSetRequest::return_timeseries
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.forecast_history]: crate::model::TimeseriesParams::forecast_history
    pub history: std::option::Option<crate::model::Timeseries>,

    /// The forecasted values in the `[`
    /// [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] `+`
    /// [granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]`,`
    /// [forecastParams.horizonTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.forecast_params] `]` time
    /// range.
    ///
    /// **NOTE**: This field is only populated if
    /// [returnTimeseries][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.return_timeseries] is true.
    ///
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.forecast_params]: crate::model::QueryDataSetRequest::forecast_params
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.return_timeseries]: crate::model::QueryDataSetRequest::return_timeseries
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]: crate::model::TimeseriesParams::granularity
    pub forecast: std::option::Option<crate::model::Timeseries>,

    /// Evaluation status. Contains an error message if the `anomalyScore` is < 0.
    ///
    /// Possible error messages:
    ///
    /// - **"Time series too sparse"**: The returned time series for this slice did
    ///   not contain enough data points (we require a minimum of 10).
    /// - **"Not enough recent time series points"**: The time series contains the
    ///   minimum of 10 points, but there are not enough close in time to the
    ///   detection point.
    /// - **"Missing detection point data"**: There were not events to be
    ///   aggregated within the `[detectionTime, detectionTime + granularity]` time
    ///   interval, so we don't have an actual value with which we can compare our
    ///   prediction.
    /// - **"Data retrieval error"**: We failed to retrieve the time series data
    ///   for this slice and could not evaluate it successfully. Should be a
    ///   transient error.
    /// - **"Internal server error"**: Internal unexpected error.
    pub status: std::option::Option<rpc::model::Status>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EvaluatedSlice {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dimensions][crate::model::EvaluatedSlice::dimensions].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluatedSlice;
    /// use google_cloud_timeseriesinsights_v1::model::PinnedDimension;
    /// let x = EvaluatedSlice::new()
    ///     .set_dimensions([
    ///         PinnedDimension::default()/* use setters */,
    ///         PinnedDimension::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PinnedDimension>,
    {
        use std::iter::Iterator;
        self.dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [detection_point_actual][crate::model::EvaluatedSlice::detection_point_actual].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluatedSlice;
    /// let x = EvaluatedSlice::new().set_detection_point_actual(42.0);
    /// ```
    pub fn set_detection_point_actual<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.detection_point_actual = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [detection_point_actual][crate::model::EvaluatedSlice::detection_point_actual].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluatedSlice;
    /// let x = EvaluatedSlice::new().set_or_clear_detection_point_actual(Some(42.0));
    /// let x = EvaluatedSlice::new().set_or_clear_detection_point_actual(None::<f32>);
    /// ```
    pub fn set_or_clear_detection_point_actual<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.detection_point_actual = v.map(|x| x.into());
        self
    }

    /// Sets the value of [detection_point_forecast][crate::model::EvaluatedSlice::detection_point_forecast].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluatedSlice;
    /// let x = EvaluatedSlice::new().set_detection_point_forecast(42.0);
    /// ```
    pub fn set_detection_point_forecast<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.detection_point_forecast = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [detection_point_forecast][crate::model::EvaluatedSlice::detection_point_forecast].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluatedSlice;
    /// let x = EvaluatedSlice::new().set_or_clear_detection_point_forecast(Some(42.0));
    /// let x = EvaluatedSlice::new().set_or_clear_detection_point_forecast(None::<f32>);
    /// ```
    pub fn set_or_clear_detection_point_forecast<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.detection_point_forecast = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expected_deviation][crate::model::EvaluatedSlice::expected_deviation].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluatedSlice;
    /// let x = EvaluatedSlice::new().set_expected_deviation(42.0);
    /// ```
    pub fn set_expected_deviation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.expected_deviation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expected_deviation][crate::model::EvaluatedSlice::expected_deviation].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluatedSlice;
    /// let x = EvaluatedSlice::new().set_or_clear_expected_deviation(Some(42.0));
    /// let x = EvaluatedSlice::new().set_or_clear_expected_deviation(None::<f32>);
    /// ```
    pub fn set_or_clear_expected_deviation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.expected_deviation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [anomaly_score][crate::model::EvaluatedSlice::anomaly_score].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluatedSlice;
    /// let x = EvaluatedSlice::new().set_anomaly_score(42.0);
    /// ```
    pub fn set_anomaly_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.anomaly_score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [anomaly_score][crate::model::EvaluatedSlice::anomaly_score].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluatedSlice;
    /// let x = EvaluatedSlice::new().set_or_clear_anomaly_score(Some(42.0));
    /// let x = EvaluatedSlice::new().set_or_clear_anomaly_score(None::<f32>);
    /// ```
    pub fn set_or_clear_anomaly_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.anomaly_score = v.map(|x| x.into());
        self
    }

    /// Sets the value of [history][crate::model::EvaluatedSlice::history].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluatedSlice;
    /// use google_cloud_timeseriesinsights_v1::model::Timeseries;
    /// let x = EvaluatedSlice::new().set_history(Timeseries::default()/* use setters */);
    /// ```
    pub fn set_history<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Timeseries>,
    {
        self.history = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [history][crate::model::EvaluatedSlice::history].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluatedSlice;
    /// use google_cloud_timeseriesinsights_v1::model::Timeseries;
    /// let x = EvaluatedSlice::new().set_or_clear_history(Some(Timeseries::default()/* use setters */));
    /// let x = EvaluatedSlice::new().set_or_clear_history(None::<Timeseries>);
    /// ```
    pub fn set_or_clear_history<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Timeseries>,
    {
        self.history = v.map(|x| x.into());
        self
    }

    /// Sets the value of [forecast][crate::model::EvaluatedSlice::forecast].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluatedSlice;
    /// use google_cloud_timeseriesinsights_v1::model::Timeseries;
    /// let x = EvaluatedSlice::new().set_forecast(Timeseries::default()/* use setters */);
    /// ```
    pub fn set_forecast<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Timeseries>,
    {
        self.forecast = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [forecast][crate::model::EvaluatedSlice::forecast].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluatedSlice;
    /// use google_cloud_timeseriesinsights_v1::model::Timeseries;
    /// let x = EvaluatedSlice::new().set_or_clear_forecast(Some(Timeseries::default()/* use setters */));
    /// let x = EvaluatedSlice::new().set_or_clear_forecast(None::<Timeseries>);
    /// ```
    pub fn set_or_clear_forecast<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Timeseries>,
    {
        self.forecast = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::EvaluatedSlice::status].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluatedSlice;
    /// use rpc::model::Status;
    /// let x = EvaluatedSlice::new().set_status(Status::default()/* use setters */);
    /// ```
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::EvaluatedSlice::status].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluatedSlice;
    /// use rpc::model::Status;
    /// let x = EvaluatedSlice::new().set_or_clear_status(Some(Status::default()/* use setters */));
    /// let x = EvaluatedSlice::new().set_or_clear_status(None::<Status>);
    /// ```
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EvaluatedSlice {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.EvaluatedSlice"
    }
}

/// Parameters that control how we slice the dataset and, optionally, filter
/// slices that have some specific values on some dimensions (pinned dimensions).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SlicingParams {
    /// Required. Dimensions over which we will group the events in slices. The names
    /// specified here come from the
    /// [EventDimension.name][google.cloud.timeseriesinsights.v1.EventDimension.name] field. At least
    /// one dimension name must be specified. All dimension names that do not exist
    /// in the queried `DataSet` will be ignored.
    ///
    /// Currently only dimensions that hold string values can be specified here.
    ///
    /// [google.cloud.timeseriesinsights.v1.EventDimension.name]: crate::model::EventDimension::name
    pub dimension_names: std::vec::Vec<std::string::String>,

    /// Optional. We will only analyze slices for which
    /// [EvaluatedSlice.dimensions][google.cloud.timeseriesinsights.v1.EvaluatedSlice.dimensions] contain all of the
    /// following pinned dimensions. A query with a pinned dimension `{ name: "d3"
    /// stringVal: "v3" }` will only analyze events which contain the dimension `{
    /// name: "d3" stringVal: "v3" }`.
    /// The [pinnedDimensions][google.cloud.timeseriesinsights.v1.SlicingParams.pinned_dimensions] and
    /// [dimensionNames][google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names] fields can **not**
    /// share the same dimension names.
    ///
    /// Example a valid specification:
    ///
    /// ```norust
    /// {
    ///   dimensionNames: ["d1", "d2"],
    ///   pinnedDimensions: [
    ///     { name: "d3" stringVal: "v3" },
    ///     { name: "d4" stringVal: "v4" }
    ///   ]
    /// }
    /// ```
    ///
    /// In the previous example we will slice the dataset by dimensions "d1",
    /// "d2", "d3" and "d4", but we will only analyze slices for which "d3=v3" and
    /// "d4=v4".
    ///
    /// The following example is **invalid** as "d2" is present in both
    /// dimensionNames and pinnedDimensions:
    ///
    /// ```norust
    /// {
    ///   dimensionNames: ["d1", "d2"],
    ///   pinnedDimensions: [
    ///     { name: "d2" stringVal: "v2" },
    ///     { name: "d4" stringVal: "v4" }
    ///   ]
    /// }
    /// ```
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.dimensions]: crate::model::EvaluatedSlice::dimensions
    /// [google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names]: crate::model::SlicingParams::dimension_names
    /// [google.cloud.timeseriesinsights.v1.SlicingParams.pinned_dimensions]: crate::model::SlicingParams::pinned_dimensions
    pub pinned_dimensions: std::vec::Vec<crate::model::PinnedDimension>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SlicingParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dimension_names][crate::model::SlicingParams::dimension_names].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::SlicingParams;
    /// let x = SlicingParams::new().set_dimension_names(["a", "b", "c"]);
    /// ```
    pub fn set_dimension_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dimension_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pinned_dimensions][crate::model::SlicingParams::pinned_dimensions].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::SlicingParams;
    /// use google_cloud_timeseriesinsights_v1::model::PinnedDimension;
    /// let x = SlicingParams::new()
    ///     .set_pinned_dimensions([
    ///         PinnedDimension::default()/* use setters */,
    ///         PinnedDimension::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_pinned_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PinnedDimension>,
    {
        use std::iter::Iterator;
        self.pinned_dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SlicingParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.SlicingParams"
    }
}

/// Parameters that control how we construct the time series for each slice.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeseriesParams {
    /// Required. How long should we go in the past when fetching the timeline used for
    /// forecasting each slice.
    ///
    /// This is used in combination with the
    /// [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] parameter.
    /// The time series we construct will have the following time range:
    /// `[detectionTime - forecastHistory, detectionTime + granularity]`.
    ///
    /// The forecast history might be rounded up, so that a multiple of
    /// `granularity` is used to process the query.
    ///
    /// Note: If there are not enough events in the
    /// `[detectionTime - forecastHistory, detectionTime + granularity]` time
    /// interval, the slice evaluation can fail. For more information, see
    /// [EvaluatedSlice.status][google.cloud.timeseriesinsights.v1.EvaluatedSlice.status].
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.status]: crate::model::EvaluatedSlice::status
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    pub forecast_history: std::option::Option<wkt::Duration>,

    /// Required. The time granularity of the time series (on the x-axis). Each time series
    /// point starting at time T will aggregate all events for a particular slice
    /// in *[T, T + granularity)* time windows.
    ///
    /// Note: The aggregation is decided based on the
    /// [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] parameter.
    ///
    /// This granularity defines the query-time aggregation windows and is not
    /// necessarily related to any event time granularity in the raw data (though
    /// we do recommend that the query-time granularity is not finer than the
    /// ingestion-time one).
    ///
    /// Currently, the minimal supported granularity is 10 seconds.
    ///
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric]: crate::model::TimeseriesParams::metric
    pub granularity: std::option::Option<wkt::Duration>,

    /// Optional. Denotes the [name][google.cloud.timeseriesinsights.v1.EventDimension.name] of a numerical
    /// dimension that will have its values aggregated to compute the y-axis of the
    /// time series.
    ///
    /// The aggregation method must also be specified by setting the
    /// [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
    /// field.
    ///
    /// Note: Currently, if the aggregation method is unspecified, we will
    /// default to SUM for backward compatibility reasons, but new implementations
    /// should set the
    /// [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
    /// explicitly.
    ///
    /// If the metric is unspecified, we will use the number of events that each
    /// time series point contains as the point value.
    ///
    /// Example: Let's assume we have the following three events in our dataset:
    ///
    /// ```norust
    /// {
    ///   eventTime: "2020-12-27T00:00:00Z",
    ///   dimensions: [
    ///     { name: "d1" stringVal: "v1" },
    ///     { name: "d2" stringVal: "v2" }
    ///     { name: "m1" longVal: 100 }
    ///     { name: "m2" longVal: 11 }
    ///   ]
    /// },
    /// {
    ///   eventTime: "2020-12-27T00:10:00Z",
    ///   dimensions: [
    ///     { name: "d1" stringVal: "v1" },
    ///     { name: "d2" stringVal: "v2" }
    ///     { name: "m1" longVal: 200 }
    ///     { name: "m2" longVal: 22 }
    ///   ]
    /// },
    /// {
    ///   eventTime: "2020-12-27T00:20:00Z",
    ///   dimensions: [
    ///     { name: "d1" stringVal: "v1" },
    ///     { name: "d2" stringVal: "v2" }
    ///     { name: "m1" longVal: 300 }
    ///     { name: "m2" longVal: 33 }
    ///   ]
    /// }
    /// ```
    ///
    /// These events are all within the same hour, spaced 10 minutes between each
    /// of them. Assuming our [QueryDataSetRequest][google.cloud.timeseriesinsights.v1.QueryDataSetRequest] had set
    /// [slicingParams.dimensionNames][google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names] to ["d1",
    /// "d2"] and [timeseries_params.granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity] to
    /// "3600s", then all the previous events will be aggregated into the same
    /// [timeseries point][google.cloud.timeseriesinsights.v1.TimeseriesPoint].
    ///
    /// The time series point that they're all part of will have the
    /// [time][google.cloud.timeseriesinsights.v1.TimeseriesPoint.time] set to "2020-12-27T00:00:00Z" and the
    /// [value][google.cloud.timeseriesinsights.v1.TimeseriesPoint.value] populated based on this metric field:
    ///
    /// - If the metric is set to "m1" and metric_aggregation_method to SUM, then
    ///   the value of the point will be 600.
    /// - If the metric is set to "m2" and metric_aggregation_method to SUM, then
    ///   the value of the point will be 66.
    /// - If the metric is set to "m1" and metric_aggregation_method to AVERAGE,
    ///   then the value of the point will be 200.
    /// - If the metric is set to "m2" and metric_aggregation_method to AVERAGE,
    ///   then the value of the point will be 22.
    /// - If the metric field is "" or unspecified, then the value of the point
    ///   will be 3, as we will simply count the events.
    ///
    /// [google.cloud.timeseriesinsights.v1.EventDimension.name]: crate::model::EventDimension::name
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest]: crate::model::QueryDataSetRequest
    /// [google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names]: crate::model::SlicingParams::dimension_names
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]: crate::model::TimeseriesParams::granularity
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]: crate::model::TimeseriesParams::metric_aggregation_method
    /// [google.cloud.timeseriesinsights.v1.TimeseriesPoint]: crate::model::TimeseriesPoint
    /// [google.cloud.timeseriesinsights.v1.TimeseriesPoint.time]: crate::model::TimeseriesPoint::time
    /// [google.cloud.timeseriesinsights.v1.TimeseriesPoint.value]: crate::model::TimeseriesPoint::value
    pub metric: std::option::Option<std::string::String>,

    /// Optional. Together with the [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] field, specifies how
    /// we will aggregate multiple events to obtain the value of a time series
    /// point. See the [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] documentation for more
    /// details.
    ///
    /// If the metric is not specified or "", then this field will be ignored.
    ///
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric]: crate::model::TimeseriesParams::metric
    pub metric_aggregation_method: crate::model::timeseries_params::AggregationMethod,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeseriesParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [forecast_history][crate::model::TimeseriesParams::forecast_history].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::TimeseriesParams;
    /// use wkt::Duration;
    /// let x = TimeseriesParams::new().set_forecast_history(Duration::default()/* use setters */);
    /// ```
    pub fn set_forecast_history<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.forecast_history = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [forecast_history][crate::model::TimeseriesParams::forecast_history].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::TimeseriesParams;
    /// use wkt::Duration;
    /// let x = TimeseriesParams::new().set_or_clear_forecast_history(Some(Duration::default()/* use setters */));
    /// let x = TimeseriesParams::new().set_or_clear_forecast_history(None::<Duration>);
    /// ```
    pub fn set_or_clear_forecast_history<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.forecast_history = v.map(|x| x.into());
        self
    }

    /// Sets the value of [granularity][crate::model::TimeseriesParams::granularity].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::TimeseriesParams;
    /// use wkt::Duration;
    /// let x = TimeseriesParams::new().set_granularity(Duration::default()/* use setters */);
    /// ```
    pub fn set_granularity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.granularity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [granularity][crate::model::TimeseriesParams::granularity].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::TimeseriesParams;
    /// use wkt::Duration;
    /// let x = TimeseriesParams::new().set_or_clear_granularity(Some(Duration::default()/* use setters */));
    /// let x = TimeseriesParams::new().set_or_clear_granularity(None::<Duration>);
    /// ```
    pub fn set_or_clear_granularity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.granularity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metric][crate::model::TimeseriesParams::metric].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::TimeseriesParams;
    /// let x = TimeseriesParams::new().set_metric("example");
    /// ```
    pub fn set_metric<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.metric = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metric][crate::model::TimeseriesParams::metric].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::TimeseriesParams;
    /// let x = TimeseriesParams::new().set_or_clear_metric(Some("example"));
    /// let x = TimeseriesParams::new().set_or_clear_metric(None::<String>);
    /// ```
    pub fn set_or_clear_metric<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.metric = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metric_aggregation_method][crate::model::TimeseriesParams::metric_aggregation_method].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::TimeseriesParams;
    /// use google_cloud_timeseriesinsights_v1::model::timeseries_params::AggregationMethod;
    /// let x0 = TimeseriesParams::new().set_metric_aggregation_method(AggregationMethod::Sum);
    /// let x1 = TimeseriesParams::new().set_metric_aggregation_method(AggregationMethod::Average);
    /// ```
    pub fn set_metric_aggregation_method<
        T: std::convert::Into<crate::model::timeseries_params::AggregationMethod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_aggregation_method = v.into();
        self
    }
}

impl wkt::message::Message for TimeseriesParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.TimeseriesParams"
    }
}

/// Defines additional types related to [TimeseriesParams].
pub mod timeseries_params {
    #[allow(unused_imports)]
    use super::*;

    /// Methods by which we can aggregate multiple events by a given
    /// [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric].
    ///
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric]: crate::model::TimeseriesParams::metric
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AggregationMethod {
        /// Unspecified.
        Unspecified,
        /// Aggregate multiple events by summing up the values found in the
        /// [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] dimension.
        ///
        /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric]: crate::model::TimeseriesParams::metric
        Sum,
        /// Aggregate multiple events by averaging out the values found in the
        /// [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] dimension.
        ///
        /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric]: crate::model::TimeseriesParams::metric
        Average,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AggregationMethod::value] or
        /// [AggregationMethod::name].
        UnknownValue(aggregation_method::UnknownValue),
    }

    #[doc(hidden)]
    pub mod aggregation_method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AggregationMethod {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Sum => std::option::Option::Some(1),
                Self::Average => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AGGREGATION_METHOD_UNSPECIFIED"),
                Self::Sum => std::option::Option::Some("SUM"),
                Self::Average => std::option::Option::Some("AVERAGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AggregationMethod {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AggregationMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AggregationMethod {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Sum,
                2 => Self::Average,
                _ => Self::UnknownValue(aggregation_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AggregationMethod {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AGGREGATION_METHOD_UNSPECIFIED" => Self::Unspecified,
                "SUM" => Self::Sum,
                "AVERAGE" => Self::Average,
                _ => Self::UnknownValue(aggregation_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AggregationMethod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Sum => serializer.serialize_i32(1),
                Self::Average => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AggregationMethod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AggregationMethod>::new(
                ".google.cloud.timeseriesinsights.v1.TimeseriesParams.AggregationMethod",
            ))
        }
    }
}

/// Request for performing a query against a loaded DataSet.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryDataSetRequest {
    /// Required. Loaded DataSet to be queried in the format of
    /// "projects/{project}/datasets/{dataset}"
    pub name: std::string::String,

    /// Required. This is the point in time that we want to probe for anomalies.
    ///
    /// The corresponding [TimeseriesPoint][google.cloud.timeseriesinsights.v1.TimeseriesPoint] is referred to as the
    /// detection point.
    ///
    /// **NOTE**: As with any other time series point, the value is given by
    /// aggregating all events in the slice that are in the
    /// [detectionTime, detectionTime + granularity) time interval, where
    /// the granularity is specified in the
    /// [timeseriesParams.granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity] field.
    ///
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]: crate::model::TimeseriesParams::granularity
    /// [google.cloud.timeseriesinsights.v1.TimeseriesPoint]: crate::model::TimeseriesPoint
    pub detection_time: std::option::Option<wkt::Timestamp>,

    /// How many slices are returned in
    /// [QueryDataSetResponse.slices][google.cloud.timeseriesinsights.v1.QueryDataSetResponse.slices].
    ///
    /// The returned slices are tentatively the ones with the highest
    /// [anomaly scores][google.cloud.timeseriesinsights.v1.EvaluatedSlice.anomaly_score] in the dataset that match
    /// the query, but it is not guaranteed.
    ///
    /// Reducing this number will improve query performance, both in terms of
    /// latency and resource usage.
    ///
    /// Defaults to 50.
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.anomaly_score]: crate::model::EvaluatedSlice::anomaly_score
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetResponse.slices]: crate::model::QueryDataSetResponse::slices
    pub num_returned_slices: std::option::Option<i32>,

    /// Parameters controlling how we will split the dataset into the slices that
    /// we will analyze.
    pub slicing_params: std::option::Option<crate::model::SlicingParams>,

    /// Parameters controlling how we will build the time series used to predict
    /// the [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] value for each slice.
    ///
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    pub timeseries_params: std::option::Option<crate::model::TimeseriesParams>,

    /// Parameters that control the time series forecasting models, such as the
    /// sensitivity of the anomaly detection.
    pub forecast_params: std::option::Option<crate::model::ForecastParams>,

    /// If specified, we will return the actual and forecasted time for all
    /// returned slices.
    ///
    /// The time series are returned in the
    /// [EvaluatedSlice.history][google.cloud.timeseriesinsights.v1.EvaluatedSlice.history] and
    /// [EvaluatedSlice.forecast][google.cloud.timeseriesinsights.v1.EvaluatedSlice.forecast] fields.
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.forecast]: crate::model::EvaluatedSlice::forecast
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.history]: crate::model::EvaluatedSlice::history
    pub return_timeseries: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryDataSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QueryDataSetRequest::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::QueryDataSetRequest;
    /// let x = QueryDataSetRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [detection_time][crate::model::QueryDataSetRequest::detection_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::QueryDataSetRequest;
    /// use wkt::Timestamp;
    /// let x = QueryDataSetRequest::new().set_detection_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_detection_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.detection_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [detection_time][crate::model::QueryDataSetRequest::detection_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::QueryDataSetRequest;
    /// use wkt::Timestamp;
    /// let x = QueryDataSetRequest::new().set_or_clear_detection_time(Some(Timestamp::default()/* use setters */));
    /// let x = QueryDataSetRequest::new().set_or_clear_detection_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_detection_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.detection_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [num_returned_slices][crate::model::QueryDataSetRequest::num_returned_slices].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::QueryDataSetRequest;
    /// let x = QueryDataSetRequest::new().set_num_returned_slices(42);
    /// ```
    pub fn set_num_returned_slices<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.num_returned_slices = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [num_returned_slices][crate::model::QueryDataSetRequest::num_returned_slices].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::QueryDataSetRequest;
    /// let x = QueryDataSetRequest::new().set_or_clear_num_returned_slices(Some(42));
    /// let x = QueryDataSetRequest::new().set_or_clear_num_returned_slices(None::<i32>);
    /// ```
    pub fn set_or_clear_num_returned_slices<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.num_returned_slices = v.map(|x| x.into());
        self
    }

    /// Sets the value of [slicing_params][crate::model::QueryDataSetRequest::slicing_params].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::QueryDataSetRequest;
    /// use google_cloud_timeseriesinsights_v1::model::SlicingParams;
    /// let x = QueryDataSetRequest::new().set_slicing_params(SlicingParams::default()/* use setters */);
    /// ```
    pub fn set_slicing_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SlicingParams>,
    {
        self.slicing_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [slicing_params][crate::model::QueryDataSetRequest::slicing_params].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::QueryDataSetRequest;
    /// use google_cloud_timeseriesinsights_v1::model::SlicingParams;
    /// let x = QueryDataSetRequest::new().set_or_clear_slicing_params(Some(SlicingParams::default()/* use setters */));
    /// let x = QueryDataSetRequest::new().set_or_clear_slicing_params(None::<SlicingParams>);
    /// ```
    pub fn set_or_clear_slicing_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SlicingParams>,
    {
        self.slicing_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timeseries_params][crate::model::QueryDataSetRequest::timeseries_params].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::QueryDataSetRequest;
    /// use google_cloud_timeseriesinsights_v1::model::TimeseriesParams;
    /// let x = QueryDataSetRequest::new().set_timeseries_params(TimeseriesParams::default()/* use setters */);
    /// ```
    pub fn set_timeseries_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeseriesParams>,
    {
        self.timeseries_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeseries_params][crate::model::QueryDataSetRequest::timeseries_params].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::QueryDataSetRequest;
    /// use google_cloud_timeseriesinsights_v1::model::TimeseriesParams;
    /// let x = QueryDataSetRequest::new().set_or_clear_timeseries_params(Some(TimeseriesParams::default()/* use setters */));
    /// let x = QueryDataSetRequest::new().set_or_clear_timeseries_params(None::<TimeseriesParams>);
    /// ```
    pub fn set_or_clear_timeseries_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeseriesParams>,
    {
        self.timeseries_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [forecast_params][crate::model::QueryDataSetRequest::forecast_params].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::QueryDataSetRequest;
    /// use google_cloud_timeseriesinsights_v1::model::ForecastParams;
    /// let x = QueryDataSetRequest::new().set_forecast_params(ForecastParams::default()/* use setters */);
    /// ```
    pub fn set_forecast_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ForecastParams>,
    {
        self.forecast_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [forecast_params][crate::model::QueryDataSetRequest::forecast_params].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::QueryDataSetRequest;
    /// use google_cloud_timeseriesinsights_v1::model::ForecastParams;
    /// let x = QueryDataSetRequest::new().set_or_clear_forecast_params(Some(ForecastParams::default()/* use setters */));
    /// let x = QueryDataSetRequest::new().set_or_clear_forecast_params(None::<ForecastParams>);
    /// ```
    pub fn set_or_clear_forecast_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ForecastParams>,
    {
        self.forecast_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [return_timeseries][crate::model::QueryDataSetRequest::return_timeseries].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::QueryDataSetRequest;
    /// let x = QueryDataSetRequest::new().set_return_timeseries(true);
    /// ```
    pub fn set_return_timeseries<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.return_timeseries = v.into();
        self
    }
}

impl wkt::message::Message for QueryDataSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.QueryDataSetRequest"
    }
}

/// Response for a query executed by the system.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryDataSetResponse {
    /// Loaded DataSet that was queried.
    pub name: std::string::String,

    /// Slices sorted in descending order by their
    /// [anomalyScore][google.cloud.timeseriesinsights.v1.EvaluatedSlice.anomaly_score].
    ///
    /// At most [numReturnedSlices][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.num_returned_slices]
    /// slices are present in this field.
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.anomaly_score]: crate::model::EvaluatedSlice::anomaly_score
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.num_returned_slices]: crate::model::QueryDataSetRequest::num_returned_slices
    pub slices: std::vec::Vec<crate::model::EvaluatedSlice>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryDataSetResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QueryDataSetResponse::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::QueryDataSetResponse;
    /// let x = QueryDataSetResponse::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [slices][crate::model::QueryDataSetResponse::slices].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::QueryDataSetResponse;
    /// use google_cloud_timeseriesinsights_v1::model::EvaluatedSlice;
    /// let x = QueryDataSetResponse::new()
    ///     .set_slices([
    ///         EvaluatedSlice::default()/* use setters */,
    ///         EvaluatedSlice::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_slices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EvaluatedSlice>,
    {
        use std::iter::Iterator;
        self.slices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for QueryDataSetResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.QueryDataSetResponse"
    }
}

/// Request for evaluateSlice.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EvaluateSliceRequest {
    /// Required. Loaded DataSet to be queried in the format of
    /// "projects/{project}/datasets/{dataset}"
    pub dataset: std::string::String,

    /// Required. Dimensions with pinned values that specify the slice for which we will
    /// fetch the time series.
    pub pinned_dimensions: std::vec::Vec<crate::model::PinnedDimension>,

    /// Required. This is the point in time that we want to probe for anomalies.
    ///
    /// See documentation for
    /// [QueryDataSetRequest.detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time].
    ///
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    pub detection_time: std::option::Option<wkt::Timestamp>,

    /// Parameters controlling how we will build the time series used to predict
    /// the [detectionTime][google.cloud.timeseriesinsights.v1.EvaluateSliceRequest.detection_time] value for this slice.
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluateSliceRequest.detection_time]: crate::model::EvaluateSliceRequest::detection_time
    pub timeseries_params: std::option::Option<crate::model::TimeseriesParams>,

    /// Parameters that control the time series forecasting models, such as the
    /// sensitivity of the anomaly detection.
    pub forecast_params: std::option::Option<crate::model::ForecastParams>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EvaluateSliceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::EvaluateSliceRequest::dataset].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluateSliceRequest;
    /// let x = EvaluateSliceRequest::new().set_dataset("example");
    /// ```
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [pinned_dimensions][crate::model::EvaluateSliceRequest::pinned_dimensions].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluateSliceRequest;
    /// use google_cloud_timeseriesinsights_v1::model::PinnedDimension;
    /// let x = EvaluateSliceRequest::new()
    ///     .set_pinned_dimensions([
    ///         PinnedDimension::default()/* use setters */,
    ///         PinnedDimension::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_pinned_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PinnedDimension>,
    {
        use std::iter::Iterator;
        self.pinned_dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [detection_time][crate::model::EvaluateSliceRequest::detection_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluateSliceRequest;
    /// use wkt::Timestamp;
    /// let x = EvaluateSliceRequest::new().set_detection_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_detection_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.detection_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [detection_time][crate::model::EvaluateSliceRequest::detection_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluateSliceRequest;
    /// use wkt::Timestamp;
    /// let x = EvaluateSliceRequest::new().set_or_clear_detection_time(Some(Timestamp::default()/* use setters */));
    /// let x = EvaluateSliceRequest::new().set_or_clear_detection_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_detection_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.detection_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timeseries_params][crate::model::EvaluateSliceRequest::timeseries_params].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluateSliceRequest;
    /// use google_cloud_timeseriesinsights_v1::model::TimeseriesParams;
    /// let x = EvaluateSliceRequest::new().set_timeseries_params(TimeseriesParams::default()/* use setters */);
    /// ```
    pub fn set_timeseries_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeseriesParams>,
    {
        self.timeseries_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeseries_params][crate::model::EvaluateSliceRequest::timeseries_params].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluateSliceRequest;
    /// use google_cloud_timeseriesinsights_v1::model::TimeseriesParams;
    /// let x = EvaluateSliceRequest::new().set_or_clear_timeseries_params(Some(TimeseriesParams::default()/* use setters */));
    /// let x = EvaluateSliceRequest::new().set_or_clear_timeseries_params(None::<TimeseriesParams>);
    /// ```
    pub fn set_or_clear_timeseries_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeseriesParams>,
    {
        self.timeseries_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [forecast_params][crate::model::EvaluateSliceRequest::forecast_params].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluateSliceRequest;
    /// use google_cloud_timeseriesinsights_v1::model::ForecastParams;
    /// let x = EvaluateSliceRequest::new().set_forecast_params(ForecastParams::default()/* use setters */);
    /// ```
    pub fn set_forecast_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ForecastParams>,
    {
        self.forecast_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [forecast_params][crate::model::EvaluateSliceRequest::forecast_params].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluateSliceRequest;
    /// use google_cloud_timeseriesinsights_v1::model::ForecastParams;
    /// let x = EvaluateSliceRequest::new().set_or_clear_forecast_params(Some(ForecastParams::default()/* use setters */));
    /// let x = EvaluateSliceRequest::new().set_or_clear_forecast_params(None::<ForecastParams>);
    /// ```
    pub fn set_or_clear_forecast_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ForecastParams>,
    {
        self.forecast_params = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EvaluateSliceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.EvaluateSliceRequest"
    }
}

/// Request for evaluateTimeseries.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EvaluateTimeseriesRequest {
    /// Required. Client project name in the format of 'projects/{project}'.
    pub parent: std::string::String,

    /// Evaluate this time series without requiring it was previously loaded in
    /// a data set.
    ///
    /// The evaluated time series point is the last one, analogous to calling
    /// evaluateSlice or query with
    /// [detectionTime][google.cloud.timeseriesinsights.v1.EvaluateSliceRequest.detection_time] set to
    /// `timeseries.point(timeseries.point_size() - 1).time`.
    ///
    /// The length of the time series must be at least 10.
    ///
    /// All points must have the same time offset relative to the granularity. For
    /// example, if the [granularity][google.cloud.timeseriesinsights.v1.EvaluateTimeseriesRequest.granularity] is "5s", then the following
    /// point.time sequences are valid:
    ///
    /// - "100s", "105s", "120s", "125s" (no offset)
    /// - "102s", "107s", "122s", "127s" (offset is "2s")
    ///   However, the following sequence is invalid as it has inconsistent offsets:
    /// - "100s", "105s", "122s", "127s" (offsets are either "0s" or "2s")
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluateSliceRequest.detection_time]: crate::model::EvaluateSliceRequest::detection_time
    /// [google.cloud.timeseriesinsights.v1.EvaluateTimeseriesRequest.granularity]: crate::model::EvaluateTimeseriesRequest::granularity
    pub timeseries: std::option::Option<crate::model::Timeseries>,

    /// The granularity of the time series (time distance between two consecutive
    /// points).
    pub granularity: std::option::Option<wkt::Duration>,

    /// The forecast parameters.
    pub forecast_params: std::option::Option<crate::model::ForecastParams>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EvaluateTimeseriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::EvaluateTimeseriesRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluateTimeseriesRequest;
    /// let x = EvaluateTimeseriesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [timeseries][crate::model::EvaluateTimeseriesRequest::timeseries].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluateTimeseriesRequest;
    /// use google_cloud_timeseriesinsights_v1::model::Timeseries;
    /// let x = EvaluateTimeseriesRequest::new().set_timeseries(Timeseries::default()/* use setters */);
    /// ```
    pub fn set_timeseries<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Timeseries>,
    {
        self.timeseries = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeseries][crate::model::EvaluateTimeseriesRequest::timeseries].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluateTimeseriesRequest;
    /// use google_cloud_timeseriesinsights_v1::model::Timeseries;
    /// let x = EvaluateTimeseriesRequest::new().set_or_clear_timeseries(Some(Timeseries::default()/* use setters */));
    /// let x = EvaluateTimeseriesRequest::new().set_or_clear_timeseries(None::<Timeseries>);
    /// ```
    pub fn set_or_clear_timeseries<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Timeseries>,
    {
        self.timeseries = v.map(|x| x.into());
        self
    }

    /// Sets the value of [granularity][crate::model::EvaluateTimeseriesRequest::granularity].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluateTimeseriesRequest;
    /// use wkt::Duration;
    /// let x = EvaluateTimeseriesRequest::new().set_granularity(Duration::default()/* use setters */);
    /// ```
    pub fn set_granularity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.granularity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [granularity][crate::model::EvaluateTimeseriesRequest::granularity].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluateTimeseriesRequest;
    /// use wkt::Duration;
    /// let x = EvaluateTimeseriesRequest::new().set_or_clear_granularity(Some(Duration::default()/* use setters */));
    /// let x = EvaluateTimeseriesRequest::new().set_or_clear_granularity(None::<Duration>);
    /// ```
    pub fn set_or_clear_granularity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.granularity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [forecast_params][crate::model::EvaluateTimeseriesRequest::forecast_params].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluateTimeseriesRequest;
    /// use google_cloud_timeseriesinsights_v1::model::ForecastParams;
    /// let x = EvaluateTimeseriesRequest::new().set_forecast_params(ForecastParams::default()/* use setters */);
    /// ```
    pub fn set_forecast_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ForecastParams>,
    {
        self.forecast_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [forecast_params][crate::model::EvaluateTimeseriesRequest::forecast_params].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_timeseriesinsights_v1::model::EvaluateTimeseriesRequest;
    /// use google_cloud_timeseriesinsights_v1::model::ForecastParams;
    /// let x = EvaluateTimeseriesRequest::new().set_or_clear_forecast_params(Some(ForecastParams::default()/* use setters */));
    /// let x = EvaluateTimeseriesRequest::new().set_or_clear_forecast_params(None::<ForecastParams>);
    /// ```
    pub fn set_or_clear_forecast_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ForecastParams>,
    {
        self.forecast_params = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EvaluateTimeseriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.EvaluateTimeseriesRequest"
    }
}
