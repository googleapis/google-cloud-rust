// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Mapping of BigQuery columns to timestamp, group_id and dimensions.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigqueryMapping {
    /// The column which should be used as the event timestamps. If not specified
    /// 'Timestamp' is used by default. The column may have TIMESTAMP or INT64
    /// type (the latter is interpreted as microseconds since the Unix epoch).
    pub timestamp_column: std::string::String,

    /// The column which should be used as the group ID (grouping events into
    /// sessions). If not specified 'GroupId' is used by default, if the input
    /// table does not have such a column, random unique group IDs are
    /// generated automatically (different group ID per input row).
    pub group_id_column: std::string::String,

    /// The list of columns that should be translated to dimensions. If empty,
    /// all columns are translated to dimensions. The timestamp and group_id
    /// columns should not be listed here again. Columns are expected to have
    /// primitive types (STRING, INT64, FLOAT64 or NUMERIC).
    pub dimension_column: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigqueryMapping {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [timestamp_column][crate::model::BigqueryMapping::timestamp_column].
    pub fn set_timestamp_column<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.timestamp_column = v.into();
        self
    }

    /// Sets the value of [group_id_column][crate::model::BigqueryMapping::group_id_column].
    pub fn set_group_id_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group_id_column = v.into();
        self
    }

    /// Sets the value of [dimension_column][crate::model::BigqueryMapping::dimension_column].
    pub fn set_dimension_column<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dimension_column = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BigqueryMapping {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.BigqueryMapping"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigqueryMapping {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __timestamp_column,
            __group_id_column,
            __dimension_column,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigqueryMapping")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timestampColumn" => Ok(__FieldTag::__timestamp_column),
                            "timestamp_column" => Ok(__FieldTag::__timestamp_column),
                            "groupIdColumn" => Ok(__FieldTag::__group_id_column),
                            "group_id_column" => Ok(__FieldTag::__group_id_column),
                            "dimensionColumn" => Ok(__FieldTag::__dimension_column),
                            "dimension_column" => Ok(__FieldTag::__dimension_column),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigqueryMapping;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigqueryMapping")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__timestamp_column => {
                            if !fields.insert(__FieldTag::__timestamp_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timestamp_column",
                                ));
                            }
                            result.timestamp_column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__group_id_column => {
                            if !fields.insert(__FieldTag::__group_id_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_id_column",
                                ));
                            }
                            result.group_id_column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dimension_column => {
                            if !fields.insert(__FieldTag::__dimension_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dimension_column",
                                ));
                            }
                            result.dimension_column = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigqueryMapping {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.timestamp_column.is_empty() {
            state.serialize_entry("timestampColumn", &self.timestamp_column)?;
        }
        if !self.group_id_column.is_empty() {
            state.serialize_entry("groupIdColumn", &self.group_id_column)?;
        }
        if !self.dimension_column.is_empty() {
            state.serialize_entry("dimensionColumn", &self.dimension_column)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A data source consists of multiple [Event][google.cloud.timeseriesinsights.v1.Event] objects stored on
/// Cloud Storage.  Each Event should be in JSON format, with one Event
/// per line, also known as JSON Lines format.
///
/// [google.cloud.timeseriesinsights.v1.Event]: crate::model::Event
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataSource {
    /// Data source URI.
    ///
    /// 1. Google Cloud Storage files (JSON) are defined in the following form.
    ///    `gs://bucket_name/object_name`. For more information on Cloud Storage URIs,
    ///    please see <https://cloud.google.com/storage/docs/reference-uris>.
    pub uri: std::string::String,

    /// For BigQuery inputs defines the columns that should be used for dimensions
    /// (including time and group ID).
    pub bq_mapping: std::option::Option<crate::model::BigqueryMapping>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::DataSource::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [bq_mapping][crate::model::DataSource::bq_mapping].
    pub fn set_bq_mapping<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigqueryMapping>,
    {
        self.bq_mapping = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bq_mapping][crate::model::DataSource::bq_mapping].
    pub fn set_or_clear_bq_mapping<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigqueryMapping>,
    {
        self.bq_mapping = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.DataSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __bq_mapping,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "bqMapping" => Ok(__FieldTag::__bq_mapping),
                            "bq_mapping" => Ok(__FieldTag::__bq_mapping),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bq_mapping => {
                            if !fields.insert(__FieldTag::__bq_mapping) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bq_mapping",
                                ));
                            }
                            result.bq_mapping = map
                                .next_value::<std::option::Option<crate::model::BigqueryMapping>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if self.bq_mapping.is_some() {
            state.serialize_entry("bqMapping", &self.bq_mapping)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A collection of data sources sent for processing.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataSet {
    /// The dataset name, which will be used for querying, status and unload
    /// requests. This must be unique within a project.
    pub name: std::string::String,

    /// [Data dimension names][google.cloud.timeseriesinsights.v1.EventDimension.name] allowed for this `DataSet`.
    ///
    /// If left empty, all dimension names are included. This field works as a
    /// filter to avoid regenerating the data.
    ///
    /// [google.cloud.timeseriesinsights.v1.EventDimension.name]: crate::model::EventDimension::name
    pub data_names: std::vec::Vec<std::string::String>,

    /// Input data.
    pub data_sources: std::vec::Vec<crate::model::DataSource>,

    /// Dataset state in the system.
    pub state: crate::model::data_set::State,

    /// Dataset processing status.
    pub status: std::option::Option<rpc::model::Status>,

    /// Periodically we discard dataset [Event][google.cloud.timeseriesinsights.v1.Event] objects that have
    /// timestamps older than 'ttl'.  Omitting this field or a zero value means no
    /// events are discarded.
    ///
    /// [google.cloud.timeseriesinsights.v1.Event]: crate::model::Event
    pub ttl: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataSet::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data_names][crate::model::DataSet::data_names].
    pub fn set_data_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_sources][crate::model::DataSet::data_sources].
    pub fn set_data_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataSource>,
    {
        use std::iter::Iterator;
        self.data_sources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::DataSet::state].
    pub fn set_state<T: std::convert::Into<crate::model::data_set::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [status][crate::model::DataSet::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::DataSet::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ttl][crate::model::DataSet::ttl].
    pub fn set_ttl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ttl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ttl][crate::model::DataSet::ttl].
    pub fn set_or_clear_ttl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ttl = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.DataSet"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataSet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __data_names,
            __data_sources,
            __state,
            __status,
            __ttl,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataSet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "dataNames" => Ok(__FieldTag::__data_names),
                            "data_names" => Ok(__FieldTag::__data_names),
                            "dataSources" => Ok(__FieldTag::__data_sources),
                            "data_sources" => Ok(__FieldTag::__data_sources),
                            "state" => Ok(__FieldTag::__state),
                            "status" => Ok(__FieldTag::__status),
                            "ttl" => Ok(__FieldTag::__ttl),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataSet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataSet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_names => {
                            if !fields.insert(__FieldTag::__data_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_names",
                                ));
                            }
                            result.data_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__data_sources => {
                            if !fields.insert(__FieldTag::__data_sources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_sources",
                                ));
                            }
                            result.data_sources = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DataSource>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::data_set::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__ttl => {
                            if !fields.insert(__FieldTag::__ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ttl",
                                ));
                            }
                            result.ttl = map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataSet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.data_names.is_empty() {
            state.serialize_entry("dataNames", &self.data_names)?;
        }
        if !self.data_sources.is_empty() {
            state.serialize_entry("dataSources", &self.data_sources)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.ttl.is_some() {
            state.serialize_entry("ttl", &self.ttl)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataSet].
pub mod data_set {
    #[allow(unused_imports)]
    use super::*;

    /// DataSet state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified / undefined state.
        Unspecified,
        /// Dataset is unknown to the system; we have never seen this dataset before
        /// or we have seen this dataset but have fully GC-ed it.
        Unknown,
        /// Dataset processing is pending.
        Pending,
        /// Dataset is loading.
        Loading,
        /// Dataset is loaded and can be queried.
        Loaded,
        /// Dataset is unloading.
        Unloading,
        /// Dataset is unloaded and is removed from the system.
        Unloaded,
        /// Dataset processing failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unknown => std::option::Option::Some(1),
                Self::Pending => std::option::Option::Some(2),
                Self::Loading => std::option::Option::Some(3),
                Self::Loaded => std::option::Option::Some(4),
                Self::Unloading => std::option::Option::Some(5),
                Self::Unloaded => std::option::Option::Some(6),
                Self::Failed => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Loading => std::option::Option::Some("LOADING"),
                Self::Loaded => std::option::Option::Some("LOADED"),
                Self::Unloading => std::option::Option::Some("UNLOADING"),
                Self::Unloaded => std::option::Option::Some("UNLOADED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unknown,
                2 => Self::Pending,
                3 => Self::Loading,
                4 => Self::Loaded,
                5 => Self::Unloading,
                6 => Self::Unloaded,
                7 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "UNKNOWN" => Self::Unknown,
                "PENDING" => Self::Pending,
                "LOADING" => Self::Loading,
                "LOADED" => Self::Loaded,
                "UNLOADING" => Self::Unloading,
                "UNLOADED" => Self::Unloaded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unknown => serializer.serialize_i32(1),
                Self::Pending => serializer.serialize_i32(2),
                Self::Loading => serializer.serialize_i32(3),
                Self::Loaded => serializer.serialize_i32(4),
                Self::Unloading => serializer.serialize_i32(5),
                Self::Unloaded => serializer.serialize_i32(6),
                Self::Failed => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.timeseriesinsights.v1.DataSet.State",
            ))
        }
    }
}

/// Represents an event dimension.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EventDimension {
    /// Dimension name.
    ///
    /// **NOTE**: `EventDimension` names must be composed of alphanumeric
    /// characters only, and are case insensitive. Unicode characters are *not*
    /// supported. The underscore '_' is also allowed.
    pub name: std::string::String,

    /// Dimension value.
    ///
    /// **NOTE**: All entries of the dimension `name` must have the same `value`
    /// type.
    pub value: std::option::Option<crate::model::event_dimension::Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EventDimension {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EventDimension::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::EventDimension::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::event_dimension::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::EventDimension::value]
    /// if it holds a `StringVal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_val(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::event_dimension::Value::StringVal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::EventDimension::value]
    /// to hold a `StringVal`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_val<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::event_dimension::Value::StringVal(v.into()));
        self
    }

    /// The value of [value][crate::model::EventDimension::value]
    /// if it holds a `LongVal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn long_val(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::event_dimension::Value::LongVal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::EventDimension::value]
    /// to hold a `LongVal`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_long_val<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::event_dimension::Value::LongVal(v.into()));
        self
    }

    /// The value of [value][crate::model::EventDimension::value]
    /// if it holds a `BoolVal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_val(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::event_dimension::Value::BoolVal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::EventDimension::value]
    /// to hold a `BoolVal`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_val<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::event_dimension::Value::BoolVal(v.into()));
        self
    }

    /// The value of [value][crate::model::EventDimension::value]
    /// if it holds a `DoubleVal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn double_val(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::event_dimension::Value::DoubleVal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::EventDimension::value]
    /// to hold a `DoubleVal`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_double_val<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::event_dimension::Value::DoubleVal(v.into()));
        self
    }
}

impl wkt::message::Message for EventDimension {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.EventDimension"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EventDimension {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __string_val,
            __long_val,
            __bool_val,
            __double_val,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EventDimension")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "stringVal" => Ok(__FieldTag::__string_val),
                            "string_val" => Ok(__FieldTag::__string_val),
                            "longVal" => Ok(__FieldTag::__long_val),
                            "long_val" => Ok(__FieldTag::__long_val),
                            "boolVal" => Ok(__FieldTag::__bool_val),
                            "bool_val" => Ok(__FieldTag::__bool_val),
                            "doubleVal" => Ok(__FieldTag::__double_val),
                            "double_val" => Ok(__FieldTag::__double_val),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EventDimension;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EventDimension")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__string_val => {
                            if !fields.insert(__FieldTag::__string_val) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_val",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.timeseriesinsights.v1.EventDimension.string_val, latest field was stringVal",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::event_dimension::Value::StringVal(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__long_val => {
                            if !fields.insert(__FieldTag::__long_val) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for long_val",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.timeseriesinsights.v1.EventDimension.long_val, latest field was longVal",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::event_dimension::Value::LongVal(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__bool_val => {
                            if !fields.insert(__FieldTag::__bool_val) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bool_val",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.timeseriesinsights.v1.EventDimension.bool_val, latest field was boolVal",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::event_dimension::Value::BoolVal(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__double_val => {
                            if !fields.insert(__FieldTag::__double_val) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for double_val",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.timeseriesinsights.v1.EventDimension.double_val, latest field was doubleVal",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::event_dimension::Value::DoubleVal(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EventDimension {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.string_val() {
            state.serialize_entry("stringVal", value)?;
        }
        if let Some(value) = self.long_val() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("longVal", &__With(value))?;
        }
        if let Some(value) = self.bool_val() {
            state.serialize_entry("boolVal", value)?;
        }
        if let Some(value) = self.double_val() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("doubleVal", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EventDimension].
pub mod event_dimension {
    #[allow(unused_imports)]
    use super::*;

    /// Dimension value.
    ///
    /// **NOTE**: All entries of the dimension `name` must have the same `value`
    /// type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Value {
        /// String representation.
        ///
        /// **NOTE**: String values are case insensitive. Unicode characters are
        /// supported.
        StringVal(std::string::String),
        /// Long representation.
        LongVal(i64),
        /// Bool representation.
        BoolVal(bool),
        /// Double representation.
        DoubleVal(f64),
    }
}

/// Represents an entry in a data source.
///
/// Each Event has:
///
/// * A timestamp at which the event occurs.
/// * One or multiple dimensions.
/// * Optionally, a group ID that allows clients to group logically related
///   events (for example, all events representing payments transactions done by
///   a user in a day have the same group ID).  If a group ID is not provided, an
///   internal one will be generated based on the content and `eventTime`.
///
/// **NOTE**:
///
/// * Internally, we discretize time in equal-sized chunks and we assume an
///   event has a 0
///   [TimeseriesPoint.value][google.cloud.timeseriesinsights.v1.TimeseriesPoint.value]
///   in a chunk that does not contain any occurrences of an event in the input.
/// * The number of Events with the same group ID should be limited.
/// * Group ID *cannot* be queried.
/// * Group ID does *not* correspond to a user ID or the like. If a user ID is of
///   interest to be queried, use a user ID `dimension` instead.
///
/// [google.cloud.timeseriesinsights.v1.TimeseriesPoint.value]: crate::model::TimeseriesPoint::value
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Event {
    /// Event dimensions.
    pub dimensions: std::vec::Vec<crate::model::EventDimension>,

    /// Event group ID.
    ///
    /// **NOTE**: JSON encoding should use a string to hold a 64-bit integer value,
    /// because a native JSON number holds only 53 binary bits for an integer.
    pub group_id: i64,

    /// Event timestamp.
    pub event_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Event {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dimensions][crate::model::Event::dimensions].
    pub fn set_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EventDimension>,
    {
        use std::iter::Iterator;
        self.dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [group_id][crate::model::Event::group_id].
    pub fn set_group_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.group_id = v.into();
        self
    }

    /// Sets the value of [event_time][crate::model::Event::event_time].
    pub fn set_event_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event_time][crate::model::Event::event_time].
    pub fn set_or_clear_event_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Event {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.Event"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Event {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dimensions,
            __group_id,
            __event_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Event")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dimensions" => Ok(__FieldTag::__dimensions),
                            "groupId" => Ok(__FieldTag::__group_id),
                            "group_id" => Ok(__FieldTag::__group_id),
                            "eventTime" => Ok(__FieldTag::__event_time),
                            "event_time" => Ok(__FieldTag::__event_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Event;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Event")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dimensions => {
                            if !fields.insert(__FieldTag::__dimensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dimensions",
                                ));
                            }
                            result.dimensions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EventDimension>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__group_id => {
                            if !fields.insert(__FieldTag::__group_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.group_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__event_time => {
                            if !fields.insert(__FieldTag::__event_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_time",
                                ));
                            }
                            result.event_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Event {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dimensions.is_empty() {
            state.serialize_entry("dimensions", &self.dimensions)?;
        }
        if !wkt::internal::is_default(&self.group_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("groupId", &__With(&self.group_id))?;
        }
        if self.event_time.is_some() {
            state.serialize_entry("eventTime", &self.event_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Appends events to an existing DataSet.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AppendEventsRequest {
    /// Events to be appended.
    ///
    /// Note:
    ///
    /// 1. The [DataSet][google.cloud.timeseriesinsights.v1.DataSet] must be shown in a `LOADED` state
    ///    in the results of `list` method; otherwise, all events from
    ///    the append request will be dropped, and a `NOT_FOUND` status will be
    ///    returned.
    /// 1. All events in a single request must have the same
    ///    [groupId][google.cloud.timeseriesinsights.v1.Event.group_id] if set; otherwise, an
    ///    `INVALID_ARGUMENT` status will be returned.
    /// 1. If [groupId][google.cloud.timeseriesinsights.v1.Event.group_id] is not set (or 0), there
    ///    should be only 1 event; otherwise, an `INVALID_ARGUMENT` status will be
    ///    returned.
    /// 1. The events must be newer than the current time minus
    ///    [DataSet TTL][google.cloud.timeseriesinsights.v1.DataSet.ttl] or they will be dropped.
    ///
    /// [google.cloud.timeseriesinsights.v1.DataSet]: crate::model::DataSet
    /// [google.cloud.timeseriesinsights.v1.DataSet.ttl]: crate::model::DataSet::ttl
    /// [google.cloud.timeseriesinsights.v1.Event.group_id]: crate::model::Event::group_id
    pub events: std::vec::Vec<crate::model::Event>,

    /// Required. The DataSet to which we want to append to in the format of
    /// "projects/{project}/datasets/{dataset}"
    pub dataset: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AppendEventsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [events][crate::model::AppendEventsRequest::events].
    pub fn set_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Event>,
    {
        use std::iter::Iterator;
        self.events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dataset][crate::model::AppendEventsRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }
}

impl wkt::message::Message for AppendEventsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.AppendEventsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AppendEventsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __events,
            __dataset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AppendEventsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "events" => Ok(__FieldTag::__events),
                            "dataset" => Ok(__FieldTag::__dataset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AppendEventsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AppendEventsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__events => {
                            if !fields.insert(__FieldTag::__events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for events",
                                ));
                            }
                            result.events = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Event>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AppendEventsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.events.is_empty() {
            state.serialize_entry("events", &self.events)?;
        }
        if !self.dataset.is_empty() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for an AppendEvents RPC.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AppendEventsResponse {
    /// Dropped events; empty if all events are successfully added.
    pub dropped_events: std::vec::Vec<crate::model::Event>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AppendEventsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dropped_events][crate::model::AppendEventsResponse::dropped_events].
    pub fn set_dropped_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Event>,
    {
        use std::iter::Iterator;
        self.dropped_events = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AppendEventsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.AppendEventsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AppendEventsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dropped_events,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AppendEventsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "droppedEvents" => Ok(__FieldTag::__dropped_events),
                            "dropped_events" => Ok(__FieldTag::__dropped_events),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AppendEventsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AppendEventsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dropped_events => {
                            if !fields.insert(__FieldTag::__dropped_events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dropped_events",
                                ));
                            }
                            result.dropped_events = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Event>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AppendEventsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dropped_events.is_empty() {
            state.serialize_entry("droppedEvents", &self.dropped_events)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Create a DataSet request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDataSetRequest {
    /// Required. Client project name which will own this DataSet in the format of
    /// 'projects/{project}'.
    pub parent: std::string::String,

    /// Required. Dataset to be loaded.
    pub dataset: std::option::Option<crate::model::DataSet>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDataSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDataSetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::CreateDataSetRequest::dataset].
    pub fn set_dataset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataSet>,
    {
        self.dataset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataset][crate::model::CreateDataSetRequest::dataset].
    pub fn set_or_clear_dataset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataSet>,
    {
        self.dataset = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateDataSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.CreateDataSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDataSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __dataset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDataSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "dataset" => Ok(__FieldTag::__dataset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDataSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDataSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset =
                                map.next_value::<std::option::Option<crate::model::DataSet>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDataSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.dataset.is_some() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Unload DataSet request from the serving system.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDataSetRequest {
    /// Required. Dataset name in the format of "projects/{project}/datasets/{dataset}"
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDataSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDataSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDataSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.DeleteDataSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDataSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDataSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDataSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDataSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDataSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List the DataSets created by the current project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDataSetsRequest {
    /// Required. Project owning the DataSet in the format of "projects/{project}".
    pub parent: std::string::String,

    /// Number of results to return in the list.
    pub page_size: i32,

    /// Token to provide to skip to a particular spot in the list.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataSetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataSetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataSetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataSetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDataSetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.ListDataSetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDataSetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDataSetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDataSetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDataSetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDataSetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Created DataSets list response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDataSetsResponse {
    /// The list of created DataSets.
    pub datasets: std::vec::Vec<crate::model::DataSet>,

    /// Token to receive the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataSetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [datasets][crate::model::ListDataSetsResponse::datasets].
    pub fn set_datasets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataSet>,
    {
        use std::iter::Iterator;
        self.datasets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDataSetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDataSetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.ListDataSetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDataSetsResponse {
    type PageItem = crate::model::DataSet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.datasets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDataSetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __datasets,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDataSetsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datasets" => Ok(__FieldTag::__datasets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDataSetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDataSetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__datasets => {
                            if !fields.insert(__FieldTag::__datasets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datasets",
                                ));
                            }
                            result.datasets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DataSet>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDataSetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.datasets.is_empty() {
            state.serialize_entry("datasets", &self.datasets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A categorical dimension fixed to a certain value.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PinnedDimension {
    /// The name of the dimension for which we are fixing its value.
    pub name: std::string::String,

    /// Dimension value.
    ///
    /// **NOTE**: The `value` type must match that in the data with the same
    /// `dimension` as name.
    pub value: std::option::Option<crate::model::pinned_dimension::Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PinnedDimension {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PinnedDimension::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::PinnedDimension::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::pinned_dimension::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::PinnedDimension::value]
    /// if it holds a `StringVal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_val(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::pinned_dimension::Value::StringVal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::PinnedDimension::value]
    /// to hold a `StringVal`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_val<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::pinned_dimension::Value::StringVal(v.into()));
        self
    }

    /// The value of [value][crate::model::PinnedDimension::value]
    /// if it holds a `BoolVal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_val(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::pinned_dimension::Value::BoolVal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::PinnedDimension::value]
    /// to hold a `BoolVal`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_val<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::pinned_dimension::Value::BoolVal(v.into()));
        self
    }
}

impl wkt::message::Message for PinnedDimension {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.PinnedDimension"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PinnedDimension {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __string_val,
            __bool_val,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PinnedDimension")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "stringVal" => Ok(__FieldTag::__string_val),
                            "string_val" => Ok(__FieldTag::__string_val),
                            "boolVal" => Ok(__FieldTag::__bool_val),
                            "bool_val" => Ok(__FieldTag::__bool_val),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PinnedDimension;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PinnedDimension")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__string_val => {
                            if !fields.insert(__FieldTag::__string_val) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_val",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.timeseriesinsights.v1.PinnedDimension.string_val, latest field was stringVal",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::pinned_dimension::Value::StringVal(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__bool_val => {
                            if !fields.insert(__FieldTag::__bool_val) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bool_val",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.timeseriesinsights.v1.PinnedDimension.bool_val, latest field was boolVal",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::pinned_dimension::Value::BoolVal(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PinnedDimension {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.string_val() {
            state.serialize_entry("stringVal", value)?;
        }
        if let Some(value) = self.bool_val() {
            state.serialize_entry("boolVal", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [PinnedDimension].
pub mod pinned_dimension {
    #[allow(unused_imports)]
    use super::*;

    /// Dimension value.
    ///
    /// **NOTE**: The `value` type must match that in the data with the same
    /// `dimension` as name.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Value {
        /// A string value. This can be used for [dimensions][google.cloud.timeseriesinsights.v1.EventDimension], which
        /// have their value field set to [string_val][google.cloud.timeseriesinsights.v1.EventDimension.string_val].
        ///
        /// [google.cloud.timeseriesinsights.v1.EventDimension]: crate::model::EventDimension
        /// [google.cloud.timeseriesinsights.v1.EventDimension.string_val]: crate::model::EventDimension::value
        StringVal(std::string::String),
        /// A bool value. This can be used for [dimensions][google.cloud.timeseriesinsights.v1.EventDimension], which
        /// have their value field set to [bool_val][google.cloud.timeseriesinsights.v1.EventDimension.bool_val].
        ///
        /// [google.cloud.timeseriesinsights.v1.EventDimension]: crate::model::EventDimension
        /// [google.cloud.timeseriesinsights.v1.EventDimension.bool_val]: crate::model::EventDimension::value
        BoolVal(bool),
    }
}

/// Parameters that control the sensitivity and other options for the time series
/// forecast.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ForecastParams {
    /// Optional. Penalize variations between the actual and forecasted values smaller than
    /// this. For more information about how this parameter affects the score, see
    /// the [anomalyScore](EvaluatedSlice.anomaly_score) formula.
    ///
    /// Intuitively, anomaly scores summarize how statistically significant the
    /// change between the actual and forecasted value is compared with what we
    /// expect the change to be (see
    /// [expectedDeviation](EvaluatedSlice.expected_deviation)). However, in
    /// practice, depending on the application, changes smaller than certain
    /// absolute values, while statistically significant, may not be important.
    ///
    /// This parameter allows us to penalize such low absolute value changes.
    ///
    /// Must be in the (0.0, inf) range.
    ///
    /// If unspecified, it defaults to 0.000001.
    pub noise_threshold: std::option::Option<f64>,

    /// Optional. Specifying any known seasonality/periodicity in the time series
    /// for the slices we will analyze can improve the quality of the results.
    ///
    /// If unsure, simply leave it unspecified by not setting a value for this
    /// field.
    ///
    /// If your time series has multiple seasonal patterns, then set it to the most
    /// granular one (e.g. if it has daily and weekly patterns, set this to DAILY).
    pub seasonality_hint: crate::model::forecast_params::Period,

    /// Optional. The length of the returned [forecasted
    /// timeseries][EvaluatedSlice.forecast].
    ///
    /// This duration is currently capped at 100 x
    /// [granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity].
    ///
    /// Example: If the detection point is set to "2020-12-27T00:00:00Z", the
    /// [granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity] to "3600s" and the
    /// horizon_duration to "10800s", then we will generate 3 time
    /// series points (from "2020-12-27T01:00:00Z" to "2020-12-27T04:00:00Z"), for
    /// which we will return their forecasted values.
    ///
    /// Note: The horizon time is only used for forecasting not for anormaly
    /// detection. To detect anomalies for multiple points of time,
    /// simply send multiple queries with those as
    /// [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time].
    ///
    /// [EvaluatedSlice.forecast]: crate::model::EvaluatedSlice::forecast
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]: crate::model::TimeseriesParams::granularity
    pub horizon_duration: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ForecastParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [noise_threshold][crate::model::ForecastParams::noise_threshold].
    pub fn set_noise_threshold<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.noise_threshold = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [noise_threshold][crate::model::ForecastParams::noise_threshold].
    pub fn set_or_clear_noise_threshold<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.noise_threshold = v.map(|x| x.into());
        self
    }

    /// Sets the value of [seasonality_hint][crate::model::ForecastParams::seasonality_hint].
    pub fn set_seasonality_hint<T: std::convert::Into<crate::model::forecast_params::Period>>(
        mut self,
        v: T,
    ) -> Self {
        self.seasonality_hint = v.into();
        self
    }

    /// Sets the value of [horizon_duration][crate::model::ForecastParams::horizon_duration].
    pub fn set_horizon_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.horizon_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [horizon_duration][crate::model::ForecastParams::horizon_duration].
    pub fn set_or_clear_horizon_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.horizon_duration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ForecastParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.ForecastParams"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ForecastParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __noise_threshold,
            __seasonality_hint,
            __horizon_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ForecastParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "noiseThreshold" => Ok(__FieldTag::__noise_threshold),
                            "noise_threshold" => Ok(__FieldTag::__noise_threshold),
                            "seasonalityHint" => Ok(__FieldTag::__seasonality_hint),
                            "seasonality_hint" => Ok(__FieldTag::__seasonality_hint),
                            "horizonDuration" => Ok(__FieldTag::__horizon_duration),
                            "horizon_duration" => Ok(__FieldTag::__horizon_duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ForecastParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ForecastParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__noise_threshold => {
                            if !fields.insert(__FieldTag::__noise_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for noise_threshold",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.noise_threshold = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__seasonality_hint => {
                            if !fields.insert(__FieldTag::__seasonality_hint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for seasonality_hint",
                                ));
                            }
                            result.seasonality_hint = map.next_value::<std::option::Option<crate::model::forecast_params::Period>>()?.unwrap_or_default();
                        }
                        __FieldTag::__horizon_duration => {
                            if !fields.insert(__FieldTag::__horizon_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for horizon_duration",
                                ));
                            }
                            result.horizon_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ForecastParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.noise_threshold.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("noiseThreshold", &__With(&self.noise_threshold))?;
        }
        if !wkt::internal::is_default(&self.seasonality_hint) {
            state.serialize_entry("seasonalityHint", &self.seasonality_hint)?;
        }
        if self.horizon_duration.is_some() {
            state.serialize_entry("horizonDuration", &self.horizon_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ForecastParams].
pub mod forecast_params {
    #[allow(unused_imports)]
    use super::*;

    /// A time period of a fixed interval.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Period {
        /// Unknown or simply not given.
        Unspecified,
        /// 1 hour
        Hourly,
        /// 24 hours
        Daily,
        /// 7 days
        Weekly,
        /// 30 days
        Monthly,
        /// 365 days
        Yearly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Period::value] or
        /// [Period::name].
        UnknownValue(period::UnknownValue),
    }

    #[doc(hidden)]
    pub mod period {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Period {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Hourly => std::option::Option::Some(5),
                Self::Daily => std::option::Option::Some(1),
                Self::Weekly => std::option::Option::Some(2),
                Self::Monthly => std::option::Option::Some(3),
                Self::Yearly => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PERIOD_UNSPECIFIED"),
                Self::Hourly => std::option::Option::Some("HOURLY"),
                Self::Daily => std::option::Option::Some("DAILY"),
                Self::Weekly => std::option::Option::Some("WEEKLY"),
                Self::Monthly => std::option::Option::Some("MONTHLY"),
                Self::Yearly => std::option::Option::Some("YEARLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Period {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Period {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Period {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Daily,
                2 => Self::Weekly,
                3 => Self::Monthly,
                4 => Self::Yearly,
                5 => Self::Hourly,
                _ => Self::UnknownValue(period::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Period {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PERIOD_UNSPECIFIED" => Self::Unspecified,
                "HOURLY" => Self::Hourly,
                "DAILY" => Self::Daily,
                "WEEKLY" => Self::Weekly,
                "MONTHLY" => Self::Monthly,
                "YEARLY" => Self::Yearly,
                _ => Self::UnknownValue(period::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Period {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Hourly => serializer.serialize_i32(5),
                Self::Daily => serializer.serialize_i32(1),
                Self::Weekly => serializer.serialize_i32(2),
                Self::Monthly => serializer.serialize_i32(3),
                Self::Yearly => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Period {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Period>::new(
                ".google.cloud.timeseriesinsights.v1.ForecastParams.Period",
            ))
        }
    }
}

/// A point in a time series.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeseriesPoint {
    /// The timestamp of this point.
    pub time: std::option::Option<wkt::Timestamp>,

    /// The value for this point.
    ///
    /// It is computed by aggregating all events in the associated slice that are
    /// in the `[time, time + granularity]` range (see
    /// [granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]) using the specified
    /// [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric].
    ///
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]: crate::model::TimeseriesParams::granularity
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric]: crate::model::TimeseriesParams::metric
    pub value: std::option::Option<f64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeseriesPoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time][crate::model::TimeseriesPoint::time].
    pub fn set_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time][crate::model::TimeseriesPoint::time].
    pub fn set_or_clear_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [value][crate::model::TimeseriesPoint::value].
    pub fn set_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [value][crate::model::TimeseriesPoint::value].
    pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.value = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TimeseriesPoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.TimeseriesPoint"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeseriesPoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeseriesPoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "time" => Ok(__FieldTag::__time),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeseriesPoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeseriesPoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time => {
                            if !fields.insert(__FieldTag::__time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time",
                                ));
                            }
                            result.time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.value = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeseriesPoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.time.is_some() {
            state.serialize_entry("time", &self.time)?;
        }
        if self.value.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("value", &__With(&self.value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A time series.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Timeseries {
    /// The points in this time series, ordered by their timestamp.
    pub point: std::vec::Vec<crate::model::TimeseriesPoint>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Timeseries {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [point][crate::model::Timeseries::point].
    pub fn set_point<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeseriesPoint>,
    {
        use std::iter::Iterator;
        self.point = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Timeseries {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.Timeseries"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Timeseries {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __point,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Timeseries")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "point" => Ok(__FieldTag::__point),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Timeseries;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Timeseries")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__point => {
                            if !fields.insert(__FieldTag::__point) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for point",
                                ));
                            }
                            result.point =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TimeseriesPoint>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Timeseries {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.point.is_empty() {
            state.serialize_entry("point", &self.point)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Forecast result for a given slice.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EvaluatedSlice {
    /// Values for all categorical dimensions that uniquely identify this slice.
    pub dimensions: std::vec::Vec<crate::model::PinnedDimension>,

    /// The actual value at the detection time (see
    /// [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]).
    ///
    /// **NOTE**: This value can be an estimate, so it should not be used as a
    /// source of truth.
    ///
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    pub detection_point_actual: std::option::Option<f64>,

    /// The expected value at the detection time, which is obtained by forecasting
    /// on the historical time series.
    pub detection_point_forecast: std::option::Option<f64>,

    /// How much our forecast model expects the detection point actual will
    /// deviate from its forecasted value based on how well it fit the input time
    /// series.
    ///
    /// In general, we expect the `detectionPointActual` to
    /// be in the `[detectionPointForecast - expectedDeviation,
    /// detectionPointForecast + expectedDeviation]` range. The more the actual
    /// value is outside this range, the more statistically significant the
    /// anomaly is.
    ///
    /// The expected deviation is always positive.
    pub expected_deviation: std::option::Option<f64>,

    /// Summarizes how significant the change between the actual and forecasted
    /// detection points are compared with the historical patterns observed on the
    /// [history][google.cloud.timeseriesinsights.v1.EvaluatedSlice.history] time series.
    ///
    /// Defined as *|a - f| / (e + nt)*, where:
    ///
    /// - *a* is the [detectionPointActual][google.cloud.timeseriesinsights.v1.EvaluatedSlice.detection_point_actual].
    /// - *f* is the [detectionPointForecast][google.cloud.timeseriesinsights.v1.EvaluatedSlice.detection_point_forecast].
    /// - *e* is the [expectedDeviation][google.cloud.timeseriesinsights.v1.EvaluatedSlice.expected_deviation].
    /// - *nt` is the [noiseThreshold][google.cloud.timeseriesinsights.v1.ForecastParams.noise_threshold].
    ///
    /// Anomaly scores between different requests and datasets are comparable. As
    /// a guideline, the risk of a slice being an anomaly based on the anomaly
    /// score is:
    ///
    /// - **Very High** if `anomalyScore` > 5.
    /// - **High** if the `anomalyScore` is in the [2, 5] range.
    /// - **Medium** if the `anomalyScore` is in the [1, 2) range.
    /// - **Low** if the `anomalyScore` is < 1.
    ///
    /// If there were issues evaluating this slice, then the anomaly score will be
    /// set to -1.0 and the [status][google.cloud.timeseriesinsights.v1.EvaluatedSlice.status] field will contain details on what
    /// went wrong.
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.detection_point_actual]: crate::model::EvaluatedSlice::detection_point_actual
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.detection_point_forecast]: crate::model::EvaluatedSlice::detection_point_forecast
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.expected_deviation]: crate::model::EvaluatedSlice::expected_deviation
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.history]: crate::model::EvaluatedSlice::history
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.status]: crate::model::EvaluatedSlice::status
    /// [google.cloud.timeseriesinsights.v1.ForecastParams.noise_threshold]: crate::model::ForecastParams::noise_threshold
    pub anomaly_score: std::option::Option<f64>,

    /// The actual values in the `[`
    /// [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] `-`
    /// [forecastHistory][google.cloud.timeseriesinsights.v1.TimeseriesParams.forecast_history]`,`
    /// [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] `]` time
    /// range.
    ///
    /// **NOTE**: This field is only populated if
    /// [returnTimeseries][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.return_timeseries] is true.
    ///
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.return_timeseries]: crate::model::QueryDataSetRequest::return_timeseries
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.forecast_history]: crate::model::TimeseriesParams::forecast_history
    pub history: std::option::Option<crate::model::Timeseries>,

    /// The forecasted values in the `[`
    /// [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] `+`
    /// [granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]`,`
    /// [forecastParams.horizonTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.forecast_params] `]` time
    /// range.
    ///
    /// **NOTE**: This field is only populated if
    /// [returnTimeseries][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.return_timeseries] is true.
    ///
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.forecast_params]: crate::model::QueryDataSetRequest::forecast_params
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.return_timeseries]: crate::model::QueryDataSetRequest::return_timeseries
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]: crate::model::TimeseriesParams::granularity
    pub forecast: std::option::Option<crate::model::Timeseries>,

    /// Evaluation status. Contains an error message if the `anomalyScore` is < 0.
    ///
    /// Possible error messages:
    ///
    /// - **"Time series too sparse"**: The returned time series for this slice did
    ///   not contain enough data points (we require a minimum of 10).
    /// - **"Not enough recent time series points"**: The time series contains the
    ///   minimum of 10 points, but there are not enough close in time to the
    ///   detection point.
    /// - **"Missing detection point data"**: There were not events to be
    ///   aggregated within the `[detectionTime, detectionTime + granularity]` time
    ///   interval, so we don't have an actual value with which we can compare our
    ///   prediction.
    /// - **"Data retrieval error"**: We failed to retrieve the time series data
    ///   for this slice and could not evaluate it successfully. Should be a
    ///   transient error.
    /// - **"Internal server error"**: Internal unexpected error.
    pub status: std::option::Option<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EvaluatedSlice {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dimensions][crate::model::EvaluatedSlice::dimensions].
    pub fn set_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PinnedDimension>,
    {
        use std::iter::Iterator;
        self.dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [detection_point_actual][crate::model::EvaluatedSlice::detection_point_actual].
    pub fn set_detection_point_actual<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.detection_point_actual = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [detection_point_actual][crate::model::EvaluatedSlice::detection_point_actual].
    pub fn set_or_clear_detection_point_actual<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.detection_point_actual = v.map(|x| x.into());
        self
    }

    /// Sets the value of [detection_point_forecast][crate::model::EvaluatedSlice::detection_point_forecast].
    pub fn set_detection_point_forecast<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.detection_point_forecast = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [detection_point_forecast][crate::model::EvaluatedSlice::detection_point_forecast].
    pub fn set_or_clear_detection_point_forecast<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.detection_point_forecast = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expected_deviation][crate::model::EvaluatedSlice::expected_deviation].
    pub fn set_expected_deviation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.expected_deviation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expected_deviation][crate::model::EvaluatedSlice::expected_deviation].
    pub fn set_or_clear_expected_deviation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.expected_deviation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [anomaly_score][crate::model::EvaluatedSlice::anomaly_score].
    pub fn set_anomaly_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.anomaly_score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [anomaly_score][crate::model::EvaluatedSlice::anomaly_score].
    pub fn set_or_clear_anomaly_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.anomaly_score = v.map(|x| x.into());
        self
    }

    /// Sets the value of [history][crate::model::EvaluatedSlice::history].
    pub fn set_history<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Timeseries>,
    {
        self.history = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [history][crate::model::EvaluatedSlice::history].
    pub fn set_or_clear_history<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Timeseries>,
    {
        self.history = v.map(|x| x.into());
        self
    }

    /// Sets the value of [forecast][crate::model::EvaluatedSlice::forecast].
    pub fn set_forecast<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Timeseries>,
    {
        self.forecast = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [forecast][crate::model::EvaluatedSlice::forecast].
    pub fn set_or_clear_forecast<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Timeseries>,
    {
        self.forecast = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::EvaluatedSlice::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::EvaluatedSlice::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EvaluatedSlice {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.EvaluatedSlice"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EvaluatedSlice {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dimensions,
            __detection_point_actual,
            __detection_point_forecast,
            __expected_deviation,
            __anomaly_score,
            __history,
            __forecast,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvaluatedSlice")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dimensions" => Ok(__FieldTag::__dimensions),
                            "detectionPointActual" => Ok(__FieldTag::__detection_point_actual),
                            "detection_point_actual" => Ok(__FieldTag::__detection_point_actual),
                            "detectionPointForecast" => Ok(__FieldTag::__detection_point_forecast),
                            "detection_point_forecast" => {
                                Ok(__FieldTag::__detection_point_forecast)
                            }
                            "expectedDeviation" => Ok(__FieldTag::__expected_deviation),
                            "expected_deviation" => Ok(__FieldTag::__expected_deviation),
                            "anomalyScore" => Ok(__FieldTag::__anomaly_score),
                            "anomaly_score" => Ok(__FieldTag::__anomaly_score),
                            "history" => Ok(__FieldTag::__history),
                            "forecast" => Ok(__FieldTag::__forecast),
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EvaluatedSlice;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvaluatedSlice")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dimensions => {
                            if !fields.insert(__FieldTag::__dimensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dimensions",
                                ));
                            }
                            result.dimensions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PinnedDimension>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__detection_point_actual => {
                            if !fields.insert(__FieldTag::__detection_point_actual) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detection_point_actual",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.detection_point_actual = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__detection_point_forecast => {
                            if !fields.insert(__FieldTag::__detection_point_forecast) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detection_point_forecast",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.detection_point_forecast = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__expected_deviation => {
                            if !fields.insert(__FieldTag::__expected_deviation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expected_deviation",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.expected_deviation = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__anomaly_score => {
                            if !fields.insert(__FieldTag::__anomaly_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for anomaly_score",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.anomaly_score = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__history => {
                            if !fields.insert(__FieldTag::__history) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for history",
                                ));
                            }
                            result.history =
                                map.next_value::<std::option::Option<crate::model::Timeseries>>()?;
                        }
                        __FieldTag::__forecast => {
                            if !fields.insert(__FieldTag::__forecast) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forecast",
                                ));
                            }
                            result.forecast =
                                map.next_value::<std::option::Option<crate::model::Timeseries>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EvaluatedSlice {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dimensions.is_empty() {
            state.serialize_entry("dimensions", &self.dimensions)?;
        }
        if self.detection_point_actual.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "detectionPointActual",
                &__With(&self.detection_point_actual),
            )?;
        }
        if self.detection_point_forecast.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "detectionPointForecast",
                &__With(&self.detection_point_forecast),
            )?;
        }
        if self.expected_deviation.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("expectedDeviation", &__With(&self.expected_deviation))?;
        }
        if self.anomaly_score.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("anomalyScore", &__With(&self.anomaly_score))?;
        }
        if self.history.is_some() {
            state.serialize_entry("history", &self.history)?;
        }
        if self.forecast.is_some() {
            state.serialize_entry("forecast", &self.forecast)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Parameters that control how we slice the dataset and, optionally, filter
/// slices that have some specific values on some dimensions (pinned dimensions).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SlicingParams {
    /// Required. Dimensions over which we will group the events in slices. The names
    /// specified here come from the
    /// [EventDimension.name][google.cloud.timeseriesinsights.v1.EventDimension.name] field. At least
    /// one dimension name must be specified. All dimension names that do not exist
    /// in the queried `DataSet` will be ignored.
    ///
    /// Currently only dimensions that hold string values can be specified here.
    ///
    /// [google.cloud.timeseriesinsights.v1.EventDimension.name]: crate::model::EventDimension::name
    pub dimension_names: std::vec::Vec<std::string::String>,

    /// Optional. We will only analyze slices for which
    /// [EvaluatedSlice.dimensions][google.cloud.timeseriesinsights.v1.EvaluatedSlice.dimensions] contain all of the
    /// following pinned dimensions. A query with a pinned dimension `{ name: "d3"
    /// stringVal: "v3" }` will only analyze events which contain the dimension `{
    /// name: "d3" stringVal: "v3" }`.
    /// The [pinnedDimensions][google.cloud.timeseriesinsights.v1.SlicingParams.pinned_dimensions] and
    /// [dimensionNames][google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names] fields can **not**
    /// share the same dimension names.
    ///
    /// Example a valid specification:
    ///
    /// ```norust
    /// {
    ///   dimensionNames: ["d1", "d2"],
    ///   pinnedDimensions: [
    ///     { name: "d3" stringVal: "v3" },
    ///     { name: "d4" stringVal: "v4" }
    ///   ]
    /// }
    /// ```
    ///
    /// In the previous example we will slice the dataset by dimensions "d1",
    /// "d2", "d3" and "d4", but we will only analyze slices for which "d3=v3" and
    /// "d4=v4".
    ///
    /// The following example is **invalid** as "d2" is present in both
    /// dimensionNames and pinnedDimensions:
    ///
    /// ```norust
    /// {
    ///   dimensionNames: ["d1", "d2"],
    ///   pinnedDimensions: [
    ///     { name: "d2" stringVal: "v2" },
    ///     { name: "d4" stringVal: "v4" }
    ///   ]
    /// }
    /// ```
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.dimensions]: crate::model::EvaluatedSlice::dimensions
    /// [google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names]: crate::model::SlicingParams::dimension_names
    /// [google.cloud.timeseriesinsights.v1.SlicingParams.pinned_dimensions]: crate::model::SlicingParams::pinned_dimensions
    pub pinned_dimensions: std::vec::Vec<crate::model::PinnedDimension>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SlicingParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dimension_names][crate::model::SlicingParams::dimension_names].
    pub fn set_dimension_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dimension_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pinned_dimensions][crate::model::SlicingParams::pinned_dimensions].
    pub fn set_pinned_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PinnedDimension>,
    {
        use std::iter::Iterator;
        self.pinned_dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SlicingParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.SlicingParams"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SlicingParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dimension_names,
            __pinned_dimensions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SlicingParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dimensionNames" => Ok(__FieldTag::__dimension_names),
                            "dimension_names" => Ok(__FieldTag::__dimension_names),
                            "pinnedDimensions" => Ok(__FieldTag::__pinned_dimensions),
                            "pinned_dimensions" => Ok(__FieldTag::__pinned_dimensions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SlicingParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SlicingParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dimension_names => {
                            if !fields.insert(__FieldTag::__dimension_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dimension_names",
                                ));
                            }
                            result.dimension_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__pinned_dimensions => {
                            if !fields.insert(__FieldTag::__pinned_dimensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pinned_dimensions",
                                ));
                            }
                            result.pinned_dimensions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PinnedDimension>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SlicingParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dimension_names.is_empty() {
            state.serialize_entry("dimensionNames", &self.dimension_names)?;
        }
        if !self.pinned_dimensions.is_empty() {
            state.serialize_entry("pinnedDimensions", &self.pinned_dimensions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Parameters that control how we construct the time series for each slice.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeseriesParams {
    /// Required. How long should we go in the past when fetching the timeline used for
    /// forecasting each slice.
    ///
    /// This is used in combination with the
    /// [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] parameter.
    /// The time series we construct will have the following time range:
    /// `[detectionTime - forecastHistory, detectionTime + granularity]`.
    ///
    /// The forecast history might be rounded up, so that a multiple of
    /// `granularity` is used to process the query.
    ///
    /// Note: If there are not enough events in the
    /// `[detectionTime - forecastHistory, detectionTime + granularity]` time
    /// interval, the slice evaluation can fail. For more information, see
    /// [EvaluatedSlice.status][google.cloud.timeseriesinsights.v1.EvaluatedSlice.status].
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.status]: crate::model::EvaluatedSlice::status
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    pub forecast_history: std::option::Option<wkt::Duration>,

    /// Required. The time granularity of the time series (on the x-axis). Each time series
    /// point starting at time T will aggregate all events for a particular slice
    /// in *[T, T + granularity)* time windows.
    ///
    /// Note: The aggregation is decided based on the
    /// [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] parameter.
    ///
    /// This granularity defines the query-time aggregation windows and is not
    /// necessarily related to any event time granularity in the raw data (though
    /// we do recommend that the query-time granularity is not finer than the
    /// ingestion-time one).
    ///
    /// Currently, the minimal supported granularity is 10 seconds.
    ///
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric]: crate::model::TimeseriesParams::metric
    pub granularity: std::option::Option<wkt::Duration>,

    /// Optional. Denotes the [name][google.cloud.timeseriesinsights.v1.EventDimension.name] of a numerical
    /// dimension that will have its values aggregated to compute the y-axis of the
    /// time series.
    ///
    /// The aggregation method must also be specified by setting the
    /// [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
    /// field.
    ///
    /// Note: Currently, if the aggregation method is unspecified, we will
    /// default to SUM for backward compatibility reasons, but new implementations
    /// should set the
    /// [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
    /// explicitly.
    ///
    /// If the metric is unspecified, we will use the number of events that each
    /// time series point contains as the point value.
    ///
    /// Example: Let's assume we have the following three events in our dataset:
    ///
    /// ```norust
    /// {
    ///   eventTime: "2020-12-27T00:00:00Z",
    ///   dimensions: [
    ///     { name: "d1" stringVal: "v1" },
    ///     { name: "d2" stringVal: "v2" }
    ///     { name: "m1" longVal: 100 }
    ///     { name: "m2" longVal: 11 }
    ///   ]
    /// },
    /// {
    ///   eventTime: "2020-12-27T00:10:00Z",
    ///   dimensions: [
    ///     { name: "d1" stringVal: "v1" },
    ///     { name: "d2" stringVal: "v2" }
    ///     { name: "m1" longVal: 200 }
    ///     { name: "m2" longVal: 22 }
    ///   ]
    /// },
    /// {
    ///   eventTime: "2020-12-27T00:20:00Z",
    ///   dimensions: [
    ///     { name: "d1" stringVal: "v1" },
    ///     { name: "d2" stringVal: "v2" }
    ///     { name: "m1" longVal: 300 }
    ///     { name: "m2" longVal: 33 }
    ///   ]
    /// }
    /// ```
    ///
    /// These events are all within the same hour, spaced 10 minutes between each
    /// of them. Assuming our [QueryDataSetRequest][google.cloud.timeseriesinsights.v1.QueryDataSetRequest] had set
    /// [slicingParams.dimensionNames][google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names] to ["d1",
    /// "d2"] and [timeseries_params.granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity] to
    /// "3600s", then all the previous events will be aggregated into the same
    /// [timeseries point][google.cloud.timeseriesinsights.v1.TimeseriesPoint].
    ///
    /// The time series point that they're all part of will have the
    /// [time][google.cloud.timeseriesinsights.v1.TimeseriesPoint.time] set to "2020-12-27T00:00:00Z" and the
    /// [value][google.cloud.timeseriesinsights.v1.TimeseriesPoint.value] populated based on this metric field:
    ///
    /// - If the metric is set to "m1" and metric_aggregation_method to SUM, then
    ///   the value of the point will be 600.
    /// - If the metric is set to "m2" and metric_aggregation_method to SUM, then
    ///   the value of the point will be 66.
    /// - If the metric is set to "m1" and metric_aggregation_method to AVERAGE,
    ///   then the value of the point will be 200.
    /// - If the metric is set to "m2" and metric_aggregation_method to AVERAGE,
    ///   then the value of the point will be 22.
    /// - If the metric field is "" or unspecified, then the value of the point
    ///   will be 3, as we will simply count the events.
    ///
    /// [google.cloud.timeseriesinsights.v1.EventDimension.name]: crate::model::EventDimension::name
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest]: crate::model::QueryDataSetRequest
    /// [google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names]: crate::model::SlicingParams::dimension_names
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]: crate::model::TimeseriesParams::granularity
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]: crate::model::TimeseriesParams::metric_aggregation_method
    /// [google.cloud.timeseriesinsights.v1.TimeseriesPoint]: crate::model::TimeseriesPoint
    /// [google.cloud.timeseriesinsights.v1.TimeseriesPoint.time]: crate::model::TimeseriesPoint::time
    /// [google.cloud.timeseriesinsights.v1.TimeseriesPoint.value]: crate::model::TimeseriesPoint::value
    pub metric: std::option::Option<std::string::String>,

    /// Optional. Together with the [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] field, specifies how
    /// we will aggregate multiple events to obtain the value of a time series
    /// point. See the [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] documentation for more
    /// details.
    ///
    /// If the metric is not specified or "", then this field will be ignored.
    ///
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric]: crate::model::TimeseriesParams::metric
    pub metric_aggregation_method: crate::model::timeseries_params::AggregationMethod,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeseriesParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [forecast_history][crate::model::TimeseriesParams::forecast_history].
    pub fn set_forecast_history<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.forecast_history = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [forecast_history][crate::model::TimeseriesParams::forecast_history].
    pub fn set_or_clear_forecast_history<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.forecast_history = v.map(|x| x.into());
        self
    }

    /// Sets the value of [granularity][crate::model::TimeseriesParams::granularity].
    pub fn set_granularity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.granularity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [granularity][crate::model::TimeseriesParams::granularity].
    pub fn set_or_clear_granularity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.granularity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metric][crate::model::TimeseriesParams::metric].
    pub fn set_metric<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.metric = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metric][crate::model::TimeseriesParams::metric].
    pub fn set_or_clear_metric<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.metric = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metric_aggregation_method][crate::model::TimeseriesParams::metric_aggregation_method].
    pub fn set_metric_aggregation_method<
        T: std::convert::Into<crate::model::timeseries_params::AggregationMethod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_aggregation_method = v.into();
        self
    }
}

impl wkt::message::Message for TimeseriesParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.TimeseriesParams"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeseriesParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __forecast_history,
            __granularity,
            __metric,
            __metric_aggregation_method,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeseriesParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "forecastHistory" => Ok(__FieldTag::__forecast_history),
                            "forecast_history" => Ok(__FieldTag::__forecast_history),
                            "granularity" => Ok(__FieldTag::__granularity),
                            "metric" => Ok(__FieldTag::__metric),
                            "metricAggregationMethod" => {
                                Ok(__FieldTag::__metric_aggregation_method)
                            }
                            "metric_aggregation_method" => {
                                Ok(__FieldTag::__metric_aggregation_method)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeseriesParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeseriesParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__forecast_history => {
                            if !fields.insert(__FieldTag::__forecast_history) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forecast_history",
                                ));
                            }
                            result.forecast_history =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__granularity => {
                            if !fields.insert(__FieldTag::__granularity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for granularity",
                                ));
                            }
                            result.granularity =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__metric => {
                            if !fields.insert(__FieldTag::__metric) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric",
                                ));
                            }
                            result.metric =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__metric_aggregation_method => {
                            if !fields.insert(__FieldTag::__metric_aggregation_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric_aggregation_method",
                                ));
                            }
                            result.metric_aggregation_method = map
                                .next_value::<std::option::Option<
                                    crate::model::timeseries_params::AggregationMethod,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeseriesParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.forecast_history.is_some() {
            state.serialize_entry("forecastHistory", &self.forecast_history)?;
        }
        if self.granularity.is_some() {
            state.serialize_entry("granularity", &self.granularity)?;
        }
        if self.metric.is_some() {
            state.serialize_entry("metric", &self.metric)?;
        }
        if !wkt::internal::is_default(&self.metric_aggregation_method) {
            state.serialize_entry("metricAggregationMethod", &self.metric_aggregation_method)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TimeseriesParams].
pub mod timeseries_params {
    #[allow(unused_imports)]
    use super::*;

    /// Methods by which we can aggregate multiple events by a given
    /// [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric].
    ///
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric]: crate::model::TimeseriesParams::metric
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AggregationMethod {
        /// Unspecified.
        Unspecified,
        /// Aggregate multiple events by summing up the values found in the
        /// [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] dimension.
        ///
        /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric]: crate::model::TimeseriesParams::metric
        Sum,
        /// Aggregate multiple events by averaging out the values found in the
        /// [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] dimension.
        ///
        /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.metric]: crate::model::TimeseriesParams::metric
        Average,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AggregationMethod::value] or
        /// [AggregationMethod::name].
        UnknownValue(aggregation_method::UnknownValue),
    }

    #[doc(hidden)]
    pub mod aggregation_method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AggregationMethod {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Sum => std::option::Option::Some(1),
                Self::Average => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AGGREGATION_METHOD_UNSPECIFIED"),
                Self::Sum => std::option::Option::Some("SUM"),
                Self::Average => std::option::Option::Some("AVERAGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AggregationMethod {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AggregationMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AggregationMethod {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Sum,
                2 => Self::Average,
                _ => Self::UnknownValue(aggregation_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AggregationMethod {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AGGREGATION_METHOD_UNSPECIFIED" => Self::Unspecified,
                "SUM" => Self::Sum,
                "AVERAGE" => Self::Average,
                _ => Self::UnknownValue(aggregation_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AggregationMethod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Sum => serializer.serialize_i32(1),
                Self::Average => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AggregationMethod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AggregationMethod>::new(
                ".google.cloud.timeseriesinsights.v1.TimeseriesParams.AggregationMethod",
            ))
        }
    }
}

/// Request for performing a query against a loaded DataSet.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryDataSetRequest {
    /// Required. Loaded DataSet to be queried in the format of
    /// "projects/{project}/datasets/{dataset}"
    pub name: std::string::String,

    /// Required. This is the point in time that we want to probe for anomalies.
    ///
    /// The corresponding [TimeseriesPoint][google.cloud.timeseriesinsights.v1.TimeseriesPoint] is referred to as the
    /// detection point.
    ///
    /// **NOTE**: As with any other time series point, the value is given by
    /// aggregating all events in the slice that are in the
    /// [detectionTime, detectionTime + granularity) time interval, where
    /// the granularity is specified in the
    /// [timeseriesParams.granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity] field.
    ///
    /// [google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity]: crate::model::TimeseriesParams::granularity
    /// [google.cloud.timeseriesinsights.v1.TimeseriesPoint]: crate::model::TimeseriesPoint
    pub detection_time: std::option::Option<wkt::Timestamp>,

    /// How many slices are returned in
    /// [QueryDataSetResponse.slices][google.cloud.timeseriesinsights.v1.QueryDataSetResponse.slices].
    ///
    /// The returned slices are tentatively the ones with the highest
    /// [anomaly scores][google.cloud.timeseriesinsights.v1.EvaluatedSlice.anomaly_score] in the dataset that match
    /// the query, but it is not guaranteed.
    ///
    /// Reducing this number will improve query performance, both in terms of
    /// latency and resource usage.
    ///
    /// Defaults to 50.
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.anomaly_score]: crate::model::EvaluatedSlice::anomaly_score
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetResponse.slices]: crate::model::QueryDataSetResponse::slices
    pub num_returned_slices: std::option::Option<i32>,

    /// Parameters controlling how we will split the dataset into the slices that
    /// we will analyze.
    pub slicing_params: std::option::Option<crate::model::SlicingParams>,

    /// Parameters controlling how we will build the time series used to predict
    /// the [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] value for each slice.
    ///
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    pub timeseries_params: std::option::Option<crate::model::TimeseriesParams>,

    /// Parameters that control the time series forecasting models, such as the
    /// sensitivity of the anomaly detection.
    pub forecast_params: std::option::Option<crate::model::ForecastParams>,

    /// If specified, we will return the actual and forecasted time for all
    /// returned slices.
    ///
    /// The time series are returned in the
    /// [EvaluatedSlice.history][google.cloud.timeseriesinsights.v1.EvaluatedSlice.history] and
    /// [EvaluatedSlice.forecast][google.cloud.timeseriesinsights.v1.EvaluatedSlice.forecast] fields.
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.forecast]: crate::model::EvaluatedSlice::forecast
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.history]: crate::model::EvaluatedSlice::history
    pub return_timeseries: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryDataSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QueryDataSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [detection_time][crate::model::QueryDataSetRequest::detection_time].
    pub fn set_detection_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.detection_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [detection_time][crate::model::QueryDataSetRequest::detection_time].
    pub fn set_or_clear_detection_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.detection_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [num_returned_slices][crate::model::QueryDataSetRequest::num_returned_slices].
    pub fn set_num_returned_slices<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.num_returned_slices = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [num_returned_slices][crate::model::QueryDataSetRequest::num_returned_slices].
    pub fn set_or_clear_num_returned_slices<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.num_returned_slices = v.map(|x| x.into());
        self
    }

    /// Sets the value of [slicing_params][crate::model::QueryDataSetRequest::slicing_params].
    pub fn set_slicing_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SlicingParams>,
    {
        self.slicing_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [slicing_params][crate::model::QueryDataSetRequest::slicing_params].
    pub fn set_or_clear_slicing_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SlicingParams>,
    {
        self.slicing_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timeseries_params][crate::model::QueryDataSetRequest::timeseries_params].
    pub fn set_timeseries_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeseriesParams>,
    {
        self.timeseries_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeseries_params][crate::model::QueryDataSetRequest::timeseries_params].
    pub fn set_or_clear_timeseries_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeseriesParams>,
    {
        self.timeseries_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [forecast_params][crate::model::QueryDataSetRequest::forecast_params].
    pub fn set_forecast_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ForecastParams>,
    {
        self.forecast_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [forecast_params][crate::model::QueryDataSetRequest::forecast_params].
    pub fn set_or_clear_forecast_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ForecastParams>,
    {
        self.forecast_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [return_timeseries][crate::model::QueryDataSetRequest::return_timeseries].
    pub fn set_return_timeseries<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.return_timeseries = v.into();
        self
    }
}

impl wkt::message::Message for QueryDataSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.QueryDataSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryDataSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __detection_time,
            __num_returned_slices,
            __slicing_params,
            __timeseries_params,
            __forecast_params,
            __return_timeseries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryDataSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "detectionTime" => Ok(__FieldTag::__detection_time),
                            "detection_time" => Ok(__FieldTag::__detection_time),
                            "numReturnedSlices" => Ok(__FieldTag::__num_returned_slices),
                            "num_returned_slices" => Ok(__FieldTag::__num_returned_slices),
                            "slicingParams" => Ok(__FieldTag::__slicing_params),
                            "slicing_params" => Ok(__FieldTag::__slicing_params),
                            "timeseriesParams" => Ok(__FieldTag::__timeseries_params),
                            "timeseries_params" => Ok(__FieldTag::__timeseries_params),
                            "forecastParams" => Ok(__FieldTag::__forecast_params),
                            "forecast_params" => Ok(__FieldTag::__forecast_params),
                            "returnTimeseries" => Ok(__FieldTag::__return_timeseries),
                            "return_timeseries" => Ok(__FieldTag::__return_timeseries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryDataSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryDataSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__detection_time => {
                            if !fields.insert(__FieldTag::__detection_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detection_time",
                                ));
                            }
                            result.detection_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__num_returned_slices => {
                            if !fields.insert(__FieldTag::__num_returned_slices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_returned_slices",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_returned_slices = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__slicing_params => {
                            if !fields.insert(__FieldTag::__slicing_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slicing_params",
                                ));
                            }
                            result.slicing_params = map
                                .next_value::<std::option::Option<crate::model::SlicingParams>>()?;
                        }
                        __FieldTag::__timeseries_params => {
                            if !fields.insert(__FieldTag::__timeseries_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeseries_params",
                                ));
                            }
                            result.timeseries_params = map
                                .next_value::<std::option::Option<crate::model::TimeseriesParams>>(
                                )?;
                        }
                        __FieldTag::__forecast_params => {
                            if !fields.insert(__FieldTag::__forecast_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forecast_params",
                                ));
                            }
                            result.forecast_params = map
                                .next_value::<std::option::Option<crate::model::ForecastParams>>(
                                )?;
                        }
                        __FieldTag::__return_timeseries => {
                            if !fields.insert(__FieldTag::__return_timeseries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for return_timeseries",
                                ));
                            }
                            result.return_timeseries = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryDataSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.detection_time.is_some() {
            state.serialize_entry("detectionTime", &self.detection_time)?;
        }
        if self.num_returned_slices.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("numReturnedSlices", &__With(&self.num_returned_slices))?;
        }
        if self.slicing_params.is_some() {
            state.serialize_entry("slicingParams", &self.slicing_params)?;
        }
        if self.timeseries_params.is_some() {
            state.serialize_entry("timeseriesParams", &self.timeseries_params)?;
        }
        if self.forecast_params.is_some() {
            state.serialize_entry("forecastParams", &self.forecast_params)?;
        }
        if !wkt::internal::is_default(&self.return_timeseries) {
            state.serialize_entry("returnTimeseries", &self.return_timeseries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for a query executed by the system.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryDataSetResponse {
    /// Loaded DataSet that was queried.
    pub name: std::string::String,

    /// Slices sorted in descending order by their
    /// [anomalyScore][google.cloud.timeseriesinsights.v1.EvaluatedSlice.anomaly_score].
    ///
    /// At most [numReturnedSlices][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.num_returned_slices]
    /// slices are present in this field.
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluatedSlice.anomaly_score]: crate::model::EvaluatedSlice::anomaly_score
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.num_returned_slices]: crate::model::QueryDataSetRequest::num_returned_slices
    pub slices: std::vec::Vec<crate::model::EvaluatedSlice>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryDataSetResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QueryDataSetResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [slices][crate::model::QueryDataSetResponse::slices].
    pub fn set_slices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EvaluatedSlice>,
    {
        use std::iter::Iterator;
        self.slices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for QueryDataSetResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.QueryDataSetResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryDataSetResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __slices,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryDataSetResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "slices" => Ok(__FieldTag::__slices),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryDataSetResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryDataSetResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__slices => {
                            if !fields.insert(__FieldTag::__slices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slices",
                                ));
                            }
                            result.slices =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EvaluatedSlice>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryDataSetResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.slices.is_empty() {
            state.serialize_entry("slices", &self.slices)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for evaluateSlice.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EvaluateSliceRequest {
    /// Required. Loaded DataSet to be queried in the format of
    /// "projects/{project}/datasets/{dataset}"
    pub dataset: std::string::String,

    /// Required. Dimensions with pinned values that specify the slice for which we will
    /// fetch the time series.
    pub pinned_dimensions: std::vec::Vec<crate::model::PinnedDimension>,

    /// Required. This is the point in time that we want to probe for anomalies.
    ///
    /// See documentation for
    /// [QueryDataSetRequest.detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time].
    ///
    /// [google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time]: crate::model::QueryDataSetRequest::detection_time
    pub detection_time: std::option::Option<wkt::Timestamp>,

    /// Parameters controlling how we will build the time series used to predict
    /// the [detectionTime][google.cloud.timeseriesinsights.v1.EvaluateSliceRequest.detection_time] value for this slice.
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluateSliceRequest.detection_time]: crate::model::EvaluateSliceRequest::detection_time
    pub timeseries_params: std::option::Option<crate::model::TimeseriesParams>,

    /// Parameters that control the time series forecasting models, such as the
    /// sensitivity of the anomaly detection.
    pub forecast_params: std::option::Option<crate::model::ForecastParams>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EvaluateSliceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::EvaluateSliceRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [pinned_dimensions][crate::model::EvaluateSliceRequest::pinned_dimensions].
    pub fn set_pinned_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PinnedDimension>,
    {
        use std::iter::Iterator;
        self.pinned_dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [detection_time][crate::model::EvaluateSliceRequest::detection_time].
    pub fn set_detection_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.detection_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [detection_time][crate::model::EvaluateSliceRequest::detection_time].
    pub fn set_or_clear_detection_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.detection_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timeseries_params][crate::model::EvaluateSliceRequest::timeseries_params].
    pub fn set_timeseries_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeseriesParams>,
    {
        self.timeseries_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeseries_params][crate::model::EvaluateSliceRequest::timeseries_params].
    pub fn set_or_clear_timeseries_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeseriesParams>,
    {
        self.timeseries_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [forecast_params][crate::model::EvaluateSliceRequest::forecast_params].
    pub fn set_forecast_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ForecastParams>,
    {
        self.forecast_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [forecast_params][crate::model::EvaluateSliceRequest::forecast_params].
    pub fn set_or_clear_forecast_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ForecastParams>,
    {
        self.forecast_params = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EvaluateSliceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.EvaluateSliceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EvaluateSliceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset,
            __pinned_dimensions,
            __detection_time,
            __timeseries_params,
            __forecast_params,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvaluateSliceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataset" => Ok(__FieldTag::__dataset),
                            "pinnedDimensions" => Ok(__FieldTag::__pinned_dimensions),
                            "pinned_dimensions" => Ok(__FieldTag::__pinned_dimensions),
                            "detectionTime" => Ok(__FieldTag::__detection_time),
                            "detection_time" => Ok(__FieldTag::__detection_time),
                            "timeseriesParams" => Ok(__FieldTag::__timeseries_params),
                            "timeseries_params" => Ok(__FieldTag::__timeseries_params),
                            "forecastParams" => Ok(__FieldTag::__forecast_params),
                            "forecast_params" => Ok(__FieldTag::__forecast_params),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EvaluateSliceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvaluateSliceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pinned_dimensions => {
                            if !fields.insert(__FieldTag::__pinned_dimensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pinned_dimensions",
                                ));
                            }
                            result.pinned_dimensions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PinnedDimension>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__detection_time => {
                            if !fields.insert(__FieldTag::__detection_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detection_time",
                                ));
                            }
                            result.detection_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__timeseries_params => {
                            if !fields.insert(__FieldTag::__timeseries_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeseries_params",
                                ));
                            }
                            result.timeseries_params = map
                                .next_value::<std::option::Option<crate::model::TimeseriesParams>>(
                                )?;
                        }
                        __FieldTag::__forecast_params => {
                            if !fields.insert(__FieldTag::__forecast_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forecast_params",
                                ));
                            }
                            result.forecast_params = map
                                .next_value::<std::option::Option<crate::model::ForecastParams>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EvaluateSliceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dataset.is_empty() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if !self.pinned_dimensions.is_empty() {
            state.serialize_entry("pinnedDimensions", &self.pinned_dimensions)?;
        }
        if self.detection_time.is_some() {
            state.serialize_entry("detectionTime", &self.detection_time)?;
        }
        if self.timeseries_params.is_some() {
            state.serialize_entry("timeseriesParams", &self.timeseries_params)?;
        }
        if self.forecast_params.is_some() {
            state.serialize_entry("forecastParams", &self.forecast_params)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for evaluateTimeseries.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EvaluateTimeseriesRequest {
    /// Required. Client project name in the format of 'projects/{project}'.
    pub parent: std::string::String,

    /// Evaluate this time series without requiring it was previously loaded in
    /// a data set.
    ///
    /// The evaluated time series point is the last one, analogous to calling
    /// evaluateSlice or query with
    /// [detectionTime][google.cloud.timeseriesinsights.v1.EvaluateSliceRequest.detection_time] set to
    /// `timeseries.point(timeseries.point_size() - 1).time`.
    ///
    /// The length of the time series must be at least 10.
    ///
    /// All points must have the same time offset relative to the granularity. For
    /// example, if the [granularity][google.cloud.timeseriesinsights.v1.EvaluateTimeseriesRequest.granularity] is "5s", then the following
    /// point.time sequences are valid:
    ///
    /// - "100s", "105s", "120s", "125s" (no offset)
    /// - "102s", "107s", "122s", "127s" (offset is "2s")
    ///   However, the following sequence is invalid as it has inconsistent offsets:
    /// - "100s", "105s", "122s", "127s" (offsets are either "0s" or "2s")
    ///
    /// [google.cloud.timeseriesinsights.v1.EvaluateSliceRequest.detection_time]: crate::model::EvaluateSliceRequest::detection_time
    /// [google.cloud.timeseriesinsights.v1.EvaluateTimeseriesRequest.granularity]: crate::model::EvaluateTimeseriesRequest::granularity
    pub timeseries: std::option::Option<crate::model::Timeseries>,

    /// The granularity of the time series (time distance between two consecutive
    /// points).
    pub granularity: std::option::Option<wkt::Duration>,

    /// The forecast parameters.
    pub forecast_params: std::option::Option<crate::model::ForecastParams>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EvaluateTimeseriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::EvaluateTimeseriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [timeseries][crate::model::EvaluateTimeseriesRequest::timeseries].
    pub fn set_timeseries<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Timeseries>,
    {
        self.timeseries = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeseries][crate::model::EvaluateTimeseriesRequest::timeseries].
    pub fn set_or_clear_timeseries<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Timeseries>,
    {
        self.timeseries = v.map(|x| x.into());
        self
    }

    /// Sets the value of [granularity][crate::model::EvaluateTimeseriesRequest::granularity].
    pub fn set_granularity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.granularity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [granularity][crate::model::EvaluateTimeseriesRequest::granularity].
    pub fn set_or_clear_granularity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.granularity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [forecast_params][crate::model::EvaluateTimeseriesRequest::forecast_params].
    pub fn set_forecast_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ForecastParams>,
    {
        self.forecast_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [forecast_params][crate::model::EvaluateTimeseriesRequest::forecast_params].
    pub fn set_or_clear_forecast_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ForecastParams>,
    {
        self.forecast_params = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EvaluateTimeseriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.timeseriesinsights.v1.EvaluateTimeseriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EvaluateTimeseriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __timeseries,
            __granularity,
            __forecast_params,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvaluateTimeseriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "timeseries" => Ok(__FieldTag::__timeseries),
                            "granularity" => Ok(__FieldTag::__granularity),
                            "forecastParams" => Ok(__FieldTag::__forecast_params),
                            "forecast_params" => Ok(__FieldTag::__forecast_params),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EvaluateTimeseriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvaluateTimeseriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__timeseries => {
                            if !fields.insert(__FieldTag::__timeseries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeseries",
                                ));
                            }
                            result.timeseries =
                                map.next_value::<std::option::Option<crate::model::Timeseries>>()?;
                        }
                        __FieldTag::__granularity => {
                            if !fields.insert(__FieldTag::__granularity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for granularity",
                                ));
                            }
                            result.granularity =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__forecast_params => {
                            if !fields.insert(__FieldTag::__forecast_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forecast_params",
                                ));
                            }
                            result.forecast_params = map
                                .next_value::<std::option::Option<crate::model::ForecastParams>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EvaluateTimeseriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.timeseries.is_some() {
            state.serialize_entry("timeseries", &self.timeseries)?;
        }
        if self.granularity.is_some() {
            state.serialize_entry("granularity", &self.granularity)?;
        }
        if self.forecast_params.is_some() {
            state.serialize_entry("forecastParams", &self.forecast_params)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
