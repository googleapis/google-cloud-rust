// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

mod debug;
mod deserialize;
mod serialize;

/// A Challenge from the server used to guarantee freshness of attestations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Challenge {
    /// Output only. The resource name for this Challenge in the format
    /// `projects/*/locations/*/challenges/*`
    pub name: std::string::String,

    /// Output only. The time at which this Challenge was created
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this Challenge will no longer be usable. It
    /// is also the expiration time for any tokens generated from this Challenge.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Indicates if this challenge has been used to generate a token.
    pub used: bool,

    /// Output only. Identical to nonce, but as a string.
    pub tpm_nonce: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Challenge {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Challenge::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Challenge::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Challenge::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::Challenge::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::Challenge::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [used][crate::model::Challenge::used].
    pub fn set_used<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.used = v.into();
        self
    }

    /// Sets the value of [tpm_nonce][crate::model::Challenge::tpm_nonce].
    pub fn set_tpm_nonce<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tpm_nonce = v.into();
        self
    }
}

impl wkt::message::Message for Challenge {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.Challenge"
    }
}

/// Message for creating a Challenge
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateChallengeRequest {
    /// Required. The resource name of the location where the Challenge will be
    /// used, in the format `projects/*/locations/*`.
    pub parent: std::string::String,

    /// Required. The Challenge to be created. Currently this field can be empty as
    /// all the Challenge fields are set by the server.
    pub challenge: std::option::Option<crate::model::Challenge>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateChallengeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateChallengeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [challenge][crate::model::CreateChallengeRequest::challenge].
    pub fn set_challenge<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Challenge>,
    {
        self.challenge = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [challenge][crate::model::CreateChallengeRequest::challenge].
    pub fn set_or_clear_challenge<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Challenge>,
    {
        self.challenge = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateChallengeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.CreateChallengeRequest"
    }
}

/// A request for an attestation token, providing all the necessary information
/// needed for this service to verify the platform state of the requestor.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VerifyAttestationRequest {
    /// Required. The name of the Challenge whose nonce was used to generate the
    /// attestation, in the format `projects/*/locations/*/challenges/*`. The
    /// provided Challenge will be consumed, and cannot be used again.
    pub challenge: std::string::String,

    /// Optional. Credentials used to populate the "emails" claim in the
    /// claims_token.
    pub gcp_credentials: std::option::Option<crate::model::GcpCredentials>,

    /// Required. The TPM-specific data provided by the attesting platform, used to
    /// populate any of the claims regarding platform state.
    pub tpm_attestation: std::option::Option<crate::model::TpmAttestation>,

    /// Optional. Optional information related to the Confidential Space TEE.
    pub confidential_space_info: std::option::Option<crate::model::ConfidentialSpaceInfo>,

    /// Optional. A collection of optional, workload-specified claims that modify
    /// the token output.
    pub token_options: std::option::Option<crate::model::TokenOptions>,

    /// Optional. An optional indicator of the attester, only applies to certain
    /// products.
    pub attester: std::string::String,

    /// An optional tee attestation report, used to populate hardware rooted
    /// claims.
    pub tee_attestation:
        std::option::Option<crate::model::verify_attestation_request::TeeAttestation>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyAttestationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [challenge][crate::model::VerifyAttestationRequest::challenge].
    pub fn set_challenge<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.challenge = v.into();
        self
    }

    /// Sets the value of [gcp_credentials][crate::model::VerifyAttestationRequest::gcp_credentials].
    pub fn set_gcp_credentials<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GcpCredentials>,
    {
        self.gcp_credentials = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gcp_credentials][crate::model::VerifyAttestationRequest::gcp_credentials].
    pub fn set_or_clear_gcp_credentials<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GcpCredentials>,
    {
        self.gcp_credentials = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tpm_attestation][crate::model::VerifyAttestationRequest::tpm_attestation].
    pub fn set_tpm_attestation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TpmAttestation>,
    {
        self.tpm_attestation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tpm_attestation][crate::model::VerifyAttestationRequest::tpm_attestation].
    pub fn set_or_clear_tpm_attestation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TpmAttestation>,
    {
        self.tpm_attestation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [confidential_space_info][crate::model::VerifyAttestationRequest::confidential_space_info].
    pub fn set_confidential_space_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialSpaceInfo>,
    {
        self.confidential_space_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [confidential_space_info][crate::model::VerifyAttestationRequest::confidential_space_info].
    pub fn set_or_clear_confidential_space_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialSpaceInfo>,
    {
        self.confidential_space_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [token_options][crate::model::VerifyAttestationRequest::token_options].
    pub fn set_token_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TokenOptions>,
    {
        self.token_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [token_options][crate::model::VerifyAttestationRequest::token_options].
    pub fn set_or_clear_token_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TokenOptions>,
    {
        self.token_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attester][crate::model::VerifyAttestationRequest::attester].
    pub fn set_attester<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.attester = v.into();
        self
    }

    /// Sets the value of [tee_attestation][crate::model::VerifyAttestationRequest::tee_attestation].
    ///
    /// Note that all the setters affecting `tee_attestation` are mutually
    /// exclusive.
    pub fn set_tee_attestation<
        T: std::convert::Into<
                std::option::Option<crate::model::verify_attestation_request::TeeAttestation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tee_attestation = v.into();
        self
    }

    /// The value of [tee_attestation][crate::model::VerifyAttestationRequest::tee_attestation]
    /// if it holds a `TdCcel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn td_ccel(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TdxCcelAttestation>> {
        #[allow(unreachable_patterns)]
        self.tee_attestation.as_ref().and_then(|v| match v {
            crate::model::verify_attestation_request::TeeAttestation::TdCcel(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tee_attestation][crate::model::VerifyAttestationRequest::tee_attestation]
    /// to hold a `TdCcel`.
    ///
    /// Note that all the setters affecting `tee_attestation` are
    /// mutually exclusive.
    pub fn set_td_ccel<T: std::convert::Into<std::boxed::Box<crate::model::TdxCcelAttestation>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tee_attestation = std::option::Option::Some(
            crate::model::verify_attestation_request::TeeAttestation::TdCcel(v.into()),
        );
        self
    }

    /// The value of [tee_attestation][crate::model::VerifyAttestationRequest::tee_attestation]
    /// if it holds a `SevSnpAttestation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sev_snp_attestation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SevSnpAttestation>> {
        #[allow(unreachable_patterns)]
        self.tee_attestation.as_ref().and_then(|v| match v {
            crate::model::verify_attestation_request::TeeAttestation::SevSnpAttestation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tee_attestation][crate::model::VerifyAttestationRequest::tee_attestation]
    /// to hold a `SevSnpAttestation`.
    ///
    /// Note that all the setters affecting `tee_attestation` are
    /// mutually exclusive.
    pub fn set_sev_snp_attestation<
        T: std::convert::Into<std::boxed::Box<crate::model::SevSnpAttestation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tee_attestation = std::option::Option::Some(
            crate::model::verify_attestation_request::TeeAttestation::SevSnpAttestation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for VerifyAttestationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.VerifyAttestationRequest"
    }
}

/// Defines additional types related to [VerifyAttestationRequest].
pub mod verify_attestation_request {
    #[allow(unused_imports)]
    use super::*;

    /// An optional tee attestation report, used to populate hardware rooted
    /// claims.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TeeAttestation {
        /// Optional. A TDX with CCEL and RTMR Attestation Quote.
        TdCcel(std::boxed::Box<crate::model::TdxCcelAttestation>),
        /// Optional. An SEV-SNP Attestation Report.
        SevSnpAttestation(std::boxed::Box<crate::model::SevSnpAttestation>),
    }
}

/// A TDX Attestation quote.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TdxCcelAttestation {
    /// Optional. The Confidential Computing Event Log (CCEL) ACPI table. Formatted
    /// as described in the ACPI Specification 6.5.
    pub ccel_acpi_table: ::bytes::Bytes,

    /// Optional. The CCEL event log. Formatted as described in the UEFI 2.10.
    pub ccel_data: ::bytes::Bytes,

    /// Optional. An Event Log containing additional events measured into the RTMR
    /// that are not already present in the CCEL.
    pub canonical_event_log: ::bytes::Bytes,

    /// Optional. The TDX attestation quote from the guest. It contains the RTMR
    /// values.
    pub td_quote: ::bytes::Bytes,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TdxCcelAttestation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ccel_acpi_table][crate::model::TdxCcelAttestation::ccel_acpi_table].
    pub fn set_ccel_acpi_table<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.ccel_acpi_table = v.into();
        self
    }

    /// Sets the value of [ccel_data][crate::model::TdxCcelAttestation::ccel_data].
    pub fn set_ccel_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.ccel_data = v.into();
        self
    }

    /// Sets the value of [canonical_event_log][crate::model::TdxCcelAttestation::canonical_event_log].
    pub fn set_canonical_event_log<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.canonical_event_log = v.into();
        self
    }

    /// Sets the value of [td_quote][crate::model::TdxCcelAttestation::td_quote].
    pub fn set_td_quote<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.td_quote = v.into();
        self
    }
}

impl wkt::message::Message for TdxCcelAttestation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.TdxCcelAttestation"
    }
}

/// An SEV-SNP Attestation Report.
/// Contains the attestation report and the certificate bundle that the client
/// collects.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SevSnpAttestation {
    /// Optional. The SEV-SNP Attestation Report
    /// Format is in revision 1.55, ยง7.3 Attestation, Table 22. ATTESTATION_REPORT
    /// Structure in this document:
    /// <https://www.amd.com/content/dam/amd/en/documents/epyc-technical-docs/specifications/56860.pdf>
    pub report: ::bytes::Bytes,

    /// Optional. Certificate bundle defined in the GHCB protocol definition
    /// Format is documented in GHCB revision 2.03, section 4.1.8.1 struct
    /// cert_table in this document:
    /// <https://www.amd.com/content/dam/amd/en/documents/epyc-technical-docs/specifications/56421.pdf>
    pub aux_blob: ::bytes::Bytes,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SevSnpAttestation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [report][crate::model::SevSnpAttestation::report].
    pub fn set_report<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.report = v.into();
        self
    }

    /// Sets the value of [aux_blob][crate::model::SevSnpAttestation::aux_blob].
    pub fn set_aux_blob<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.aux_blob = v.into();
        self
    }
}

impl wkt::message::Message for SevSnpAttestation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.SevSnpAttestation"
    }
}

/// A response once an attestation has been successfully verified, containing a
/// signed attestation token.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VerifyAttestationResponse {
    /// Output only. Same as claims_token, but as a string.
    pub oidc_claims_token: std::string::String,

    /// Output only. A list of messages that carry the partial error details
    /// related to VerifyAttestation.
    pub partial_errors: std::vec::Vec<rpc::model::Status>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyAttestationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [oidc_claims_token][crate::model::VerifyAttestationResponse::oidc_claims_token].
    pub fn set_oidc_claims_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.oidc_claims_token = v.into();
        self
    }

    /// Sets the value of [partial_errors][crate::model::VerifyAttestationResponse::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VerifyAttestationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.VerifyAttestationResponse"
    }
}

/// Credentials issued by GCP which are linked to the platform attestation. These
/// will be verified server-side as part of attestaion verification.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcpCredentials {
    /// Same as id_tokens, but as a string.
    pub service_account_id_tokens: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcpCredentials {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account_id_tokens][crate::model::GcpCredentials::service_account_id_tokens].
    pub fn set_service_account_id_tokens<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.service_account_id_tokens = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GcpCredentials {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.GcpCredentials"
    }
}

/// Options to modify claims in the token to generate custom-purpose tokens.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TokenOptions {
    /// Optional. Optional string to issue the token with a custom audience claim.
    /// Required if one or more nonces are specified.
    pub audience: std::string::String,

    /// Optional. Optional parameter to place one or more nonces in the eat_nonce
    /// claim in the output token. The minimum size for JSON-encoded EATs is 10
    /// bytes and the maximum size is 74 bytes.
    pub nonce: std::vec::Vec<std::string::String>,

    /// Optional. Optional token type to select what type of token to return.
    pub token_type: crate::model::TokenType,

    /// An optional additional configuration per token type.
    pub token_type_options: std::option::Option<crate::model::token_options::TokenTypeOptions>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TokenOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audience][crate::model::TokenOptions::audience].
    pub fn set_audience<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audience = v.into();
        self
    }

    /// Sets the value of [nonce][crate::model::TokenOptions::nonce].
    pub fn set_nonce<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.nonce = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [token_type][crate::model::TokenOptions::token_type].
    pub fn set_token_type<T: std::convert::Into<crate::model::TokenType>>(mut self, v: T) -> Self {
        self.token_type = v.into();
        self
    }

    /// Sets the value of [token_type_options][crate::model::TokenOptions::token_type_options].
    ///
    /// Note that all the setters affecting `token_type_options` are mutually
    /// exclusive.
    pub fn set_token_type_options<
        T: std::convert::Into<std::option::Option<crate::model::token_options::TokenTypeOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.token_type_options = v.into();
        self
    }

    /// The value of [token_type_options][crate::model::TokenOptions::token_type_options]
    /// if it holds a `AwsPrincipalTagsOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_principal_tags_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AwsPrincipalTagsOptions>> {
        #[allow(unreachable_patterns)]
        self.token_type_options.as_ref().and_then(|v| match v {
            crate::model::token_options::TokenTypeOptions::AwsPrincipalTagsOptions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [token_type_options][crate::model::TokenOptions::token_type_options]
    /// to hold a `AwsPrincipalTagsOptions`.
    ///
    /// Note that all the setters affecting `token_type_options` are
    /// mutually exclusive.
    pub fn set_aws_principal_tags_options<
        T: std::convert::Into<std::boxed::Box<crate::model::AwsPrincipalTagsOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.token_type_options = std::option::Option::Some(
            crate::model::token_options::TokenTypeOptions::AwsPrincipalTagsOptions(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TokenOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.TokenOptions"
    }
}

/// Defines additional types related to [TokenOptions].
pub mod token_options {
    #[allow(unused_imports)]
    use super::*;

    /// An optional additional configuration per token type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TokenTypeOptions {
        /// Optional. Options for AWS token type.
        AwsPrincipalTagsOptions(std::boxed::Box<crate::model::AwsPrincipalTagsOptions>),
    }
}

/// Token options that only apply to the AWS Principal Tags token type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsPrincipalTagsOptions {
    /// Optional. Principal tags to allow in the token.
    pub allowed_principal_tags:
        std::option::Option<crate::model::aws_principal_tags_options::AllowedPrincipalTags>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsPrincipalTagsOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowed_principal_tags][crate::model::AwsPrincipalTagsOptions::allowed_principal_tags].
    pub fn set_allowed_principal_tags<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::aws_principal_tags_options::AllowedPrincipalTags>,
    {
        self.allowed_principal_tags = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [allowed_principal_tags][crate::model::AwsPrincipalTagsOptions::allowed_principal_tags].
    pub fn set_or_clear_allowed_principal_tags<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::aws_principal_tags_options::AllowedPrincipalTags>,
    {
        self.allowed_principal_tags = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AwsPrincipalTagsOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.AwsPrincipalTagsOptions"
    }
}

/// Defines additional types related to [AwsPrincipalTagsOptions].
pub mod aws_principal_tags_options {
    #[allow(unused_imports)]
    use super::*;

    /// Allowed principal tags is used to define what principal tags will be
    /// placed in the token.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AllowedPrincipalTags {

        /// Optional. Container image signatures allowed in the token.
        pub container_image_signatures: std::option::Option<crate::model::aws_principal_tags_options::allowed_principal_tags::ContainerImageSignatures>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AllowedPrincipalTags {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [container_image_signatures][crate::model::aws_principal_tags_options::AllowedPrincipalTags::container_image_signatures].
        pub fn set_container_image_signatures<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::aws_principal_tags_options::allowed_principal_tags::ContainerImageSignatures>
        {
            self.container_image_signatures = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [container_image_signatures][crate::model::aws_principal_tags_options::AllowedPrincipalTags::container_image_signatures].
        pub fn set_or_clear_container_image_signatures<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::aws_principal_tags_options::allowed_principal_tags::ContainerImageSignatures>
        {
            self.container_image_signatures = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for AllowedPrincipalTags {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.confidentialcomputing.v1.AwsPrincipalTagsOptions.AllowedPrincipalTags"
        }
    }

    /// Defines additional types related to [AllowedPrincipalTags].
    pub mod allowed_principal_tags {
        #[allow(unused_imports)]
        use super::*;

        /// Allowed Container Image Signatures. Key IDs are required to allow
        /// this claim to fit within the narrow AWS IAM restrictions.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ContainerImageSignatures {
            /// Optional. List of key ids to filter into the Principal tags. Only keys
            /// that have been validated and added to the token will be filtered into
            /// principal tags. Unrecognized key ids will be ignored.
            pub key_ids: std::vec::Vec<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ContainerImageSignatures {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key_ids][crate::model::aws_principal_tags_options::allowed_principal_tags::ContainerImageSignatures::key_ids].
            pub fn set_key_ids<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.key_ids = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for ContainerImageSignatures {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.confidentialcomputing.v1.AwsPrincipalTagsOptions.AllowedPrincipalTags.ContainerImageSignatures"
            }
        }
    }
}

/// TPM2 data containing everything necessary to validate any platform state
/// measured into the TPM.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TpmAttestation {
    /// TPM2 PCR Quotes generated by calling TPM2_Quote on each PCR bank.
    pub quotes: std::vec::Vec<crate::model::tpm_attestation::Quote>,

    /// The binary TCG Event Log containing events measured into the TPM by the
    /// platform firmware and operating system. Formatted as described in the
    /// "TCG PC Client Platform Firmware Profile Specification".
    pub tcg_event_log: ::bytes::Bytes,

    /// An Event Log containing additional events measured into the TPM that are
    /// not already present in the tcg_event_log. Formatted as described in the
    /// "Canonical Event Log Format" TCG Specification.
    pub canonical_event_log: ::bytes::Bytes,

    /// DER-encoded X.509 certificate of the Attestation Key (otherwise known as
    /// an AK or a TPM restricted signing key) used to generate the quotes.
    pub ak_cert: ::bytes::Bytes,

    /// List of DER-encoded X.509 certificates which, together with the ak_cert,
    /// chain back to a trusted Root Certificate.
    pub cert_chain: std::vec::Vec<::bytes::Bytes>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TpmAttestation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [quotes][crate::model::TpmAttestation::quotes].
    pub fn set_quotes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::tpm_attestation::Quote>,
    {
        use std::iter::Iterator;
        self.quotes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tcg_event_log][crate::model::TpmAttestation::tcg_event_log].
    pub fn set_tcg_event_log<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.tcg_event_log = v.into();
        self
    }

    /// Sets the value of [canonical_event_log][crate::model::TpmAttestation::canonical_event_log].
    pub fn set_canonical_event_log<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.canonical_event_log = v.into();
        self
    }

    /// Sets the value of [ak_cert][crate::model::TpmAttestation::ak_cert].
    pub fn set_ak_cert<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.ak_cert = v.into();
        self
    }

    /// Sets the value of [cert_chain][crate::model::TpmAttestation::cert_chain].
    pub fn set_cert_chain<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.cert_chain = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TpmAttestation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.TpmAttestation"
    }
}

/// Defines additional types related to [TpmAttestation].
pub mod tpm_attestation {
    #[allow(unused_imports)]
    use super::*;

    /// Information about Platform Control Registers (PCRs) including a signature
    /// over their values, which can be used for remote validation.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Quote {
        /// The hash algorithm of the PCR bank being quoted, encoded as a TPM_ALG_ID
        pub hash_algo: i32,

        /// Raw binary values of each PCRs being quoted.
        pub pcr_values: std::collections::HashMap<i32, ::bytes::Bytes>,

        /// TPM2 quote, encoded as a TPMS_ATTEST
        pub raw_quote: ::bytes::Bytes,

        /// TPM2 signature, encoded as a TPMT_SIGNATURE
        pub raw_signature: ::bytes::Bytes,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Quote {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [hash_algo][crate::model::tpm_attestation::Quote::hash_algo].
        pub fn set_hash_algo<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.hash_algo = v.into();
            self
        }

        /// Sets the value of [pcr_values][crate::model::tpm_attestation::Quote::pcr_values].
        pub fn set_pcr_values<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<i32>,
            V: std::convert::Into<::bytes::Bytes>,
        {
            use std::iter::Iterator;
            self.pcr_values = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [raw_quote][crate::model::tpm_attestation::Quote::raw_quote].
        pub fn set_raw_quote<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
            self.raw_quote = v.into();
            self
        }

        /// Sets the value of [raw_signature][crate::model::tpm_attestation::Quote::raw_signature].
        pub fn set_raw_signature<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
            self.raw_signature = v.into();
            self
        }
    }

    impl wkt::message::Message for Quote {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.confidentialcomputing.v1.TpmAttestation.Quote"
        }
    }
}

/// ConfidentialSpaceInfo contains information related to the Confidential Space
/// TEE.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConfidentialSpaceInfo {
    /// Optional. A list of signed entities containing container image signatures
    /// that can be used for server-side signature verification.
    pub signed_entities: std::vec::Vec<crate::model::SignedEntity>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfidentialSpaceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [signed_entities][crate::model::ConfidentialSpaceInfo::signed_entities].
    pub fn set_signed_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SignedEntity>,
    {
        use std::iter::Iterator;
        self.signed_entities = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ConfidentialSpaceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.ConfidentialSpaceInfo"
    }
}

/// SignedEntity represents an OCI image object containing everything necessary
/// to verify container image signatures.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SignedEntity {
    /// Optional. A list of container image signatures attached to an OCI image
    /// object.
    pub container_image_signatures: std::vec::Vec<crate::model::ContainerImageSignature>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SignedEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [container_image_signatures][crate::model::SignedEntity::container_image_signatures].
    pub fn set_container_image_signatures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ContainerImageSignature>,
    {
        use std::iter::Iterator;
        self.container_image_signatures = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SignedEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.SignedEntity"
    }
}

/// ContainerImageSignature holds necessary metadata to verify a container image
/// signature.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ContainerImageSignature {
    /// Optional. The binary signature payload following the SimpleSigning format
    /// <https://github.com/sigstore/cosign/blob/main/specs/SIGNATURE_SPEC.md#simple-signing>.
    /// This payload includes the container image digest.
    pub payload: ::bytes::Bytes,

    /// Optional. A signature over the payload.
    /// The container image digest is incorporated into the signature as follows:
    ///
    /// 1. Generate a SimpleSigning format payload that includes the container
    ///    image digest.
    /// 1. Generate a signature over SHA256 digest of the payload.
    ///    The signature generation process can be represented as follows:
    ///    `Sign(sha256(SimpleSigningPayload(sha256(Image Manifest))))`
    pub signature: ::bytes::Bytes,

    /// Optional. Reserved for future use.
    pub public_key: ::bytes::Bytes,

    /// Optional. Reserved for future use.
    pub sig_alg: crate::model::SigningAlgorithm,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContainerImageSignature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [payload][crate::model::ContainerImageSignature::payload].
    pub fn set_payload<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.payload = v.into();
        self
    }

    /// Sets the value of [signature][crate::model::ContainerImageSignature::signature].
    pub fn set_signature<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.signature = v.into();
        self
    }

    /// Sets the value of [public_key][crate::model::ContainerImageSignature::public_key].
    pub fn set_public_key<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.public_key = v.into();
        self
    }

    /// Sets the value of [sig_alg][crate::model::ContainerImageSignature::sig_alg].
    pub fn set_sig_alg<T: std::convert::Into<crate::model::SigningAlgorithm>>(
        mut self,
        v: T,
    ) -> Self {
        self.sig_alg = v.into();
        self
    }
}

impl wkt::message::Message for ContainerImageSignature {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.ContainerImageSignature"
    }
}

/// A request for an attestation token, providing all the necessary information
/// needed for this service to verify the platform state of the requestor.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VerifyConfidentialSpaceRequest {
    /// Required. The name of the Challenge whose nonce was used to generate the
    /// attestation, in the format `projects/*/locations/*/challenges/*`. The
    /// provided Challenge will be consumed, and cannot be used again.
    pub challenge: std::string::String,

    /// Optional. Credentials used to populate the "emails" claim in the
    /// claims_token. If not present, token will not contain the "emails" claim.
    pub gcp_credentials: std::option::Option<crate::model::GcpCredentials>,

    /// Optional. A list of signed entities containing container image signatures
    /// that can be used for server-side signature verification.
    pub signed_entities: std::vec::Vec<crate::model::SignedEntity>,

    /// Optional. Information about the associated Compute Engine instance.
    /// Required for td_ccel requests only - tpm_attestation requests will provide
    /// this information in the attestation.
    pub gce_shielded_identity: std::option::Option<crate::model::GceShieldedIdentity>,

    /// Optional. A collection of fields that modify the token output.
    pub options: std::option::Option<
        crate::model::verify_confidential_space_request::ConfidentialSpaceOptions,
    >,

    /// Required. A tee attestation report, used to populate hardware rooted
    /// claims.
    pub tee_attestation:
        std::option::Option<crate::model::verify_confidential_space_request::TeeAttestation>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyConfidentialSpaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [challenge][crate::model::VerifyConfidentialSpaceRequest::challenge].
    pub fn set_challenge<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.challenge = v.into();
        self
    }

    /// Sets the value of [gcp_credentials][crate::model::VerifyConfidentialSpaceRequest::gcp_credentials].
    pub fn set_gcp_credentials<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GcpCredentials>,
    {
        self.gcp_credentials = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gcp_credentials][crate::model::VerifyConfidentialSpaceRequest::gcp_credentials].
    pub fn set_or_clear_gcp_credentials<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GcpCredentials>,
    {
        self.gcp_credentials = v.map(|x| x.into());
        self
    }

    /// Sets the value of [signed_entities][crate::model::VerifyConfidentialSpaceRequest::signed_entities].
    pub fn set_signed_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SignedEntity>,
    {
        use std::iter::Iterator;
        self.signed_entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [gce_shielded_identity][crate::model::VerifyConfidentialSpaceRequest::gce_shielded_identity].
    pub fn set_gce_shielded_identity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GceShieldedIdentity>,
    {
        self.gce_shielded_identity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gce_shielded_identity][crate::model::VerifyConfidentialSpaceRequest::gce_shielded_identity].
    pub fn set_or_clear_gce_shielded_identity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GceShieldedIdentity>,
    {
        self.gce_shielded_identity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [options][crate::model::VerifyConfidentialSpaceRequest::options].
    pub fn set_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::verify_confidential_space_request::ConfidentialSpaceOptions,
            >,
    {
        self.options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [options][crate::model::VerifyConfidentialSpaceRequest::options].
    pub fn set_or_clear_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::verify_confidential_space_request::ConfidentialSpaceOptions,
            >,
    {
        self.options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tee_attestation][crate::model::VerifyConfidentialSpaceRequest::tee_attestation].
    ///
    /// Note that all the setters affecting `tee_attestation` are mutually
    /// exclusive.
    pub fn set_tee_attestation<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::verify_confidential_space_request::TeeAttestation,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tee_attestation = v.into();
        self
    }

    /// The value of [tee_attestation][crate::model::VerifyConfidentialSpaceRequest::tee_attestation]
    /// if it holds a `TdCcel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn td_ccel(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TdxCcelAttestation>> {
        #[allow(unreachable_patterns)]
        self.tee_attestation.as_ref().and_then(|v| match v {
            crate::model::verify_confidential_space_request::TeeAttestation::TdCcel(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tee_attestation][crate::model::VerifyConfidentialSpaceRequest::tee_attestation]
    /// to hold a `TdCcel`.
    ///
    /// Note that all the setters affecting `tee_attestation` are
    /// mutually exclusive.
    pub fn set_td_ccel<T: std::convert::Into<std::boxed::Box<crate::model::TdxCcelAttestation>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tee_attestation = std::option::Option::Some(
            crate::model::verify_confidential_space_request::TeeAttestation::TdCcel(v.into()),
        );
        self
    }

    /// The value of [tee_attestation][crate::model::VerifyConfidentialSpaceRequest::tee_attestation]
    /// if it holds a `TpmAttestation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tpm_attestation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TpmAttestation>> {
        #[allow(unreachable_patterns)]
        self.tee_attestation.as_ref().and_then(|v| match v {
            crate::model::verify_confidential_space_request::TeeAttestation::TpmAttestation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tee_attestation][crate::model::VerifyConfidentialSpaceRequest::tee_attestation]
    /// to hold a `TpmAttestation`.
    ///
    /// Note that all the setters affecting `tee_attestation` are
    /// mutually exclusive.
    pub fn set_tpm_attestation<
        T: std::convert::Into<std::boxed::Box<crate::model::TpmAttestation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tee_attestation = std::option::Option::Some(
            crate::model::verify_confidential_space_request::TeeAttestation::TpmAttestation(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for VerifyConfidentialSpaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.VerifyConfidentialSpaceRequest"
    }
}

/// Defines additional types related to [VerifyConfidentialSpaceRequest].
pub mod verify_confidential_space_request {
    #[allow(unused_imports)]
    use super::*;

    /// Token options for Confidential Space attestation.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConfidentialSpaceOptions {

        /// Optional. Optional string to issue the token with a custom audience
        /// claim. Required if custom nonces are specified.
        pub audience: std::string::String,

        /// Optional. Optional specification for token claims profile.
        pub token_profile: crate::model::TokenProfile,

        /// Optional. Optional parameter to place one or more nonces in the eat_nonce
        /// claim in the output token. The minimum size for JSON-encoded EATs is 10
        /// bytes and the maximum size is 74 bytes.
        pub nonce: std::vec::Vec<std::string::String>,

        /// Optional. Optional specification for how to sign the attestation token.
        /// Defaults to SIGNATURE_TYPE_OIDC if unspecified.
        pub signature_type: crate::model::SignatureType,

        /// An optional additional configuration per token type.
        pub token_profile_options: std::option::Option<crate::model::verify_confidential_space_request::confidential_space_options::TokenProfileOptions>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConfidentialSpaceOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [audience][crate::model::verify_confidential_space_request::ConfidentialSpaceOptions::audience].
        pub fn set_audience<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.audience = v.into();
            self
        }

        /// Sets the value of [token_profile][crate::model::verify_confidential_space_request::ConfidentialSpaceOptions::token_profile].
        pub fn set_token_profile<T: std::convert::Into<crate::model::TokenProfile>>(
            mut self,
            v: T,
        ) -> Self {
            self.token_profile = v.into();
            self
        }

        /// Sets the value of [nonce][crate::model::verify_confidential_space_request::ConfidentialSpaceOptions::nonce].
        pub fn set_nonce<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.nonce = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [signature_type][crate::model::verify_confidential_space_request::ConfidentialSpaceOptions::signature_type].
        pub fn set_signature_type<T: std::convert::Into<crate::model::SignatureType>>(
            mut self,
            v: T,
        ) -> Self {
            self.signature_type = v.into();
            self
        }

        /// Sets the value of [token_profile_options][crate::model::verify_confidential_space_request::ConfidentialSpaceOptions::token_profile_options].
        ///
        /// Note that all the setters affecting `token_profile_options` are mutually
        /// exclusive.
        pub fn set_token_profile_options<T: std::convert::Into<std::option::Option<crate::model::verify_confidential_space_request::confidential_space_options::TokenProfileOptions>>>(mut self, v: T) -> Self
        {
            self.token_profile_options = v.into();
            self
        }

        /// The value of [token_profile_options][crate::model::verify_confidential_space_request::ConfidentialSpaceOptions::token_profile_options]
        /// if it holds a `AwsPrincipalTagsOptions`, `None` if the field is not set or
        /// holds a different branch.
        pub fn aws_principal_tags_options(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::AwsPrincipalTagsOptions>> {
            #[allow(unreachable_patterns)]
            self.token_profile_options.as_ref().and_then(|v| match v {
                crate::model::verify_confidential_space_request::confidential_space_options::TokenProfileOptions::AwsPrincipalTagsOptions(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [token_profile_options][crate::model::verify_confidential_space_request::ConfidentialSpaceOptions::token_profile_options]
        /// to hold a `AwsPrincipalTagsOptions`.
        ///
        /// Note that all the setters affecting `token_profile_options` are
        /// mutually exclusive.
        pub fn set_aws_principal_tags_options<
            T: std::convert::Into<std::boxed::Box<crate::model::AwsPrincipalTagsOptions>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.token_profile_options = std::option::Option::Some(
                crate::model::verify_confidential_space_request::confidential_space_options::TokenProfileOptions::AwsPrincipalTagsOptions(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for ConfidentialSpaceOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.confidentialcomputing.v1.VerifyConfidentialSpaceRequest.ConfidentialSpaceOptions"
        }
    }

    /// Defines additional types related to [ConfidentialSpaceOptions].
    pub mod confidential_space_options {
        #[allow(unused_imports)]
        use super::*;

        /// An optional additional configuration per token type.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum TokenProfileOptions {
            /// Optional. Options for the AWS token type.
            AwsPrincipalTagsOptions(std::boxed::Box<crate::model::AwsPrincipalTagsOptions>),
        }
    }

    /// Required. A tee attestation report, used to populate hardware rooted
    /// claims.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TeeAttestation {
        /// Input only. A TDX with CCEL and RTMR Attestation Quote.
        TdCcel(std::boxed::Box<crate::model::TdxCcelAttestation>),
        /// Input only. The TPM-specific data provided by the attesting platform,
        /// used to populate any of the claims regarding platform state.
        TpmAttestation(std::boxed::Box<crate::model::TpmAttestation>),
    }
}

/// GceShieldedIdentity contains information about a Compute Engine instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GceShieldedIdentity {
    /// Optional. DER-encoded X.509 certificate of the Attestation Key (otherwise
    /// known as an AK or a TPM restricted signing key) used to generate the
    /// quotes.
    pub ak_cert: ::bytes::Bytes,

    /// Optional. List of DER-encoded X.509 certificates which, together with the
    /// ak_cert, chain back to a trusted Root Certificate.
    pub ak_cert_chain: std::vec::Vec<::bytes::Bytes>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GceShieldedIdentity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ak_cert][crate::model::GceShieldedIdentity::ak_cert].
    pub fn set_ak_cert<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.ak_cert = v.into();
        self
    }

    /// Sets the value of [ak_cert_chain][crate::model::GceShieldedIdentity::ak_cert_chain].
    pub fn set_ak_cert_chain<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.ak_cert_chain = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GceShieldedIdentity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.GceShieldedIdentity"
    }
}

/// VerifyConfidentialSpaceResponse is returned once a Confidential Space
/// attestation has been successfully verified, containing a signed token.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VerifyConfidentialSpaceResponse {
    /// Output only. The attestation token issued by this service. It contains
    /// specific platform claims based on the contents of the provided attestation.
    pub attestation_token: std::string::String,

    /// Output only. A list of messages that carry the partial error details
    /// related to VerifyConfidentialSpace. This field is populated by errors
    /// during container image signature verification, which may reflect problems
    /// in the provided image signatures. This does not block the issuing of an
    /// attestation token, but the token will not contain claims for the failed
    /// image signatures.
    pub partial_errors: std::vec::Vec<rpc::model::Status>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyConfidentialSpaceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attestation_token][crate::model::VerifyConfidentialSpaceResponse::attestation_token].
    pub fn set_attestation_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attestation_token = v.into();
        self
    }

    /// Sets the value of [partial_errors][crate::model::VerifyConfidentialSpaceResponse::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VerifyConfidentialSpaceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.VerifyConfidentialSpaceResponse"
    }
}

/// A request for an attestation token, providing all the necessary information
/// needed for this service to verify Confidential GKE platform state of the
/// requestor.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VerifyConfidentialGkeRequest {
    /// Required. The name of the Challenge whose nonce was used to generate the
    /// attestation, in the format projects/*/locations/*/challenges/*. The
    /// provided Challenge will be consumed, and cannot be used again.
    pub challenge: std::string::String,

    /// Required. A tee attestation report, used to populate hardware rooted
    /// claims.
    pub tee_attestation:
        std::option::Option<crate::model::verify_confidential_gke_request::TeeAttestation>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyConfidentialGkeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [challenge][crate::model::VerifyConfidentialGkeRequest::challenge].
    pub fn set_challenge<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.challenge = v.into();
        self
    }

    /// Sets the value of [tee_attestation][crate::model::VerifyConfidentialGkeRequest::tee_attestation].
    ///
    /// Note that all the setters affecting `tee_attestation` are mutually
    /// exclusive.
    pub fn set_tee_attestation<
        T: std::convert::Into<
                std::option::Option<crate::model::verify_confidential_gke_request::TeeAttestation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tee_attestation = v.into();
        self
    }

    /// The value of [tee_attestation][crate::model::VerifyConfidentialGkeRequest::tee_attestation]
    /// if it holds a `TpmAttestation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tpm_attestation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TpmAttestation>> {
        #[allow(unreachable_patterns)]
        self.tee_attestation.as_ref().and_then(|v| match v {
            crate::model::verify_confidential_gke_request::TeeAttestation::TpmAttestation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tee_attestation][crate::model::VerifyConfidentialGkeRequest::tee_attestation]
    /// to hold a `TpmAttestation`.
    ///
    /// Note that all the setters affecting `tee_attestation` are
    /// mutually exclusive.
    pub fn set_tpm_attestation<
        T: std::convert::Into<std::boxed::Box<crate::model::TpmAttestation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tee_attestation = std::option::Option::Some(
            crate::model::verify_confidential_gke_request::TeeAttestation::TpmAttestation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for VerifyConfidentialGkeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.VerifyConfidentialGkeRequest"
    }
}

/// Defines additional types related to [VerifyConfidentialGkeRequest].
pub mod verify_confidential_gke_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required. A tee attestation report, used to populate hardware rooted
    /// claims.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TeeAttestation {
        /// The TPM-specific data provided by the attesting platform, used to
        /// populate any of the claims regarding platform state.
        TpmAttestation(std::boxed::Box<crate::model::TpmAttestation>),
    }
}

/// VerifyConfidentialGkeResponse response is returened once a Confidential GKE
/// attestation has been successfully verified, containing a signed OIDC token.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VerifyConfidentialGkeResponse {
    /// Output only. The attestation token issued by this service for Confidential
    /// GKE. It contains specific platform claims based on the contents of the
    /// provided attestation.
    pub attestation_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyConfidentialGkeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attestation_token][crate::model::VerifyConfidentialGkeResponse::attestation_token].
    pub fn set_attestation_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attestation_token = v.into();
        self
    }
}

impl wkt::message::Message for VerifyConfidentialGkeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.VerifyConfidentialGkeResponse"
    }
}

/// SigningAlgorithm enumerates all the supported signing algorithms.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SigningAlgorithm {
    /// Unspecified signing algorithm.
    Unspecified,
    /// RSASSA-PSS with a SHA256 digest.
    RsassaPssSha256,
    /// RSASSA-PKCS1 v1.5 with a SHA256 digest.
    RsassaPkcs1V15Sha256,
    /// ECDSA on the P-256 Curve with a SHA256 digest.
    EcdsaP256Sha256,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SigningAlgorithm::value] or
    /// [SigningAlgorithm::name].
    UnknownValue(signing_algorithm::UnknownValue),
}

#[doc(hidden)]
pub mod signing_algorithm {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SigningAlgorithm {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::RsassaPssSha256 => std::option::Option::Some(1),
            Self::RsassaPkcs1V15Sha256 => std::option::Option::Some(2),
            Self::EcdsaP256Sha256 => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SIGNING_ALGORITHM_UNSPECIFIED"),
            Self::RsassaPssSha256 => std::option::Option::Some("RSASSA_PSS_SHA256"),
            Self::RsassaPkcs1V15Sha256 => std::option::Option::Some("RSASSA_PKCS1V15_SHA256"),
            Self::EcdsaP256Sha256 => std::option::Option::Some("ECDSA_P256_SHA256"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SigningAlgorithm {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SigningAlgorithm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SigningAlgorithm {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::RsassaPssSha256,
            2 => Self::RsassaPkcs1V15Sha256,
            3 => Self::EcdsaP256Sha256,
            _ => Self::UnknownValue(signing_algorithm::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SigningAlgorithm {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SIGNING_ALGORITHM_UNSPECIFIED" => Self::Unspecified,
            "RSASSA_PSS_SHA256" => Self::RsassaPssSha256,
            "RSASSA_PKCS1V15_SHA256" => Self::RsassaPkcs1V15Sha256,
            "ECDSA_P256_SHA256" => Self::EcdsaP256Sha256,
            _ => Self::UnknownValue(signing_algorithm::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SigningAlgorithm {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::RsassaPssSha256 => serializer.serialize_i32(1),
            Self::RsassaPkcs1V15Sha256 => serializer.serialize_i32(2),
            Self::EcdsaP256Sha256 => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SigningAlgorithm {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SigningAlgorithm>::new(
            ".google.cloud.confidentialcomputing.v1.SigningAlgorithm",
        ))
    }
}

/// Token type enum contains the different types of token responses Confidential
/// Space supports
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TokenType {
    /// Unspecified token type
    Unspecified,
    /// OpenID Connect (OIDC) token type
    Oidc,
    /// Public Key Infrastructure (PKI) token type
    Pki,
    /// Limited claim token type for AWS integration
    LimitedAws,
    /// Principal-tag-based token for AWS integration
    AwsPrincipaltags,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TokenType::value] or
    /// [TokenType::name].
    UnknownValue(token_type::UnknownValue),
}

#[doc(hidden)]
pub mod token_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TokenType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Oidc => std::option::Option::Some(1),
            Self::Pki => std::option::Option::Some(2),
            Self::LimitedAws => std::option::Option::Some(3),
            Self::AwsPrincipaltags => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TOKEN_TYPE_UNSPECIFIED"),
            Self::Oidc => std::option::Option::Some("TOKEN_TYPE_OIDC"),
            Self::Pki => std::option::Option::Some("TOKEN_TYPE_PKI"),
            Self::LimitedAws => std::option::Option::Some("TOKEN_TYPE_LIMITED_AWS"),
            Self::AwsPrincipaltags => std::option::Option::Some("TOKEN_TYPE_AWS_PRINCIPALTAGS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TokenType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TokenType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TokenType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Oidc,
            2 => Self::Pki,
            3 => Self::LimitedAws,
            4 => Self::AwsPrincipaltags,
            _ => Self::UnknownValue(token_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TokenType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TOKEN_TYPE_UNSPECIFIED" => Self::Unspecified,
            "TOKEN_TYPE_OIDC" => Self::Oidc,
            "TOKEN_TYPE_PKI" => Self::Pki,
            "TOKEN_TYPE_LIMITED_AWS" => Self::LimitedAws,
            "TOKEN_TYPE_AWS_PRINCIPALTAGS" => Self::AwsPrincipaltags,
            _ => Self::UnknownValue(token_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TokenType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Oidc => serializer.serialize_i32(1),
            Self::Pki => serializer.serialize_i32(2),
            Self::LimitedAws => serializer.serialize_i32(3),
            Self::AwsPrincipaltags => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TokenType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TokenType>::new(
            ".google.cloud.confidentialcomputing.v1.TokenType",
        ))
    }
}

/// SignatureType enumerates supported signature types for attestation tokens.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SignatureType {
    /// Unspecified signature type.
    Unspecified,
    /// Google OIDC signature.
    Oidc,
    /// Public Key Infrastructure (PKI) signature.
    Pki,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SignatureType::value] or
    /// [SignatureType::name].
    UnknownValue(signature_type::UnknownValue),
}

#[doc(hidden)]
pub mod signature_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SignatureType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Oidc => std::option::Option::Some(1),
            Self::Pki => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SIGNATURE_TYPE_UNSPECIFIED"),
            Self::Oidc => std::option::Option::Some("SIGNATURE_TYPE_OIDC"),
            Self::Pki => std::option::Option::Some("SIGNATURE_TYPE_PKI"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SignatureType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SignatureType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SignatureType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Oidc,
            2 => Self::Pki,
            _ => Self::UnknownValue(signature_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SignatureType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SIGNATURE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "SIGNATURE_TYPE_OIDC" => Self::Oidc,
            "SIGNATURE_TYPE_PKI" => Self::Pki,
            _ => Self::UnknownValue(signature_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SignatureType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Oidc => serializer.serialize_i32(1),
            Self::Pki => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SignatureType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SignatureType>::new(
            ".google.cloud.confidentialcomputing.v1.SignatureType",
        ))
    }
}

/// TokenProfile enumerates the supported token claims profiles.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TokenProfile {
    /// Unspecified token profile.
    Unspecified,
    /// EAT claims.
    DefaultEat,
    /// AWS Principal Tags claims.
    Aws,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TokenProfile::value] or
    /// [TokenProfile::name].
    UnknownValue(token_profile::UnknownValue),
}

#[doc(hidden)]
pub mod token_profile {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TokenProfile {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::DefaultEat => std::option::Option::Some(1),
            Self::Aws => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TOKEN_PROFILE_UNSPECIFIED"),
            Self::DefaultEat => std::option::Option::Some("TOKEN_PROFILE_DEFAULT_EAT"),
            Self::Aws => std::option::Option::Some("TOKEN_PROFILE_AWS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TokenProfile {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TokenProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TokenProfile {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::DefaultEat,
            2 => Self::Aws,
            _ => Self::UnknownValue(token_profile::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TokenProfile {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TOKEN_PROFILE_UNSPECIFIED" => Self::Unspecified,
            "TOKEN_PROFILE_DEFAULT_EAT" => Self::DefaultEat,
            "TOKEN_PROFILE_AWS" => Self::Aws,
            _ => Self::UnknownValue(token_profile::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TokenProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::DefaultEat => serializer.serialize_i32(1),
            Self::Aws => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TokenProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TokenProfile>::new(
            ".google.cloud.confidentialcomputing.v1.TokenProfile",
        ))
    }
}
