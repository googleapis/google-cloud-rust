// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate lazy_static;
extern crate location;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A Challenge from the server used to guarantee freshness of attestations
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Challenge {
    /// Output only. The resource name for this Challenge in the format
    /// `projects/*/locations/*/challenges/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The time at which this Challenge was created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this Challenge will no longer be usable. It
    /// is also the expiration time for any tokens generated from this Challenge.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Indicates if this challenge has been used to generate a token.
    pub used: bool,

    /// Output only. Identical to nonce, but as a string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tpm_nonce: std::string::String,
}

impl Challenge {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Challenge::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Challenge::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Challenge::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [used][crate::model::Challenge::used].
    pub fn set_used<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.used = v.into();
        self
    }

    /// Sets the value of [tpm_nonce][crate::model::Challenge::tpm_nonce].
    pub fn set_tpm_nonce<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tpm_nonce = v.into();
        self
    }
}

impl wkt::message::Message for Challenge {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.Challenge"
    }
}

/// Message for creating a Challenge
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateChallengeRequest {
    /// Required. The resource name of the location where the Challenge will be
    /// used, in the format `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Challenge to be created. Currently this field can be empty as
    /// all the Challenge fields are set by the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub challenge: std::option::Option<crate::model::Challenge>,
}

impl CreateChallengeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateChallengeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [challenge][crate::model::CreateChallengeRequest::challenge].
    pub fn set_challenge<T: std::convert::Into<std::option::Option<crate::model::Challenge>>>(
        mut self,
        v: T,
    ) -> Self {
        self.challenge = v.into();
        self
    }
}

impl wkt::message::Message for CreateChallengeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.CreateChallengeRequest"
    }
}

/// A request for an OIDC token, providing all the necessary information needed
/// for this service to verify the plaform state of the requestor.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VerifyAttestationRequest {
    /// Required. The name of the Challenge whose nonce was used to generate the
    /// attestation, in the format `projects/*/locations/*/challenges/*`. The
    /// provided Challenge will be consumed, and cannot be used again.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub challenge: std::string::String,

    /// Optional. Credentials used to populate the "emails" claim in the
    /// claims_token.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcp_credentials: std::option::Option<crate::model::GcpCredentials>,

    /// Required. The TPM-specific data provided by the attesting platform, used to
    /// populate any of the claims regarding platform state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tpm_attestation: std::option::Option<crate::model::TpmAttestation>,

    /// Optional. Optional information related to the Confidential Space TEE.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidential_space_info: std::option::Option<crate::model::ConfidentialSpaceInfo>,

    /// Optional. A collection of optional, workload-specified claims that modify
    /// the token output.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub token_options: std::option::Option<crate::model::TokenOptions>,

    /// An optional tee attestation report, used to populate hardware rooted
    /// claims.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub tee_attestation:
        std::option::Option<crate::model::verify_attestation_request::TeeAttestation>,
}

impl VerifyAttestationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [challenge][crate::model::VerifyAttestationRequest::challenge].
    pub fn set_challenge<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.challenge = v.into();
        self
    }

    /// Sets the value of [gcp_credentials][crate::model::VerifyAttestationRequest::gcp_credentials].
    pub fn set_gcp_credentials<
        T: std::convert::Into<std::option::Option<crate::model::GcpCredentials>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gcp_credentials = v.into();
        self
    }

    /// Sets the value of [tpm_attestation][crate::model::VerifyAttestationRequest::tpm_attestation].
    pub fn set_tpm_attestation<
        T: std::convert::Into<std::option::Option<crate::model::TpmAttestation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tpm_attestation = v.into();
        self
    }

    /// Sets the value of [confidential_space_info][crate::model::VerifyAttestationRequest::confidential_space_info].
    pub fn set_confidential_space_info<
        T: std::convert::Into<std::option::Option<crate::model::ConfidentialSpaceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.confidential_space_info = v.into();
        self
    }

    /// Sets the value of [token_options][crate::model::VerifyAttestationRequest::token_options].
    pub fn set_token_options<
        T: std::convert::Into<std::option::Option<crate::model::TokenOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.token_options = v.into();
        self
    }

    /// Sets the value of `tee_attestation`.
    pub fn set_tee_attestation<
        T: std::convert::Into<
            std::option::Option<crate::model::verify_attestation_request::TeeAttestation>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tee_attestation = v.into();
        self
    }

    /// The value of [tee_attestation][crate::model::VerifyAttestationRequest::tee_attestation]
    /// if it holds a `TdCcel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_td_ccel(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TdxCcelAttestation>> {
        #[allow(unreachable_patterns)]
        self.tee_attestation.as_ref().and_then(|v| match v {
            crate::model::verify_attestation_request::TeeAttestation::TdCcel(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [tee_attestation][crate::model::VerifyAttestationRequest::tee_attestation]
    /// if it holds a `SevSnpAttestation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_sev_snp_attestation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SevSnpAttestation>> {
        #[allow(unreachable_patterns)]
        self.tee_attestation.as_ref().and_then(|v| match v {
            crate::model::verify_attestation_request::TeeAttestation::SevSnpAttestation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tee_attestation][crate::model::VerifyAttestationRequest::tee_attestation]
    /// to hold a `TdCcel`.
    ///
    /// Note that all the setters affecting `tee_attestation` are
    /// mutually exclusive.
    pub fn set_td_ccel<T: std::convert::Into<std::boxed::Box<crate::model::TdxCcelAttestation>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tee_attestation = std::option::Option::Some(
            crate::model::verify_attestation_request::TeeAttestation::TdCcel(v.into()),
        );
        self
    }

    /// Sets the value of [tee_attestation][crate::model::VerifyAttestationRequest::tee_attestation]
    /// to hold a `SevSnpAttestation`.
    ///
    /// Note that all the setters affecting `tee_attestation` are
    /// mutually exclusive.
    pub fn set_sev_snp_attestation<
        T: std::convert::Into<std::boxed::Box<crate::model::SevSnpAttestation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tee_attestation = std::option::Option::Some(
            crate::model::verify_attestation_request::TeeAttestation::SevSnpAttestation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for VerifyAttestationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.VerifyAttestationRequest"
    }
}

/// Defines additional types related to VerifyAttestationRequest
pub mod verify_attestation_request {
    #[allow(unused_imports)]
    use super::*;

    /// An optional tee attestation report, used to populate hardware rooted
    /// claims.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TeeAttestation {
        /// Optional. A TDX with CCEL and RTMR Attestation Quote.
        TdCcel(std::boxed::Box<crate::model::TdxCcelAttestation>),
        /// Optional. An SEV-SNP Attestation Report.
        SevSnpAttestation(std::boxed::Box<crate::model::SevSnpAttestation>),
    }
}

/// A TDX Attestation quote.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TdxCcelAttestation {
    /// Optional. The Confidential Computing Event Log (CCEL) ACPI table. Formatted
    /// as described in the ACPI Specification 6.5.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub ccel_acpi_table: bytes::Bytes,

    /// Optional. The CCEL event log. Formatted as described in the UEFI 2.10.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub ccel_data: bytes::Bytes,

    /// Optional. An Event Log containing additional events measured into the RTMR
    /// that are not already present in the CCEL.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub canonical_event_log: bytes::Bytes,

    /// Optional. The TDX attestation quote from the guest. It contains the RTMR
    /// values.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub td_quote: bytes::Bytes,
}

impl TdxCcelAttestation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ccel_acpi_table][crate::model::TdxCcelAttestation::ccel_acpi_table].
    pub fn set_ccel_acpi_table<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.ccel_acpi_table = v.into();
        self
    }

    /// Sets the value of [ccel_data][crate::model::TdxCcelAttestation::ccel_data].
    pub fn set_ccel_data<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.ccel_data = v.into();
        self
    }

    /// Sets the value of [canonical_event_log][crate::model::TdxCcelAttestation::canonical_event_log].
    pub fn set_canonical_event_log<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.canonical_event_log = v.into();
        self
    }

    /// Sets the value of [td_quote][crate::model::TdxCcelAttestation::td_quote].
    pub fn set_td_quote<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.td_quote = v.into();
        self
    }
}

impl wkt::message::Message for TdxCcelAttestation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.TdxCcelAttestation"
    }
}

/// An SEV-SNP Attestation Report.
/// Contains the attestation report and the certificate bundle that the client
/// collects.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SevSnpAttestation {
    /// Optional. The SEV-SNP Attestation Report
    /// Format is in revision 1.55, §7.3 Attestation, Table 22. ATTESTATION_REPORT
    /// Structure in this document:
    /// <https://www.amd.com/content/dam/amd/en/documents/epyc-technical-docs/specifications/56860.pdf>
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub report: bytes::Bytes,

    /// Optional. Certificate bundle defined in the GHCB protocol definition
    /// Format is documented in GHCB revision 2.03, section 4.1.8.1 struct
    /// cert_table in this document:
    /// <https://www.amd.com/content/dam/amd/en/documents/epyc-technical-docs/specifications/56421.pdf>
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub aux_blob: bytes::Bytes,
}

impl SevSnpAttestation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [report][crate::model::SevSnpAttestation::report].
    pub fn set_report<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.report = v.into();
        self
    }

    /// Sets the value of [aux_blob][crate::model::SevSnpAttestation::aux_blob].
    pub fn set_aux_blob<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.aux_blob = v.into();
        self
    }
}

impl wkt::message::Message for SevSnpAttestation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.SevSnpAttestation"
    }
}

/// A response once an attestation has been successfully verified, containing a
/// signed OIDC token.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VerifyAttestationResponse {
    /// Output only. Same as claims_token, but as a string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub oidc_claims_token: std::string::String,

    /// Output only. A list of messages that carry the partial error details
    /// related to VerifyAttestation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partial_errors: std::vec::Vec<rpc::model::Status>,
}

impl VerifyAttestationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [oidc_claims_token][crate::model::VerifyAttestationResponse::oidc_claims_token].
    pub fn set_oidc_claims_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.oidc_claims_token = v.into();
        self
    }

    /// Sets the value of [partial_errors][crate::model::VerifyAttestationResponse::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VerifyAttestationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.VerifyAttestationResponse"
    }
}

/// Credentials issued by GCP which are linked to the platform attestation. These
/// will be verified server-side as part of attestaion verification.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcpCredentials {
    /// Same as id_tokens, but as a string.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub service_account_id_tokens: std::vec::Vec<std::string::String>,
}

impl GcpCredentials {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account_id_tokens][crate::model::GcpCredentials::service_account_id_tokens].
    pub fn set_service_account_id_tokens<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.service_account_id_tokens = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GcpCredentials {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.GcpCredentials"
    }
}

/// Options to modify claims in the token to generate custom-purpose tokens.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TokenOptions {
    /// Optional. Optional string to issue the token with a custom audience claim.
    /// Required if one or more nonces are specified.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub audience: std::string::String,

    /// Optional. Optional parameter to place one or more nonces in the eat_nonce
    /// claim in the output token. The minimum size for JSON-encoded EATs is 10
    /// bytes and the maximum size is 74 bytes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub nonce: std::vec::Vec<std::string::String>,

    /// Optional. Optional token type to select what type of token to return.
    pub token_type: crate::model::TokenType,

    /// An optional additional configuration per token type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub token_type_options: std::option::Option<crate::model::token_options::TokenTypeOptions>,
}

impl TokenOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audience][crate::model::TokenOptions::audience].
    pub fn set_audience<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audience = v.into();
        self
    }

    /// Sets the value of [token_type][crate::model::TokenOptions::token_type].
    pub fn set_token_type<T: std::convert::Into<crate::model::TokenType>>(mut self, v: T) -> Self {
        self.token_type = v.into();
        self
    }

    /// Sets the value of [nonce][crate::model::TokenOptions::nonce].
    pub fn set_nonce<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.nonce = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `token_type_options`.
    pub fn set_token_type_options<
        T: std::convert::Into<std::option::Option<crate::model::token_options::TokenTypeOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.token_type_options = v.into();
        self
    }

    /// The value of [token_type_options][crate::model::TokenOptions::token_type_options]
    /// if it holds a `AwsPrincipalTagsOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_aws_principal_tags_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::token_options::AwsPrincipalTagsOptions>>
    {
        #[allow(unreachable_patterns)]
        self.token_type_options.as_ref().and_then(|v| match v {
            crate::model::token_options::TokenTypeOptions::AwsPrincipalTagsOptions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [token_type_options][crate::model::TokenOptions::token_type_options]
    /// to hold a `AwsPrincipalTagsOptions`.
    ///
    /// Note that all the setters affecting `token_type_options` are
    /// mutually exclusive.
    pub fn set_aws_principal_tags_options<
        T: std::convert::Into<std::boxed::Box<crate::model::token_options::AwsPrincipalTagsOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.token_type_options = std::option::Option::Some(
            crate::model::token_options::TokenTypeOptions::AwsPrincipalTagsOptions(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TokenOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.TokenOptions"
    }
}

/// Defines additional types related to TokenOptions
pub mod token_options {
    #[allow(unused_imports)]
    use super::*;

    /// Token options that only apply to the AWS Principal Tags token type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AwsPrincipalTagsOptions {
        /// Optional. Principal tags to allow in the token.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub allowed_principal_tags: std::option::Option<
            crate::model::token_options::aws_principal_tags_options::AllowedPrincipalTags,
        >,
    }

    impl AwsPrincipalTagsOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [allowed_principal_tags][crate::model::token_options::AwsPrincipalTagsOptions::allowed_principal_tags].
        pub fn set_allowed_principal_tags<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::token_options::aws_principal_tags_options::AllowedPrincipalTags,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.allowed_principal_tags = v.into();
            self
        }
    }

    impl wkt::message::Message for AwsPrincipalTagsOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.confidentialcomputing.v1.TokenOptions.AwsPrincipalTagsOptions"
        }
    }

    /// Defines additional types related to AwsPrincipalTagsOptions
    pub mod aws_principal_tags_options {
        #[allow(unused_imports)]
        use super::*;

        /// Allowed principal tags is used to define what principal tags will be
        /// placed in the token.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct AllowedPrincipalTags {

            /// Optional. Container image signatures allowed in the token.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub container_image_signatures: std::option::Option<crate::model::token_options::aws_principal_tags_options::allowed_principal_tags::ContainerImageSignatures>,
        }

        impl AllowedPrincipalTags {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [container_image_signatures][crate::model::token_options::aws_principal_tags_options::AllowedPrincipalTags::container_image_signatures].
            pub fn set_container_image_signatures<T: std::convert::Into<std::option::Option<crate::model::token_options::aws_principal_tags_options::allowed_principal_tags::ContainerImageSignatures>>>(mut self, v: T) -> Self{
                self.container_image_signatures = v.into();
                self
            }
        }

        impl wkt::message::Message for AllowedPrincipalTags {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.confidentialcomputing.v1.TokenOptions.AwsPrincipalTagsOptions.AllowedPrincipalTags"
            }
        }

        /// Defines additional types related to AllowedPrincipalTags
        pub mod allowed_principal_tags {
            #[allow(unused_imports)]
            use super::*;

            /// Allowed Container Image Signatures. Key IDs are required to allow this
            /// claim to fit within the narrow AWS IAM restrictions.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct ContainerImageSignatures {
                /// Optional. List of key ids to filter into the Principal tags. Only
                /// keys that have been validated and added to the token will be filtered
                /// into principal tags. Unrecognized key ids will be ignored.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub key_ids: std::vec::Vec<std::string::String>,
            }

            impl ContainerImageSignatures {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [key_ids][crate::model::token_options::aws_principal_tags_options::allowed_principal_tags::ContainerImageSignatures::key_ids].
                pub fn set_key_ids<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.key_ids = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for ContainerImageSignatures {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.confidentialcomputing.v1.TokenOptions.AwsPrincipalTagsOptions.AllowedPrincipalTags.ContainerImageSignatures"
                }
            }
        }
    }

    /// An optional additional configuration per token type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TokenTypeOptions {
        /// Optional. Options for the Limited AWS token type.
        AwsPrincipalTagsOptions(
            std::boxed::Box<crate::model::token_options::AwsPrincipalTagsOptions>,
        ),
    }
}

/// TPM2 data containing everything necessary to validate any platform state
/// measured into the TPM.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TpmAttestation {
    /// TPM2 PCR Quotes generated by calling TPM2_Quote on each PCR bank.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub quotes: std::vec::Vec<crate::model::tpm_attestation::Quote>,

    /// The binary TCG Event Log containing events measured into the TPM by the
    /// platform firmware and operating system. Formatted as described in the
    /// "TCG PC Client Platform Firmware Profile Specification".
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub tcg_event_log: bytes::Bytes,

    /// An Event Log containing additional events measured into the TPM that are
    /// not already present in the tcg_event_log. Formatted as described in the
    /// "Canonical Event Log Format" TCG Specification.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub canonical_event_log: bytes::Bytes,

    /// DER-encoded X.509 certificate of the Attestation Key (otherwise known as
    /// an AK or a TPM restricted signing key) used to generate the quotes.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub ak_cert: bytes::Bytes,

    /// List of DER-encoded X.509 certificates which, together with the ak_cert,
    /// chain back to a trusted Root Certificate.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::base64::Base64>")]
    pub cert_chain: std::vec::Vec<bytes::Bytes>,
}

impl TpmAttestation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tcg_event_log][crate::model::TpmAttestation::tcg_event_log].
    pub fn set_tcg_event_log<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.tcg_event_log = v.into();
        self
    }

    /// Sets the value of [canonical_event_log][crate::model::TpmAttestation::canonical_event_log].
    pub fn set_canonical_event_log<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.canonical_event_log = v.into();
        self
    }

    /// Sets the value of [ak_cert][crate::model::TpmAttestation::ak_cert].
    pub fn set_ak_cert<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.ak_cert = v.into();
        self
    }

    /// Sets the value of [quotes][crate::model::TpmAttestation::quotes].
    pub fn set_quotes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::tpm_attestation::Quote>,
    {
        use std::iter::Iterator;
        self.quotes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cert_chain][crate::model::TpmAttestation::cert_chain].
    pub fn set_cert_chain<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.cert_chain = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TpmAttestation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.TpmAttestation"
    }
}

/// Defines additional types related to TpmAttestation
pub mod tpm_attestation {
    #[allow(unused_imports)]
    use super::*;

    /// Information about Platform Control Registers (PCRs) including a signature
    /// over their values, which can be used for remote validation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Quote {
        /// The hash algorithm of the PCR bank being quoted, encoded as a TPM_ALG_ID
        pub hash_algo: i32,

        /// Raw binary values of each PCRs being quoted.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        #[serde_as(as = "std::collections::HashMap<_, serde_with::base64::Base64>")]
        pub pcr_values: std::collections::HashMap<i32, bytes::Bytes>,

        /// TPM2 quote, encoded as a TPMS_ATTEST
        #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
        #[serde_as(as = "serde_with::base64::Base64")]
        pub raw_quote: bytes::Bytes,

        /// TPM2 signature, encoded as a TPMT_SIGNATURE
        #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
        #[serde_as(as = "serde_with::base64::Base64")]
        pub raw_signature: bytes::Bytes,
    }

    impl Quote {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [hash_algo][crate::model::tpm_attestation::Quote::hash_algo].
        pub fn set_hash_algo<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.hash_algo = v.into();
            self
        }

        /// Sets the value of [raw_quote][crate::model::tpm_attestation::Quote::raw_quote].
        pub fn set_raw_quote<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
            self.raw_quote = v.into();
            self
        }

        /// Sets the value of [raw_signature][crate::model::tpm_attestation::Quote::raw_signature].
        pub fn set_raw_signature<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
            self.raw_signature = v.into();
            self
        }

        /// Sets the value of [pcr_values][crate::model::tpm_attestation::Quote::pcr_values].
        pub fn set_pcr_values<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<i32>,
            V: std::convert::Into<bytes::Bytes>,
        {
            use std::iter::Iterator;
            self.pcr_values = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for Quote {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.confidentialcomputing.v1.TpmAttestation.Quote"
        }
    }
}

/// ConfidentialSpaceInfo contains information related to the Confidential Space
/// TEE.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConfidentialSpaceInfo {
    /// Optional. A list of signed entities containing container image signatures
    /// that can be used for server-side signature verification.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub signed_entities: std::vec::Vec<crate::model::SignedEntity>,
}

impl ConfidentialSpaceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [signed_entities][crate::model::ConfidentialSpaceInfo::signed_entities].
    pub fn set_signed_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SignedEntity>,
    {
        use std::iter::Iterator;
        self.signed_entities = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ConfidentialSpaceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.ConfidentialSpaceInfo"
    }
}

/// SignedEntity represents an OCI image object containing everything necessary
/// to verify container image signatures.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SignedEntity {
    /// Optional. A list of container image signatures attached to an OCI image
    /// object.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub container_image_signatures: std::vec::Vec<crate::model::ContainerImageSignature>,
}

impl SignedEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [container_image_signatures][crate::model::SignedEntity::container_image_signatures].
    pub fn set_container_image_signatures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ContainerImageSignature>,
    {
        use std::iter::Iterator;
        self.container_image_signatures = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SignedEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.SignedEntity"
    }
}

/// ContainerImageSignature holds necessary metadata to verify a container image
/// signature.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ContainerImageSignature {
    /// Optional. The binary signature payload following the SimpleSigning format
    /// <https://github.com/sigstore/cosign/blob/main/specs/SIGNATURE_SPEC.md#simple-signing>.
    /// This payload includes the container image digest.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub payload: bytes::Bytes,

    /// Optional. A signature over the payload.
    /// The container image digest is incorporated into the signature as follows:
    ///
    /// . Generate a SimpleSigning format payload that includes the container
    ///   image digest.
    /// . Generate a signature over SHA256 digest of the payload.
    ///   The signature generation process can be represented as follows:
    ///   `Sign(sha256(SimpleSigningPayload(sha256(Image Manifest))))`
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub signature: bytes::Bytes,

    /// Optional. Reserved for future use.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub public_key: bytes::Bytes,

    /// Optional. Reserved for future use.
    pub sig_alg: crate::model::SigningAlgorithm,
}

impl ContainerImageSignature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [payload][crate::model::ContainerImageSignature::payload].
    pub fn set_payload<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.payload = v.into();
        self
    }

    /// Sets the value of [signature][crate::model::ContainerImageSignature::signature].
    pub fn set_signature<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.signature = v.into();
        self
    }

    /// Sets the value of [public_key][crate::model::ContainerImageSignature::public_key].
    pub fn set_public_key<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.public_key = v.into();
        self
    }

    /// Sets the value of [sig_alg][crate::model::ContainerImageSignature::sig_alg].
    pub fn set_sig_alg<T: std::convert::Into<crate::model::SigningAlgorithm>>(
        mut self,
        v: T,
    ) -> Self {
        self.sig_alg = v.into();
        self
    }
}

impl wkt::message::Message for ContainerImageSignature {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.confidentialcomputing.v1.ContainerImageSignature"
    }
}

/// SigningAlgorithm enumerates all the supported signing algorithms.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct SigningAlgorithm(std::borrow::Cow<'static, str>);

impl SigningAlgorithm {
    /// Creates a new SigningAlgorithm instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [SigningAlgorithm](SigningAlgorithm)
pub mod signing_algorithm {
    use super::SigningAlgorithm;

    /// Unspecified signing algorithm.
    pub const SIGNING_ALGORITHM_UNSPECIFIED: SigningAlgorithm =
        SigningAlgorithm::new("SIGNING_ALGORITHM_UNSPECIFIED");

    /// RSASSA-PSS with a SHA256 digest.
    pub const RSASSA_PSS_SHA256: SigningAlgorithm = SigningAlgorithm::new("RSASSA_PSS_SHA256");

    /// RSASSA-PKCS1 v1.5 with a SHA256 digest.
    pub const RSASSA_PKCS1V15_SHA256: SigningAlgorithm =
        SigningAlgorithm::new("RSASSA_PKCS1V15_SHA256");

    /// ECDSA on the P-256 Curve with a SHA256 digest.
    pub const ECDSA_P256_SHA256: SigningAlgorithm = SigningAlgorithm::new("ECDSA_P256_SHA256");
}

impl std::convert::From<std::string::String> for SigningAlgorithm {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for SigningAlgorithm {
    fn default() -> Self {
        signing_algorithm::SIGNING_ALGORITHM_UNSPECIFIED
    }
}

/// Token type enum contains the different types of token responses Confidential
/// Space supports
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct TokenType(std::borrow::Cow<'static, str>);

impl TokenType {
    /// Creates a new TokenType instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [TokenType](TokenType)
pub mod token_type {
    use super::TokenType;

    /// Unspecified token type
    pub const TOKEN_TYPE_UNSPECIFIED: TokenType = TokenType::new("TOKEN_TYPE_UNSPECIFIED");

    /// OpenID Connect (OIDC) token type
    pub const TOKEN_TYPE_OIDC: TokenType = TokenType::new("TOKEN_TYPE_OIDC");

    /// Public Key Infrastructure (PKI) token type
    pub const TOKEN_TYPE_PKI: TokenType = TokenType::new("TOKEN_TYPE_PKI");

    /// Limited claim token type for AWS integration
    pub const TOKEN_TYPE_LIMITED_AWS: TokenType = TokenType::new("TOKEN_TYPE_LIMITED_AWS");

    /// Principal-tag-based token for AWS integration
    pub const TOKEN_TYPE_AWS_PRINCIPALTAGS: TokenType =
        TokenType::new("TOKEN_TYPE_AWS_PRINCIPALTAGS");
}

impl std::convert::From<std::string::String> for TokenType {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for TokenType {
    fn default() -> Self {
        token_type::TOKEN_TYPE_UNSPECIFIED
    }
}
