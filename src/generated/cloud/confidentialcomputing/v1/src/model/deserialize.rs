// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Challenge {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __expire_time,
            __used,
            __tpm_nonce,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Challenge")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "used" => Ok(__FieldTag::__used),
                            "tpmNonce" => Ok(__FieldTag::__tpm_nonce),
                            "tpm_nonce" => Ok(__FieldTag::__tpm_nonce),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Challenge;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Challenge")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for expire_time"));
                            }
                            result.expire_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__used => {
                            if !fields.insert(__FieldTag::__used) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for used"));
                            }
                            result.used = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__tpm_nonce => {
                            if !fields.insert(__FieldTag::__tpm_nonce) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tpm_nonce"));
                            }
                            result.tpm_nonce = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateChallengeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __challenge,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateChallengeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "challenge" => Ok(__FieldTag::__challenge),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateChallengeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateChallengeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__challenge => {
                            if !fields.insert(__FieldTag::__challenge) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for challenge"));
                            }
                            result.challenge = map.next_value::<std::option::Option<crate::model::Challenge>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VerifyAttestationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __td_ccel,
            __sev_snp_attestation,
            __challenge,
            __gcp_credentials,
            __tpm_attestation,
            __confidential_space_info,
            __token_options,
            __attester,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerifyAttestationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tdCcel" => Ok(__FieldTag::__td_ccel),
                            "td_ccel" => Ok(__FieldTag::__td_ccel),
                            "sevSnpAttestation" => Ok(__FieldTag::__sev_snp_attestation),
                            "sev_snp_attestation" => Ok(__FieldTag::__sev_snp_attestation),
                            "challenge" => Ok(__FieldTag::__challenge),
                            "gcpCredentials" => Ok(__FieldTag::__gcp_credentials),
                            "gcp_credentials" => Ok(__FieldTag::__gcp_credentials),
                            "tpmAttestation" => Ok(__FieldTag::__tpm_attestation),
                            "tpm_attestation" => Ok(__FieldTag::__tpm_attestation),
                            "confidentialSpaceInfo" => Ok(__FieldTag::__confidential_space_info),
                            "confidential_space_info" => Ok(__FieldTag::__confidential_space_info),
                            "tokenOptions" => Ok(__FieldTag::__token_options),
                            "token_options" => Ok(__FieldTag::__token_options),
                            "attester" => Ok(__FieldTag::__attester),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VerifyAttestationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerifyAttestationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__td_ccel => {
                            if !fields.insert(__FieldTag::__td_ccel) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for td_ccel"));
                            }
                            if result.tee_attestation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `tee_attestation`, a oneof with full ID .google.cloud.confidentialcomputing.v1.VerifyAttestationRequest.td_ccel, latest field was tdCcel",
                                ));
                            }
                            result.tee_attestation = std::option::Option::Some(
                                crate::model::verify_attestation_request::TeeAttestation::TdCcel(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::TdxCcelAttestation>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__sev_snp_attestation => {
                            if !fields.insert(__FieldTag::__sev_snp_attestation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sev_snp_attestation"));
                            }
                            if result.tee_attestation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `tee_attestation`, a oneof with full ID .google.cloud.confidentialcomputing.v1.VerifyAttestationRequest.sev_snp_attestation, latest field was sevSnpAttestation",
                                ));
                            }
                            result.tee_attestation = std::option::Option::Some(
                                crate::model::verify_attestation_request::TeeAttestation::SevSnpAttestation(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SevSnpAttestation>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__challenge => {
                            if !fields.insert(__FieldTag::__challenge) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for challenge"));
                            }
                            result.challenge = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__gcp_credentials => {
                            if !fields.insert(__FieldTag::__gcp_credentials) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for gcp_credentials"));
                            }
                            result.gcp_credentials = map.next_value::<std::option::Option<crate::model::GcpCredentials>>()?
                                ;
                        },
                        __FieldTag::__tpm_attestation => {
                            if !fields.insert(__FieldTag::__tpm_attestation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tpm_attestation"));
                            }
                            result.tpm_attestation = map.next_value::<std::option::Option<crate::model::TpmAttestation>>()?
                                ;
                        },
                        __FieldTag::__confidential_space_info => {
                            if !fields.insert(__FieldTag::__confidential_space_info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for confidential_space_info"));
                            }
                            result.confidential_space_info = map.next_value::<std::option::Option<crate::model::ConfidentialSpaceInfo>>()?
                                ;
                        },
                        __FieldTag::__token_options => {
                            if !fields.insert(__FieldTag::__token_options) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for token_options"));
                            }
                            result.token_options = map.next_value::<std::option::Option<crate::model::TokenOptions>>()?
                                ;
                        },
                        __FieldTag::__attester => {
                            if !fields.insert(__FieldTag::__attester) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for attester"));
                            }
                            result.attester = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TdxCcelAttestation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ccel_acpi_table,
            __ccel_data,
            __canonical_event_log,
            __td_quote,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TdxCcelAttestation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ccelAcpiTable" => Ok(__FieldTag::__ccel_acpi_table),
                            "ccel_acpi_table" => Ok(__FieldTag::__ccel_acpi_table),
                            "ccelData" => Ok(__FieldTag::__ccel_data),
                            "ccel_data" => Ok(__FieldTag::__ccel_data),
                            "canonicalEventLog" => Ok(__FieldTag::__canonical_event_log),
                            "canonical_event_log" => Ok(__FieldTag::__canonical_event_log),
                            "tdQuote" => Ok(__FieldTag::__td_quote),
                            "td_quote" => Ok(__FieldTag::__td_quote),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TdxCcelAttestation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TdxCcelAttestation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ccel_acpi_table => {
                            if !fields.insert(__FieldTag::__ccel_acpi_table) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ccel_acpi_table"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ccel_acpi_table = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__ccel_data => {
                            if !fields.insert(__FieldTag::__ccel_data) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ccel_data"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ccel_data = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__canonical_event_log => {
                            if !fields.insert(__FieldTag::__canonical_event_log) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for canonical_event_log"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.canonical_event_log = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__td_quote => {
                            if !fields.insert(__FieldTag::__td_quote) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for td_quote"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.td_quote = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SevSnpAttestation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __report,
            __aux_blob,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SevSnpAttestation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "report" => Ok(__FieldTag::__report),
                            "auxBlob" => Ok(__FieldTag::__aux_blob),
                            "aux_blob" => Ok(__FieldTag::__aux_blob),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SevSnpAttestation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SevSnpAttestation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__report => {
                            if !fields.insert(__FieldTag::__report) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for report"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.report = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__aux_blob => {
                            if !fields.insert(__FieldTag::__aux_blob) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for aux_blob"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.aux_blob = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VerifyAttestationResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __oidc_claims_token,
            __partial_errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerifyAttestationResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "oidcClaimsToken" => Ok(__FieldTag::__oidc_claims_token),
                            "oidc_claims_token" => Ok(__FieldTag::__oidc_claims_token),
                            "partialErrors" => Ok(__FieldTag::__partial_errors),
                            "partial_errors" => Ok(__FieldTag::__partial_errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VerifyAttestationResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerifyAttestationResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__oidc_claims_token => {
                            if !fields.insert(__FieldTag::__oidc_claims_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for oidc_claims_token"));
                            }
                            result.oidc_claims_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__partial_errors => {
                            if !fields.insert(__FieldTag::__partial_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for partial_errors"));
                            }
                            result.partial_errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GcpCredentials {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_account_id_tokens,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcpCredentials")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceAccountIdTokens" => Ok(__FieldTag::__service_account_id_tokens),
                            "service_account_id_tokens" => Ok(__FieldTag::__service_account_id_tokens),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GcpCredentials;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcpCredentials")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_account_id_tokens => {
                            if !fields.insert(__FieldTag::__service_account_id_tokens) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for service_account_id_tokens"));
                            }
                            result.service_account_id_tokens = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TokenOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aws_principal_tags_options,
            __audience,
            __nonce,
            __token_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TokenOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "awsPrincipalTagsOptions" => Ok(__FieldTag::__aws_principal_tags_options),
                            "aws_principal_tags_options" => Ok(__FieldTag::__aws_principal_tags_options),
                            "audience" => Ok(__FieldTag::__audience),
                            "nonce" => Ok(__FieldTag::__nonce),
                            "tokenType" => Ok(__FieldTag::__token_type),
                            "token_type" => Ok(__FieldTag::__token_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TokenOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TokenOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aws_principal_tags_options => {
                            if !fields.insert(__FieldTag::__aws_principal_tags_options) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for aws_principal_tags_options"));
                            }
                            if result.token_type_options.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `token_type_options`, a oneof with full ID .google.cloud.confidentialcomputing.v1.TokenOptions.aws_principal_tags_options, latest field was awsPrincipalTagsOptions",
                                ));
                            }
                            result.token_type_options = std::option::Option::Some(
                                crate::model::token_options::TokenTypeOptions::AwsPrincipalTagsOptions(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AwsPrincipalTagsOptions>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__audience => {
                            if !fields.insert(__FieldTag::__audience) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for audience"));
                            }
                            result.audience = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__nonce => {
                            if !fields.insert(__FieldTag::__nonce) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for nonce"));
                            }
                            result.nonce = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__token_type => {
                            if !fields.insert(__FieldTag::__token_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for token_type"));
                            }
                            result.token_type = map.next_value::<std::option::Option<crate::model::TokenType>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AwsPrincipalTagsOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allowed_principal_tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsPrincipalTagsOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowedPrincipalTags" => Ok(__FieldTag::__allowed_principal_tags),
                            "allowed_principal_tags" => Ok(__FieldTag::__allowed_principal_tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AwsPrincipalTagsOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsPrincipalTagsOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allowed_principal_tags => {
                            if !fields.insert(__FieldTag::__allowed_principal_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for allowed_principal_tags"));
                            }
                            result.allowed_principal_tags = map.next_value::<std::option::Option<crate::model::aws_principal_tags_options::AllowedPrincipalTags>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::aws_principal_tags_options::AllowedPrincipalTags {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __container_image_signatures,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AllowedPrincipalTags")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "containerImageSignatures" => Ok(__FieldTag::__container_image_signatures),
                            "container_image_signatures" => Ok(__FieldTag::__container_image_signatures),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::aws_principal_tags_options::AllowedPrincipalTags;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AllowedPrincipalTags")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__container_image_signatures => {
                            if !fields.insert(__FieldTag::__container_image_signatures) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for container_image_signatures"));
                            }
                            result.container_image_signatures = map.next_value::<std::option::Option<crate::model::aws_principal_tags_options::allowed_principal_tags::ContainerImageSignatures>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::aws_principal_tags_options::allowed_principal_tags::ContainerImageSignatures {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ContainerImageSignatures")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keyIds" => Ok(__FieldTag::__key_ids),
                            "key_ids" => Ok(__FieldTag::__key_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::aws_principal_tags_options::allowed_principal_tags::ContainerImageSignatures;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ContainerImageSignatures")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key_ids => {
                            if !fields.insert(__FieldTag::__key_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for key_ids"));
                            }
                            result.key_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TpmAttestation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __quotes,
            __tcg_event_log,
            __canonical_event_log,
            __ak_cert,
            __cert_chain,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TpmAttestation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "quotes" => Ok(__FieldTag::__quotes),
                            "tcgEventLog" => Ok(__FieldTag::__tcg_event_log),
                            "tcg_event_log" => Ok(__FieldTag::__tcg_event_log),
                            "canonicalEventLog" => Ok(__FieldTag::__canonical_event_log),
                            "canonical_event_log" => Ok(__FieldTag::__canonical_event_log),
                            "akCert" => Ok(__FieldTag::__ak_cert),
                            "ak_cert" => Ok(__FieldTag::__ak_cert),
                            "certChain" => Ok(__FieldTag::__cert_chain),
                            "cert_chain" => Ok(__FieldTag::__cert_chain),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TpmAttestation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TpmAttestation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__quotes => {
                            if !fields.insert(__FieldTag::__quotes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for quotes"));
                            }
                            result.quotes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::tpm_attestation::Quote>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__tcg_event_log => {
                            if !fields.insert(__FieldTag::__tcg_event_log) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tcg_event_log"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.tcg_event_log = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__canonical_event_log => {
                            if !fields.insert(__FieldTag::__canonical_event_log) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for canonical_event_log"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.canonical_event_log = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__ak_cert => {
                            if !fields.insert(__FieldTag::__ak_cert) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ak_cert"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ak_cert = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__cert_chain => {
                            if !fields.insert(__FieldTag::__cert_chain) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cert_chain"));
                            }
                            struct __With( std::option::Option<std::vec::Vec<::bytes::Bytes>> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<std::vec::Vec<serde_with::base64::Base64>> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cert_chain = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::tpm_attestation::Quote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hash_algo,
            __pcr_values,
            __raw_quote,
            __raw_signature,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Quote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hashAlgo" => Ok(__FieldTag::__hash_algo),
                            "hash_algo" => Ok(__FieldTag::__hash_algo),
                            "pcrValues" => Ok(__FieldTag::__pcr_values),
                            "pcr_values" => Ok(__FieldTag::__pcr_values),
                            "rawQuote" => Ok(__FieldTag::__raw_quote),
                            "raw_quote" => Ok(__FieldTag::__raw_quote),
                            "rawSignature" => Ok(__FieldTag::__raw_signature),
                            "raw_signature" => Ok(__FieldTag::__raw_signature),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::tpm_attestation::Quote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Quote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hash_algo => {
                            if !fields.insert(__FieldTag::__hash_algo) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for hash_algo"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hash_algo = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__pcr_values => {
                            if !fields.insert(__FieldTag::__pcr_values) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for pcr_values"));
                            }
                            struct __With( std::option::Option<std::collections::HashMap<i32,::bytes::Bytes>> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<std::collections::HashMap<wkt::internal::I32, serde_with::base64::Base64>> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pcr_values = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__raw_quote => {
                            if !fields.insert(__FieldTag::__raw_quote) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for raw_quote"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.raw_quote = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__raw_signature => {
                            if !fields.insert(__FieldTag::__raw_signature) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for raw_signature"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.raw_signature = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConfidentialSpaceInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __signed_entities,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfidentialSpaceInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "signedEntities" => Ok(__FieldTag::__signed_entities),
                            "signed_entities" => Ok(__FieldTag::__signed_entities),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConfidentialSpaceInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfidentialSpaceInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__signed_entities => {
                            if !fields.insert(__FieldTag::__signed_entities) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for signed_entities"));
                            }
                            result.signed_entities = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SignedEntity>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SignedEntity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __container_image_signatures,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SignedEntity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "containerImageSignatures" => Ok(__FieldTag::__container_image_signatures),
                            "container_image_signatures" => Ok(__FieldTag::__container_image_signatures),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SignedEntity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SignedEntity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__container_image_signatures => {
                            if !fields.insert(__FieldTag::__container_image_signatures) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for container_image_signatures"));
                            }
                            result.container_image_signatures = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ContainerImageSignature>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ContainerImageSignature {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __payload,
            __signature,
            __public_key,
            __sig_alg,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ContainerImageSignature")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "payload" => Ok(__FieldTag::__payload),
                            "signature" => Ok(__FieldTag::__signature),
                            "publicKey" => Ok(__FieldTag::__public_key),
                            "public_key" => Ok(__FieldTag::__public_key),
                            "sigAlg" => Ok(__FieldTag::__sig_alg),
                            "sig_alg" => Ok(__FieldTag::__sig_alg),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ContainerImageSignature;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ContainerImageSignature")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for payload"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.payload = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__signature => {
                            if !fields.insert(__FieldTag::__signature) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for signature"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.signature = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__public_key => {
                            if !fields.insert(__FieldTag::__public_key) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for public_key"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.public_key = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__sig_alg => {
                            if !fields.insert(__FieldTag::__sig_alg) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sig_alg"));
                            }
                            result.sig_alg = map.next_value::<std::option::Option<crate::model::SigningAlgorithm>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VerifyConfidentialSpaceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __td_ccel,
            __tpm_attestation,
            __challenge,
            __gcp_credentials,
            __signed_entities,
            __gce_shielded_identity,
            __options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerifyConfidentialSpaceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tdCcel" => Ok(__FieldTag::__td_ccel),
                            "td_ccel" => Ok(__FieldTag::__td_ccel),
                            "tpmAttestation" => Ok(__FieldTag::__tpm_attestation),
                            "tpm_attestation" => Ok(__FieldTag::__tpm_attestation),
                            "challenge" => Ok(__FieldTag::__challenge),
                            "gcpCredentials" => Ok(__FieldTag::__gcp_credentials),
                            "gcp_credentials" => Ok(__FieldTag::__gcp_credentials),
                            "signedEntities" => Ok(__FieldTag::__signed_entities),
                            "signed_entities" => Ok(__FieldTag::__signed_entities),
                            "gceShieldedIdentity" => Ok(__FieldTag::__gce_shielded_identity),
                            "gce_shielded_identity" => Ok(__FieldTag::__gce_shielded_identity),
                            "options" => Ok(__FieldTag::__options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VerifyConfidentialSpaceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerifyConfidentialSpaceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__td_ccel => {
                            if !fields.insert(__FieldTag::__td_ccel) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for td_ccel"));
                            }
                            if result.tee_attestation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `tee_attestation`, a oneof with full ID .google.cloud.confidentialcomputing.v1.VerifyConfidentialSpaceRequest.td_ccel, latest field was tdCcel",
                                ));
                            }
                            result.tee_attestation = std::option::Option::Some(
                                crate::model::verify_confidential_space_request::TeeAttestation::TdCcel(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::TdxCcelAttestation>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__tpm_attestation => {
                            if !fields.insert(__FieldTag::__tpm_attestation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tpm_attestation"));
                            }
                            if result.tee_attestation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `tee_attestation`, a oneof with full ID .google.cloud.confidentialcomputing.v1.VerifyConfidentialSpaceRequest.tpm_attestation, latest field was tpmAttestation",
                                ));
                            }
                            result.tee_attestation = std::option::Option::Some(
                                crate::model::verify_confidential_space_request::TeeAttestation::TpmAttestation(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::TpmAttestation>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__challenge => {
                            if !fields.insert(__FieldTag::__challenge) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for challenge"));
                            }
                            result.challenge = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__gcp_credentials => {
                            if !fields.insert(__FieldTag::__gcp_credentials) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for gcp_credentials"));
                            }
                            result.gcp_credentials = map.next_value::<std::option::Option<crate::model::GcpCredentials>>()?
                                ;
                        },
                        __FieldTag::__signed_entities => {
                            if !fields.insert(__FieldTag::__signed_entities) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for signed_entities"));
                            }
                            result.signed_entities = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SignedEntity>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__gce_shielded_identity => {
                            if !fields.insert(__FieldTag::__gce_shielded_identity) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for gce_shielded_identity"));
                            }
                            result.gce_shielded_identity = map.next_value::<std::option::Option<crate::model::GceShieldedIdentity>>()?
                                ;
                        },
                        __FieldTag::__options => {
                            if !fields.insert(__FieldTag::__options) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for options"));
                            }
                            result.options = map.next_value::<std::option::Option<crate::model::verify_confidential_space_request::ConfidentialSpaceOptions>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::verify_confidential_space_request::ConfidentialSpaceOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aws_principal_tags_options,
            __audience,
            __token_profile,
            __nonce,
            __signature_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfidentialSpaceOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "awsPrincipalTagsOptions" => Ok(__FieldTag::__aws_principal_tags_options),
                            "aws_principal_tags_options" => Ok(__FieldTag::__aws_principal_tags_options),
                            "audience" => Ok(__FieldTag::__audience),
                            "tokenProfile" => Ok(__FieldTag::__token_profile),
                            "token_profile" => Ok(__FieldTag::__token_profile),
                            "nonce" => Ok(__FieldTag::__nonce),
                            "signatureType" => Ok(__FieldTag::__signature_type),
                            "signature_type" => Ok(__FieldTag::__signature_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::verify_confidential_space_request::ConfidentialSpaceOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfidentialSpaceOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aws_principal_tags_options => {
                            if !fields.insert(__FieldTag::__aws_principal_tags_options) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for aws_principal_tags_options"));
                            }
                            if result.token_profile_options.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `token_profile_options`, a oneof with full ID .google.cloud.confidentialcomputing.v1.VerifyConfidentialSpaceRequest.ConfidentialSpaceOptions.aws_principal_tags_options, latest field was awsPrincipalTagsOptions",
                                ));
                            }
                            result.token_profile_options = std::option::Option::Some(
                                crate::model::verify_confidential_space_request::confidential_space_options::TokenProfileOptions::AwsPrincipalTagsOptions(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AwsPrincipalTagsOptions>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__audience => {
                            if !fields.insert(__FieldTag::__audience) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for audience"));
                            }
                            result.audience = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__token_profile => {
                            if !fields.insert(__FieldTag::__token_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for token_profile"));
                            }
                            result.token_profile = map.next_value::<std::option::Option<crate::model::TokenProfile>>()?.unwrap_or_default();
                        },
                        __FieldTag::__nonce => {
                            if !fields.insert(__FieldTag::__nonce) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for nonce"));
                            }
                            result.nonce = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__signature_type => {
                            if !fields.insert(__FieldTag::__signature_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for signature_type"));
                            }
                            result.signature_type = map.next_value::<std::option::Option<crate::model::SignatureType>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GceShieldedIdentity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ak_cert,
            __ak_cert_chain,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GceShieldedIdentity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "akCert" => Ok(__FieldTag::__ak_cert),
                            "ak_cert" => Ok(__FieldTag::__ak_cert),
                            "akCertChain" => Ok(__FieldTag::__ak_cert_chain),
                            "ak_cert_chain" => Ok(__FieldTag::__ak_cert_chain),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GceShieldedIdentity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GceShieldedIdentity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ak_cert => {
                            if !fields.insert(__FieldTag::__ak_cert) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ak_cert"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ak_cert = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__ak_cert_chain => {
                            if !fields.insert(__FieldTag::__ak_cert_chain) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ak_cert_chain"));
                            }
                            struct __With( std::option::Option<std::vec::Vec<::bytes::Bytes>> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<std::vec::Vec<serde_with::base64::Base64>> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ak_cert_chain = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VerifyConfidentialSpaceResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attestation_token,
            __partial_errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerifyConfidentialSpaceResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attestationToken" => Ok(__FieldTag::__attestation_token),
                            "attestation_token" => Ok(__FieldTag::__attestation_token),
                            "partialErrors" => Ok(__FieldTag::__partial_errors),
                            "partial_errors" => Ok(__FieldTag::__partial_errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VerifyConfidentialSpaceResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerifyConfidentialSpaceResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attestation_token => {
                            if !fields.insert(__FieldTag::__attestation_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for attestation_token"));
                            }
                            result.attestation_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__partial_errors => {
                            if !fields.insert(__FieldTag::__partial_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for partial_errors"));
                            }
                            result.partial_errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VerifyConfidentialGkeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tpm_attestation,
            __challenge,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerifyConfidentialGkeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tpmAttestation" => Ok(__FieldTag::__tpm_attestation),
                            "tpm_attestation" => Ok(__FieldTag::__tpm_attestation),
                            "challenge" => Ok(__FieldTag::__challenge),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VerifyConfidentialGkeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerifyConfidentialGkeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tpm_attestation => {
                            if !fields.insert(__FieldTag::__tpm_attestation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tpm_attestation"));
                            }
                            if result.tee_attestation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `tee_attestation`, a oneof with full ID .google.cloud.confidentialcomputing.v1.VerifyConfidentialGkeRequest.tpm_attestation, latest field was tpmAttestation",
                                ));
                            }
                            result.tee_attestation = std::option::Option::Some(
                                crate::model::verify_confidential_gke_request::TeeAttestation::TpmAttestation(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::TpmAttestation>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__challenge => {
                            if !fields.insert(__FieldTag::__challenge) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for challenge"));
                            }
                            result.challenge = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VerifyConfidentialGkeResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attestation_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerifyConfidentialGkeResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attestationToken" => Ok(__FieldTag::__attestation_token),
                            "attestation_token" => Ok(__FieldTag::__attestation_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VerifyConfidentialGkeResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerifyConfidentialGkeResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attestation_token => {
                            if !fields.insert(__FieldTag::__attestation_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for attestation_token"));
                            }
                            result.attestation_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
