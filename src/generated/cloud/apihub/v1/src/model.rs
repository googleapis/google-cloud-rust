// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// The [CreateApi][google.cloud.apihub.v1.ApiHub.CreateApi] method's request.
///
/// [google.cloud.apihub.v1.ApiHub.CreateApi]: crate::client::ApiHub::create_api
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateApiRequest {
    /// Required. The parent resource for the API resource.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Optional. The ID to use for the API resource, which will become the final
    /// component of the API's resource name. This field is optional.
    ///
    /// * If provided, the same will be used. The service will throw an error if
    ///   the specified id is already used by another API resource in the API hub.
    /// * If not provided, a system generated id will be used.
    ///
    /// This value should be 4-500 characters, and valid characters
    /// are /[a-z][A-Z][0-9]-_/.
    pub api_id: std::string::String,

    /// Required. The API resource to create.
    pub api: std::option::Option<crate::model::Api>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateApiRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateApiRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [api_id][crate::model::CreateApiRequest::api_id].
    pub fn set_api_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_id = v.into();
        self
    }

    /// Sets the value of [api][crate::model::CreateApiRequest::api].
    pub fn set_api<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Api>,
    {
        self.api = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [api][crate::model::CreateApiRequest::api].
    pub fn set_or_clear_api<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Api>,
    {
        self.api = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateApiRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.CreateApiRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateApiRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __api_id,
            __api,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateApiRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "apiId" => Ok(__FieldTag::__api_id),
                            "api_id" => Ok(__FieldTag::__api_id),
                            "api" => Ok(__FieldTag::__api),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateApiRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateApiRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_id => {
                            if !fields.insert(__FieldTag::__api_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_id",
                                ));
                            }
                            result.api_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api => {
                            if !fields.insert(__FieldTag::__api) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api",
                                ));
                            }
                            result.api =
                                map.next_value::<std::option::Option<crate::model::Api>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateApiRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.api_id.is_empty() {
            state.serialize_entry("apiId", &self.api_id)?;
        }
        if self.api.is_some() {
            state.serialize_entry("api", &self.api)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateApiRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateApiRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("api_id", &self.api_id);
        debug_struct.field("api", &self.api);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [GetApi][google.cloud.apihub.v1.ApiHub.GetApi] method's request.
///
/// [google.cloud.apihub.v1.ApiHub.GetApi]: crate::client::ApiHub::get_api
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetApiRequest {
    /// Required. The name of the API resource to retrieve.
    /// Format: `projects/{project}/locations/{location}/apis/{api}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetApiRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetApiRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetApiRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetApiRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetApiRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetApiRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetApiRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetApiRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetApiRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetApiRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetApiRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [UpdateApi][google.cloud.apihub.v1.ApiHub.UpdateApi] method's request.
///
/// [google.cloud.apihub.v1.ApiHub.UpdateApi]: crate::client::ApiHub::update_api
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateApiRequest {
    /// Required. The API resource to update.
    ///
    /// The API resource's `name` field is used to identify the API resource to
    /// update.
    /// Format: `projects/{project}/locations/{location}/apis/{api}`
    pub api: std::option::Option<crate::model::Api>,

    /// Required. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateApiRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [api][crate::model::UpdateApiRequest::api].
    pub fn set_api<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Api>,
    {
        self.api = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [api][crate::model::UpdateApiRequest::api].
    pub fn set_or_clear_api<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Api>,
    {
        self.api = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateApiRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateApiRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateApiRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.UpdateApiRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateApiRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __api,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateApiRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "api" => Ok(__FieldTag::__api),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateApiRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateApiRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__api => {
                            if !fields.insert(__FieldTag::__api) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api",
                                ));
                            }
                            result.api =
                                map.next_value::<std::option::Option<crate::model::Api>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateApiRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.api.is_some() {
            state.serialize_entry("api", &self.api)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateApiRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateApiRequest");
        debug_struct.field("api", &self.api);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [DeleteApi][google.cloud.apihub.v1.ApiHub.DeleteApi] method's request.
///
/// [google.cloud.apihub.v1.ApiHub.DeleteApi]: crate::client::ApiHub::delete_api
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteApiRequest {
    /// Required. The name of the API resource to delete.
    /// Format: `projects/{project}/locations/{location}/apis/{api}`
    pub name: std::string::String,

    /// Optional. If set to true, any versions from this API will also be deleted.
    /// Otherwise, the request will only work if the API has no versions.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteApiRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteApiRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteApiRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteApiRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DeleteApiRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteApiRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteApiRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteApiRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteApiRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteApiRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteApiRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteApiRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [ListApis][google.cloud.apihub.v1.ApiHub.ListApis] method's request.
///
/// [google.cloud.apihub.v1.ApiHub.ListApis]: crate::client::ApiHub::list_apis
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListApisRequest {
    /// Required. The parent, which owns this collection of API resources.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Optional. An expression that filters the list of ApiResources.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string. The
    /// comparison operator must be one of: `<`, `>`, `:` or `=`. Filters are not
    /// case sensitive.
    ///
    /// The following fields in the `ApiResource` are eligible for filtering:
    ///
    /// * `owner.email` - The email of the team which owns the ApiResource.
    ///   Allowed comparison operators: `=`.
    /// * `create_time` - The time at which the ApiResource was created. The
    ///   value should be in the (RFC3339)[<https://tools.ietf.org/html/rfc3339>]
    ///   format. Allowed comparison operators: `>` and `<`.
    /// * `display_name` - The display name of the ApiResource. Allowed
    ///   comparison operators: `=`.
    /// * `target_user.enum_values.values.id` - The allowed value id of the
    ///   target users attribute associated with the ApiResource. Allowed
    ///   comparison operator is `:`.
    /// * `target_user.enum_values.values.display_name` - The allowed value
    ///   display name of the target users attribute associated with the
    ///   ApiResource. Allowed comparison operator is `:`.
    /// * `team.enum_values.values.id` - The allowed value id of the team
    ///   attribute associated with the ApiResource. Allowed comparison operator is
    ///   `:`.
    /// * `team.enum_values.values.display_name` - The allowed value display name
    ///   of the team attribute associated with the ApiResource. Allowed comparison
    ///   operator is `:`.
    /// * `business_unit.enum_values.values.id` - The allowed value id of the
    ///   business unit attribute associated with the ApiResource. Allowed
    ///   comparison operator is `:`.
    /// * `business_unit.enum_values.values.display_name` - The allowed value
    ///   display name of the business unit attribute associated with the
    ///   ApiResource. Allowed comparison operator is `:`.
    /// * `maturity_level.enum_values.values.id` - The allowed value id of the
    ///   maturity level attribute associated with the ApiResource. Allowed
    ///   comparison operator is `:`.
    /// * `maturity_level.enum_values.values.display_name` - The allowed value
    ///   display name of the maturity level attribute associated with the
    ///   ApiResource. Allowed comparison operator is `:`.
    /// * `api_style.enum_values.values.id` - The allowed value id of the
    ///   api style attribute associated with the ApiResource. Allowed
    ///   comparison operator is `:`.
    /// * `api_style.enum_values.values.display_name` - The allowed value display
    ///   name of the api style attribute associated with the ApiResource. Allowed
    ///   comparison operator is `:`.
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.enum_values.values.id` - The
    ///   allowed value id of the user defined enum attribute associated with the
    ///   Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-enum-id is a placeholder that can be replaced with
    ///   any user defined enum attribute name.
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.enum_values.values.display_name`
    ///
    /// - The allowed value display name of the user defined enum attribute
    ///   associated with the Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-enum-display-name is a placeholder that can be
    ///   replaced with any user defined enum attribute enum name.
    ///
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.string_values.values` - The
    ///   allowed value of the user defined string attribute associated with the
    ///   Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-string is a placeholder that can be replaced with
    ///   any user defined string attribute name.
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.json_values.values` - The
    ///   allowed value of the user defined JSON attribute associated with the
    ///   Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-json is a placeholder that can be replaced with
    ///   any user defined JSON attribute name.
    ///
    /// A filter function is also supported in the filter string. The filter
    /// function is `id(name)`. The `id(name)` function returns the id of the
    /// resource name. For example, `id(name) = \"api-1\"` is equivalent to
    /// `name = \"projects/test-project-id/locations/test-location-id/apis/api-1\"`
    /// provided the parent is
    /// `projects/test-project-id/locations/test-location-id`.
    ///
    /// Expressions are combined with either `AND` logic operator or `OR` logical
    /// operator but not both of them together i.e. only one of the `AND` or `OR`
    /// operator can be used throughout the filter string and both the operators
    /// cannot be used together. No other logical operators are supported. At most
    /// three filter fields are allowed in the filter string and if provided
    /// more than that then `INVALID_ARGUMENT` error is returned by the API.
    ///
    /// Here are a few examples:
    ///
    /// * `owner.email = \"apihub@google.com\"` -  - The owner team email is
    ///   _apihub@google.com_.
    /// * `owner.email = \"apihub@google.com\" AND create_time <
    ///   \"2021-08-15T14:50:00Z\" AND create_time > \"2021-08-10T12:00:00Z\"` -
    ///   The owner team email is _apihub@google.com_ and the api was created
    ///   before _2021-08-15 14:50:00 UTC_ and after _2021-08-10 12:00:00 UTC_.
    /// * `owner.email = \"apihub@google.com\" OR team.enum_values.values.id:
    ///   apihub-team-id` - The filter string specifies the APIs where the owner
    ///   team email is _apihub@google.com_ or the id of the allowed value
    ///   associated with the team attribute is _apihub-team-id_.
    /// * `owner.email = \"apihub@google.com\" OR
    ///   team.enum_values.values.display_name: ApiHub Team` - The filter string
    ///   specifies the APIs where the owner team email is _apihub@google.com_ or
    ///   the display name of the allowed value associated with the team attribute
    ///   is `ApiHub Team`.
    /// * `owner.email = \"apihub@google.com\" AND
    ///   attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/17650f90-4a29-4971-b3c0-d5532da3764b.enum_values.values.id:
    ///   test_enum_id AND
    ///   attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/1765\0f90-4a29-5431-b3d0-d5532da3764c.string_values.values:
    ///   test_string_value`  - The filter string specifies the APIs where the
    ///   owner team email is _apihub@google.com_ and the id of the allowed value
    ///   associated with the user defined attribute of type enum is _test_enum_id_
    ///   and the value of the user defined attribute of type string is _test_..
    pub filter: std::string::String,

    /// Optional. The maximum number of API resources to return. The service may
    /// return fewer than this value. If unspecified, at most 50 Apis will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListApis` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters (except page_size) provided to
    /// `ListApis` must match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListApisRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListApisRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListApisRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListApisRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListApisRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListApisRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListApisRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListApisRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListApisRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListApisRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListApisRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListApisRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListApisRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListApisRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [ListApis][google.cloud.apihub.v1.ApiHub.ListApis] method's response.
///
/// [google.cloud.apihub.v1.ApiHub.ListApis]: crate::client::ApiHub::list_apis
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListApisResponse {
    /// The API resources present in the API hub.
    pub apis: std::vec::Vec<crate::model::Api>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListApisResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [apis][crate::model::ListApisResponse::apis].
    pub fn set_apis<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Api>,
    {
        use std::iter::Iterator;
        self.apis = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListApisResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListApisResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListApisResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListApisResponse {
    type PageItem = crate::model::Api;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.apis
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListApisResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __apis,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListApisResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "apis" => Ok(__FieldTag::__apis),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListApisResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListApisResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__apis => {
                            if !fields.insert(__FieldTag::__apis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for apis",
                                ));
                            }
                            result.apis = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Api>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListApisResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.apis.is_empty() {
            state.serialize_entry("apis", &self.apis)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListApisResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListApisResponse");
        debug_struct.field("apis", &self.apis);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [CreateVersion][google.cloud.apihub.v1.ApiHub.CreateVersion] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHub.CreateVersion]: crate::client::ApiHub::create_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVersionRequest {
    /// Required. The parent resource for API version.
    /// Format: `projects/{project}/locations/{location}/apis/{api}`
    pub parent: std::string::String,

    /// Optional. The ID to use for the API version, which will become the final
    /// component of the version's resource name. This field is optional.
    ///
    /// * If provided, the same will be used. The service will throw an error if
    ///   the specified id is already used by another version in the API resource.
    /// * If not provided, a system generated id will be used.
    ///
    /// This value should be 4-500 characters, overall resource name which will be
    /// of format
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`,
    /// its length is limited to 700 characters and valid characters are
    /// /[a-z][A-Z][0-9]-_/.
    pub version_id: std::string::String,

    /// Required. The version to create.
    pub version: std::option::Option<crate::model::Version>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVersionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [version_id][crate::model::CreateVersionRequest::version_id].
    pub fn set_version_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_id = v.into();
        self
    }

    /// Sets the value of [version][crate::model::CreateVersionRequest::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::CreateVersionRequest::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.CreateVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __version_id,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "versionId" => Ok(__FieldTag::__version_id),
                            "version_id" => Ok(__FieldTag::__version_id),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version_id => {
                            if !fields.insert(__FieldTag::__version_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_id",
                                ));
                            }
                            result.version_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.version_id.is_empty() {
            state.serialize_entry("versionId", &self.version_id)?;
        }
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateVersionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("version_id", &self.version_id);
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [GetVersion][google.cloud.apihub.v1.ApiHub.GetVersion] method's request.
///
/// [google.cloud.apihub.v1.ApiHub.GetVersion]: crate::client::ApiHub::get_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVersionRequest {
    /// Required. The name of the API version to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetVersionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [UpdateVersion][google.cloud.apihub.v1.ApiHub.UpdateVersion] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHub.UpdateVersion]: crate::client::ApiHub::update_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateVersionRequest {
    /// Required. The API version to update.
    ///
    /// The version's `name` field is used to identify the API version to update.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    pub version: std::option::Option<crate::model::Version>,

    /// Required. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::UpdateVersionRequest::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::UpdateVersionRequest::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateVersionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateVersionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.UpdateVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateVersionRequest");
        debug_struct.field("version", &self.version);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [DeleteVersion][google.cloud.apihub.v1.ApiHub.DeleteVersion] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHub.DeleteVersion]: crate::client::ApiHub::delete_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteVersionRequest {
    /// Required. The name of the version to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    pub name: std::string::String,

    /// Optional. If set to true, any specs from this version will also be deleted.
    /// Otherwise, the request will only work if the version has no specs.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteVersionRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DeleteVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteVersionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [ListVersions][google.cloud.apihub.v1.ApiHub.ListVersions] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHub.ListVersions]: crate::client::ApiHub::list_versions
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVersionsRequest {
    /// Required. The parent which owns this collection of API versions i.e., the
    /// API resource Format: `projects/{project}/locations/{location}/apis/{api}`
    pub parent: std::string::String,

    /// Optional. An expression that filters the list of Versions.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string, a
    /// number, or a boolean. The comparison operator must be one of: `<`, `>` or
    /// `=`. Filters are not case sensitive.
    ///
    /// The following fields in the `Version` are eligible for filtering:
    ///
    /// * `display_name` - The display name of the Version. Allowed
    ///   comparison operators: `=`.
    /// * `create_time` - The time at which the Version was created. The
    ///   value should be in the (RFC3339)[<https://tools.ietf.org/html/rfc3339>]
    ///   format. Allowed comparison operators: `>` and `<`.
    /// * `lifecycle.enum_values.values.id` - The allowed value id of the
    ///   lifecycle attribute associated with the Version. Allowed comparison
    ///   operators: `:`.
    /// * `lifecycle.enum_values.values.display_name` - The allowed value display
    ///   name of the lifecycle attribute associated with the Version. Allowed
    ///   comparison operators: `:`.
    /// * `compliance.enum_values.values.id` -  The allowed value id of the
    ///   compliances attribute associated with the Version. Allowed comparison
    ///   operators: `:`.
    /// * `compliance.enum_values.values.display_name` -  The allowed value
    ///   display name of the compliances attribute associated with the Version.
    ///   Allowed comparison operators: `:`.
    /// * `accreditation.enum_values.values.id` - The allowed value id of the
    ///   accreditations attribute associated with the Version. Allowed
    ///   comparison operators: `:`.
    /// * `accreditation.enum_values.values.display_name` - The allowed value
    ///   display name of the accreditations attribute associated with the Version.
    ///   Allowed comparison operators: `:`.
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.enum_values.values.id` - The
    ///   allowed value id of the user defined enum attribute associated with the
    ///   Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-enum-id is a placeholder that can be replaced with
    ///   any user defined enum attribute name.
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.enum_values.values.display_name`
    ///
    /// - The allowed value display name of the user defined enum attribute
    ///   associated with the Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-enum-display-name is a placeholder that can be
    ///   replaced with any user defined enum attribute enum name.
    ///
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.string_values.values` - The
    ///   allowed value of the user defined string attribute associated with the
    ///   Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-string is a placeholder that can be replaced with
    ///   any user defined string attribute name.
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.json_values.values` - The
    ///   allowed value of the user defined JSON attribute associated with the
    ///   Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-json is a placeholder that can be replaced with
    ///   any user defined JSON attribute name.
    ///
    /// Expressions are combined with either `AND` logic operator or `OR` logical
    /// operator but not both of them together i.e. only one of the `AND` or `OR`
    /// operator can be used throughout the filter string and both the operators
    /// cannot be used together. No other logical operators are
    /// supported. At most three filter fields are allowed in the filter
    /// string and if provided more than that then `INVALID_ARGUMENT` error is
    /// returned by the API.
    ///
    /// Here are a few examples:
    ///
    /// * `lifecycle.enum_values.values.id: preview-id` - The filter string
    ///   specifies that the id of the allowed value associated with the lifecycle
    ///   attribute of the Version is _preview-id_.
    /// * `lifecycle.enum_values.values.display_name: \"Preview Display Name\"` -
    ///   The filter string specifies that the display name of the allowed value
    ///   associated with the lifecycle attribute of the Version is `Preview
    ///   Display Name`.
    /// * `lifecycle.enum_values.values.id: preview-id AND create_time <
    ///   \"2021-08-15T14:50:00Z\" AND create_time > \"2021-08-10T12:00:00Z\"` -
    ///   The id of the allowed value associated with the lifecycle attribute of
    ///   the Version is _preview-id_ and it was created before _2021-08-15
    ///   14:50:00 UTC_ and after _2021-08-10 12:00:00 UTC_.
    /// * `compliance.enum_values.values.id: gdpr-id OR
    ///   compliance.enum_values.values.id: pci-dss-id`
    ///
    /// - The id of the allowed value associated with the compliance attribute is
    ///   _gdpr-id_ or _pci-dss-id_.
    ///
    /// * `lifecycle.enum_values.values.id: preview-id AND
    ///   attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/17650f90-4a29-4971-b3c0-d5532da3764b.string_values.values:
    ///   test`  - The filter string specifies that the id of the allowed value
    ///   associated with the lifecycle attribute of the Version is _preview-id_
    ///   and the value of the user defined attribute of type string is _test_.
    pub filter: std::string::String,

    /// Optional. The maximum number of versions to return. The service may return
    /// fewer than this value. If unspecified, at most 50 versions will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListVersions` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters (except page_size) provided to
    /// `ListVersions` must match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVersionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListVersionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVersionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVersionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVersionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVersionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListVersionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListVersionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [ListVersions][google.cloud.apihub.v1.ApiHub.ListVersions] method's
/// response.
///
/// [google.cloud.apihub.v1.ApiHub.ListVersions]: crate::client::ApiHub::list_versions
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVersionsResponse {
    /// The versions corresponding to an API.
    pub versions: std::vec::Vec<crate::model::Version>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [versions][crate::model::ListVersionsResponse::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Version>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVersionsResponse {
    type PageItem = crate::model::Version;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVersionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __versions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVersionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "versions" => Ok(__FieldTag::__versions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVersionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVersionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__versions => {
                            if !fields.insert(__FieldTag::__versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for versions",
                                ));
                            }
                            result.versions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Version>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVersionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.versions.is_empty() {
            state.serialize_entry("versions", &self.versions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListVersionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListVersionsResponse");
        debug_struct.field("versions", &self.versions);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [CreateSpec][google.cloud.apihub.v1.ApiHub.CreateSpec] method's request.
///
/// [google.cloud.apihub.v1.ApiHub.CreateSpec]: crate::client::ApiHub::create_spec
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSpecRequest {
    /// Required. The parent resource for Spec.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    pub parent: std::string::String,

    /// Optional. The ID to use for the spec, which will become the final component
    /// of the spec's resource name. This field is optional.
    ///
    /// * If provided, the same will be used. The service will throw an error if
    ///   the specified id is already used by another spec in the API
    ///   resource.
    /// * If not provided, a system generated id will be used.
    ///
    /// This value should be 4-500 characters, overall resource name which will be
    /// of format
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`,
    /// its length is limited to 1000 characters and valid characters are
    /// /[a-z][A-Z][0-9]-_/.
    pub spec_id: std::string::String,

    /// Required. The spec to create.
    pub spec: std::option::Option<crate::model::Spec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSpecRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSpecRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [spec_id][crate::model::CreateSpecRequest::spec_id].
    pub fn set_spec_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.spec_id = v.into();
        self
    }

    /// Sets the value of [spec][crate::model::CreateSpecRequest::spec].
    pub fn set_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Spec>,
    {
        self.spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [spec][crate::model::CreateSpecRequest::spec].
    pub fn set_or_clear_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Spec>,
    {
        self.spec = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateSpecRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.CreateSpecRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSpecRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __spec_id,
            __spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSpecRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "specId" => Ok(__FieldTag::__spec_id),
                            "spec_id" => Ok(__FieldTag::__spec_id),
                            "spec" => Ok(__FieldTag::__spec),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSpecRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSpecRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__spec_id => {
                            if !fields.insert(__FieldTag::__spec_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spec_id",
                                ));
                            }
                            result.spec_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__spec => {
                            if !fields.insert(__FieldTag::__spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spec",
                                ));
                            }
                            result.spec =
                                map.next_value::<std::option::Option<crate::model::Spec>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSpecRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.spec_id.is_empty() {
            state.serialize_entry("specId", &self.spec_id)?;
        }
        if self.spec.is_some() {
            state.serialize_entry("spec", &self.spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateSpecRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateSpecRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("spec_id", &self.spec_id);
        debug_struct.field("spec", &self.spec);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [GetSpec][google.cloud.apihub.v1.ApiHub.GetSpec] method's request.
///
/// [google.cloud.apihub.v1.ApiHub.GetSpec]: crate::client::ApiHub::get_spec
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSpecRequest {
    /// Required. The name of the spec to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSpecRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSpecRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSpecRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetSpecRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSpecRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSpecRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSpecRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSpecRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSpecRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetSpecRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSpecRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [UpdateSpec][google.cloud.apihub.v1.ApiHub.UpdateSpec] method's request.
///
/// [google.cloud.apihub.v1.ApiHub.UpdateSpec]: crate::client::ApiHub::update_spec
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSpecRequest {
    /// Required. The spec to update.
    ///
    /// The spec's `name` field is used to identify the spec to
    /// update. Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
    pub spec: std::option::Option<crate::model::Spec>,

    /// Required. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSpecRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [spec][crate::model::UpdateSpecRequest::spec].
    pub fn set_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Spec>,
    {
        self.spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [spec][crate::model::UpdateSpecRequest::spec].
    pub fn set_or_clear_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Spec>,
    {
        self.spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSpecRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSpecRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSpecRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.UpdateSpecRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSpecRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __spec,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSpecRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "spec" => Ok(__FieldTag::__spec),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSpecRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSpecRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__spec => {
                            if !fields.insert(__FieldTag::__spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spec",
                                ));
                            }
                            result.spec =
                                map.next_value::<std::option::Option<crate::model::Spec>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSpecRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.spec.is_some() {
            state.serialize_entry("spec", &self.spec)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateSpecRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateSpecRequest");
        debug_struct.field("spec", &self.spec);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [DeleteSpec][google.cloud.apihub.v1.ApiHub.DeleteSpec] method's request.
///
/// [google.cloud.apihub.v1.ApiHub.DeleteSpec]: crate::client::ApiHub::delete_spec
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSpecRequest {
    /// Required. The name of the spec  to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSpecRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSpecRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSpecRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DeleteSpecRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSpecRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSpecRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSpecRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSpecRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSpecRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteSpecRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSpecRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [ListSpecs][ListSpecs] method's request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSpecsRequest {
    /// Required. The parent, which owns this collection of specs.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    pub parent: std::string::String,

    /// Optional. An expression that filters the list of Specs.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string. The
    /// comparison operator must be one of: `<`, `>`, `:` or `=`. Filters are not
    /// case sensitive.
    ///
    /// The following fields in the `Spec` are eligible for filtering:
    ///
    /// * `display_name` - The display name of the Spec. Allowed comparison
    ///   operators: `=`.
    /// * `create_time` - The time at which the Spec was created. The
    ///   value should be in the (RFC3339)[<https://tools.ietf.org/html/rfc3339>]
    ///   format. Allowed comparison operators: `>` and `<`.
    /// * `spec_type.enum_values.values.id` - The allowed value id of the
    ///   spec_type attribute associated with the Spec. Allowed comparison
    ///   operators: `:`.
    /// * `spec_type.enum_values.values.display_name` - The allowed value display
    ///   name of the spec_type attribute associated with the Spec. Allowed
    ///   comparison operators: `:`.
    /// * `lint_response.json_values.values` - The json value of the
    ///   lint_response attribute associated with the Spec. Allowed comparison
    ///   operators: `:`.
    /// * `mime_type` - The MIME type of the Spec. Allowed comparison
    ///   operators: `=`.
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.enum_values.values.id` - The
    ///   allowed value id of the user defined enum attribute associated with the
    ///   Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-enum-id is a placeholder that can be replaced with
    ///   any user defined enum attribute name.
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.enum_values.values.display_name`
    ///
    /// - The allowed value display name of the user defined enum attribute
    ///   associated with the Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-enum-display-name is a placeholder that can be
    ///   replaced with any user defined enum attribute enum name.
    ///
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.string_values.values` - The
    ///   allowed value of the user defined string attribute associated with the
    ///   Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-string is a placeholder that can be replaced with
    ///   any user defined string attribute name.
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.json_values.values` - The
    ///   allowed value of the user defined JSON attribute associated with the
    ///   Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-json is a placeholder that can be replaced with
    ///   any user defined JSON attribute name.
    ///
    /// Expressions are combined with either `AND` logic operator or `OR` logical
    /// operator but not both of them together i.e. only one of the `AND` or `OR`
    /// operator can be used throughout the filter string and both the operators
    /// cannot be used together. No other logical operators are
    /// supported. At most three filter fields are allowed in the filter
    /// string and if provided more than that then `INVALID_ARGUMENT` error is
    /// returned by the API.
    ///
    /// Here are a few examples:
    ///
    /// * `spec_type.enum_values.values.id: rest-id` -  The filter
    ///   string specifies that the id of the allowed value associated with the
    ///   spec_type attribute is _rest-id_.
    /// * `spec_type.enum_values.values.display_name: \"Rest Display Name\"` -
    ///   The filter string specifies that the display name of the allowed value
    ///   associated with the spec_type attribute is `Rest Display Name`.
    /// * `spec_type.enum_values.values.id: grpc-id AND create_time <
    ///   \"2021-08-15T14:50:00Z\" AND create_time > \"2021-08-10T12:00:00Z\"` -
    ///   The id of the allowed value associated with the spec_type attribute is
    ///   _grpc-id_ and the spec was created before _2021-08-15 14:50:00 UTC_ and
    ///   after _2021-08-10 12:00:00 UTC_.
    /// * `spec_type.enum_values.values.id: rest-id OR
    ///   spec_type.enum_values.values.id: grpc-id`
    ///
    /// - The id of the allowed value associated with the spec_type attribute is
    ///   _rest-id_ or _grpc-id_.
    ///
    /// * `spec_type.enum_values.values.id: rest-id AND
    ///   attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/17650f90-4a29-4971-b3c0-d5532da3764b.enum_values.values.id:
    ///   test`  - The filter string specifies that the id of the allowed value
    ///   associated with the spec_type attribute is _rest-id_ and the id of the
    ///   allowed value associated with the user defined attribute of type enum is
    ///   _test_.
    pub filter: std::string::String,

    /// Optional. The maximum number of specs to return. The service may return
    /// fewer than this value. If unspecified, at most 50 specs will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListSpecs` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListSpecs` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSpecsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSpecsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSpecsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSpecsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSpecsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSpecsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListSpecsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSpecsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSpecsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSpecsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSpecsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSpecsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSpecsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSpecsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [ListSpecs][google.cloud.apihub.v1.ApiHub.ListSpecs] method's response.
///
/// [google.cloud.apihub.v1.ApiHub.ListSpecs]: crate::client::ApiHub::list_specs
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSpecsResponse {
    /// The specs corresponding to an API Version.
    pub specs: std::vec::Vec<crate::model::Spec>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSpecsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [specs][crate::model::ListSpecsResponse::specs].
    pub fn set_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Spec>,
    {
        use std::iter::Iterator;
        self.specs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSpecsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSpecsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListSpecsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSpecsResponse {
    type PageItem = crate::model::Spec;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.specs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSpecsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __specs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSpecsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "specs" => Ok(__FieldTag::__specs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSpecsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSpecsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__specs => {
                            if !fields.insert(__FieldTag::__specs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for specs",
                                ));
                            }
                            result.specs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Spec>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSpecsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.specs.is_empty() {
            state.serialize_entry("specs", &self.specs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSpecsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSpecsResponse");
        debug_struct.field("specs", &self.specs);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [GetSpecContents][google.cloud.apihub.v1.ApiHub.GetSpecContents] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHub.GetSpecContents]: crate::client::ApiHub::get_spec_contents
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSpecContentsRequest {
    /// Required. The name of the spec whose contents need to be retrieved.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSpecContentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSpecContentsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSpecContentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetSpecContentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSpecContentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSpecContentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSpecContentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSpecContentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSpecContentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetSpecContentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSpecContentsRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [CreateApiOperation][google.cloud.apihub.v1.ApiHub.CreateApiOperation]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHub.CreateApiOperation]: crate::client::ApiHub::create_api_operation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateApiOperationRequest {
    /// Required. The parent resource for the operation resource.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    pub parent: std::string::String,

    /// Optional. The ID to use for the operation resource, which will become the
    /// final component of the operation's resource name. This field is optional.
    ///
    /// * If provided, the same will be used. The service will throw an error if
    ///   the specified id is already used by another operation resource in the API
    ///   hub.
    /// * If not provided, a system generated id will be used.
    ///
    /// This value should be 4-500 characters, overall resource name which
    /// will be of format
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/operations/{operation}`,
    /// its length is limited to 700 characters, and valid characters are
    /// /[a-z][A-Z][0-9]-_/.
    pub api_operation_id: std::string::String,

    /// Required. The operation resource to create.
    pub api_operation: std::option::Option<crate::model::ApiOperation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateApiOperationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateApiOperationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [api_operation_id][crate::model::CreateApiOperationRequest::api_operation_id].
    pub fn set_api_operation_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.api_operation_id = v.into();
        self
    }

    /// Sets the value of [api_operation][crate::model::CreateApiOperationRequest::api_operation].
    pub fn set_api_operation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApiOperation>,
    {
        self.api_operation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [api_operation][crate::model::CreateApiOperationRequest::api_operation].
    pub fn set_or_clear_api_operation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApiOperation>,
    {
        self.api_operation = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateApiOperationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.CreateApiOperationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateApiOperationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __api_operation_id,
            __api_operation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateApiOperationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "apiOperationId" => Ok(__FieldTag::__api_operation_id),
                            "api_operation_id" => Ok(__FieldTag::__api_operation_id),
                            "apiOperation" => Ok(__FieldTag::__api_operation),
                            "api_operation" => Ok(__FieldTag::__api_operation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateApiOperationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateApiOperationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_operation_id => {
                            if !fields.insert(__FieldTag::__api_operation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_operation_id",
                                ));
                            }
                            result.api_operation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_operation => {
                            if !fields.insert(__FieldTag::__api_operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_operation",
                                ));
                            }
                            result.api_operation = map
                                .next_value::<std::option::Option<crate::model::ApiOperation>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateApiOperationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.api_operation_id.is_empty() {
            state.serialize_entry("apiOperationId", &self.api_operation_id)?;
        }
        if self.api_operation.is_some() {
            state.serialize_entry("apiOperation", &self.api_operation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateApiOperationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateApiOperationRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("api_operation_id", &self.api_operation_id);
        debug_struct.field("api_operation", &self.api_operation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [GetApiOperation][google.cloud.apihub.v1.ApiHub.GetApiOperation] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHub.GetApiOperation]: crate::client::ApiHub::get_api_operation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetApiOperationRequest {
    /// Required. The name of the operation to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/operations/{operation}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetApiOperationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetApiOperationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetApiOperationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetApiOperationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetApiOperationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetApiOperationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetApiOperationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetApiOperationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetApiOperationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetApiOperationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetApiOperationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [UpdateApiOperation][google.cloud.apihub.v1.ApiHub.UpdateApiOperation]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHub.UpdateApiOperation]: crate::client::ApiHub::update_api_operation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateApiOperationRequest {
    /// Required. The apiOperation resource to update.
    ///
    /// The operation resource's `name` field is used to identify the operation
    /// resource to update.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/operations/{operation}`
    pub api_operation: std::option::Option<crate::model::ApiOperation>,

    /// Required. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateApiOperationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [api_operation][crate::model::UpdateApiOperationRequest::api_operation].
    pub fn set_api_operation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApiOperation>,
    {
        self.api_operation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [api_operation][crate::model::UpdateApiOperationRequest::api_operation].
    pub fn set_or_clear_api_operation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApiOperation>,
    {
        self.api_operation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateApiOperationRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateApiOperationRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateApiOperationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.UpdateApiOperationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateApiOperationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __api_operation,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateApiOperationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "apiOperation" => Ok(__FieldTag::__api_operation),
                            "api_operation" => Ok(__FieldTag::__api_operation),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateApiOperationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateApiOperationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__api_operation => {
                            if !fields.insert(__FieldTag::__api_operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_operation",
                                ));
                            }
                            result.api_operation = map
                                .next_value::<std::option::Option<crate::model::ApiOperation>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateApiOperationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.api_operation.is_some() {
            state.serialize_entry("apiOperation", &self.api_operation)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateApiOperationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateApiOperationRequest");
        debug_struct.field("api_operation", &self.api_operation);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [DeleteApiOperation][google.cloud.apihub.v1.ApiHub.DeleteApiOperation]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHub.DeleteApiOperation]: crate::client::ApiHub::delete_api_operation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteApiOperationRequest {
    /// Required. The name of the operation resource to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/operations/{operation}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteApiOperationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteApiOperationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteApiOperationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DeleteApiOperationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteApiOperationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteApiOperationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteApiOperationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteApiOperationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteApiOperationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteApiOperationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteApiOperationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [ListApiOperations][google.cloud.apihub.v1.ApiHub.ListApiOperations]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHub.ListApiOperations]: crate::client::ApiHub::list_api_operations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListApiOperationsRequest {
    /// Required. The parent which owns this collection of operations i.e., the API
    /// version. Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    pub parent: std::string::String,

    /// Optional. An expression that filters the list of ApiOperations.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string or a
    /// boolean. The comparison operator must be one of: `<`, `>` or
    /// `=`. Filters are not case sensitive.
    ///
    /// The following fields in the `ApiOperation` are eligible for filtering:
    ///
    /// * `name` - The ApiOperation resource name. Allowed comparison
    ///   operators:
    ///   `=`.
    /// * `details.http_operation.path.path` - The http operation's complete path
    ///   relative to server endpoint. Allowed comparison operators: `=`.
    /// * `details.http_operation.method` - The http operation method type.
    ///   Allowed comparison operators: `=`.
    /// * `details.deprecated` - Indicates if the ApiOperation is deprecated.
    ///   Allowed values are True / False indicating the deprycation status of the
    ///   ApiOperation. Allowed comparison operators: `=`.
    /// * `create_time` - The time at which the ApiOperation was created. The
    ///   value should be in the (RFC3339)[<https://tools.ietf.org/html/rfc3339>]
    ///   format. Allowed comparison operators: `>` and `<`.
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.enum_values.values.id` - The
    ///   allowed value id of the user defined enum attribute associated with the
    ///   Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-enum-id is a placeholder that can be replaced with
    ///   any user defined enum attribute name.
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.enum_values.values.display_name`
    ///
    /// - The allowed value display name of the user defined enum attribute
    ///   associated with the Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-enum-display-name is a placeholder that can be
    ///   replaced with any user defined enum attribute enum name.
    ///
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.string_values.values` - The
    ///   allowed value of the user defined string attribute associated with the
    ///   Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-string is a placeholder that can be replaced with
    ///   any user defined string attribute name.
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.json_values.values` - The
    ///   allowed value of the user defined JSON attribute associated with the
    ///   Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-json is a placeholder that can be replaced with
    ///   any user defined JSON attribute name.
    ///
    /// Expressions are combined with either `AND` logic operator or `OR` logical
    /// operator but not both of them together i.e. only one of the `AND` or `OR`
    /// operator can be used throughout the filter string and both the operators
    /// cannot be used together. No other logical operators are supported. At most
    /// three filter fields are allowed in the filter string and if provided
    /// more than that then `INVALID_ARGUMENT` error is returned by the API.
    ///
    /// Here are a few examples:
    ///
    /// * `details.deprecated = True` -  The ApiOperation is deprecated.
    /// * `details.http_operation.method = GET AND create_time <
    ///   \"2021-08-15T14:50:00Z\" AND create_time > \"2021-08-10T12:00:00Z\"` -
    ///   The method of the http operation of the ApiOperation is _GET_ and the
    ///   spec was created before _2021-08-15 14:50:00 UTC_ and after _2021-08-10
    ///   12:00:00 UTC_.
    /// * `details.http_operation.method = GET OR details.http_operation.method =
    ///   POST`. - The http operation of the method of ApiOperation is _GET_ or
    ///   _POST_.
    /// * `details.deprecated = True AND
    ///   attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/17650f90-4a29-4971-b3c0-d5532da3764b.string_values.values:
    ///   test`  - The filter string specifies that the ApiOperation is deprecated
    ///   and the value of the user defined attribute of type string is _test_.
    pub filter: std::string::String,

    /// Optional. The maximum number of operations to return. The service may
    /// return fewer than this value. If unspecified, at most 50 operations will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListApiOperations` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters (except page_size) provided to
    /// `ListApiOperations` must match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListApiOperationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListApiOperationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListApiOperationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListApiOperationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListApiOperationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListApiOperationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListApiOperationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListApiOperationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListApiOperationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListApiOperationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListApiOperationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListApiOperationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListApiOperationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListApiOperationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [ListApiOperations][google.cloud.apihub.v1.ApiHub.ListApiOperations]
/// method's response.
///
/// [google.cloud.apihub.v1.ApiHub.ListApiOperations]: crate::client::ApiHub::list_api_operations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListApiOperationsResponse {
    /// The operations corresponding to an API version.
    pub api_operations: std::vec::Vec<crate::model::ApiOperation>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListApiOperationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [api_operations][crate::model::ListApiOperationsResponse::api_operations].
    pub fn set_api_operations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ApiOperation>,
    {
        use std::iter::Iterator;
        self.api_operations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListApiOperationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListApiOperationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListApiOperationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListApiOperationsResponse {
    type PageItem = crate::model::ApiOperation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.api_operations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListApiOperationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __api_operations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListApiOperationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "apiOperations" => Ok(__FieldTag::__api_operations),
                            "api_operations" => Ok(__FieldTag::__api_operations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListApiOperationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListApiOperationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__api_operations => {
                            if !fields.insert(__FieldTag::__api_operations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_operations",
                                ));
                            }
                            result.api_operations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ApiOperation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListApiOperationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.api_operations.is_empty() {
            state.serialize_entry("apiOperations", &self.api_operations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListApiOperationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListApiOperationsResponse");
        debug_struct.field("api_operations", &self.api_operations);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [GetDefinition][google.cloud.apihub.v1.ApiHub.GetDefinition] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHub.GetDefinition]: crate::client::ApiHub::get_definition
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDefinitionRequest {
    /// Required. The name of the definition to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/definitions/{definition}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDefinitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDefinitionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDefinitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetDefinitionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDefinitionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDefinitionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDefinitionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDefinitionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDefinitionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetDefinitionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDefinitionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [CreateDeployment][google.cloud.apihub.v1.ApiHub.CreateDeployment]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHub.CreateDeployment]: crate::client::ApiHub::create_deployment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDeploymentRequest {
    /// Required. The parent resource for the deployment resource.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Optional. The ID to use for the deployment resource, which will become the
    /// final component of the deployment's resource name. This field is optional.
    ///
    /// * If provided, the same will be used. The service will throw an error if
    ///   the specified id is already used by another deployment resource in the API
    ///   hub.
    /// * If not provided, a system generated id will be used.
    ///
    /// This value should be 4-500 characters, and valid characters
    /// are /[a-z][A-Z][0-9]-_/.
    pub deployment_id: std::string::String,

    /// Required. The deployment resource to create.
    pub deployment: std::option::Option<crate::model::Deployment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDeploymentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [deployment_id][crate::model::CreateDeploymentRequest::deployment_id].
    pub fn set_deployment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.deployment_id = v.into();
        self
    }

    /// Sets the value of [deployment][crate::model::CreateDeploymentRequest::deployment].
    pub fn set_deployment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Deployment>,
    {
        self.deployment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deployment][crate::model::CreateDeploymentRequest::deployment].
    pub fn set_or_clear_deployment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Deployment>,
    {
        self.deployment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.CreateDeploymentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __deployment_id,
            __deployment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "deploymentId" => Ok(__FieldTag::__deployment_id),
                            "deployment_id" => Ok(__FieldTag::__deployment_id),
                            "deployment" => Ok(__FieldTag::__deployment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deployment_id => {
                            if !fields.insert(__FieldTag::__deployment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment_id",
                                ));
                            }
                            result.deployment_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deployment => {
                            if !fields.insert(__FieldTag::__deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment",
                                ));
                            }
                            result.deployment =
                                map.next_value::<std::option::Option<crate::model::Deployment>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDeploymentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.deployment_id.is_empty() {
            state.serialize_entry("deploymentId", &self.deployment_id)?;
        }
        if self.deployment.is_some() {
            state.serialize_entry("deployment", &self.deployment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateDeploymentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateDeploymentRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("deployment_id", &self.deployment_id);
        debug_struct.field("deployment", &self.deployment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [GetDeployment][google.cloud.apihub.v1.ApiHub.GetDeployment] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHub.GetDeployment]: crate::client::ApiHub::get_deployment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDeploymentRequest {
    /// Required. The name of the deployment resource to retrieve.
    /// Format: `projects/{project}/locations/{location}/deployments/{deployment}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetDeploymentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDeploymentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetDeploymentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDeploymentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [UpdateDeployment][google.cloud.apihub.v1.ApiHub.UpdateDeployment]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHub.UpdateDeployment]: crate::client::ApiHub::update_deployment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDeploymentRequest {
    /// Required. The deployment resource to update.
    ///
    /// The deployment resource's `name` field is used to identify the deployment
    /// resource to update.
    /// Format: `projects/{project}/locations/{location}/deployments/{deployment}`
    pub deployment: std::option::Option<crate::model::Deployment>,

    /// Required. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployment][crate::model::UpdateDeploymentRequest::deployment].
    pub fn set_deployment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Deployment>,
    {
        self.deployment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deployment][crate::model::UpdateDeploymentRequest::deployment].
    pub fn set_or_clear_deployment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Deployment>,
    {
        self.deployment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDeploymentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDeploymentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.UpdateDeploymentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __deployment,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deployment" => Ok(__FieldTag::__deployment),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__deployment => {
                            if !fields.insert(__FieldTag::__deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment",
                                ));
                            }
                            result.deployment =
                                map.next_value::<std::option::Option<crate::model::Deployment>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDeploymentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.deployment.is_some() {
            state.serialize_entry("deployment", &self.deployment)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateDeploymentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateDeploymentRequest");
        debug_struct.field("deployment", &self.deployment);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [DeleteDeployment][google.cloud.apihub.v1.ApiHub.DeleteDeployment]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHub.DeleteDeployment]: crate::client::ApiHub::delete_deployment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDeploymentRequest {
    /// Required. The name of the deployment resource to delete.
    /// Format: `projects/{project}/locations/{location}/deployments/{deployment}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DeleteDeploymentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDeploymentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteDeploymentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteDeploymentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [ListDeployments][google.cloud.apihub.v1.ApiHub.ListDeployments] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHub.ListDeployments]: crate::client::ApiHub::list_deployments
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDeploymentsRequest {
    /// Required. The parent, which owns this collection of deployment resources.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Optional. An expression that filters the list of Deployments.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string. The
    /// comparison operator must be one of: `<`, `>` or
    /// `=`. Filters are not case sensitive.
    ///
    /// The following fields in the `Deployments` are eligible for filtering:
    ///
    /// * `display_name` - The display name of the Deployment. Allowed
    ///   comparison operators: `=`.
    /// * `create_time` - The time at which the Deployment was created. The
    ///   value should be in the (RFC3339)[<https://tools.ietf.org/html/rfc3339>]
    ///   format. Allowed comparison operators: `>` and `<`.
    /// * `resource_uri` - A URI to the deployment resource. Allowed
    ///   comparison operators: `=`.
    /// * `api_versions` - The API versions linked to this deployment. Allowed
    ///   comparison operators: `:`.
    /// * `source_project` - The project/organization at source for the
    ///   deployment. Allowed comparison operators: `=`.
    /// * `source_environment` - The environment at source for the
    ///   deployment. Allowed comparison operators: `=`.
    /// * `deployment_type.enum_values.values.id` - The allowed value id of the
    ///   deployment_type attribute associated with the Deployment. Allowed
    ///   comparison operators: `:`.
    /// * `deployment_type.enum_values.values.display_name` - The allowed value
    ///   display name of the deployment_type attribute associated with the
    ///   Deployment. Allowed comparison operators: `:`.
    /// * `slo.string_values.values` -The allowed string value of the slo
    ///   attribute associated with the deployment. Allowed comparison
    ///   operators: `:`.
    /// * `environment.enum_values.values.id` - The allowed value id of the
    ///   environment attribute associated with the deployment. Allowed
    ///   comparison operators: `:`.
    /// * `environment.enum_values.values.display_name` - The allowed value
    ///   display name of the environment attribute associated with the deployment.
    ///   Allowed comparison operators: `:`.
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.enum_values.values.id` - The
    ///   allowed value id of the user defined enum attribute associated with the
    ///   Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-enum-id is a placeholder that can be replaced with
    ///   any user defined enum attribute name.
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.enum_values.values.display_name`
    ///
    /// - The allowed value display name of the user defined enum attribute
    ///   associated with the Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-enum-display-name is a placeholder that can be
    ///   replaced with any user defined enum attribute enum name.
    ///
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.string_values.values` - The
    ///   allowed value of the user defined string attribute associated with the
    ///   Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-string is a placeholder that can be replaced with
    ///   any user defined string attribute name.
    /// * `attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/user-defined-attribute-id.json_values.values` - The
    ///   allowed value of the user defined JSON attribute associated with the
    ///   Resource. Allowed comparison operator is `:`. Here
    ///   user-defined-attribute-json is a placeholder that can be replaced with
    ///   any user defined JSON attribute name.
    ///
    /// A filter function is also supported in the filter string. The filter
    /// function is `id(name)`. The `id(name)` function returns the id of the
    /// resource name. For example, `id(name) = \"deployment-1\"` is equivalent to
    /// `name =
    /// \"projects/test-project-id/locations/test-location-id/deployments/deployment-1\"`
    /// provided the parent is
    /// `projects/test-project-id/locations/test-location-id`.
    ///
    /// Expressions are combined with either `AND` logic operator or `OR` logical
    /// operator but not both of them together i.e. only one of the `AND` or `OR`
    /// operator can be used throughout the filter string and both the operators
    /// cannot be used together. No other logical operators are supported. At most
    /// three filter fields are allowed in the filter string and if provided
    /// more than that then `INVALID_ARGUMENT` error is returned by the API.
    ///
    /// Here are a few examples:
    ///
    /// * `environment.enum_values.values.id: staging-id` - The allowed value id
    ///   of the environment attribute associated with the Deployment is
    ///   _staging-id_.
    /// * `environment.enum_values.values.display_name: \"Staging Deployment\"` -
    ///   The allowed value display name of the environment attribute associated
    ///   with the Deployment is `Staging Deployment`.
    /// * `environment.enum_values.values.id: production-id AND create_time <
    ///   \"2021-08-15T14:50:00Z\" AND create_time > \"2021-08-10T12:00:00Z\"` -
    ///   The allowed value id of the environment attribute associated with the
    ///   Deployment is _production-id_ and Deployment was created before
    ///   _2021-08-15 14:50:00 UTC_ and after _2021-08-10 12:00:00 UTC_.
    /// * `environment.enum_values.values.id: production-id OR
    ///   slo.string_values.values: \"99.99%\"`
    ///
    /// - The allowed value id of the environment attribute Deployment is
    ///   _production-id_ or string value of the slo attribute is _99.99%_.
    ///
    /// * `environment.enum_values.values.id: staging-id AND
    ///   attributes.projects/test-project-id/locations/test-location-id/
    ///   attributes/17650f90-4a29-4971-b3c0-d5532da3764b.string_values.values:
    ///   test`  - The filter string specifies that the allowed value id of the
    ///   environment attribute associated with the Deployment is _staging-id_ and
    ///   the value of the user defined attribute of type string is _test_.
    pub filter: std::string::String,

    /// Optional. The maximum number of deployment resources to return. The service
    /// may return fewer than this value. If unspecified, at most 50 deployments
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListDeployments` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters (except page_size) provided to
    /// `ListDeployments` must match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeploymentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDeploymentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDeploymentsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDeploymentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDeploymentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDeploymentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListDeploymentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDeploymentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDeploymentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDeploymentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDeploymentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDeploymentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDeploymentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDeploymentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [ListDeployments][google.cloud.apihub.v1.ApiHub.ListDeployments] method's
/// response.
///
/// [google.cloud.apihub.v1.ApiHub.ListDeployments]: crate::client::ApiHub::list_deployments
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDeploymentsResponse {
    /// The deployment resources present in the API hub.
    pub deployments: std::vec::Vec<crate::model::Deployment>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeploymentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployments][crate::model::ListDeploymentsResponse::deployments].
    pub fn set_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Deployment>,
    {
        use std::iter::Iterator;
        self.deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDeploymentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDeploymentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListDeploymentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDeploymentsResponse {
    type PageItem = crate::model::Deployment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.deployments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDeploymentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __deployments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDeploymentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deployments" => Ok(__FieldTag::__deployments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDeploymentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDeploymentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__deployments => {
                            if !fields.insert(__FieldTag::__deployments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployments",
                                ));
                            }
                            result.deployments = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Deployment>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDeploymentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.deployments.is_empty() {
            state.serialize_entry("deployments", &self.deployments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDeploymentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDeploymentsResponse");
        debug_struct.field("deployments", &self.deployments);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [CreateAttribute][google.cloud.apihub.v1.ApiHub.CreateAttribute] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHub.CreateAttribute]: crate::client::ApiHub::create_attribute
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAttributeRequest {
    /// Required. The parent resource for Attribute.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Optional. The ID to use for the attribute, which will become the final
    /// component of the attribute's resource name. This field is optional.
    ///
    /// * If provided, the same will be used. The service will throw an error if
    ///   the specified id is already used by another attribute resource in the API
    ///   hub.
    /// * If not provided, a system generated id will be used.
    ///
    /// This value should be 4-500 characters, and valid characters
    /// are /[a-z][A-Z][0-9]-_/.
    pub attribute_id: std::string::String,

    /// Required. The attribute to create.
    pub attribute: std::option::Option<crate::model::Attribute>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAttributeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAttributeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [attribute_id][crate::model::CreateAttributeRequest::attribute_id].
    pub fn set_attribute_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.attribute_id = v.into();
        self
    }

    /// Sets the value of [attribute][crate::model::CreateAttributeRequest::attribute].
    pub fn set_attribute<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Attribute>,
    {
        self.attribute = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [attribute][crate::model::CreateAttributeRequest::attribute].
    pub fn set_or_clear_attribute<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Attribute>,
    {
        self.attribute = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateAttributeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.CreateAttributeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAttributeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __attribute_id,
            __attribute,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAttributeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "attributeId" => Ok(__FieldTag::__attribute_id),
                            "attribute_id" => Ok(__FieldTag::__attribute_id),
                            "attribute" => Ok(__FieldTag::__attribute),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAttributeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAttributeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attribute_id => {
                            if !fields.insert(__FieldTag::__attribute_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribute_id",
                                ));
                            }
                            result.attribute_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attribute => {
                            if !fields.insert(__FieldTag::__attribute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribute",
                                ));
                            }
                            result.attribute =
                                map.next_value::<std::option::Option<crate::model::Attribute>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAttributeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.attribute_id.is_empty() {
            state.serialize_entry("attributeId", &self.attribute_id)?;
        }
        if self.attribute.is_some() {
            state.serialize_entry("attribute", &self.attribute)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateAttributeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateAttributeRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("attribute_id", &self.attribute_id);
        debug_struct.field("attribute", &self.attribute);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [GetAttribute][google.cloud.apihub.v1.ApiHub.GetAttribute] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHub.GetAttribute]: crate::client::ApiHub::get_attribute
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAttributeRequest {
    /// Required. The name of the attribute to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/attributes/{attribute}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAttributeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAttributeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAttributeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetAttributeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAttributeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAttributeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAttributeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAttributeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAttributeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetAttributeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetAttributeRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [UpdateAttribute][google.cloud.apihub.v1.ApiHub.UpdateAttribute] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHub.UpdateAttribute]: crate::client::ApiHub::update_attribute
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAttributeRequest {
    /// Required. The attribute to update.
    ///
    /// The attribute's `name` field is used to identify the attribute to update.
    /// Format:
    /// `projects/{project}/locations/{location}/attributes/{attribute}`
    pub attribute: std::option::Option<crate::model::Attribute>,

    /// Required. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAttributeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attribute][crate::model::UpdateAttributeRequest::attribute].
    pub fn set_attribute<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Attribute>,
    {
        self.attribute = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [attribute][crate::model::UpdateAttributeRequest::attribute].
    pub fn set_or_clear_attribute<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Attribute>,
    {
        self.attribute = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAttributeRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAttributeRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAttributeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.UpdateAttributeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAttributeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attribute,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAttributeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attribute" => Ok(__FieldTag::__attribute),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAttributeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAttributeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attribute => {
                            if !fields.insert(__FieldTag::__attribute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribute",
                                ));
                            }
                            result.attribute =
                                map.next_value::<std::option::Option<crate::model::Attribute>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAttributeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.attribute.is_some() {
            state.serialize_entry("attribute", &self.attribute)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateAttributeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateAttributeRequest");
        debug_struct.field("attribute", &self.attribute);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [DeleteAttribute][google.cloud.apihub.v1.ApiHub.DeleteAttribute] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHub.DeleteAttribute]: crate::client::ApiHub::delete_attribute
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAttributeRequest {
    /// Required. The name of the attribute to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/attributes/{attribute}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAttributeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAttributeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAttributeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DeleteAttributeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAttributeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAttributeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAttributeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAttributeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAttributeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteAttributeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteAttributeRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [ListAttributes][google.cloud.apihub.v1.ApiHub.ListAttributes] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHub.ListAttributes]: crate::client::ApiHub::list_attributes
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAttributesRequest {
    /// Required. The parent resource for Attribute.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Optional. An expression that filters the list of Attributes.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string or a
    /// boolean. The comparison operator must be one of: `<`, `>` or
    /// `=`. Filters are not case sensitive.
    ///
    /// The following fields in the `Attribute` are eligible for filtering:
    ///
    /// * `display_name` - The display name of the Attribute. Allowed
    ///   comparison operators: `=`.
    /// * `definition_type` - The definition type of the attribute. Allowed
    ///   comparison operators: `=`.
    /// * `scope` - The scope of the attribute. Allowed comparison operators:
    ///   `=`.
    /// * `data_type` - The type of the data of the attribute. Allowed
    ///   comparison operators: `=`.
    /// * `mandatory` - Denotes whether the attribute is mandatory or not.
    ///   Allowed comparison operators: `=`.
    /// * `create_time` - The time at which the Attribute was created. The
    ///   value should be in the (RFC3339)[<https://tools.ietf.org/html/rfc3339>]
    ///   format. Allowed comparison operators: `>` and `<`.
    ///
    /// Expressions are combined with either `AND` logic operator or `OR` logical
    /// operator but not both of them together i.e. only one of the `AND` or `OR`
    /// operator can be used throughout the filter string and both the operators
    /// cannot be used together. No other logical operators are
    /// supported. At most three filter fields are allowed in the filter
    /// string and if provided more than that then `INVALID_ARGUMENT` error is
    /// returned by the API.
    ///
    /// Here are a few examples:
    ///
    /// * `display_name = production` -  - The display name of the attribute is
    ///   _production_.
    /// * `(display_name = production) AND (create_time <
    ///   \"2021-08-15T14:50:00Z\") AND (create_time > \"2021-08-10T12:00:00Z\")` -
    ///   The display name of the attribute is _production_ and the attribute was
    ///   created before _2021-08-15 14:50:00 UTC_ and after _2021-08-10 12:00:00
    ///   UTC_.
    /// * `display_name = production OR scope = api` -
    ///   The attribute where the display name is _production_ or the scope is
    ///   _api_.
    pub filter: std::string::String,

    /// Optional. The maximum number of attribute resources to return. The service
    /// may return fewer than this value. If unspecified, at most 50 attributes
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListAttributes` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListAttributes` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAttributesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAttributesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAttributesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAttributesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAttributesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAttributesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListAttributesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAttributesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAttributesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAttributesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAttributesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAttributesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAttributesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAttributesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [ListAttributes][google.cloud.apihub.v1.ApiHub.ListAttributes] method's
/// response.
///
/// [google.cloud.apihub.v1.ApiHub.ListAttributes]: crate::client::ApiHub::list_attributes
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAttributesResponse {
    /// The list of all attributes.
    pub attributes: std::vec::Vec<crate::model::Attribute>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAttributesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attributes][crate::model::ListAttributesResponse::attributes].
    pub fn set_attributes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Attribute>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAttributesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAttributesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListAttributesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAttributesResponse {
    type PageItem = crate::model::Attribute;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.attributes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAttributesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attributes,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAttributesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attributes" => Ok(__FieldTag::__attributes),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAttributesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAttributesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Attribute>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAttributesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAttributesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAttributesResponse");
        debug_struct.field("attributes", &self.attributes);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [SearchResources][google.cloud.apihub.v1.ApiHub.SearchResources] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHub.SearchResources]: crate::client::ApiHub::search_resources
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchResourcesRequest {
    /// Required. The resource name of the location which will be of the type
    /// `projects/{project_id}/locations/{location_id}`. This field is used to
    /// identify the instance of API-Hub in which resources should be searched.
    pub location: std::string::String,

    /// Required. The free text search query. This query can contain keywords which
    /// could be related to any detail of the API-Hub resources such display names,
    /// descriptions, attributes etc.
    pub query: std::string::String,

    /// Optional. An expression that filters the list of search results.
    ///
    /// A filter expression consists of a field name, a comparison operator,
    /// and a value for filtering. The value must be a string, a number, or a
    /// boolean. The comparison operator must be `=`. Filters are not case
    /// sensitive.
    ///
    /// The following field names are eligible for filtering:
    ///
    /// * `resource_type` - The type of resource in the search results.
    ///   Must be one of the following: `Api`, `ApiOperation`, `Deployment`,
    ///   `Definition`, `Spec` or `Version`. This field can only be specified once
    ///   in the filter.
    ///
    /// Here are is an example:
    ///
    /// * `resource_type = Api` - The resource_type is _Api_.
    pub filter: std::string::String,

    /// Optional. The maximum number of search results to return. The service may
    /// return fewer than this value. If unspecified at most 10 search results will
    /// be returned. If value is negative then `INVALID_ARGUMENT` error is
    /// returned. The maximum value is 25; values above 25 will be coerced to 25.
    /// While paginating, you can specify a new page size parameter for each page
    /// of search results to be listed.
    pub page_size: i32,

    /// Optional. A page token, received from a previous
    /// [SearchResources][SearchResources]
    /// call. Specify this parameter to retrieve the next page of transactions.
    ///
    /// When paginating, you must specify the `page_token` parameter and all the
    /// other parameters except
    /// [page_size][google.cloud.apihub.v1.SearchResourcesRequest.page_size]
    /// should be specified with the same value which was used in the previous
    /// call. If the other fields are set with a different value than the previous
    /// call then `INVALID_ARGUMENT` error is returned.
    ///
    /// [google.cloud.apihub.v1.SearchResourcesRequest.page_size]: crate::model::SearchResourcesRequest::page_size
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchResourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::SearchResourcesRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchResourcesRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::SearchResourcesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchResourcesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchResourcesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchResourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.SearchResourcesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchResourcesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            __query,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchResourcesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            "query" => Ok(__FieldTag::__query),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchResourcesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchResourcesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchResourcesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchResourcesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchResourcesRequest");
        debug_struct.field("location", &self.location);
        debug_struct.field("query", &self.query);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ApiHubResource is one of the resources such as Api, Operation, Deployment,
/// Definition, Spec and Version resources stored in API-Hub.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApiHubResource {
    pub resource: std::option::Option<crate::model::api_hub_resource::Resource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApiHubResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource][crate::model::ApiHubResource::resource].
    ///
    /// Note that all the setters affecting `resource` are mutually
    /// exclusive.
    pub fn set_resource<
        T: std::convert::Into<std::option::Option<crate::model::api_hub_resource::Resource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = v.into();
        self
    }

    /// The value of [resource][crate::model::ApiHubResource::resource]
    /// if it holds a `Api`, `None` if the field is not set or
    /// holds a different branch.
    pub fn api(&self) -> std::option::Option<&std::boxed::Box<crate::model::Api>> {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::api_hub_resource::Resource::Api(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource][crate::model::ApiHubResource::resource]
    /// to hold a `Api`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_api<T: std::convert::Into<std::boxed::Box<crate::model::Api>>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource =
            std::option::Option::Some(crate::model::api_hub_resource::Resource::Api(v.into()));
        self
    }

    /// The value of [resource][crate::model::ApiHubResource::resource]
    /// if it holds a `Operation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn operation(&self) -> std::option::Option<&std::boxed::Box<crate::model::ApiOperation>> {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::api_hub_resource::Resource::Operation(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource][crate::model::ApiHubResource::resource]
    /// to hold a `Operation`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_operation<T: std::convert::Into<std::boxed::Box<crate::model::ApiOperation>>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::api_hub_resource::Resource::Operation(v.into()),
        );
        self
    }

    /// The value of [resource][crate::model::ApiHubResource::resource]
    /// if it holds a `Deployment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deployment(&self) -> std::option::Option<&std::boxed::Box<crate::model::Deployment>> {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::api_hub_resource::Resource::Deployment(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource][crate::model::ApiHubResource::resource]
    /// to hold a `Deployment`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_deployment<T: std::convert::Into<std::boxed::Box<crate::model::Deployment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::api_hub_resource::Resource::Deployment(v.into()),
        );
        self
    }

    /// The value of [resource][crate::model::ApiHubResource::resource]
    /// if it holds a `Spec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::Spec>> {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::api_hub_resource::Resource::Spec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource][crate::model::ApiHubResource::resource]
    /// to hold a `Spec`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_spec<T: std::convert::Into<std::boxed::Box<crate::model::Spec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource =
            std::option::Option::Some(crate::model::api_hub_resource::Resource::Spec(v.into()));
        self
    }

    /// The value of [resource][crate::model::ApiHubResource::resource]
    /// if it holds a `Definition`, `None` if the field is not set or
    /// holds a different branch.
    pub fn definition(&self) -> std::option::Option<&std::boxed::Box<crate::model::Definition>> {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::api_hub_resource::Resource::Definition(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource][crate::model::ApiHubResource::resource]
    /// to hold a `Definition`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_definition<T: std::convert::Into<std::boxed::Box<crate::model::Definition>>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::api_hub_resource::Resource::Definition(v.into()),
        );
        self
    }

    /// The value of [resource][crate::model::ApiHubResource::resource]
    /// if it holds a `Version`, `None` if the field is not set or
    /// holds a different branch.
    pub fn version(&self) -> std::option::Option<&std::boxed::Box<crate::model::Version>> {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::api_hub_resource::Resource::Version(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource][crate::model::ApiHubResource::resource]
    /// to hold a `Version`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_version<T: std::convert::Into<std::boxed::Box<crate::model::Version>>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource =
            std::option::Option::Some(crate::model::api_hub_resource::Resource::Version(v.into()));
        self
    }
}

impl wkt::message::Message for ApiHubResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ApiHubResource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApiHubResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __api,
            __operation,
            __deployment,
            __spec,
            __definition,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApiHubResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "api" => Ok(__FieldTag::__api),
                            "operation" => Ok(__FieldTag::__operation),
                            "deployment" => Ok(__FieldTag::__deployment),
                            "spec" => Ok(__FieldTag::__spec),
                            "definition" => Ok(__FieldTag::__definition),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApiHubResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApiHubResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__api => {
                            if !fields.insert(__FieldTag::__api) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api",
                                ));
                            }
                            if result.resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource`, a oneof with full ID .google.cloud.apihub.v1.ApiHubResource.api, latest field was api",
                                ));
                            }
                            result.resource = std::option::Option::Some(
                                crate::model::api_hub_resource::Resource::Api(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::Api>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__operation => {
                            if !fields.insert(__FieldTag::__operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation",
                                ));
                            }
                            if result.resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource`, a oneof with full ID .google.cloud.apihub.v1.ApiHubResource.operation, latest field was operation",
                                ));
                            }
                            result.resource = std::option::Option::Some(
                                crate::model::api_hub_resource::Resource::Operation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ApiOperation>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__deployment => {
                            if !fields.insert(__FieldTag::__deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment",
                                ));
                            }
                            if result.resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource`, a oneof with full ID .google.cloud.apihub.v1.ApiHubResource.deployment, latest field was deployment",
                                ));
                            }
                            result.resource = std::option::Option::Some(
                                crate::model::api_hub_resource::Resource::Deployment(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Deployment>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__spec => {
                            if !fields.insert(__FieldTag::__spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spec",
                                ));
                            }
                            if result.resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource`, a oneof with full ID .google.cloud.apihub.v1.ApiHubResource.spec, latest field was spec",
                                ));
                            }
                            result.resource =
                                std::option::Option::Some(
                                    crate::model::api_hub_resource::Resource::Spec(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Spec>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__definition => {
                            if !fields.insert(__FieldTag::__definition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for definition",
                                ));
                            }
                            if result.resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource`, a oneof with full ID .google.cloud.apihub.v1.ApiHubResource.definition, latest field was definition",
                                ));
                            }
                            result.resource = std::option::Option::Some(
                                crate::model::api_hub_resource::Resource::Definition(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Definition>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            if result.resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource`, a oneof with full ID .google.cloud.apihub.v1.ApiHubResource.version, latest field was version",
                                ));
                            }
                            result.resource =
                                std::option::Option::Some(
                                    crate::model::api_hub_resource::Resource::Version(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Version>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApiHubResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.api() {
            state.serialize_entry("api", value)?;
        }
        if let Some(value) = self.operation() {
            state.serialize_entry("operation", value)?;
        }
        if let Some(value) = self.deployment() {
            state.serialize_entry("deployment", value)?;
        }
        if let Some(value) = self.spec() {
            state.serialize_entry("spec", value)?;
        }
        if let Some(value) = self.definition() {
            state.serialize_entry("definition", value)?;
        }
        if let Some(value) = self.version() {
            state.serialize_entry("version", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApiHubResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApiHubResource");
        debug_struct.field("resource", &self.resource);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ApiHubResource].
pub mod api_hub_resource {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Resource {
        /// This represents Api resource in search results. Only name, display_name,
        /// description and owner fields are populated in search results.
        Api(std::boxed::Box<crate::model::Api>),
        /// This represents ApiOperation resource in search results. Only name,
        /// description, spec and details fields are populated in search results.
        Operation(std::boxed::Box<crate::model::ApiOperation>),
        /// This represents Deployment resource in search results. Only name,
        /// display_name, description, deployment_type and api_versions fields are
        /// populated in search results.
        Deployment(std::boxed::Box<crate::model::Deployment>),
        /// This represents Spec resource in search results. Only name,
        /// display_name, description, spec_type and documentation fields are
        /// populated in search results.
        Spec(std::boxed::Box<crate::model::Spec>),
        /// This represents Definition resource in search results.
        /// Only name field is populated in search results.
        Definition(std::boxed::Box<crate::model::Definition>),
        /// This represents Version resource in search results. Only name,
        /// display_name, description, lifecycle, compliance and accreditation fields
        /// are populated in search results.
        Version(std::boxed::Box<crate::model::Version>),
    }
}

/// Represents the search results.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchResult {
    /// This represents the ApiHubResource.
    /// Note: Only selected fields of the resources are populated in response.
    pub resource: std::option::Option<crate::model::ApiHubResource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource][crate::model::SearchResult::resource].
    pub fn set_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApiHubResource>,
    {
        self.resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource][crate::model::SearchResult::resource].
    pub fn set_or_clear_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApiHubResource>,
    {
        self.resource = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SearchResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.SearchResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resource" => Ok(__FieldTag::__resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<crate::model::ApiHubResource>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchResult");
        debug_struct.field("resource", &self.resource);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for the
/// [SearchResources][google.cloud.apihub.v1.ApiHub.SearchResources] method.
///
/// [google.cloud.apihub.v1.ApiHub.SearchResources]: crate::client::ApiHub::search_resources
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchResourcesResponse {
    /// List of search results according to the filter and search query specified.
    /// The order of search results represents the ranking.
    pub search_results: std::vec::Vec<crate::model::SearchResult>,

    /// Pass this token in the
    /// [SearchResourcesRequest][google.cloud.apihub.v1.SearchResourcesRequest]
    /// to continue to list results. If all results have been returned, this field
    /// is an empty string or not present in the response.
    ///
    /// [google.cloud.apihub.v1.SearchResourcesRequest]: crate::model::SearchResourcesRequest
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchResourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [search_results][crate::model::SearchResourcesResponse::search_results].
    pub fn set_search_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SearchResult>,
    {
        use std::iter::Iterator;
        self.search_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchResourcesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchResourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.SearchResourcesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchResourcesResponse {
    type PageItem = crate::model::SearchResult;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.search_results
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchResourcesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __search_results,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchResourcesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "searchResults" => Ok(__FieldTag::__search_results),
                            "search_results" => Ok(__FieldTag::__search_results),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchResourcesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchResourcesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__search_results => {
                            if !fields.insert(__FieldTag::__search_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for search_results",
                                ));
                            }
                            result.search_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SearchResult>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchResourcesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.search_results.is_empty() {
            state.serialize_entry("searchResults", &self.search_results)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchResourcesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchResourcesResponse");
        debug_struct.field("search_results", &self.search_results);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [CreateDependency][google.cloud.apihub.v1.ApiHubDependencies.CreateDependency]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHubDependencies.CreateDependency]: crate::client::ApiHubDependencies::create_dependency
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDependencyRequest {
    /// Required. The parent resource for the dependency resource.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Optional. The ID to use for the dependency resource, which will become the
    /// final component of the dependency's resource name. This field is optional.
    ///
    /// * If provided, the same will be used. The service will throw an error if
    ///   duplicate id is provided by the client.
    /// * If not provided, a system generated id will be used.
    ///
    /// This value should be 4-500 characters, and valid characters
    /// are `[a-z][A-Z][0-9]-_`.
    pub dependency_id: std::string::String,

    /// Required. The dependency resource to create.
    pub dependency: std::option::Option<crate::model::Dependency>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDependencyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDependencyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dependency_id][crate::model::CreateDependencyRequest::dependency_id].
    pub fn set_dependency_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dependency_id = v.into();
        self
    }

    /// Sets the value of [dependency][crate::model::CreateDependencyRequest::dependency].
    pub fn set_dependency<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Dependency>,
    {
        self.dependency = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dependency][crate::model::CreateDependencyRequest::dependency].
    pub fn set_or_clear_dependency<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Dependency>,
    {
        self.dependency = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateDependencyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.CreateDependencyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDependencyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __dependency_id,
            __dependency,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDependencyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "dependencyId" => Ok(__FieldTag::__dependency_id),
                            "dependency_id" => Ok(__FieldTag::__dependency_id),
                            "dependency" => Ok(__FieldTag::__dependency),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDependencyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDependencyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dependency_id => {
                            if !fields.insert(__FieldTag::__dependency_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dependency_id",
                                ));
                            }
                            result.dependency_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dependency => {
                            if !fields.insert(__FieldTag::__dependency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dependency",
                                ));
                            }
                            result.dependency =
                                map.next_value::<std::option::Option<crate::model::Dependency>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDependencyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.dependency_id.is_empty() {
            state.serialize_entry("dependencyId", &self.dependency_id)?;
        }
        if self.dependency.is_some() {
            state.serialize_entry("dependency", &self.dependency)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateDependencyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateDependencyRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("dependency_id", &self.dependency_id);
        debug_struct.field("dependency", &self.dependency);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [GetDependency][.ApiHubDependencies.GetDependency]
/// method's request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDependencyRequest {
    /// Required. The name of the dependency resource to retrieve.
    /// Format: `projects/{project}/locations/{location}/dependencies/{dependency}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDependencyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDependencyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDependencyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetDependencyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDependencyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDependencyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDependencyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDependencyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDependencyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetDependencyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDependencyRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [UpdateDependency][google.cloud.apihub.v1.ApiHubDependencies.UpdateDependency]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHubDependencies.UpdateDependency]: crate::client::ApiHubDependencies::update_dependency
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDependencyRequest {
    /// Required. The dependency resource to update.
    ///
    /// The dependency's `name` field is used to identify the dependency to update.
    /// Format: `projects/{project}/locations/{location}/dependencies/{dependency}`
    pub dependency: std::option::Option<crate::model::Dependency>,

    /// Required. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDependencyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dependency][crate::model::UpdateDependencyRequest::dependency].
    pub fn set_dependency<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Dependency>,
    {
        self.dependency = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dependency][crate::model::UpdateDependencyRequest::dependency].
    pub fn set_or_clear_dependency<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Dependency>,
    {
        self.dependency = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDependencyRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDependencyRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateDependencyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.UpdateDependencyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDependencyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dependency,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDependencyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dependency" => Ok(__FieldTag::__dependency),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDependencyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDependencyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dependency => {
                            if !fields.insert(__FieldTag::__dependency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dependency",
                                ));
                            }
                            result.dependency =
                                map.next_value::<std::option::Option<crate::model::Dependency>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDependencyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.dependency.is_some() {
            state.serialize_entry("dependency", &self.dependency)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateDependencyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateDependencyRequest");
        debug_struct.field("dependency", &self.dependency);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [DeleteDependency][google.cloud.apihub.v1.ApiHubDependencies.DeleteDependency]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHubDependencies.DeleteDependency]: crate::client::ApiHubDependencies::delete_dependency
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDependencyRequest {
    /// Required. The name of the dependency resource to delete.
    /// Format: `projects/{project}/locations/{location}/dependencies/{dependency}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDependencyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDependencyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDependencyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DeleteDependencyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDependencyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDependencyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDependencyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDependencyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDependencyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteDependencyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteDependencyRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [ListDependencies][google.cloud.apihub.v1.ApiHubDependencies.ListDependencies]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHubDependencies.ListDependencies]: crate::client::ApiHubDependencies::list_dependencies
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDependenciesRequest {
    /// Required. The parent which owns this collection of dependency resources.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Optional. An expression that filters the list of Dependencies.
    ///
    /// A filter expression consists of a field name, a comparison operator, and
    /// a value for filtering. The value must be a string. Allowed comparison
    /// operator is `=`. Filters are not case sensitive.
    ///
    /// The following fields in the `Dependency` are eligible for filtering:
    ///
    /// * `consumer.operation_resource_name` - The operation resource name for
    ///   the consumer entity involved in a dependency. Allowed comparison
    ///   operators: `=`.
    /// * `consumer.external_api_resource_name` - The external api resource name
    ///   for the consumer entity involved in a dependency. Allowed comparison
    ///   operators: `=`.
    /// * `supplier.operation_resource_name` - The operation resource name for
    ///   the supplier entity involved in a dependency. Allowed comparison
    ///   operators: `=`.
    /// * `supplier.external_api_resource_name` - The external api resource name
    ///   for the supplier entity involved in a dependency. Allowed comparison
    ///   operators: `=`.
    ///
    /// Expressions are combined with either `AND` logic operator or `OR` logical
    /// operator but not both of them together i.e. only one of the `AND` or `OR`
    /// operator can be used throughout the filter string and both the operators
    /// cannot be used together. No other logical operators are supported. At most
    /// three filter fields are allowed in the filter string and if provided
    /// more than that then `INVALID_ARGUMENT` error is returned by the API.
    ///
    /// For example, `consumer.operation_resource_name =
    /// \"projects/p1/locations/global/apis/a1/versions/v1/operations/o1\" OR
    /// supplier.operation_resource_name =
    /// \"projects/p1/locations/global/apis/a1/versions/v1/operations/o1\"` - The
    /// dependencies with either consumer or supplier operation resource name as
    /// _projects/p1/locations/global/apis/a1/versions/v1/operations/o1_.
    pub filter: std::string::String,

    /// Optional. The maximum number of dependency resources to return. The service
    /// may return fewer than this value. If unspecified, at most 50 dependencies
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListDependencies` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListDependencies` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDependenciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDependenciesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDependenciesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDependenciesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDependenciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDependenciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListDependenciesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDependenciesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDependenciesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDependenciesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDependenciesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDependenciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDependenciesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDependenciesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [ListDependencies][google.cloud.apihub.v1.ApiHubDependencies.ListDependencies]
/// method's response.
///
/// [google.cloud.apihub.v1.ApiHubDependencies.ListDependencies]: crate::client::ApiHubDependencies::list_dependencies
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDependenciesResponse {
    /// The dependency resources present in the API hub.
    pub dependencies: std::vec::Vec<crate::model::Dependency>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDependenciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dependencies][crate::model::ListDependenciesResponse::dependencies].
    pub fn set_dependencies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Dependency>,
    {
        use std::iter::Iterator;
        self.dependencies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDependenciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDependenciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListDependenciesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDependenciesResponse {
    type PageItem = crate::model::Dependency;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.dependencies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDependenciesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dependencies,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDependenciesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dependencies" => Ok(__FieldTag::__dependencies),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDependenciesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDependenciesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dependencies => {
                            if !fields.insert(__FieldTag::__dependencies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dependencies",
                                ));
                            }
                            result.dependencies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Dependency>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDependenciesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dependencies.is_empty() {
            state.serialize_entry("dependencies", &self.dependencies)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDependenciesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDependenciesResponse");
        debug_struct.field("dependencies", &self.dependencies);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [CreateExternalApi][google.cloud.apihub.v1.ApiHub.CreateExternalApi]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHub.CreateExternalApi]: crate::client::ApiHub::create_external_api
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateExternalApiRequest {
    /// Required. The parent resource for the External API resource.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Optional. The ID to use for the External API resource, which will become
    /// the final component of the External API's resource name. This field is
    /// optional.
    ///
    /// * If provided, the same will be used. The service will throw an error if
    ///   the specified id is already used by another External API resource in the
    ///   API hub.
    /// * If not provided, a system generated id will be used.
    ///
    /// This value should be 4-500 characters, and valid characters
    /// are /[a-z][A-Z][0-9]-_/.
    pub external_api_id: std::string::String,

    /// Required. The External API resource to create.
    pub external_api: std::option::Option<crate::model::ExternalApi>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateExternalApiRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateExternalApiRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [external_api_id][crate::model::CreateExternalApiRequest::external_api_id].
    pub fn set_external_api_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_api_id = v.into();
        self
    }

    /// Sets the value of [external_api][crate::model::CreateExternalApiRequest::external_api].
    pub fn set_external_api<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExternalApi>,
    {
        self.external_api = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_api][crate::model::CreateExternalApiRequest::external_api].
    pub fn set_or_clear_external_api<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExternalApi>,
    {
        self.external_api = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateExternalApiRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.CreateExternalApiRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateExternalApiRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __external_api_id,
            __external_api,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateExternalApiRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "externalApiId" => Ok(__FieldTag::__external_api_id),
                            "external_api_id" => Ok(__FieldTag::__external_api_id),
                            "externalApi" => Ok(__FieldTag::__external_api),
                            "external_api" => Ok(__FieldTag::__external_api),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateExternalApiRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateExternalApiRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_api_id => {
                            if !fields.insert(__FieldTag::__external_api_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_api_id",
                                ));
                            }
                            result.external_api_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_api => {
                            if !fields.insert(__FieldTag::__external_api) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_api",
                                ));
                            }
                            result.external_api =
                                map.next_value::<std::option::Option<crate::model::ExternalApi>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateExternalApiRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.external_api_id.is_empty() {
            state.serialize_entry("externalApiId", &self.external_api_id)?;
        }
        if self.external_api.is_some() {
            state.serialize_entry("externalApi", &self.external_api)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateExternalApiRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateExternalApiRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("external_api_id", &self.external_api_id);
        debug_struct.field("external_api", &self.external_api);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [GetExternalApi][google.cloud.apihub.v1.ApiHub.GetExternalApi] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHub.GetExternalApi]: crate::client::ApiHub::get_external_api
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetExternalApiRequest {
    /// Required. The name of the External API resource to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/externalApis/{externalApi}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetExternalApiRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetExternalApiRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetExternalApiRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetExternalApiRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetExternalApiRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetExternalApiRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetExternalApiRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetExternalApiRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetExternalApiRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetExternalApiRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetExternalApiRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [UpdateExternalApi][google.cloud.apihub.v1.ApiHub.UpdateExternalApi]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHub.UpdateExternalApi]: crate::client::ApiHub::update_external_api
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateExternalApiRequest {
    /// Required. The External API resource to update.
    ///
    /// The External API resource's `name` field is used to identify the External
    /// API resource to update. Format:
    /// `projects/{project}/locations/{location}/externalApis/{externalApi}`
    pub external_api: std::option::Option<crate::model::ExternalApi>,

    /// Required. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateExternalApiRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [external_api][crate::model::UpdateExternalApiRequest::external_api].
    pub fn set_external_api<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExternalApi>,
    {
        self.external_api = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_api][crate::model::UpdateExternalApiRequest::external_api].
    pub fn set_or_clear_external_api<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExternalApi>,
    {
        self.external_api = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateExternalApiRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateExternalApiRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateExternalApiRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.UpdateExternalApiRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateExternalApiRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __external_api,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateExternalApiRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "externalApi" => Ok(__FieldTag::__external_api),
                            "external_api" => Ok(__FieldTag::__external_api),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateExternalApiRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateExternalApiRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__external_api => {
                            if !fields.insert(__FieldTag::__external_api) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_api",
                                ));
                            }
                            result.external_api =
                                map.next_value::<std::option::Option<crate::model::ExternalApi>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateExternalApiRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.external_api.is_some() {
            state.serialize_entry("externalApi", &self.external_api)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateExternalApiRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateExternalApiRequest");
        debug_struct.field("external_api", &self.external_api);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [DeleteExternalApi][google.cloud.apihub.v1.ApiHub.DeleteExternalApi]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHub.DeleteExternalApi]: crate::client::ApiHub::delete_external_api
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteExternalApiRequest {
    /// Required. The name of the External API resource to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/externalApis/{externalApi}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteExternalApiRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteExternalApiRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteExternalApiRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DeleteExternalApiRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteExternalApiRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteExternalApiRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteExternalApiRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteExternalApiRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteExternalApiRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteExternalApiRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteExternalApiRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [ListExternalApis][google.cloud.apihub.v1.ApiHub.ListExternalApis]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHub.ListExternalApis]: crate::client::ApiHub::list_external_apis
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListExternalApisRequest {
    /// Required. The parent, which owns this collection of External API resources.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Optional. The maximum number of External API resources to return. The
    /// service may return fewer than this value. If unspecified, at most 50
    /// ExternalApis will be returned. The maximum value is 1000; values above 1000
    /// will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListExternalApis` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters (except page_size) provided to
    /// `ListExternalApis` must match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExternalApisRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListExternalApisRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListExternalApisRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListExternalApisRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListExternalApisRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListExternalApisRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListExternalApisRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListExternalApisRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListExternalApisRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListExternalApisRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListExternalApisRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListExternalApisRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListExternalApisRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [ListExternalApis][google.cloud.apihub.v1.ApiHub.ListExternalApis]
/// method's response.
///
/// [google.cloud.apihub.v1.ApiHub.ListExternalApis]: crate::client::ApiHub::list_external_apis
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListExternalApisResponse {
    /// The External API resources present in the API hub.
    pub external_apis: std::vec::Vec<crate::model::ExternalApi>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExternalApisResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [external_apis][crate::model::ListExternalApisResponse::external_apis].
    pub fn set_external_apis<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExternalApi>,
    {
        use std::iter::Iterator;
        self.external_apis = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListExternalApisResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListExternalApisResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListExternalApisResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListExternalApisResponse {
    type PageItem = crate::model::ExternalApi;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.external_apis
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListExternalApisResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __external_apis,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListExternalApisResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "externalApis" => Ok(__FieldTag::__external_apis),
                            "external_apis" => Ok(__FieldTag::__external_apis),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListExternalApisResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListExternalApisResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__external_apis => {
                            if !fields.insert(__FieldTag::__external_apis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_apis",
                                ));
                            }
                            result.external_apis = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ExternalApi>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListExternalApisResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.external_apis.is_empty() {
            state.serialize_entry("externalApis", &self.external_apis)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListExternalApisResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListExternalApisResponse");
        debug_struct.field("external_apis", &self.external_apis);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The CollectApiData method's request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CollectApiDataRequest {
    /// Required. The regional location of the API hub instance and its resources.
    /// Format: `projects/{project}/locations/{location}`
    pub location: std::string::String,

    /// Required. The type of collection. Applies to all entries in
    /// [api_data][google.cloud.apihub.v1.CollectApiDataRequest.api_data].
    ///
    /// [google.cloud.apihub.v1.CollectApiDataRequest.api_data]: crate::model::CollectApiDataRequest::api_data
    pub collection_type: crate::model::CollectionType,

    /// Required. The plugin instance collecting the API data.
    /// Format:
    /// `projects/{project}/locations/{location}/plugins/{plugin}/instances/{instance}`.
    pub plugin_instance: std::string::String,

    /// Required. The action ID to be used for collecting the API data.
    /// This should map to one of the action IDs specified
    /// in action configs in the plugin.
    pub action_id: std::string::String,

    /// Required. The API data to be collected.
    pub api_data: std::option::Option<crate::model::ApiData>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CollectApiDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::CollectApiDataRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [collection_type][crate::model::CollectApiDataRequest::collection_type].
    pub fn set_collection_type<T: std::convert::Into<crate::model::CollectionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.collection_type = v.into();
        self
    }

    /// Sets the value of [plugin_instance][crate::model::CollectApiDataRequest::plugin_instance].
    pub fn set_plugin_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.plugin_instance = v.into();
        self
    }

    /// Sets the value of [action_id][crate::model::CollectApiDataRequest::action_id].
    pub fn set_action_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action_id = v.into();
        self
    }

    /// Sets the value of [api_data][crate::model::CollectApiDataRequest::api_data].
    pub fn set_api_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApiData>,
    {
        self.api_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [api_data][crate::model::CollectApiDataRequest::api_data].
    pub fn set_or_clear_api_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApiData>,
    {
        self.api_data = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CollectApiDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.CollectApiDataRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CollectApiDataRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            __collection_type,
            __plugin_instance,
            __action_id,
            __api_data,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CollectApiDataRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            "collectionType" => Ok(__FieldTag::__collection_type),
                            "collection_type" => Ok(__FieldTag::__collection_type),
                            "pluginInstance" => Ok(__FieldTag::__plugin_instance),
                            "plugin_instance" => Ok(__FieldTag::__plugin_instance),
                            "actionId" => Ok(__FieldTag::__action_id),
                            "action_id" => Ok(__FieldTag::__action_id),
                            "apiData" => Ok(__FieldTag::__api_data),
                            "api_data" => Ok(__FieldTag::__api_data),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CollectApiDataRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CollectApiDataRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__collection_type => {
                            if !fields.insert(__FieldTag::__collection_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collection_type",
                                ));
                            }
                            result.collection_type = map
                                .next_value::<std::option::Option<crate::model::CollectionType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__plugin_instance => {
                            if !fields.insert(__FieldTag::__plugin_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plugin_instance",
                                ));
                            }
                            result.plugin_instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__action_id => {
                            if !fields.insert(__FieldTag::__action_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action_id",
                                ));
                            }
                            result.action_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_data => {
                            if !fields.insert(__FieldTag::__api_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_data",
                                ));
                            }
                            result.api_data =
                                map.next_value::<std::option::Option<crate::model::ApiData>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CollectApiDataRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !wkt::internal::is_default(&self.collection_type) {
            state.serialize_entry("collectionType", &self.collection_type)?;
        }
        if !self.plugin_instance.is_empty() {
            state.serialize_entry("pluginInstance", &self.plugin_instance)?;
        }
        if !self.action_id.is_empty() {
            state.serialize_entry("actionId", &self.action_id)?;
        }
        if self.api_data.is_some() {
            state.serialize_entry("apiData", &self.api_data)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CollectApiDataRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CollectApiDataRequest");
        debug_struct.field("location", &self.location);
        debug_struct.field("collection_type", &self.collection_type);
        debug_struct.field("plugin_instance", &self.plugin_instance);
        debug_struct.field("action_id", &self.action_id);
        debug_struct.field("api_data", &self.api_data);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The API data to be collected.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApiData {
    /// The data to be collected.
    pub data: std::option::Option<crate::model::api_data::Data>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApiData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data][crate::model::ApiData::data].
    ///
    /// Note that all the setters affecting `data` are mutually
    /// exclusive.
    pub fn set_data<T: std::convert::Into<std::option::Option<crate::model::api_data::Data>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// The value of [data][crate::model::ApiData::data]
    /// if it holds a `ApiMetadataList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn api_metadata_list(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ApiMetadataList>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::api_data::Data::ApiMetadataList(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::ApiData::data]
    /// to hold a `ApiMetadataList`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_api_metadata_list<
        T: std::convert::Into<std::boxed::Box<crate::model::ApiMetadataList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data =
            std::option::Option::Some(crate::model::api_data::Data::ApiMetadataList(v.into()));
        self
    }
}

impl wkt::message::Message for ApiData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ApiData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApiData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __api_metadata_list,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApiData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "apiMetadataList" => Ok(__FieldTag::__api_metadata_list),
                            "api_metadata_list" => Ok(__FieldTag::__api_metadata_list),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApiData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApiData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__api_metadata_list => {
                            if !fields.insert(__FieldTag::__api_metadata_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_metadata_list",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.apihub.v1.ApiData.api_metadata_list, latest field was apiMetadataList",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::api_data::Data::ApiMetadataList(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ApiMetadataList>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApiData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.api_metadata_list() {
            state.serialize_entry("apiMetadataList", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApiData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApiData");
        debug_struct.field("data", &self.data);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ApiData].
pub mod api_data {
    #[allow(unused_imports)]
    use super::*;

    /// The data to be collected.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Data {
        /// Optional. The list of API metadata.
        ApiMetadataList(std::boxed::Box<crate::model::ApiMetadataList>),
    }
}

/// The message to hold repeated API metadata.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApiMetadataList {
    /// Required. The list of API metadata.
    pub api_metadata: std::vec::Vec<crate::model::APIMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApiMetadataList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [api_metadata][crate::model::ApiMetadataList::api_metadata].
    pub fn set_api_metadata<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::APIMetadata>,
    {
        use std::iter::Iterator;
        self.api_metadata = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ApiMetadataList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ApiMetadataList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApiMetadataList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __api_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApiMetadataList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "apiMetadata" => Ok(__FieldTag::__api_metadata),
                            "api_metadata" => Ok(__FieldTag::__api_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApiMetadataList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApiMetadataList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__api_metadata => {
                            if !fields.insert(__FieldTag::__api_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_metadata",
                                ));
                            }
                            result.api_metadata = map.next_value::<std::option::Option<std::vec::Vec<crate::model::APIMetadata>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApiMetadataList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.api_metadata.is_empty() {
            state.serialize_entry("apiMetadata", &self.api_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApiMetadataList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApiMetadataList");
        debug_struct.field("api_metadata", &self.api_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The API metadata.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct APIMetadata {
    /// Required. The API resource to be pushed to Hub's collect layer. The ID of
    /// the API resource will be generated by Hub to ensure uniqueness across all
    /// APIs across systems.
    pub api: std::option::Option<crate::model::Api>,

    /// Optional. The list of versions present in an API resource.
    pub versions: std::vec::Vec<crate::model::VersionMetadata>,

    /// Optional. The unique identifier of the API in the system where it was
    /// originally created.
    pub original_id: std::string::String,

    /// Optional. Timestamp indicating when the API was created at the source.
    pub original_create_time: std::option::Option<wkt::Timestamp>,

    /// Required. Timestamp indicating when the API was last updated at the source.
    pub original_update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl APIMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [api][crate::model::APIMetadata::api].
    pub fn set_api<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Api>,
    {
        self.api = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [api][crate::model::APIMetadata::api].
    pub fn set_or_clear_api<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Api>,
    {
        self.api = v.map(|x| x.into());
        self
    }

    /// Sets the value of [versions][crate::model::APIMetadata::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VersionMetadata>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [original_id][crate::model::APIMetadata::original_id].
    pub fn set_original_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.original_id = v.into();
        self
    }

    /// Sets the value of [original_create_time][crate::model::APIMetadata::original_create_time].
    pub fn set_original_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_create_time][crate::model::APIMetadata::original_create_time].
    pub fn set_or_clear_original_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [original_update_time][crate::model::APIMetadata::original_update_time].
    pub fn set_original_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_update_time][crate::model::APIMetadata::original_update_time].
    pub fn set_or_clear_original_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for APIMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.APIMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for APIMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __api,
            __versions,
            __original_id,
            __original_create_time,
            __original_update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for APIMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "api" => Ok(__FieldTag::__api),
                            "versions" => Ok(__FieldTag::__versions),
                            "originalId" => Ok(__FieldTag::__original_id),
                            "original_id" => Ok(__FieldTag::__original_id),
                            "originalCreateTime" => Ok(__FieldTag::__original_create_time),
                            "original_create_time" => Ok(__FieldTag::__original_create_time),
                            "originalUpdateTime" => Ok(__FieldTag::__original_update_time),
                            "original_update_time" => Ok(__FieldTag::__original_update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = APIMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct APIMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__api => {
                            if !fields.insert(__FieldTag::__api) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api",
                                ));
                            }
                            result.api =
                                map.next_value::<std::option::Option<crate::model::Api>>()?;
                        }
                        __FieldTag::__versions => {
                            if !fields.insert(__FieldTag::__versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for versions",
                                ));
                            }
                            result.versions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VersionMetadata>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__original_id => {
                            if !fields.insert(__FieldTag::__original_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_id",
                                ));
                            }
                            result.original_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__original_create_time => {
                            if !fields.insert(__FieldTag::__original_create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_create_time",
                                ));
                            }
                            result.original_create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__original_update_time => {
                            if !fields.insert(__FieldTag::__original_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_update_time",
                                ));
                            }
                            result.original_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for APIMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.api.is_some() {
            state.serialize_entry("api", &self.api)?;
        }
        if !self.versions.is_empty() {
            state.serialize_entry("versions", &self.versions)?;
        }
        if !self.original_id.is_empty() {
            state.serialize_entry("originalId", &self.original_id)?;
        }
        if self.original_create_time.is_some() {
            state.serialize_entry("originalCreateTime", &self.original_create_time)?;
        }
        if self.original_update_time.is_some() {
            state.serialize_entry("originalUpdateTime", &self.original_update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for APIMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("APIMetadata");
        debug_struct.field("api", &self.api);
        debug_struct.field("versions", &self.versions);
        debug_struct.field("original_id", &self.original_id);
        debug_struct.field("original_create_time", &self.original_create_time);
        debug_struct.field("original_update_time", &self.original_update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The metadata associated with a version of the API resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VersionMetadata {
    /// Required. Represents a version of the API resource in API hub. The ID of
    /// the version will be generated by Hub.
    pub version: std::option::Option<crate::model::Version>,

    /// Optional. The specs associated with this version.
    /// Note that an API version can be associated with multiple specs.
    pub specs: std::vec::Vec<crate::model::SpecMetadata>,

    /// Optional. The deployments linked to this API version.
    /// Note: A particular API version could be deployed to multiple deployments
    /// (for dev deployment, UAT deployment, etc.)
    pub deployments: std::vec::Vec<crate::model::DeploymentMetadata>,

    /// Optional. The unique identifier of the version in the system where it was
    /// originally created.
    pub original_id: std::string::String,

    /// Optional. Timestamp indicating when the version was created at the source.
    pub original_create_time: std::option::Option<wkt::Timestamp>,

    /// Required. Timestamp indicating when the version was last updated at the
    /// source.
    pub original_update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VersionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::VersionMetadata::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::VersionMetadata::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [specs][crate::model::VersionMetadata::specs].
    pub fn set_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SpecMetadata>,
    {
        use std::iter::Iterator;
        self.specs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [deployments][crate::model::VersionMetadata::deployments].
    pub fn set_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeploymentMetadata>,
    {
        use std::iter::Iterator;
        self.deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [original_id][crate::model::VersionMetadata::original_id].
    pub fn set_original_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.original_id = v.into();
        self
    }

    /// Sets the value of [original_create_time][crate::model::VersionMetadata::original_create_time].
    pub fn set_original_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_create_time][crate::model::VersionMetadata::original_create_time].
    pub fn set_or_clear_original_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [original_update_time][crate::model::VersionMetadata::original_update_time].
    pub fn set_original_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_update_time][crate::model::VersionMetadata::original_update_time].
    pub fn set_or_clear_original_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VersionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.VersionMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VersionMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __specs,
            __deployments,
            __original_id,
            __original_create_time,
            __original_update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VersionMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "specs" => Ok(__FieldTag::__specs),
                            "deployments" => Ok(__FieldTag::__deployments),
                            "originalId" => Ok(__FieldTag::__original_id),
                            "original_id" => Ok(__FieldTag::__original_id),
                            "originalCreateTime" => Ok(__FieldTag::__original_create_time),
                            "original_create_time" => Ok(__FieldTag::__original_create_time),
                            "originalUpdateTime" => Ok(__FieldTag::__original_update_time),
                            "original_update_time" => Ok(__FieldTag::__original_update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VersionMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VersionMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__specs => {
                            if !fields.insert(__FieldTag::__specs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for specs",
                                ));
                            }
                            result.specs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SpecMetadata>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__deployments => {
                            if !fields.insert(__FieldTag::__deployments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployments",
                                ));
                            }
                            result.deployments = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DeploymentMetadata>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__original_id => {
                            if !fields.insert(__FieldTag::__original_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_id",
                                ));
                            }
                            result.original_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__original_create_time => {
                            if !fields.insert(__FieldTag::__original_create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_create_time",
                                ));
                            }
                            result.original_create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__original_update_time => {
                            if !fields.insert(__FieldTag::__original_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_update_time",
                                ));
                            }
                            result.original_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VersionMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.specs.is_empty() {
            state.serialize_entry("specs", &self.specs)?;
        }
        if !self.deployments.is_empty() {
            state.serialize_entry("deployments", &self.deployments)?;
        }
        if !self.original_id.is_empty() {
            state.serialize_entry("originalId", &self.original_id)?;
        }
        if self.original_create_time.is_some() {
            state.serialize_entry("originalCreateTime", &self.original_create_time)?;
        }
        if self.original_update_time.is_some() {
            state.serialize_entry("originalUpdateTime", &self.original_update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VersionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VersionMetadata");
        debug_struct.field("version", &self.version);
        debug_struct.field("specs", &self.specs);
        debug_struct.field("deployments", &self.deployments);
        debug_struct.field("original_id", &self.original_id);
        debug_struct.field("original_create_time", &self.original_create_time);
        debug_struct.field("original_update_time", &self.original_update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The metadata associated with a spec of the API version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SpecMetadata {
    /// Required. The spec resource to be pushed to Hub's collect layer. The ID of
    /// the spec will be generated by Hub.
    pub spec: std::option::Option<crate::model::Spec>,

    /// Optional. The unique identifier of the spec in the system where it was
    /// originally created.
    pub original_id: std::string::String,

    /// Optional. Timestamp indicating when the spec was created at the source.
    pub original_create_time: std::option::Option<wkt::Timestamp>,

    /// Required. Timestamp indicating when the spec was last updated at the
    /// source.
    pub original_update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SpecMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [spec][crate::model::SpecMetadata::spec].
    pub fn set_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Spec>,
    {
        self.spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [spec][crate::model::SpecMetadata::spec].
    pub fn set_or_clear_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Spec>,
    {
        self.spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [original_id][crate::model::SpecMetadata::original_id].
    pub fn set_original_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.original_id = v.into();
        self
    }

    /// Sets the value of [original_create_time][crate::model::SpecMetadata::original_create_time].
    pub fn set_original_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_create_time][crate::model::SpecMetadata::original_create_time].
    pub fn set_or_clear_original_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [original_update_time][crate::model::SpecMetadata::original_update_time].
    pub fn set_original_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_update_time][crate::model::SpecMetadata::original_update_time].
    pub fn set_or_clear_original_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SpecMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.SpecMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SpecMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __spec,
            __original_id,
            __original_create_time,
            __original_update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpecMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "spec" => Ok(__FieldTag::__spec),
                            "originalId" => Ok(__FieldTag::__original_id),
                            "original_id" => Ok(__FieldTag::__original_id),
                            "originalCreateTime" => Ok(__FieldTag::__original_create_time),
                            "original_create_time" => Ok(__FieldTag::__original_create_time),
                            "originalUpdateTime" => Ok(__FieldTag::__original_update_time),
                            "original_update_time" => Ok(__FieldTag::__original_update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SpecMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpecMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__spec => {
                            if !fields.insert(__FieldTag::__spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spec",
                                ));
                            }
                            result.spec =
                                map.next_value::<std::option::Option<crate::model::Spec>>()?;
                        }
                        __FieldTag::__original_id => {
                            if !fields.insert(__FieldTag::__original_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_id",
                                ));
                            }
                            result.original_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__original_create_time => {
                            if !fields.insert(__FieldTag::__original_create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_create_time",
                                ));
                            }
                            result.original_create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__original_update_time => {
                            if !fields.insert(__FieldTag::__original_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_update_time",
                                ));
                            }
                            result.original_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SpecMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.spec.is_some() {
            state.serialize_entry("spec", &self.spec)?;
        }
        if !self.original_id.is_empty() {
            state.serialize_entry("originalId", &self.original_id)?;
        }
        if self.original_create_time.is_some() {
            state.serialize_entry("originalCreateTime", &self.original_create_time)?;
        }
        if self.original_update_time.is_some() {
            state.serialize_entry("originalUpdateTime", &self.original_update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SpecMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SpecMetadata");
        debug_struct.field("spec", &self.spec);
        debug_struct.field("original_id", &self.original_id);
        debug_struct.field("original_create_time", &self.original_create_time);
        debug_struct.field("original_update_time", &self.original_update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The metadata associated with a deployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeploymentMetadata {
    /// Required. The deployment resource to be pushed to Hub's collect layer. The
    /// ID of the deployment will be generated by Hub.
    pub deployment: std::option::Option<crate::model::Deployment>,

    /// Optional. The unique identifier of the deployment in the system where it
    /// was originally created.
    pub original_id: std::string::String,

    /// Optional. Timestamp indicating when the deployment was created at the
    /// source.
    pub original_create_time: std::option::Option<wkt::Timestamp>,

    /// Required. Timestamp indicating when the deployment was last updated at the
    /// source.
    pub original_update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeploymentMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployment][crate::model::DeploymentMetadata::deployment].
    pub fn set_deployment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Deployment>,
    {
        self.deployment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deployment][crate::model::DeploymentMetadata::deployment].
    pub fn set_or_clear_deployment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Deployment>,
    {
        self.deployment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [original_id][crate::model::DeploymentMetadata::original_id].
    pub fn set_original_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.original_id = v.into();
        self
    }

    /// Sets the value of [original_create_time][crate::model::DeploymentMetadata::original_create_time].
    pub fn set_original_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_create_time][crate::model::DeploymentMetadata::original_create_time].
    pub fn set_or_clear_original_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [original_update_time][crate::model::DeploymentMetadata::original_update_time].
    pub fn set_original_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_update_time][crate::model::DeploymentMetadata::original_update_time].
    pub fn set_or_clear_original_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeploymentMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DeploymentMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeploymentMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __deployment,
            __original_id,
            __original_create_time,
            __original_update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeploymentMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deployment" => Ok(__FieldTag::__deployment),
                            "originalId" => Ok(__FieldTag::__original_id),
                            "original_id" => Ok(__FieldTag::__original_id),
                            "originalCreateTime" => Ok(__FieldTag::__original_create_time),
                            "original_create_time" => Ok(__FieldTag::__original_create_time),
                            "originalUpdateTime" => Ok(__FieldTag::__original_update_time),
                            "original_update_time" => Ok(__FieldTag::__original_update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeploymentMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeploymentMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__deployment => {
                            if !fields.insert(__FieldTag::__deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment",
                                ));
                            }
                            result.deployment =
                                map.next_value::<std::option::Option<crate::model::Deployment>>()?;
                        }
                        __FieldTag::__original_id => {
                            if !fields.insert(__FieldTag::__original_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_id",
                                ));
                            }
                            result.original_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__original_create_time => {
                            if !fields.insert(__FieldTag::__original_create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_create_time",
                                ));
                            }
                            result.original_create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__original_update_time => {
                            if !fields.insert(__FieldTag::__original_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_update_time",
                                ));
                            }
                            result.original_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeploymentMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.deployment.is_some() {
            state.serialize_entry("deployment", &self.deployment)?;
        }
        if !self.original_id.is_empty() {
            state.serialize_entry("originalId", &self.original_id)?;
        }
        if self.original_create_time.is_some() {
            state.serialize_entry("originalCreateTime", &self.original_create_time)?;
        }
        if self.original_update_time.is_some() {
            state.serialize_entry("originalUpdateTime", &self.original_update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeploymentMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeploymentMetadata");
        debug_struct.field("deployment", &self.deployment);
        debug_struct.field("original_id", &self.original_id);
        debug_struct.field("original_create_time", &self.original_create_time);
        debug_struct.field("original_update_time", &self.original_update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The CollectApiData method's response.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CollectApiDataResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CollectApiDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CollectApiDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.CollectApiDataResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CollectApiDataResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CollectApiDataResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CollectApiDataResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CollectApiDataResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CollectApiDataResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CollectApiDataResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CollectApiDataResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An API resource in the API Hub.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Api {
    /// Identifier. The name of the API resource in the API Hub.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}`
    pub name: std::string::String,

    /// Required. The display name of the API resource.
    pub display_name: std::string::String,

    /// Optional. The description of the API resource.
    pub description: std::string::String,

    /// Optional. The documentation for the API resource.
    pub documentation: std::option::Option<crate::model::Documentation>,

    /// Optional. Owner details for the API resource.
    pub owner: std::option::Option<crate::model::Owner>,

    /// Output only. The list of versions present in an API resource.
    /// Note: An API resource can be associated with more than 1 version.
    /// Format is
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    pub versions: std::vec::Vec<std::string::String>,

    /// Output only. The time at which the API resource was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the API resource was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The target users for the API.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-target-user`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    pub target_user: std::option::Option<crate::model::AttributeValues>,

    /// Optional. The team owning the API.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-team`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    pub team: std::option::Option<crate::model::AttributeValues>,

    /// Optional. The business unit owning the API.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-business-unit`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    pub business_unit: std::option::Option<crate::model::AttributeValues>,

    /// Optional. The maturity level of the API.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-maturity-level`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    pub maturity_level: std::option::Option<crate::model::AttributeValues>,

    /// Optional. The list of user defined attributes associated with the API
    /// resource. The key is the attribute name. It will be of the format:
    /// `projects/{project}/locations/{location}/attributes/{attribute}`.
    /// The value is the attribute values associated with the resource.
    pub attributes: std::collections::HashMap<std::string::String, crate::model::AttributeValues>,

    /// Optional. The style of the API.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-api-style`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    pub api_style: std::option::Option<crate::model::AttributeValues>,

    /// Optional. The selected version for an API resource.
    /// This can be used when special handling is needed on client side for
    /// particular version of the API. Format is
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    pub selected_version: std::string::String,

    /// Optional. The api requirement doc associated with the API resource.
    /// Carinality is 1 for this attribute. This maps to the following system
    /// defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-api-requirements`
    /// attribute. The value of the attribute should be a proper URI, and in case
    /// of Cloud Storage URI, it should point to a Cloud Storage object,
    /// not a directory.
    pub api_requirements: std::option::Option<crate::model::AttributeValues>,

    /// Optional. Fingerprint of the API resource.
    pub fingerprint: std::string::String,

    /// Output only. The list of sources and metadata from the sources of the API
    /// resource.
    pub source_metadata: std::vec::Vec<crate::model::SourceMetadata>,

    /// Optional. The api functional requirements associated with the API resource.
    /// Carinality is 1 for this attribute.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-api-functional-requirements`
    /// attribute. The value of the attribute should be a proper URI, and in case
    /// of Cloud Storage URI, it should point to a Cloud Storage object,
    /// not a directory.
    pub api_functional_requirements: std::option::Option<crate::model::AttributeValues>,

    /// Optional. The api technical requirements associated with the API resource.
    /// Carinality is 1 for this attribute. This maps to the following system
    /// defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-api-technical-requirements`
    /// attribute. The value of the attribute should be a proper URI, and in case
    /// of Cloud Storage URI, it should point to a Cloud Storage object,
    /// not a directory.
    pub api_technical_requirements: std::option::Option<crate::model::AttributeValues>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Api {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Api::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Api::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Api::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [documentation][crate::model::Api::documentation].
    pub fn set_documentation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Documentation>,
    {
        self.documentation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [documentation][crate::model::Api::documentation].
    pub fn set_or_clear_documentation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Documentation>,
    {
        self.documentation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [owner][crate::model::Api::owner].
    pub fn set_owner<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Owner>,
    {
        self.owner = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [owner][crate::model::Api::owner].
    pub fn set_or_clear_owner<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Owner>,
    {
        self.owner = v.map(|x| x.into());
        self
    }

    /// Sets the value of [versions][crate::model::Api::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Api::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Api::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Api::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Api::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_user][crate::model::Api::target_user].
    pub fn set_target_user<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.target_user = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_user][crate::model::Api::target_user].
    pub fn set_or_clear_target_user<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.target_user = v.map(|x| x.into());
        self
    }

    /// Sets the value of [team][crate::model::Api::team].
    pub fn set_team<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.team = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [team][crate::model::Api::team].
    pub fn set_or_clear_team<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.team = v.map(|x| x.into());
        self
    }

    /// Sets the value of [business_unit][crate::model::Api::business_unit].
    pub fn set_business_unit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.business_unit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [business_unit][crate::model::Api::business_unit].
    pub fn set_or_clear_business_unit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.business_unit = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maturity_level][crate::model::Api::maturity_level].
    pub fn set_maturity_level<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.maturity_level = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maturity_level][crate::model::Api::maturity_level].
    pub fn set_or_clear_maturity_level<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.maturity_level = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attributes][crate::model::Api::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::AttributeValues>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [api_style][crate::model::Api::api_style].
    pub fn set_api_style<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.api_style = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [api_style][crate::model::Api::api_style].
    pub fn set_or_clear_api_style<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.api_style = v.map(|x| x.into());
        self
    }

    /// Sets the value of [selected_version][crate::model::Api::selected_version].
    pub fn set_selected_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.selected_version = v.into();
        self
    }

    /// Sets the value of [api_requirements][crate::model::Api::api_requirements].
    pub fn set_api_requirements<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.api_requirements = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [api_requirements][crate::model::Api::api_requirements].
    pub fn set_or_clear_api_requirements<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.api_requirements = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fingerprint][crate::model::Api::fingerprint].
    pub fn set_fingerprint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fingerprint = v.into();
        self
    }

    /// Sets the value of [source_metadata][crate::model::Api::source_metadata].
    pub fn set_source_metadata<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SourceMetadata>,
    {
        use std::iter::Iterator;
        self.source_metadata = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [api_functional_requirements][crate::model::Api::api_functional_requirements].
    pub fn set_api_functional_requirements<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.api_functional_requirements = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [api_functional_requirements][crate::model::Api::api_functional_requirements].
    pub fn set_or_clear_api_functional_requirements<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.api_functional_requirements = v.map(|x| x.into());
        self
    }

    /// Sets the value of [api_technical_requirements][crate::model::Api::api_technical_requirements].
    pub fn set_api_technical_requirements<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.api_technical_requirements = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [api_technical_requirements][crate::model::Api::api_technical_requirements].
    pub fn set_or_clear_api_technical_requirements<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.api_technical_requirements = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Api {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.Api"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Api {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __documentation,
            __owner,
            __versions,
            __create_time,
            __update_time,
            __target_user,
            __team,
            __business_unit,
            __maturity_level,
            __attributes,
            __api_style,
            __selected_version,
            __api_requirements,
            __fingerprint,
            __source_metadata,
            __api_functional_requirements,
            __api_technical_requirements,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Api")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "documentation" => Ok(__FieldTag::__documentation),
                            "owner" => Ok(__FieldTag::__owner),
                            "versions" => Ok(__FieldTag::__versions),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "targetUser" => Ok(__FieldTag::__target_user),
                            "target_user" => Ok(__FieldTag::__target_user),
                            "team" => Ok(__FieldTag::__team),
                            "businessUnit" => Ok(__FieldTag::__business_unit),
                            "business_unit" => Ok(__FieldTag::__business_unit),
                            "maturityLevel" => Ok(__FieldTag::__maturity_level),
                            "maturity_level" => Ok(__FieldTag::__maturity_level),
                            "attributes" => Ok(__FieldTag::__attributes),
                            "apiStyle" => Ok(__FieldTag::__api_style),
                            "api_style" => Ok(__FieldTag::__api_style),
                            "selectedVersion" => Ok(__FieldTag::__selected_version),
                            "selected_version" => Ok(__FieldTag::__selected_version),
                            "apiRequirements" => Ok(__FieldTag::__api_requirements),
                            "api_requirements" => Ok(__FieldTag::__api_requirements),
                            "fingerprint" => Ok(__FieldTag::__fingerprint),
                            "sourceMetadata" => Ok(__FieldTag::__source_metadata),
                            "source_metadata" => Ok(__FieldTag::__source_metadata),
                            "apiFunctionalRequirements" => {
                                Ok(__FieldTag::__api_functional_requirements)
                            }
                            "api_functional_requirements" => {
                                Ok(__FieldTag::__api_functional_requirements)
                            }
                            "apiTechnicalRequirements" => {
                                Ok(__FieldTag::__api_technical_requirements)
                            }
                            "api_technical_requirements" => {
                                Ok(__FieldTag::__api_technical_requirements)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Api;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Api")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__documentation => {
                            if !fields.insert(__FieldTag::__documentation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documentation",
                                ));
                            }
                            result.documentation = map
                                .next_value::<std::option::Option<crate::model::Documentation>>()?;
                        }
                        __FieldTag::__owner => {
                            if !fields.insert(__FieldTag::__owner) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for owner",
                                ));
                            }
                            result.owner =
                                map.next_value::<std::option::Option<crate::model::Owner>>()?;
                        }
                        __FieldTag::__versions => {
                            if !fields.insert(__FieldTag::__versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for versions",
                                ));
                            }
                            result.versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target_user => {
                            if !fields.insert(__FieldTag::__target_user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_user",
                                ));
                            }
                            result.target_user = map
                                .next_value::<std::option::Option<crate::model::AttributeValues>>(
                                )?;
                        }
                        __FieldTag::__team => {
                            if !fields.insert(__FieldTag::__team) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for team",
                                ));
                            }
                            result.team = map
                                .next_value::<std::option::Option<crate::model::AttributeValues>>(
                                )?;
                        }
                        __FieldTag::__business_unit => {
                            if !fields.insert(__FieldTag::__business_unit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for business_unit",
                                ));
                            }
                            result.business_unit = map
                                .next_value::<std::option::Option<crate::model::AttributeValues>>(
                                )?;
                        }
                        __FieldTag::__maturity_level => {
                            if !fields.insert(__FieldTag::__maturity_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maturity_level",
                                ));
                            }
                            result.maturity_level = map
                                .next_value::<std::option::Option<crate::model::AttributeValues>>(
                                )?;
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::AttributeValues,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_style => {
                            if !fields.insert(__FieldTag::__api_style) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_style",
                                ));
                            }
                            result.api_style = map
                                .next_value::<std::option::Option<crate::model::AttributeValues>>(
                                )?;
                        }
                        __FieldTag::__selected_version => {
                            if !fields.insert(__FieldTag::__selected_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selected_version",
                                ));
                            }
                            result.selected_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_requirements => {
                            if !fields.insert(__FieldTag::__api_requirements) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_requirements",
                                ));
                            }
                            result.api_requirements = map
                                .next_value::<std::option::Option<crate::model::AttributeValues>>(
                                )?;
                        }
                        __FieldTag::__fingerprint => {
                            if !fields.insert(__FieldTag::__fingerprint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fingerprint",
                                ));
                            }
                            result.fingerprint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_metadata => {
                            if !fields.insert(__FieldTag::__source_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_metadata",
                                ));
                            }
                            result.source_metadata =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SourceMetadata>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_functional_requirements => {
                            if !fields.insert(__FieldTag::__api_functional_requirements) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_functional_requirements",
                                ));
                            }
                            result.api_functional_requirements = map
                                .next_value::<std::option::Option<crate::model::AttributeValues>>(
                                )?;
                        }
                        __FieldTag::__api_technical_requirements => {
                            if !fields.insert(__FieldTag::__api_technical_requirements) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_technical_requirements",
                                ));
                            }
                            result.api_technical_requirements = map
                                .next_value::<std::option::Option<crate::model::AttributeValues>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Api {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.documentation.is_some() {
            state.serialize_entry("documentation", &self.documentation)?;
        }
        if self.owner.is_some() {
            state.serialize_entry("owner", &self.owner)?;
        }
        if !self.versions.is_empty() {
            state.serialize_entry("versions", &self.versions)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.target_user.is_some() {
            state.serialize_entry("targetUser", &self.target_user)?;
        }
        if self.team.is_some() {
            state.serialize_entry("team", &self.team)?;
        }
        if self.business_unit.is_some() {
            state.serialize_entry("businessUnit", &self.business_unit)?;
        }
        if self.maturity_level.is_some() {
            state.serialize_entry("maturityLevel", &self.maturity_level)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if self.api_style.is_some() {
            state.serialize_entry("apiStyle", &self.api_style)?;
        }
        if !self.selected_version.is_empty() {
            state.serialize_entry("selectedVersion", &self.selected_version)?;
        }
        if self.api_requirements.is_some() {
            state.serialize_entry("apiRequirements", &self.api_requirements)?;
        }
        if !self.fingerprint.is_empty() {
            state.serialize_entry("fingerprint", &self.fingerprint)?;
        }
        if !self.source_metadata.is_empty() {
            state.serialize_entry("sourceMetadata", &self.source_metadata)?;
        }
        if self.api_functional_requirements.is_some() {
            state.serialize_entry(
                "apiFunctionalRequirements",
                &self.api_functional_requirements,
            )?;
        }
        if self.api_technical_requirements.is_some() {
            state.serialize_entry("apiTechnicalRequirements", &self.api_technical_requirements)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Api {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Api");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("documentation", &self.documentation);
        debug_struct.field("owner", &self.owner);
        debug_struct.field("versions", &self.versions);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("target_user", &self.target_user);
        debug_struct.field("team", &self.team);
        debug_struct.field("business_unit", &self.business_unit);
        debug_struct.field("maturity_level", &self.maturity_level);
        debug_struct.field("attributes", &self.attributes);
        debug_struct.field("api_style", &self.api_style);
        debug_struct.field("selected_version", &self.selected_version);
        debug_struct.field("api_requirements", &self.api_requirements);
        debug_struct.field("fingerprint", &self.fingerprint);
        debug_struct.field("source_metadata", &self.source_metadata);
        debug_struct.field(
            "api_functional_requirements",
            &self.api_functional_requirements,
        );
        debug_struct.field(
            "api_technical_requirements",
            &self.api_technical_requirements,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a version of the API resource in API hub. This is also referred
/// to as the API version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Version {
    /// Identifier. The name of the version.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    pub name: std::string::String,

    /// Required. The display name of the version.
    pub display_name: std::string::String,

    /// Optional. The description of the version.
    pub description: std::string::String,

    /// Optional. The documentation of the version.
    pub documentation: std::option::Option<crate::model::Documentation>,

    /// Output only. The specs associated with this version.
    /// Note that an API version can be associated with multiple specs.
    /// Format is
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
    pub specs: std::vec::Vec<std::string::String>,

    /// Output only. The operations contained in the API version.
    /// These operations will be added to the version when a new spec is
    /// added or when an existing spec is updated. Format is
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/operations/{operation}`
    pub api_operations: std::vec::Vec<std::string::String>,

    /// Output only. The definitions contained in the API version.
    /// These definitions will be added to the version when a new spec is
    /// added or when an existing spec is updated. Format is
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/definitions/{definition}`
    pub definitions: std::vec::Vec<std::string::String>,

    /// Optional. The deployments linked to this API version.
    /// Note: A particular API version could be deployed to multiple deployments
    /// (for dev deployment, UAT deployment, etc)
    /// Format is
    /// `projects/{project}/locations/{location}/deployments/{deployment}`
    pub deployments: std::vec::Vec<std::string::String>,

    /// Output only. The time at which the version was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the version was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The lifecycle of the API version.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-lifecycle`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    pub lifecycle: std::option::Option<crate::model::AttributeValues>,

    /// Optional. The compliance associated with the API version.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-compliance`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    pub compliance: std::option::Option<crate::model::AttributeValues>,

    /// Optional. The accreditations associated with the API version.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-accreditation`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    pub accreditation: std::option::Option<crate::model::AttributeValues>,

    /// Optional. The list of user defined attributes associated with the Version
    /// resource. The key is the attribute name. It will be of the format:
    /// `projects/{project}/locations/{location}/attributes/{attribute}`.
    /// The value is the attribute values associated with the resource.
    pub attributes: std::collections::HashMap<std::string::String, crate::model::AttributeValues>,

    /// Optional. The selected deployment for a Version resource.
    /// This can be used when special handling is needed on client side for a
    /// particular deployment linked to the version.
    /// Format is
    /// `projects/{project}/locations/{location}/deployments/{deployment}`
    pub selected_deployment: std::string::String,

    /// Output only. The list of sources and metadata from the sources of the
    /// version.
    pub source_metadata: std::vec::Vec<crate::model::SourceMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Version {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Version::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Version::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Version::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [documentation][crate::model::Version::documentation].
    pub fn set_documentation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Documentation>,
    {
        self.documentation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [documentation][crate::model::Version::documentation].
    pub fn set_or_clear_documentation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Documentation>,
    {
        self.documentation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [specs][crate::model::Version::specs].
    pub fn set_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.specs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [api_operations][crate::model::Version::api_operations].
    pub fn set_api_operations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.api_operations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [definitions][crate::model::Version::definitions].
    pub fn set_definitions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.definitions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [deployments][crate::model::Version::deployments].
    pub fn set_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Version::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Version::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Version::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Version::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lifecycle][crate::model::Version::lifecycle].
    pub fn set_lifecycle<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.lifecycle = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lifecycle][crate::model::Version::lifecycle].
    pub fn set_or_clear_lifecycle<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.lifecycle = v.map(|x| x.into());
        self
    }

    /// Sets the value of [compliance][crate::model::Version::compliance].
    pub fn set_compliance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.compliance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compliance][crate::model::Version::compliance].
    pub fn set_or_clear_compliance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.compliance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [accreditation][crate::model::Version::accreditation].
    pub fn set_accreditation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.accreditation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [accreditation][crate::model::Version::accreditation].
    pub fn set_or_clear_accreditation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.accreditation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attributes][crate::model::Version::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::AttributeValues>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [selected_deployment][crate::model::Version::selected_deployment].
    pub fn set_selected_deployment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.selected_deployment = v.into();
        self
    }

    /// Sets the value of [source_metadata][crate::model::Version::source_metadata].
    pub fn set_source_metadata<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SourceMetadata>,
    {
        use std::iter::Iterator;
        self.source_metadata = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Version {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.Version"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Version {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __documentation,
            __specs,
            __api_operations,
            __definitions,
            __deployments,
            __create_time,
            __update_time,
            __lifecycle,
            __compliance,
            __accreditation,
            __attributes,
            __selected_deployment,
            __source_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Version")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "documentation" => Ok(__FieldTag::__documentation),
                            "specs" => Ok(__FieldTag::__specs),
                            "apiOperations" => Ok(__FieldTag::__api_operations),
                            "api_operations" => Ok(__FieldTag::__api_operations),
                            "definitions" => Ok(__FieldTag::__definitions),
                            "deployments" => Ok(__FieldTag::__deployments),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "lifecycle" => Ok(__FieldTag::__lifecycle),
                            "compliance" => Ok(__FieldTag::__compliance),
                            "accreditation" => Ok(__FieldTag::__accreditation),
                            "attributes" => Ok(__FieldTag::__attributes),
                            "selectedDeployment" => Ok(__FieldTag::__selected_deployment),
                            "selected_deployment" => Ok(__FieldTag::__selected_deployment),
                            "sourceMetadata" => Ok(__FieldTag::__source_metadata),
                            "source_metadata" => Ok(__FieldTag::__source_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Version;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Version")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__documentation => {
                            if !fields.insert(__FieldTag::__documentation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documentation",
                                ));
                            }
                            result.documentation = map
                                .next_value::<std::option::Option<crate::model::Documentation>>()?;
                        }
                        __FieldTag::__specs => {
                            if !fields.insert(__FieldTag::__specs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for specs",
                                ));
                            }
                            result.specs = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__api_operations => {
                            if !fields.insert(__FieldTag::__api_operations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_operations",
                                ));
                            }
                            result.api_operations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__definitions => {
                            if !fields.insert(__FieldTag::__definitions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for definitions",
                                ));
                            }
                            result.definitions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__deployments => {
                            if !fields.insert(__FieldTag::__deployments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployments",
                                ));
                            }
                            result.deployments = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__lifecycle => {
                            if !fields.insert(__FieldTag::__lifecycle) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifecycle",
                                ));
                            }
                            result.lifecycle = map
                                .next_value::<std::option::Option<crate::model::AttributeValues>>(
                                )?;
                        }
                        __FieldTag::__compliance => {
                            if !fields.insert(__FieldTag::__compliance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compliance",
                                ));
                            }
                            result.compliance = map
                                .next_value::<std::option::Option<crate::model::AttributeValues>>(
                                )?;
                        }
                        __FieldTag::__accreditation => {
                            if !fields.insert(__FieldTag::__accreditation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accreditation",
                                ));
                            }
                            result.accreditation = map
                                .next_value::<std::option::Option<crate::model::AttributeValues>>(
                                )?;
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::AttributeValues,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__selected_deployment => {
                            if !fields.insert(__FieldTag::__selected_deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selected_deployment",
                                ));
                            }
                            result.selected_deployment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_metadata => {
                            if !fields.insert(__FieldTag::__source_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_metadata",
                                ));
                            }
                            result.source_metadata =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SourceMetadata>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Version {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.documentation.is_some() {
            state.serialize_entry("documentation", &self.documentation)?;
        }
        if !self.specs.is_empty() {
            state.serialize_entry("specs", &self.specs)?;
        }
        if !self.api_operations.is_empty() {
            state.serialize_entry("apiOperations", &self.api_operations)?;
        }
        if !self.definitions.is_empty() {
            state.serialize_entry("definitions", &self.definitions)?;
        }
        if !self.deployments.is_empty() {
            state.serialize_entry("deployments", &self.deployments)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.lifecycle.is_some() {
            state.serialize_entry("lifecycle", &self.lifecycle)?;
        }
        if self.compliance.is_some() {
            state.serialize_entry("compliance", &self.compliance)?;
        }
        if self.accreditation.is_some() {
            state.serialize_entry("accreditation", &self.accreditation)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if !self.selected_deployment.is_empty() {
            state.serialize_entry("selectedDeployment", &self.selected_deployment)?;
        }
        if !self.source_metadata.is_empty() {
            state.serialize_entry("sourceMetadata", &self.source_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Version {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Version");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("documentation", &self.documentation);
        debug_struct.field("specs", &self.specs);
        debug_struct.field("api_operations", &self.api_operations);
        debug_struct.field("definitions", &self.definitions);
        debug_struct.field("deployments", &self.deployments);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("lifecycle", &self.lifecycle);
        debug_struct.field("compliance", &self.compliance);
        debug_struct.field("accreditation", &self.accreditation);
        debug_struct.field("attributes", &self.attributes);
        debug_struct.field("selected_deployment", &self.selected_deployment);
        debug_struct.field("source_metadata", &self.source_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a spec associated with an API version in the API
/// Hub. Note that specs of various types can be uploaded, however
/// parsing of details is supported for OpenAPI spec currently.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Spec {
    /// Identifier. The name of the spec.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
    pub name: std::string::String,

    /// Required. The display name of the spec.
    /// This can contain the file name of the spec.
    pub display_name: std::string::String,

    /// Required. The type of spec.
    /// The value should be one of the allowed values defined for
    /// `projects/{project}/locations/{location}/attributes/system-spec-type`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API.
    ///
    /// Note, this field is mandatory if content is provided.
    pub spec_type: std::option::Option<crate::model::AttributeValues>,

    /// Optional. Input only. The contents of the uploaded spec.
    pub contents: std::option::Option<crate::model::SpecContents>,

    /// Output only. Details parsed from the spec.
    pub details: std::option::Option<crate::model::SpecDetails>,

    /// Optional. The URI of the spec source in case file is uploaded
    /// from an external version control system.
    pub source_uri: std::string::String,

    /// Output only. The time at which the spec was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the spec was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The lint response for the spec.
    pub lint_response: std::option::Option<crate::model::LintResponse>,

    /// Optional. The list of user defined attributes associated with the spec.
    /// The key is the attribute name. It will be of the format:
    /// `projects/{project}/locations/{location}/attributes/{attribute}`.
    /// The value is the attribute values associated with the resource.
    pub attributes: std::collections::HashMap<std::string::String, crate::model::AttributeValues>,

    /// Optional. The documentation of the spec.
    /// For OpenAPI spec, this will be populated from `externalDocs` in OpenAPI
    /// spec.
    pub documentation: std::option::Option<crate::model::Documentation>,

    /// Optional. Input only. Enum specifying the parsing mode for OpenAPI
    /// Specification (OAS) parsing.
    pub parsing_mode: crate::model::spec::ParsingMode,

    /// Output only. The list of sources and metadata from the sources of the spec.
    pub source_metadata: std::vec::Vec<crate::model::SourceMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Spec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Spec::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Spec::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [spec_type][crate::model::Spec::spec_type].
    pub fn set_spec_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.spec_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [spec_type][crate::model::Spec::spec_type].
    pub fn set_or_clear_spec_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.spec_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [contents][crate::model::Spec::contents].
    pub fn set_contents<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SpecContents>,
    {
        self.contents = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [contents][crate::model::Spec::contents].
    pub fn set_or_clear_contents<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SpecContents>,
    {
        self.contents = v.map(|x| x.into());
        self
    }

    /// Sets the value of [details][crate::model::Spec::details].
    pub fn set_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SpecDetails>,
    {
        self.details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [details][crate::model::Spec::details].
    pub fn set_or_clear_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SpecDetails>,
    {
        self.details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_uri][crate::model::Spec::source_uri].
    pub fn set_source_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_uri = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Spec::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Spec::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Spec::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Spec::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lint_response][crate::model::Spec::lint_response].
    pub fn set_lint_response<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LintResponse>,
    {
        self.lint_response = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lint_response][crate::model::Spec::lint_response].
    pub fn set_or_clear_lint_response<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LintResponse>,
    {
        self.lint_response = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attributes][crate::model::Spec::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::AttributeValues>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [documentation][crate::model::Spec::documentation].
    pub fn set_documentation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Documentation>,
    {
        self.documentation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [documentation][crate::model::Spec::documentation].
    pub fn set_or_clear_documentation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Documentation>,
    {
        self.documentation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [parsing_mode][crate::model::Spec::parsing_mode].
    pub fn set_parsing_mode<T: std::convert::Into<crate::model::spec::ParsingMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.parsing_mode = v.into();
        self
    }

    /// Sets the value of [source_metadata][crate::model::Spec::source_metadata].
    pub fn set_source_metadata<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SourceMetadata>,
    {
        use std::iter::Iterator;
        self.source_metadata = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Spec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.Spec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Spec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __spec_type,
            __contents,
            __details,
            __source_uri,
            __create_time,
            __update_time,
            __lint_response,
            __attributes,
            __documentation,
            __parsing_mode,
            __source_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Spec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "specType" => Ok(__FieldTag::__spec_type),
                            "spec_type" => Ok(__FieldTag::__spec_type),
                            "contents" => Ok(__FieldTag::__contents),
                            "details" => Ok(__FieldTag::__details),
                            "sourceUri" => Ok(__FieldTag::__source_uri),
                            "source_uri" => Ok(__FieldTag::__source_uri),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "lintResponse" => Ok(__FieldTag::__lint_response),
                            "lint_response" => Ok(__FieldTag::__lint_response),
                            "attributes" => Ok(__FieldTag::__attributes),
                            "documentation" => Ok(__FieldTag::__documentation),
                            "parsingMode" => Ok(__FieldTag::__parsing_mode),
                            "parsing_mode" => Ok(__FieldTag::__parsing_mode),
                            "sourceMetadata" => Ok(__FieldTag::__source_metadata),
                            "source_metadata" => Ok(__FieldTag::__source_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Spec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Spec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__spec_type => {
                            if !fields.insert(__FieldTag::__spec_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spec_type",
                                ));
                            }
                            result.spec_type = map
                                .next_value::<std::option::Option<crate::model::AttributeValues>>(
                                )?;
                        }
                        __FieldTag::__contents => {
                            if !fields.insert(__FieldTag::__contents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contents",
                                ));
                            }
                            result.contents = map
                                .next_value::<std::option::Option<crate::model::SpecContents>>()?;
                        }
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details =
                                map.next_value::<std::option::Option<crate::model::SpecDetails>>()?;
                        }
                        __FieldTag::__source_uri => {
                            if !fields.insert(__FieldTag::__source_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_uri",
                                ));
                            }
                            result.source_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__lint_response => {
                            if !fields.insert(__FieldTag::__lint_response) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lint_response",
                                ));
                            }
                            result.lint_response = map
                                .next_value::<std::option::Option<crate::model::LintResponse>>()?;
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::AttributeValues,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__documentation => {
                            if !fields.insert(__FieldTag::__documentation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documentation",
                                ));
                            }
                            result.documentation = map
                                .next_value::<std::option::Option<crate::model::Documentation>>()?;
                        }
                        __FieldTag::__parsing_mode => {
                            if !fields.insert(__FieldTag::__parsing_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parsing_mode",
                                ));
                            }
                            result.parsing_mode = map
                                .next_value::<std::option::Option<crate::model::spec::ParsingMode>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_metadata => {
                            if !fields.insert(__FieldTag::__source_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_metadata",
                                ));
                            }
                            result.source_metadata =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SourceMetadata>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Spec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.spec_type.is_some() {
            state.serialize_entry("specType", &self.spec_type)?;
        }
        if self.contents.is_some() {
            state.serialize_entry("contents", &self.contents)?;
        }
        if self.details.is_some() {
            state.serialize_entry("details", &self.details)?;
        }
        if !self.source_uri.is_empty() {
            state.serialize_entry("sourceUri", &self.source_uri)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.lint_response.is_some() {
            state.serialize_entry("lintResponse", &self.lint_response)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if self.documentation.is_some() {
            state.serialize_entry("documentation", &self.documentation)?;
        }
        if !wkt::internal::is_default(&self.parsing_mode) {
            state.serialize_entry("parsingMode", &self.parsing_mode)?;
        }
        if !self.source_metadata.is_empty() {
            state.serialize_entry("sourceMetadata", &self.source_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Spec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Spec");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("spec_type", &self.spec_type);
        debug_struct.field("contents", &self.contents);
        debug_struct.field("details", &self.details);
        debug_struct.field("source_uri", &self.source_uri);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("lint_response", &self.lint_response);
        debug_struct.field("attributes", &self.attributes);
        debug_struct.field("documentation", &self.documentation);
        debug_struct.field("parsing_mode", &self.parsing_mode);
        debug_struct.field("source_metadata", &self.source_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Spec].
pub mod spec {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the parsing mode for API specifications during creation and
    /// update.
    ///
    /// - `RELAXED`: Parsing errors in the specification content do not fail the
    ///   API call.
    /// - `STRICT`: Parsing errors in the specification content result in failure
    ///   of the API call.
    ///   If not specified, defaults to `RELAXED`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ParsingMode {
        /// Defaults to `RELAXED`.
        Unspecified,
        /// Parsing of the Spec on create and update is relaxed, meaning that
        /// parsing errors the spec contents will not fail the API call.
        Relaxed,
        /// Parsing of the Spec on create and update is strict, meaning that
        /// parsing errors in the spec contents will fail the API call.
        Strict,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ParsingMode::value] or
        /// [ParsingMode::name].
        UnknownValue(parsing_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod parsing_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ParsingMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Relaxed => std::option::Option::Some(1),
                Self::Strict => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PARSING_MODE_UNSPECIFIED"),
                Self::Relaxed => std::option::Option::Some("RELAXED"),
                Self::Strict => std::option::Option::Some("STRICT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ParsingMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ParsingMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ParsingMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Relaxed,
                2 => Self::Strict,
                _ => Self::UnknownValue(parsing_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ParsingMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PARSING_MODE_UNSPECIFIED" => Self::Unspecified,
                "RELAXED" => Self::Relaxed,
                "STRICT" => Self::Strict,
                _ => Self::UnknownValue(parsing_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ParsingMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Relaxed => serializer.serialize_i32(1),
                Self::Strict => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ParsingMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ParsingMode>::new(
                ".google.cloud.apihub.v1.Spec.ParsingMode",
            ))
        }
    }
}

/// Details of the deployment where APIs are hosted.
/// A deployment could represent an Apigee proxy, API gateway, other Google Cloud
/// services or non-Google Cloud services as well. A deployment entity is a root
/// level entity in the API hub and exists independent of any API.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Deployment {
    /// Identifier. The name of the deployment.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/deployments/{deployment}`
    pub name: std::string::String,

    /// Required. The display name of the deployment.
    pub display_name: std::string::String,

    /// Optional. The description of the deployment.
    pub description: std::string::String,

    /// Optional. The documentation of the deployment.
    pub documentation: std::option::Option<crate::model::Documentation>,

    /// Required. The type of deployment.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-deployment-type`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    pub deployment_type: std::option::Option<crate::model::AttributeValues>,

    /// Required. The resource URI identifies the deployment within its gateway.
    /// For Apigee gateways, its recommended to use the format:
    /// organizations/{org}/environments/{env}/apis/{api}.
    /// For ex: if a proxy with name `orders` is deployed in `staging`
    /// environment of `cymbal` organization, the resource URI would be:
    /// `organizations/cymbal/environments/staging/apis/orders`.
    pub resource_uri: std::string::String,

    /// Required. The endpoints at which this deployment resource is listening for
    /// API requests. This could be a list of complete URIs, hostnames or an IP
    /// addresses.
    pub endpoints: std::vec::Vec<std::string::String>,

    /// Output only. The API versions linked to this deployment.
    /// Note: A particular deployment could be linked to multiple different API
    /// versions (of same or different APIs).
    pub api_versions: std::vec::Vec<std::string::String>,

    /// Output only. The time at which the deployment was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the deployment was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The SLO for this deployment.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-slo`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    pub slo: std::option::Option<crate::model::AttributeValues>,

    /// Optional. The environment mapping to this deployment.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-environment`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    pub environment: std::option::Option<crate::model::AttributeValues>,

    /// Optional. The list of user defined attributes associated with the
    /// deployment resource. The key is the attribute name. It will be of the
    /// format: `projects/{project}/locations/{location}/attributes/{attribute}`.
    /// The value is the attribute values associated with the resource.
    pub attributes: std::collections::HashMap<std::string::String, crate::model::AttributeValues>,

    /// Output only. The list of sources and metadata from the sources of the
    /// deployment.
    pub source_metadata: std::vec::Vec<crate::model::SourceMetadata>,

    /// Optional. The uri where users can navigate to for the management of the
    /// deployment. This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-management-url`
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. The value of the attribute should be a valid URL.
    pub management_url: std::option::Option<crate::model::AttributeValues>,

    /// Optional. The uri where additional source specific information for this
    /// deployment can be found. This maps to the following system defined
    /// attribute:
    /// `projects/{project}/locations/{location}/attributes/system-source-uri`
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. The value of the attribute should be a valid URI, and in case
    /// of Cloud Storage URI, it should point to a Cloud Storage object,
    /// not a directory.
    pub source_uri: std::option::Option<crate::model::AttributeValues>,

    /// Optional. The project to which the deployment belongs.
    /// For GCP gateways, this will refer to the project identifier.
    /// For others like Edge/OPDK, this will refer to the org identifier.
    pub source_project: std::string::String,

    /// Optional. The environment at source for the deployment.
    /// For example: prod, dev, staging, etc.
    pub source_environment: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Deployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Deployment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Deployment::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Deployment::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [documentation][crate::model::Deployment::documentation].
    pub fn set_documentation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Documentation>,
    {
        self.documentation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [documentation][crate::model::Deployment::documentation].
    pub fn set_or_clear_documentation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Documentation>,
    {
        self.documentation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deployment_type][crate::model::Deployment::deployment_type].
    pub fn set_deployment_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.deployment_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deployment_type][crate::model::Deployment::deployment_type].
    pub fn set_or_clear_deployment_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.deployment_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_uri][crate::model::Deployment::resource_uri].
    pub fn set_resource_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_uri = v.into();
        self
    }

    /// Sets the value of [endpoints][crate::model::Deployment::endpoints].
    pub fn set_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [api_versions][crate::model::Deployment::api_versions].
    pub fn set_api_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.api_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Deployment::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Deployment::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Deployment::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Deployment::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [slo][crate::model::Deployment::slo].
    pub fn set_slo<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.slo = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [slo][crate::model::Deployment::slo].
    pub fn set_or_clear_slo<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.slo = v.map(|x| x.into());
        self
    }

    /// Sets the value of [environment][crate::model::Deployment::environment].
    pub fn set_environment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.environment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [environment][crate::model::Deployment::environment].
    pub fn set_or_clear_environment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.environment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attributes][crate::model::Deployment::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::AttributeValues>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [source_metadata][crate::model::Deployment::source_metadata].
    pub fn set_source_metadata<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SourceMetadata>,
    {
        use std::iter::Iterator;
        self.source_metadata = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [management_url][crate::model::Deployment::management_url].
    pub fn set_management_url<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.management_url = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [management_url][crate::model::Deployment::management_url].
    pub fn set_or_clear_management_url<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.management_url = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_uri][crate::model::Deployment::source_uri].
    pub fn set_source_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.source_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_uri][crate::model::Deployment::source_uri].
    pub fn set_or_clear_source_uri<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.source_uri = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_project][crate::model::Deployment::source_project].
    pub fn set_source_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_project = v.into();
        self
    }

    /// Sets the value of [source_environment][crate::model::Deployment::source_environment].
    pub fn set_source_environment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_environment = v.into();
        self
    }
}

impl wkt::message::Message for Deployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.Deployment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Deployment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __documentation,
            __deployment_type,
            __resource_uri,
            __endpoints,
            __api_versions,
            __create_time,
            __update_time,
            __slo,
            __environment,
            __attributes,
            __source_metadata,
            __management_url,
            __source_uri,
            __source_project,
            __source_environment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Deployment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "documentation" => Ok(__FieldTag::__documentation),
                            "deploymentType" => Ok(__FieldTag::__deployment_type),
                            "deployment_type" => Ok(__FieldTag::__deployment_type),
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "endpoints" => Ok(__FieldTag::__endpoints),
                            "apiVersions" => Ok(__FieldTag::__api_versions),
                            "api_versions" => Ok(__FieldTag::__api_versions),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "slo" => Ok(__FieldTag::__slo),
                            "environment" => Ok(__FieldTag::__environment),
                            "attributes" => Ok(__FieldTag::__attributes),
                            "sourceMetadata" => Ok(__FieldTag::__source_metadata),
                            "source_metadata" => Ok(__FieldTag::__source_metadata),
                            "managementUrl" => Ok(__FieldTag::__management_url),
                            "management_url" => Ok(__FieldTag::__management_url),
                            "sourceUri" => Ok(__FieldTag::__source_uri),
                            "source_uri" => Ok(__FieldTag::__source_uri),
                            "sourceProject" => Ok(__FieldTag::__source_project),
                            "source_project" => Ok(__FieldTag::__source_project),
                            "sourceEnvironment" => Ok(__FieldTag::__source_environment),
                            "source_environment" => Ok(__FieldTag::__source_environment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Deployment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Deployment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__documentation => {
                            if !fields.insert(__FieldTag::__documentation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documentation",
                                ));
                            }
                            result.documentation = map
                                .next_value::<std::option::Option<crate::model::Documentation>>()?;
                        }
                        __FieldTag::__deployment_type => {
                            if !fields.insert(__FieldTag::__deployment_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment_type",
                                ));
                            }
                            result.deployment_type = map
                                .next_value::<std::option::Option<crate::model::AttributeValues>>(
                                )?;
                        }
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_uri",
                                ));
                            }
                            result.resource_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__endpoints => {
                            if !fields.insert(__FieldTag::__endpoints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoints",
                                ));
                            }
                            result.endpoints = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__api_versions => {
                            if !fields.insert(__FieldTag::__api_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_versions",
                                ));
                            }
                            result.api_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__slo => {
                            if !fields.insert(__FieldTag::__slo) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slo",
                                ));
                            }
                            result.slo = map
                                .next_value::<std::option::Option<crate::model::AttributeValues>>(
                                )?;
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<crate::model::AttributeValues>>(
                                )?;
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::AttributeValues,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_metadata => {
                            if !fields.insert(__FieldTag::__source_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_metadata",
                                ));
                            }
                            result.source_metadata =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SourceMetadata>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__management_url => {
                            if !fields.insert(__FieldTag::__management_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for management_url",
                                ));
                            }
                            result.management_url = map
                                .next_value::<std::option::Option<crate::model::AttributeValues>>(
                                )?;
                        }
                        __FieldTag::__source_uri => {
                            if !fields.insert(__FieldTag::__source_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_uri",
                                ));
                            }
                            result.source_uri = map
                                .next_value::<std::option::Option<crate::model::AttributeValues>>(
                                )?;
                        }
                        __FieldTag::__source_project => {
                            if !fields.insert(__FieldTag::__source_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_project",
                                ));
                            }
                            result.source_project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_environment => {
                            if !fields.insert(__FieldTag::__source_environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_environment",
                                ));
                            }
                            result.source_environment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Deployment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.documentation.is_some() {
            state.serialize_entry("documentation", &self.documentation)?;
        }
        if self.deployment_type.is_some() {
            state.serialize_entry("deploymentType", &self.deployment_type)?;
        }
        if !self.resource_uri.is_empty() {
            state.serialize_entry("resourceUri", &self.resource_uri)?;
        }
        if !self.endpoints.is_empty() {
            state.serialize_entry("endpoints", &self.endpoints)?;
        }
        if !self.api_versions.is_empty() {
            state.serialize_entry("apiVersions", &self.api_versions)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.slo.is_some() {
            state.serialize_entry("slo", &self.slo)?;
        }
        if self.environment.is_some() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if !self.source_metadata.is_empty() {
            state.serialize_entry("sourceMetadata", &self.source_metadata)?;
        }
        if self.management_url.is_some() {
            state.serialize_entry("managementUrl", &self.management_url)?;
        }
        if self.source_uri.is_some() {
            state.serialize_entry("sourceUri", &self.source_uri)?;
        }
        if !self.source_project.is_empty() {
            state.serialize_entry("sourceProject", &self.source_project)?;
        }
        if !self.source_environment.is_empty() {
            state.serialize_entry("sourceEnvironment", &self.source_environment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Deployment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Deployment");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("documentation", &self.documentation);
        debug_struct.field("deployment_type", &self.deployment_type);
        debug_struct.field("resource_uri", &self.resource_uri);
        debug_struct.field("endpoints", &self.endpoints);
        debug_struct.field("api_versions", &self.api_versions);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("slo", &self.slo);
        debug_struct.field("environment", &self.environment);
        debug_struct.field("attributes", &self.attributes);
        debug_struct.field("source_metadata", &self.source_metadata);
        debug_struct.field("management_url", &self.management_url);
        debug_struct.field("source_uri", &self.source_uri);
        debug_struct.field("source_project", &self.source_project);
        debug_struct.field("source_environment", &self.source_environment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents an operation contained in an API version in the API Hub.
/// An operation is added/updated/deleted in an API version when a new spec is
/// added or an existing spec is updated/deleted in a version.
/// Currently, an operation will be created only corresponding to OpenAPI spec as
/// parsing is supported for OpenAPI spec.
/// Alternatively operations can be managed via create,update and delete APIs,
/// creation of apiOperation can be possible only for version with no parsed
/// operations and update/delete can be possible only for operations created via
/// create API.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApiOperation {
    /// Identifier. The name of the operation.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/operations/{operation}`
    pub name: std::string::String,

    /// Output only. The name of the spec will be of the format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
    /// Note:The name of the spec will be empty if the operation is created via
    /// [CreateApiOperation][google.cloud.apihub.v1.ApiHub.CreateApiOperation] API.
    ///
    /// [google.cloud.apihub.v1.ApiHub.CreateApiOperation]: crate::client::ApiHub::create_api_operation
    pub spec: std::string::String,

    /// Optional. Operation details.
    /// Note: Even though this field is optional, it is required for
    /// [CreateApiOperation][google.cloud.apihub.v1.ApiHub.CreateApiOperation]
    /// API and we will fail the request if not provided.
    ///
    /// [google.cloud.apihub.v1.ApiHub.CreateApiOperation]: crate::client::ApiHub::create_api_operation
    pub details: std::option::Option<crate::model::OperationDetails>,

    /// Output only. The time at which the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the operation was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The list of user defined attributes associated with the API
    /// operation resource. The key is the attribute name. It will be of the
    /// format: `projects/{project}/locations/{location}/attributes/{attribute}`.
    /// The value is the attribute values associated with the resource.
    pub attributes: std::collections::HashMap<std::string::String, crate::model::AttributeValues>,

    /// Output only. The list of sources and metadata from the sources of the API
    /// operation.
    pub source_metadata: std::vec::Vec<crate::model::SourceMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApiOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApiOperation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [spec][crate::model::ApiOperation::spec].
    pub fn set_spec<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.spec = v.into();
        self
    }

    /// Sets the value of [details][crate::model::ApiOperation::details].
    pub fn set_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OperationDetails>,
    {
        self.details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [details][crate::model::ApiOperation::details].
    pub fn set_or_clear_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OperationDetails>,
    {
        self.details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::ApiOperation::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ApiOperation::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ApiOperation::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ApiOperation::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attributes][crate::model::ApiOperation::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::AttributeValues>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [source_metadata][crate::model::ApiOperation::source_metadata].
    pub fn set_source_metadata<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SourceMetadata>,
    {
        use std::iter::Iterator;
        self.source_metadata = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ApiOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ApiOperation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApiOperation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __spec,
            __details,
            __create_time,
            __update_time,
            __attributes,
            __source_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApiOperation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "spec" => Ok(__FieldTag::__spec),
                            "details" => Ok(__FieldTag::__details),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "attributes" => Ok(__FieldTag::__attributes),
                            "sourceMetadata" => Ok(__FieldTag::__source_metadata),
                            "source_metadata" => Ok(__FieldTag::__source_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApiOperation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApiOperation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__spec => {
                            if !fields.insert(__FieldTag::__spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spec",
                                ));
                            }
                            result.spec = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details = map
                                .next_value::<std::option::Option<crate::model::OperationDetails>>(
                                )?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::AttributeValues,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_metadata => {
                            if !fields.insert(__FieldTag::__source_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_metadata",
                                ));
                            }
                            result.source_metadata =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SourceMetadata>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApiOperation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.spec.is_empty() {
            state.serialize_entry("spec", &self.spec)?;
        }
        if self.details.is_some() {
            state.serialize_entry("details", &self.details)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if !self.source_metadata.is_empty() {
            state.serialize_entry("sourceMetadata", &self.source_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApiOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApiOperation");
        debug_struct.field("name", &self.name);
        debug_struct.field("spec", &self.spec);
        debug_struct.field("details", &self.details);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("attributes", &self.attributes);
        debug_struct.field("source_metadata", &self.source_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a definition for example schema, request, response definitions
/// contained in an API version.
/// A definition is added/updated/deleted in an API version when a new spec is
/// added or an existing spec is updated/deleted in a version. Currently,
/// definition will be created only corresponding to OpenAPI spec as parsing is
/// supported for OpenAPI spec. Also, within OpenAPI spec, only `schema` object
/// is supported.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Definition {
    /// Identifier. The name of the definition.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/definitions/{definition}`
    pub name: std::string::String,

    /// Output only. The name of the spec from where the definition was parsed.
    /// Format is
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
    pub spec: std::string::String,

    /// Output only. The type of the definition.
    pub r#type: crate::model::definition::Type,

    /// Output only. The time at which the definition was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the definition was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The list of user defined attributes associated with the
    /// definition resource. The key is the attribute name. It will be of the
    /// format: `projects/{project}/locations/{location}/attributes/{attribute}`.
    /// The value is the attribute values associated with the resource.
    pub attributes: std::collections::HashMap<std::string::String, crate::model::AttributeValues>,

    pub value: std::option::Option<crate::model::definition::Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Definition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Definition::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [spec][crate::model::Definition::spec].
    pub fn set_spec<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.spec = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Definition::type].
    pub fn set_type<T: std::convert::Into<crate::model::definition::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Definition::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Definition::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Definition::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Definition::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attributes][crate::model::Definition::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::AttributeValues>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [value][crate::model::Definition::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::definition::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::Definition::value]
    /// if it holds a `Schema`, `None` if the field is not set or
    /// holds a different branch.
    pub fn schema(&self) -> std::option::Option<&std::boxed::Box<crate::model::Schema>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::definition::Value::Schema(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::Definition::value]
    /// to hold a `Schema`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_schema<T: std::convert::Into<std::boxed::Box<crate::model::Schema>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(crate::model::definition::Value::Schema(v.into()));
        self
    }
}

impl wkt::message::Message for Definition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.Definition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Definition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __schema,
            __name,
            __spec,
            __type,
            __create_time,
            __update_time,
            __attributes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Definition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "schema" => Ok(__FieldTag::__schema),
                            "name" => Ok(__FieldTag::__name),
                            "spec" => Ok(__FieldTag::__spec),
                            "type" => Ok(__FieldTag::__type),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "attributes" => Ok(__FieldTag::__attributes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Definition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Definition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.apihub.v1.Definition.schema, latest field was schema",
                                ));
                            }
                            result.value =
                                std::option::Option::Some(
                                    crate::model::definition::Value::Schema(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Schema>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__spec => {
                            if !fields.insert(__FieldTag::__spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spec",
                                ));
                            }
                            result.spec = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::definition::Type>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::AttributeValues,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Definition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.schema() {
            state.serialize_entry("schema", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.spec.is_empty() {
            state.serialize_entry("spec", &self.spec)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Definition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Definition");
        debug_struct.field("name", &self.name);
        debug_struct.field("spec", &self.spec);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("attributes", &self.attributes);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Definition].
pub mod definition {
    #[allow(unused_imports)]
    use super::*;

    /// Enumeration of definition types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Definition type unspecified.
        Unspecified,
        /// Definition type schema.
        Schema,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Schema => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Schema => std::option::Option::Some("SCHEMA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Schema,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "SCHEMA" => Self::Schema,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Schema => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.apihub.v1.Definition.Type",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Value {
        /// Output only. The value of a schema definition.
        Schema(std::boxed::Box<crate::model::Schema>),
    }
}

/// An attribute in the API Hub.
/// An attribute is a name value pair which can be attached to different
/// resources in the API hub based on the scope of the attribute. Attributes can
/// either be pre-defined by the API Hub or created by users.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Attribute {
    /// Identifier. The name of the attribute in the API Hub.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/attributes/{attribute}`
    pub name: std::string::String,

    /// Required. The display name of the attribute.
    pub display_name: std::string::String,

    /// Optional. The description of the attribute.
    pub description: std::string::String,

    /// Output only. The definition type of the attribute.
    pub definition_type: crate::model::attribute::DefinitionType,

    /// Required. The scope of the attribute. It represents the resource in the API
    /// Hub to which the attribute can be linked.
    pub scope: crate::model::attribute::Scope,

    /// Required. The type of the data of the attribute.
    pub data_type: crate::model::attribute::DataType,

    /// Optional. The list of allowed values when the attribute value is of type
    /// enum. This is required when the data_type of the attribute is ENUM. The
    /// maximum number of allowed values of an attribute will be 1000.
    pub allowed_values: std::vec::Vec<crate::model::attribute::AllowedValue>,

    /// Optional. The maximum number of values that the attribute can have when
    /// associated with an API Hub resource. Cardinality 1 would represent a
    /// single-valued attribute. It must not be less than 1 or greater than 20. If
    /// not specified, the cardinality would be set to 1 by default and represent a
    /// single-valued attribute.
    pub cardinality: i32,

    /// Output only. When mandatory is true, the attribute is mandatory for the
    /// resource specified in the scope. Only System defined attributes can be
    /// mandatory.
    pub mandatory: bool,

    /// Output only. The time at which the attribute was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the attribute was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Attribute {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Attribute::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Attribute::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Attribute::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [definition_type][crate::model::Attribute::definition_type].
    pub fn set_definition_type<T: std::convert::Into<crate::model::attribute::DefinitionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.definition_type = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::Attribute::scope].
    pub fn set_scope<T: std::convert::Into<crate::model::attribute::Scope>>(
        mut self,
        v: T,
    ) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [data_type][crate::model::Attribute::data_type].
    pub fn set_data_type<T: std::convert::Into<crate::model::attribute::DataType>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_type = v.into();
        self
    }

    /// Sets the value of [allowed_values][crate::model::Attribute::allowed_values].
    pub fn set_allowed_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::attribute::AllowedValue>,
    {
        use std::iter::Iterator;
        self.allowed_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cardinality][crate::model::Attribute::cardinality].
    pub fn set_cardinality<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cardinality = v.into();
        self
    }

    /// Sets the value of [mandatory][crate::model::Attribute::mandatory].
    pub fn set_mandatory<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.mandatory = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Attribute::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Attribute::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Attribute::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Attribute::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Attribute {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.Attribute"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Attribute {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __definition_type,
            __scope,
            __data_type,
            __allowed_values,
            __cardinality,
            __mandatory,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Attribute")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "definitionType" => Ok(__FieldTag::__definition_type),
                            "definition_type" => Ok(__FieldTag::__definition_type),
                            "scope" => Ok(__FieldTag::__scope),
                            "dataType" => Ok(__FieldTag::__data_type),
                            "data_type" => Ok(__FieldTag::__data_type),
                            "allowedValues" => Ok(__FieldTag::__allowed_values),
                            "allowed_values" => Ok(__FieldTag::__allowed_values),
                            "cardinality" => Ok(__FieldTag::__cardinality),
                            "mandatory" => Ok(__FieldTag::__mandatory),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Attribute;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Attribute")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__definition_type => {
                            if !fields.insert(__FieldTag::__definition_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for definition_type",
                                ));
                            }
                            result.definition_type = map.next_value::<std::option::Option<crate::model::attribute::DefinitionType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<crate::model::attribute::Scope>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_type => {
                            if !fields.insert(__FieldTag::__data_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_type",
                                ));
                            }
                            result.data_type = map.next_value::<std::option::Option<crate::model::attribute::DataType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__allowed_values => {
                            if !fields.insert(__FieldTag::__allowed_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_values",
                                ));
                            }
                            result.allowed_values = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::attribute::AllowedValue>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cardinality => {
                            if !fields.insert(__FieldTag::__cardinality) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cardinality",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cardinality = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__mandatory => {
                            if !fields.insert(__FieldTag::__mandatory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mandatory",
                                ));
                            }
                            result.mandatory = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Attribute {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.definition_type) {
            state.serialize_entry("definitionType", &self.definition_type)?;
        }
        if !wkt::internal::is_default(&self.scope) {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !wkt::internal::is_default(&self.data_type) {
            state.serialize_entry("dataType", &self.data_type)?;
        }
        if !self.allowed_values.is_empty() {
            state.serialize_entry("allowedValues", &self.allowed_values)?;
        }
        if !wkt::internal::is_default(&self.cardinality) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cardinality", &__With(&self.cardinality))?;
        }
        if !wkt::internal::is_default(&self.mandatory) {
            state.serialize_entry("mandatory", &self.mandatory)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Attribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Attribute");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("definition_type", &self.definition_type);
        debug_struct.field("scope", &self.scope);
        debug_struct.field("data_type", &self.data_type);
        debug_struct.field("allowed_values", &self.allowed_values);
        debug_struct.field("cardinality", &self.cardinality);
        debug_struct.field("mandatory", &self.mandatory);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Attribute].
pub mod attribute {
    #[allow(unused_imports)]
    use super::*;

    /// The value that can be assigned to the attribute when the data type is
    /// enum.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AllowedValue {
        /// Required. The ID of the allowed value.
        ///
        /// * If provided, the same will be used. The service will throw an error if
        ///   the specified id is already used by another allowed value in the same
        ///   attribute resource.
        /// * If not provided, a system generated id derived from the display name
        ///   will be used. In this case, the service will handle conflict resolution
        ///   by adding a system generated suffix in case of duplicates.
        ///
        /// This value should be 4-63 characters, and valid characters
        /// are /[a-z][0-9]-/.
        pub id: std::string::String,

        /// Required. The display name of the allowed value.
        pub display_name: std::string::String,

        /// Optional. The detailed description of the allowed value.
        pub description: std::string::String,

        /// Optional. When set to true, the allowed value cannot be updated or
        /// deleted by the user. It can only be true for System defined attributes.
        pub immutable: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AllowedValue {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::attribute::AllowedValue::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [display_name][crate::model::attribute::AllowedValue::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [description][crate::model::attribute::AllowedValue::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [immutable][crate::model::attribute::AllowedValue::immutable].
        pub fn set_immutable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.immutable = v.into();
            self
        }
    }

    impl wkt::message::Message for AllowedValue {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.Attribute.AllowedValue"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AllowedValue {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __display_name,
                __description,
                __immutable,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AllowedValue")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                "description" => Ok(__FieldTag::__description),
                                "immutable" => Ok(__FieldTag::__immutable),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AllowedValue;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AllowedValue")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__immutable => {
                                if !fields.insert(__FieldTag::__immutable) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for immutable",
                                    ));
                                }
                                result.immutable = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AllowedValue {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if !wkt::internal::is_default(&self.immutable) {
                state.serialize_entry("immutable", &self.immutable)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AllowedValue {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AllowedValue");
            debug_struct.field("id", &self.id);
            debug_struct.field("display_name", &self.display_name);
            debug_struct.field("description", &self.description);
            debug_struct.field("immutable", &self.immutable);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Enumeration of attribute definition types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DefinitionType {
        /// Attribute definition type unspecified.
        Unspecified,
        /// The attribute is predefined by the API Hub. Note that only the list of
        /// allowed values can be updated in this case via UpdateAttribute method.
        SystemDefined,
        /// The attribute is defined by the user.
        UserDefined,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DefinitionType::value] or
        /// [DefinitionType::name].
        UnknownValue(definition_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod definition_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DefinitionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SystemDefined => std::option::Option::Some(1),
                Self::UserDefined => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DEFINITION_TYPE_UNSPECIFIED"),
                Self::SystemDefined => std::option::Option::Some("SYSTEM_DEFINED"),
                Self::UserDefined => std::option::Option::Some("USER_DEFINED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DefinitionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DefinitionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DefinitionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SystemDefined,
                2 => Self::UserDefined,
                _ => Self::UnknownValue(definition_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DefinitionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DEFINITION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SYSTEM_DEFINED" => Self::SystemDefined,
                "USER_DEFINED" => Self::UserDefined,
                _ => Self::UnknownValue(definition_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DefinitionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SystemDefined => serializer.serialize_i32(1),
                Self::UserDefined => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DefinitionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DefinitionType>::new(
                ".google.cloud.apihub.v1.Attribute.DefinitionType",
            ))
        }
    }

    /// Enumeration for the scope of the attribute representing the resource in the
    /// API Hub to which the attribute can be linked.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        /// Scope Unspecified.
        Unspecified,
        /// Attribute can be linked to an API.
        Api,
        /// Attribute can be linked to an API version.
        Version,
        /// Attribute can be linked to a Spec.
        Spec,
        /// Attribute can be linked to an API Operation.
        ApiOperation,
        /// Attribute can be linked to a Deployment.
        Deployment,
        /// Attribute can be linked to a Dependency.
        Dependency,
        /// Attribute can be linked to a definition.
        Definition,
        /// Attribute can be linked to a ExternalAPI.
        ExternalApi,
        /// Attribute can be linked to a Plugin.
        Plugin,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scope::value] or
        /// [Scope::name].
        UnknownValue(scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Api => std::option::Option::Some(1),
                Self::Version => std::option::Option::Some(2),
                Self::Spec => std::option::Option::Some(3),
                Self::ApiOperation => std::option::Option::Some(4),
                Self::Deployment => std::option::Option::Some(5),
                Self::Dependency => std::option::Option::Some(6),
                Self::Definition => std::option::Option::Some(7),
                Self::ExternalApi => std::option::Option::Some(8),
                Self::Plugin => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCOPE_UNSPECIFIED"),
                Self::Api => std::option::Option::Some("API"),
                Self::Version => std::option::Option::Some("VERSION"),
                Self::Spec => std::option::Option::Some("SPEC"),
                Self::ApiOperation => std::option::Option::Some("API_OPERATION"),
                Self::Deployment => std::option::Option::Some("DEPLOYMENT"),
                Self::Dependency => std::option::Option::Some("DEPENDENCY"),
                Self::Definition => std::option::Option::Some("DEFINITION"),
                Self::ExternalApi => std::option::Option::Some("EXTERNAL_API"),
                Self::Plugin => std::option::Option::Some("PLUGIN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Api,
                2 => Self::Version,
                3 => Self::Spec,
                4 => Self::ApiOperation,
                5 => Self::Deployment,
                6 => Self::Dependency,
                7 => Self::Definition,
                8 => Self::ExternalApi,
                9 => Self::Plugin,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Scope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCOPE_UNSPECIFIED" => Self::Unspecified,
                "API" => Self::Api,
                "VERSION" => Self::Version,
                "SPEC" => Self::Spec,
                "API_OPERATION" => Self::ApiOperation,
                "DEPLOYMENT" => Self::Deployment,
                "DEPENDENCY" => Self::Dependency,
                "DEFINITION" => Self::Definition,
                "EXTERNAL_API" => Self::ExternalApi,
                "PLUGIN" => Self::Plugin,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Api => serializer.serialize_i32(1),
                Self::Version => serializer.serialize_i32(2),
                Self::Spec => serializer.serialize_i32(3),
                Self::ApiOperation => serializer.serialize_i32(4),
                Self::Deployment => serializer.serialize_i32(5),
                Self::Dependency => serializer.serialize_i32(6),
                Self::Definition => serializer.serialize_i32(7),
                Self::ExternalApi => serializer.serialize_i32(8),
                Self::Plugin => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scope>::new(
                ".google.cloud.apihub.v1.Attribute.Scope",
            ))
        }
    }

    /// Enumeration of attribute's data type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataType {
        /// Attribute data type unspecified.
        Unspecified,
        /// Attribute's value is of type enum.
        Enum,
        /// Attribute's value is of type json.
        Json,
        /// Attribute's value is of type string.
        String,
        /// Attribute's value is of type uri.
        Uri,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataType::value] or
        /// [DataType::name].
        UnknownValue(data_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod data_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enum => std::option::Option::Some(1),
                Self::Json => std::option::Option::Some(2),
                Self::String => std::option::Option::Some(3),
                Self::Uri => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_TYPE_UNSPECIFIED"),
                Self::Enum => std::option::Option::Some("ENUM"),
                Self::Json => std::option::Option::Some("JSON"),
                Self::String => std::option::Option::Some("STRING"),
                Self::Uri => std::option::Option::Some("URI"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enum,
                2 => Self::Json,
                3 => Self::String,
                4 => Self::Uri,
                _ => Self::UnknownValue(data_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DataType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ENUM" => Self::Enum,
                "JSON" => Self::Json,
                "STRING" => Self::String,
                "URI" => Self::Uri,
                _ => Self::UnknownValue(data_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DataType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enum => serializer.serialize_i32(1),
                Self::Json => serializer.serialize_i32(2),
                Self::String => serializer.serialize_i32(3),
                Self::Uri => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataType>::new(
                ".google.cloud.apihub.v1.Attribute.DataType",
            ))
        }
    }
}

/// The spec contents.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SpecContents {
    /// Required. The contents of the spec.
    pub contents: ::bytes::Bytes,

    /// Required. The mime type of the content for example application/json,
    /// application/yaml, application/wsdl etc.
    pub mime_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SpecContents {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [contents][crate::model::SpecContents::contents].
    pub fn set_contents<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.contents = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::SpecContents::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }
}

impl wkt::message::Message for SpecContents {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.SpecContents"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SpecContents {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __contents,
            __mime_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpecContents")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "contents" => Ok(__FieldTag::__contents),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SpecContents;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpecContents")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__contents => {
                            if !fields.insert(__FieldTag::__contents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contents",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.contents = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SpecContents {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.contents.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contents", &__With(&self.contents))?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SpecContents {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SpecContents");
        debug_struct.field("contents", &self.contents);
        debug_struct.field("mime_type", &self.mime_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SpecDetails contains the details parsed from supported
/// spec types.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SpecDetails {
    /// Output only. The description of the spec.
    pub description: std::string::String,

    pub details: std::option::Option<crate::model::spec_details::Details>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SpecDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::SpecDetails::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [details][crate::model::SpecDetails::details].
    ///
    /// Note that all the setters affecting `details` are mutually
    /// exclusive.
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::spec_details::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::SpecDetails::details]
    /// if it holds a `OpenApiSpecDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn open_api_spec_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OpenApiSpecDetails>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::spec_details::Details::OpenApiSpecDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::SpecDetails::details]
    /// to hold a `OpenApiSpecDetails`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_open_api_spec_details<
        T: std::convert::Into<std::boxed::Box<crate::model::OpenApiSpecDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::spec_details::Details::OpenApiSpecDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SpecDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.SpecDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SpecDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __open_api_spec_details,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpecDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "openApiSpecDetails" => Ok(__FieldTag::__open_api_spec_details),
                            "open_api_spec_details" => Ok(__FieldTag::__open_api_spec_details),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SpecDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpecDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__open_api_spec_details => {
                            if !fields.insert(__FieldTag::__open_api_spec_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for open_api_spec_details",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.apihub.v1.SpecDetails.open_api_spec_details, latest field was openApiSpecDetails",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::spec_details::Details::OpenApiSpecDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::OpenApiSpecDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SpecDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.open_api_spec_details() {
            state.serialize_entry("openApiSpecDetails", value)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SpecDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SpecDetails");
        debug_struct.field("description", &self.description);
        debug_struct.field("details", &self.details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SpecDetails].
pub mod spec_details {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Details {
        /// Output only. Additional details apart from `OperationDetails` parsed from
        /// an OpenAPI spec. The OperationDetails parsed from the spec can be
        /// obtained by using
        /// [ListAPIOperations][google.cloud.apihub.v1.ApiHub.ListApiOperations]
        /// method.
        ///
        /// [google.cloud.apihub.v1.ApiHub.ListApiOperations]: crate::client::ApiHub::list_api_operations
        OpenApiSpecDetails(std::boxed::Box<crate::model::OpenApiSpecDetails>),
    }
}

/// OpenApiSpecDetails contains the details parsed from an OpenAPI spec in
/// addition to the fields mentioned in
/// [SpecDetails][google.cloud.apihub.v1.SpecDetails].
///
/// [google.cloud.apihub.v1.SpecDetails]: crate::model::SpecDetails
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OpenApiSpecDetails {
    /// Output only. The format of the spec.
    pub format: crate::model::open_api_spec_details::Format,

    /// Output only. The version in the spec.
    /// This maps to `info.version` in OpenAPI spec.
    pub version: std::string::String,

    /// Output only. Owner details for the spec.
    /// This maps to `info.contact` in OpenAPI spec.
    pub owner: std::option::Option<crate::model::Owner>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OpenApiSpecDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [format][crate::model::OpenApiSpecDetails::format].
    pub fn set_format<T: std::convert::Into<crate::model::open_api_spec_details::Format>>(
        mut self,
        v: T,
    ) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [version][crate::model::OpenApiSpecDetails::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [owner][crate::model::OpenApiSpecDetails::owner].
    pub fn set_owner<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Owner>,
    {
        self.owner = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [owner][crate::model::OpenApiSpecDetails::owner].
    pub fn set_or_clear_owner<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Owner>,
    {
        self.owner = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for OpenApiSpecDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.OpenApiSpecDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OpenApiSpecDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __format,
            __version,
            __owner,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OpenApiSpecDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "format" => Ok(__FieldTag::__format),
                            "version" => Ok(__FieldTag::__version),
                            "owner" => Ok(__FieldTag::__owner),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OpenApiSpecDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OpenApiSpecDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__format => {
                            if !fields.insert(__FieldTag::__format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for format",
                                ));
                            }
                            result.format =
                                map.next_value::<std::option::Option<
                                    crate::model::open_api_spec_details::Format,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__owner => {
                            if !fields.insert(__FieldTag::__owner) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for owner",
                                ));
                            }
                            result.owner =
                                map.next_value::<std::option::Option<crate::model::Owner>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OpenApiSpecDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.format) {
            state.serialize_entry("format", &self.format)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.owner.is_some() {
            state.serialize_entry("owner", &self.owner)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OpenApiSpecDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OpenApiSpecDetails");
        debug_struct.field("format", &self.format);
        debug_struct.field("version", &self.version);
        debug_struct.field("owner", &self.owner);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [OpenApiSpecDetails].
pub mod open_api_spec_details {
    #[allow(unused_imports)]
    use super::*;

    /// Enumeration of spec formats.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Format {
        /// SpecFile type unspecified.
        Unspecified,
        /// OpenAPI Spec v2.0.
        OpenApiSpec20,
        /// OpenAPI Spec v3.0.
        OpenApiSpec30,
        /// OpenAPI Spec v3.1.
        OpenApiSpec31,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Format::value] or
        /// [Format::name].
        UnknownValue(format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Format {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::OpenApiSpec20 => std::option::Option::Some(1),
                Self::OpenApiSpec30 => std::option::Option::Some(2),
                Self::OpenApiSpec31 => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FORMAT_UNSPECIFIED"),
                Self::OpenApiSpec20 => std::option::Option::Some("OPEN_API_SPEC_2_0"),
                Self::OpenApiSpec30 => std::option::Option::Some("OPEN_API_SPEC_3_0"),
                Self::OpenApiSpec31 => std::option::Option::Some("OPEN_API_SPEC_3_1"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Format {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Format {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Format {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::OpenApiSpec20,
                2 => Self::OpenApiSpec30,
                3 => Self::OpenApiSpec31,
                _ => Self::UnknownValue(format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Format {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FORMAT_UNSPECIFIED" => Self::Unspecified,
                "OPEN_API_SPEC_2_0" => Self::OpenApiSpec20,
                "OPEN_API_SPEC_3_0" => Self::OpenApiSpec30,
                "OPEN_API_SPEC_3_1" => Self::OpenApiSpec31,
                _ => Self::UnknownValue(format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Format {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::OpenApiSpec20 => serializer.serialize_i32(1),
                Self::OpenApiSpec30 => serializer.serialize_i32(2),
                Self::OpenApiSpec31 => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Format {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Format>::new(
                ".google.cloud.apihub.v1.OpenApiSpecDetails.Format",
            ))
        }
    }
}

/// The operation details parsed from the spec.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationDetails {
    /// Optional. Description of the operation behavior.
    /// For OpenAPI spec, this will map to `operation.description` in the
    /// spec, in case description is empty, `operation.summary` will be used.
    pub description: std::string::String,

    /// Optional. Additional external documentation for this operation.
    /// For OpenAPI spec, this will map to `operation.documentation` in the spec.
    pub documentation: std::option::Option<crate::model::Documentation>,

    /// Optional. For OpenAPI spec, this will be set if `operation.deprecated`is
    /// marked as `true` in the spec.
    pub deprecated: bool,

    pub operation: std::option::Option<crate::model::operation_details::Operation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::OperationDetails::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [documentation][crate::model::OperationDetails::documentation].
    pub fn set_documentation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Documentation>,
    {
        self.documentation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [documentation][crate::model::OperationDetails::documentation].
    pub fn set_or_clear_documentation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Documentation>,
    {
        self.documentation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deprecated][crate::model::OperationDetails::deprecated].
    pub fn set_deprecated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.deprecated = v.into();
        self
    }

    /// Sets the value of [operation][crate::model::OperationDetails::operation].
    ///
    /// Note that all the setters affecting `operation` are mutually
    /// exclusive.
    pub fn set_operation<
        T: std::convert::Into<std::option::Option<crate::model::operation_details::Operation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation = v.into();
        self
    }

    /// The value of [operation][crate::model::OperationDetails::operation]
    /// if it holds a `HttpOperation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn http_operation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::HttpOperation>> {
        #[allow(unreachable_patterns)]
        self.operation.as_ref().and_then(|v| match v {
            crate::model::operation_details::Operation::HttpOperation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [operation][crate::model::OperationDetails::operation]
    /// to hold a `HttpOperation`.
    ///
    /// Note that all the setters affecting `operation` are
    /// mutually exclusive.
    pub fn set_http_operation<
        T: std::convert::Into<std::boxed::Box<crate::model::HttpOperation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation = std::option::Option::Some(
            crate::model::operation_details::Operation::HttpOperation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OperationDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.OperationDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __http_operation,
            __description,
            __documentation,
            __deprecated,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "httpOperation" => Ok(__FieldTag::__http_operation),
                            "http_operation" => Ok(__FieldTag::__http_operation),
                            "description" => Ok(__FieldTag::__description),
                            "documentation" => Ok(__FieldTag::__documentation),
                            "deprecated" => Ok(__FieldTag::__deprecated),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__http_operation => {
                            if !fields.insert(__FieldTag::__http_operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_operation",
                                ));
                            }
                            if result.operation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `operation`, a oneof with full ID .google.cloud.apihub.v1.OperationDetails.http_operation, latest field was httpOperation",
                                ));
                            }
                            result.operation = std::option::Option::Some(
                                crate::model::operation_details::Operation::HttpOperation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::HttpOperation>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__documentation => {
                            if !fields.insert(__FieldTag::__documentation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documentation",
                                ));
                            }
                            result.documentation = map
                                .next_value::<std::option::Option<crate::model::Documentation>>()?;
                        }
                        __FieldTag::__deprecated => {
                            if !fields.insert(__FieldTag::__deprecated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deprecated",
                                ));
                            }
                            result.deprecated = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.http_operation() {
            state.serialize_entry("httpOperation", value)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.documentation.is_some() {
            state.serialize_entry("documentation", &self.documentation)?;
        }
        if !wkt::internal::is_default(&self.deprecated) {
            state.serialize_entry("deprecated", &self.deprecated)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationDetails");
        debug_struct.field("description", &self.description);
        debug_struct.field("documentation", &self.documentation);
        debug_struct.field("deprecated", &self.deprecated);
        debug_struct.field("operation", &self.operation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [OperationDetails].
pub mod operation_details {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Operation {
        /// The HTTP Operation.
        HttpOperation(std::boxed::Box<crate::model::HttpOperation>),
    }
}

/// The HTTP Operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HttpOperation {
    /// Optional. The path details for the Operation.
    /// Note: Even though this field is optional, it is required for
    /// [CreateApiOperation][google.cloud.apihub.v1.ApiHub.CreateApiOperation]
    /// API and we will fail the request if not provided.
    ///
    /// [google.cloud.apihub.v1.ApiHub.CreateApiOperation]: crate::client::ApiHub::create_api_operation
    pub path: std::option::Option<crate::model::Path>,

    /// Optional. Operation method
    /// Note: Even though this field is optional, it is required for
    /// [CreateApiOperation][google.cloud.apihub.v1.ApiHub.CreateApiOperation]
    /// API and we will fail the request if not provided.
    ///
    /// [google.cloud.apihub.v1.ApiHub.CreateApiOperation]: crate::client::ApiHub::create_api_operation
    pub method: crate::model::http_operation::Method,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HttpOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::HttpOperation::path].
    pub fn set_path<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Path>,
    {
        self.path = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [path][crate::model::HttpOperation::path].
    pub fn set_or_clear_path<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Path>,
    {
        self.path = v.map(|x| x.into());
        self
    }

    /// Sets the value of [method][crate::model::HttpOperation::method].
    pub fn set_method<T: std::convert::Into<crate::model::http_operation::Method>>(
        mut self,
        v: T,
    ) -> Self {
        self.method = v.into();
        self
    }
}

impl wkt::message::Message for HttpOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.HttpOperation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HttpOperation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __path,
            __method,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HttpOperation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "path" => Ok(__FieldTag::__path),
                            "method" => Ok(__FieldTag::__method),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HttpOperation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HttpOperation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path =
                                map.next_value::<std::option::Option<crate::model::Path>>()?;
                        }
                        __FieldTag::__method => {
                            if !fields.insert(__FieldTag::__method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for method",
                                ));
                            }
                            result.method = map.next_value::<std::option::Option<crate::model::http_operation::Method>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HttpOperation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.path.is_some() {
            state.serialize_entry("path", &self.path)?;
        }
        if !wkt::internal::is_default(&self.method) {
            state.serialize_entry("method", &self.method)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HttpOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HttpOperation");
        debug_struct.field("path", &self.path);
        debug_struct.field("method", &self.method);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [HttpOperation].
pub mod http_operation {
    #[allow(unused_imports)]
    use super::*;

    /// Enumeration of Method types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Method {
        /// Method unspecified.
        Unspecified,
        /// Get Operation type.
        Get,
        /// Put Operation type.
        Put,
        /// Post Operation type.
        Post,
        /// Delete Operation type.
        Delete,
        /// Options Operation type.
        Options,
        /// Head Operation type.
        Head,
        /// Patch Operation type.
        Patch,
        /// Trace Operation type.
        Trace,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Method::value] or
        /// [Method::name].
        UnknownValue(method::UnknownValue),
    }

    #[doc(hidden)]
    pub mod method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Method {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Get => std::option::Option::Some(1),
                Self::Put => std::option::Option::Some(2),
                Self::Post => std::option::Option::Some(3),
                Self::Delete => std::option::Option::Some(4),
                Self::Options => std::option::Option::Some(5),
                Self::Head => std::option::Option::Some(6),
                Self::Patch => std::option::Option::Some(7),
                Self::Trace => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("METHOD_UNSPECIFIED"),
                Self::Get => std::option::Option::Some("GET"),
                Self::Put => std::option::Option::Some("PUT"),
                Self::Post => std::option::Option::Some("POST"),
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::Options => std::option::Option::Some("OPTIONS"),
                Self::Head => std::option::Option::Some("HEAD"),
                Self::Patch => std::option::Option::Some("PATCH"),
                Self::Trace => std::option::Option::Some("TRACE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Method {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Method {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Method {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Get,
                2 => Self::Put,
                3 => Self::Post,
                4 => Self::Delete,
                5 => Self::Options,
                6 => Self::Head,
                7 => Self::Patch,
                8 => Self::Trace,
                _ => Self::UnknownValue(method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Method {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "METHOD_UNSPECIFIED" => Self::Unspecified,
                "GET" => Self::Get,
                "PUT" => Self::Put,
                "POST" => Self::Post,
                "DELETE" => Self::Delete,
                "OPTIONS" => Self::Options,
                "HEAD" => Self::Head,
                "PATCH" => Self::Patch,
                "TRACE" => Self::Trace,
                _ => Self::UnknownValue(method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Method {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Get => serializer.serialize_i32(1),
                Self::Put => serializer.serialize_i32(2),
                Self::Post => serializer.serialize_i32(3),
                Self::Delete => serializer.serialize_i32(4),
                Self::Options => serializer.serialize_i32(5),
                Self::Head => serializer.serialize_i32(6),
                Self::Patch => serializer.serialize_i32(7),
                Self::Trace => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Method {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Method>::new(
                ".google.cloud.apihub.v1.HttpOperation.Method",
            ))
        }
    }
}

/// The path details derived from the spec.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Path {
    /// Optional. Complete path relative to server endpoint.
    /// Note: Even though this field is optional, it is required for
    /// [CreateApiOperation][google.cloud.apihub.v1.ApiHub.CreateApiOperation]
    /// API and we will fail the request if not provided.
    ///
    /// [google.cloud.apihub.v1.ApiHub.CreateApiOperation]: crate::client::ApiHub::create_api_operation
    pub path: std::string::String,

    /// Optional. A short description for the path applicable to all operations.
    pub description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Path {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::Path::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Path::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for Path {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.Path"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Path {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __path,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Path")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "path" => Ok(__FieldTag::__path),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Path;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Path")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Path {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Path {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Path");
        debug_struct.field("path", &self.path);
        debug_struct.field("description", &self.description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The schema details derived from the spec. Currently, this entity is supported
/// for OpenAPI spec only.
/// For OpenAPI spec, this maps to the schema defined in
/// the  `definitions` section for OpenAPI 2.0 version and in
/// `components.schemas` section for OpenAPI 3.0 and 3.1 version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Schema {
    /// Output only. The display name of the schema.
    /// This will map to the name of the schema in the spec.
    pub display_name: std::string::String,

    /// Output only. The raw value of the schema definition corresponding to the
    /// schema name in the spec.
    pub raw_value: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Schema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::Schema::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [raw_value][crate::model::Schema::raw_value].
    pub fn set_raw_value<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.raw_value = v.into();
        self
    }
}

impl wkt::message::Message for Schema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.Schema"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Schema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __raw_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Schema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "rawValue" => Ok(__FieldTag::__raw_value),
                            "raw_value" => Ok(__FieldTag::__raw_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Schema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Schema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__raw_value => {
                            if !fields.insert(__FieldTag::__raw_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for raw_value",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.raw_value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Schema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.raw_value.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rawValue", &__With(&self.raw_value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Schema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Schema");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("raw_value", &self.raw_value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Owner details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Owner {
    /// Optional. The name of the owner.
    pub display_name: std::string::String,

    /// Required. The email of the owner.
    pub email: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Owner {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::Owner::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [email][crate::model::Owner::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }
}

impl wkt::message::Message for Owner {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.Owner"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Owner {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __email,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Owner")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "email" => Ok(__FieldTag::__email),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Owner;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Owner")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email",
                                ));
                            }
                            result.email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Owner {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.email.is_empty() {
            state.serialize_entry("email", &self.email)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Owner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Owner");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("email", &self.email);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Documentation details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Documentation {
    /// Optional. The uri of the externally hosted documentation.
    pub external_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Documentation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [external_uri][crate::model::Documentation::external_uri].
    pub fn set_external_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_uri = v.into();
        self
    }
}

impl wkt::message::Message for Documentation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.Documentation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Documentation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __external_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Documentation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "externalUri" => Ok(__FieldTag::__external_uri),
                            "external_uri" => Ok(__FieldTag::__external_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Documentation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Documentation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__external_uri => {
                            if !fields.insert(__FieldTag::__external_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_uri",
                                ));
                            }
                            result.external_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Documentation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.external_uri.is_empty() {
            state.serialize_entry("externalUri", &self.external_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Documentation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Documentation");
        debug_struct.field("external_uri", &self.external_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The attribute values associated with resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AttributeValues {
    /// Output only. The name of the attribute.
    /// Format: projects/{project}/locations/{location}/attributes/{attribute}
    pub attribute: std::string::String,

    /// The attribute values associated with the resource.
    pub value: std::option::Option<crate::model::attribute_values::Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttributeValues {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attribute][crate::model::AttributeValues::attribute].
    pub fn set_attribute<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.attribute = v.into();
        self
    }

    /// Sets the value of [value][crate::model::AttributeValues::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::attribute_values::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::AttributeValues::value]
    /// if it holds a `EnumValues`, `None` if the field is not set or
    /// holds a different branch.
    pub fn enum_values(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::attribute_values::EnumAttributeValues>>
    {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::attribute_values::Value::EnumValues(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::AttributeValues::value]
    /// to hold a `EnumValues`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_enum_values<
        T: std::convert::Into<std::boxed::Box<crate::model::attribute_values::EnumAttributeValues>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value =
            std::option::Option::Some(crate::model::attribute_values::Value::EnumValues(v.into()));
        self
    }

    /// The value of [value][crate::model::AttributeValues::value]
    /// if it holds a `StringValues`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_values(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::attribute_values::StringAttributeValues>>
    {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::attribute_values::Value::StringValues(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::AttributeValues::value]
    /// to hold a `StringValues`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_values<
        T: std::convert::Into<std::boxed::Box<crate::model::attribute_values::StringAttributeValues>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::attribute_values::Value::StringValues(v.into()),
        );
        self
    }

    /// The value of [value][crate::model::AttributeValues::value]
    /// if it holds a `JsonValues`, `None` if the field is not set or
    /// holds a different branch.
    pub fn json_values(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::attribute_values::StringAttributeValues>>
    {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::attribute_values::Value::JsonValues(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::AttributeValues::value]
    /// to hold a `JsonValues`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_json_values<
        T: std::convert::Into<std::boxed::Box<crate::model::attribute_values::StringAttributeValues>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value =
            std::option::Option::Some(crate::model::attribute_values::Value::JsonValues(v.into()));
        self
    }

    /// The value of [value][crate::model::AttributeValues::value]
    /// if it holds a `UriValues`, `None` if the field is not set or
    /// holds a different branch.
    pub fn uri_values(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::attribute_values::StringAttributeValues>>
    {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::attribute_values::Value::UriValues(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::AttributeValues::value]
    /// to hold a `UriValues`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_uri_values<
        T: std::convert::Into<std::boxed::Box<crate::model::attribute_values::StringAttributeValues>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value =
            std::option::Option::Some(crate::model::attribute_values::Value::UriValues(v.into()));
        self
    }
}

impl wkt::message::Message for AttributeValues {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.AttributeValues"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttributeValues {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enum_values,
            __string_values,
            __json_values,
            __uri_values,
            __attribute,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttributeValues")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enumValues" => Ok(__FieldTag::__enum_values),
                            "enum_values" => Ok(__FieldTag::__enum_values),
                            "stringValues" => Ok(__FieldTag::__string_values),
                            "string_values" => Ok(__FieldTag::__string_values),
                            "jsonValues" => Ok(__FieldTag::__json_values),
                            "json_values" => Ok(__FieldTag::__json_values),
                            "uriValues" => Ok(__FieldTag::__uri_values),
                            "uri_values" => Ok(__FieldTag::__uri_values),
                            "attribute" => Ok(__FieldTag::__attribute),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttributeValues;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttributeValues")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enum_values => {
                            if !fields.insert(__FieldTag::__enum_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enum_values",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.apihub.v1.AttributeValues.enum_values, latest field was enumValues",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::attribute_values::Value::EnumValues(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::attribute_values::EnumAttributeValues,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__string_values => {
                            if !fields.insert(__FieldTag::__string_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_values",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.apihub.v1.AttributeValues.string_values, latest field was stringValues",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::attribute_values::Value::StringValues(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::attribute_values::StringAttributeValues,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__json_values => {
                            if !fields.insert(__FieldTag::__json_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for json_values",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.apihub.v1.AttributeValues.json_values, latest field was jsonValues",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::attribute_values::Value::JsonValues(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::attribute_values::StringAttributeValues,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__uri_values => {
                            if !fields.insert(__FieldTag::__uri_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri_values",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.apihub.v1.AttributeValues.uri_values, latest field was uriValues",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::attribute_values::Value::UriValues(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::attribute_values::StringAttributeValues,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__attribute => {
                            if !fields.insert(__FieldTag::__attribute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribute",
                                ));
                            }
                            result.attribute = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttributeValues {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.enum_values() {
            state.serialize_entry("enumValues", value)?;
        }
        if let Some(value) = self.string_values() {
            state.serialize_entry("stringValues", value)?;
        }
        if let Some(value) = self.json_values() {
            state.serialize_entry("jsonValues", value)?;
        }
        if let Some(value) = self.uri_values() {
            state.serialize_entry("uriValues", value)?;
        }
        if !self.attribute.is_empty() {
            state.serialize_entry("attribute", &self.attribute)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AttributeValues {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AttributeValues");
        debug_struct.field("attribute", &self.attribute);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AttributeValues].
pub mod attribute_values {
    #[allow(unused_imports)]
    use super::*;

    /// The attribute values of data type enum.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct EnumAttributeValues {
        /// Required. The attribute values in case attribute data type is enum.
        pub values: std::vec::Vec<crate::model::attribute::AllowedValue>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EnumAttributeValues {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [values][crate::model::attribute_values::EnumAttributeValues::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::attribute::AllowedValue>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for EnumAttributeValues {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.AttributeValues.EnumAttributeValues"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for EnumAttributeValues {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __values,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for EnumAttributeValues")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "values" => Ok(__FieldTag::__values),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = EnumAttributeValues;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct EnumAttributeValues")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__values => {
                                if !fields.insert(__FieldTag::__values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for values",
                                    ));
                                }
                                result.values = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::attribute::AllowedValue>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for EnumAttributeValues {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.values.is_empty() {
                state.serialize_entry("values", &self.values)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for EnumAttributeValues {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("EnumAttributeValues");
            debug_struct.field("values", &self.values);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The attribute values of data type string or JSON.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StringAttributeValues {
        /// Required. The attribute values in case attribute data type is string or
        /// JSON.
        pub values: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StringAttributeValues {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [values][crate::model::attribute_values::StringAttributeValues::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for StringAttributeValues {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.AttributeValues.StringAttributeValues"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for StringAttributeValues {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __values,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for StringAttributeValues")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "values" => Ok(__FieldTag::__values),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = StringAttributeValues;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct StringAttributeValues")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__values => {
                                if !fields.insert(__FieldTag::__values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for values",
                                    ));
                                }
                                result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for StringAttributeValues {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.values.is_empty() {
                state.serialize_entry("values", &self.values)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for StringAttributeValues {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("StringAttributeValues");
            debug_struct.field("values", &self.values);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The attribute values associated with the resource.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Value {
        /// The attribute values associated with a resource in case attribute data
        /// type is enum.
        EnumValues(std::boxed::Box<crate::model::attribute_values::EnumAttributeValues>),
        /// The attribute values associated with a resource in case attribute data
        /// type is string.
        StringValues(std::boxed::Box<crate::model::attribute_values::StringAttributeValues>),
        /// The attribute values associated with a resource in case attribute data
        /// type is JSON.
        JsonValues(std::boxed::Box<crate::model::attribute_values::StringAttributeValues>),
        /// The attribute values associated with a resource in case attribute data
        /// type is URL, URI or IP, like gs://bucket-name/object-name.
        UriValues(std::boxed::Box<crate::model::attribute_values::StringAttributeValues>),
    }
}

/// A dependency resource defined in the API hub describes a dependency directed
/// from a consumer to a supplier entity. A dependency can be defined between two
/// [Operations][google.cloud.apihub.v1.ApiOperation] or between
/// an [Operation][google.cloud.apihub.v1.ApiOperation] and [External
/// API][google.cloud.apihub.v1.ExternalApi].
///
/// [google.cloud.apihub.v1.ApiOperation]: crate::model::ApiOperation
/// [google.cloud.apihub.v1.ExternalApi]: crate::model::ExternalApi
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Dependency {
    /// Identifier. The name of the dependency in the API Hub.
    ///
    /// Format: `projects/{project}/locations/{location}/dependencies/{dependency}`
    pub name: std::string::String,

    /// Required. Immutable. The entity acting as the consumer in the dependency.
    pub consumer: std::option::Option<crate::model::DependencyEntityReference>,

    /// Required. Immutable. The entity acting as the supplier in the dependency.
    pub supplier: std::option::Option<crate::model::DependencyEntityReference>,

    /// Output only. State of the dependency.
    pub state: crate::model::dependency::State,

    /// Optional. Human readable description corresponding of the dependency.
    pub description: std::string::String,

    /// Output only. Discovery mode of the dependency.
    pub discovery_mode: crate::model::dependency::DiscoveryMode,

    /// Output only. Error details of a dependency if the system has detected it
    /// internally.
    pub error_detail: std::option::Option<crate::model::DependencyErrorDetail>,

    /// Output only. The time at which the dependency was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the dependency was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The list of user defined attributes associated with the
    /// dependency resource. The key is the attribute name. It will be of the
    /// format: `projects/{project}/locations/{location}/attributes/{attribute}`.
    /// The value is the attribute values associated with the resource.
    pub attributes: std::collections::HashMap<std::string::String, crate::model::AttributeValues>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Dependency {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Dependency::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [consumer][crate::model::Dependency::consumer].
    pub fn set_consumer<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DependencyEntityReference>,
    {
        self.consumer = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [consumer][crate::model::Dependency::consumer].
    pub fn set_or_clear_consumer<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DependencyEntityReference>,
    {
        self.consumer = v.map(|x| x.into());
        self
    }

    /// Sets the value of [supplier][crate::model::Dependency::supplier].
    pub fn set_supplier<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DependencyEntityReference>,
    {
        self.supplier = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [supplier][crate::model::Dependency::supplier].
    pub fn set_or_clear_supplier<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DependencyEntityReference>,
    {
        self.supplier = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Dependency::state].
    pub fn set_state<T: std::convert::Into<crate::model::dependency::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Dependency::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [discovery_mode][crate::model::Dependency::discovery_mode].
    pub fn set_discovery_mode<T: std::convert::Into<crate::model::dependency::DiscoveryMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.discovery_mode = v.into();
        self
    }

    /// Sets the value of [error_detail][crate::model::Dependency::error_detail].
    pub fn set_error_detail<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DependencyErrorDetail>,
    {
        self.error_detail = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_detail][crate::model::Dependency::error_detail].
    pub fn set_or_clear_error_detail<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DependencyErrorDetail>,
    {
        self.error_detail = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Dependency::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Dependency::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Dependency::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Dependency::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attributes][crate::model::Dependency::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::AttributeValues>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Dependency {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.Dependency"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Dependency {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __consumer,
            __supplier,
            __state,
            __description,
            __discovery_mode,
            __error_detail,
            __create_time,
            __update_time,
            __attributes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Dependency")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "consumer" => Ok(__FieldTag::__consumer),
                            "supplier" => Ok(__FieldTag::__supplier),
                            "state" => Ok(__FieldTag::__state),
                            "description" => Ok(__FieldTag::__description),
                            "discoveryMode" => Ok(__FieldTag::__discovery_mode),
                            "discovery_mode" => Ok(__FieldTag::__discovery_mode),
                            "errorDetail" => Ok(__FieldTag::__error_detail),
                            "error_detail" => Ok(__FieldTag::__error_detail),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "attributes" => Ok(__FieldTag::__attributes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Dependency;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Dependency")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__consumer => {
                            if !fields.insert(__FieldTag::__consumer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for consumer",
                                ));
                            }
                            result.consumer = map.next_value::<std::option::Option<crate::model::DependencyEntityReference>>()?
                                ;
                        }
                        __FieldTag::__supplier => {
                            if !fields.insert(__FieldTag::__supplier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supplier",
                                ));
                            }
                            result.supplier = map.next_value::<std::option::Option<crate::model::DependencyEntityReference>>()?
                                ;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::dependency::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__discovery_mode => {
                            if !fields.insert(__FieldTag::__discovery_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovery_mode",
                                ));
                            }
                            result.discovery_mode = map.next_value::<std::option::Option<crate::model::dependency::DiscoveryMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error_detail => {
                            if !fields.insert(__FieldTag::__error_detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_detail",
                                ));
                            }
                            result.error_detail = map.next_value::<std::option::Option<crate::model::DependencyErrorDetail>>()?
                                ;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::AttributeValues,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Dependency {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.consumer.is_some() {
            state.serialize_entry("consumer", &self.consumer)?;
        }
        if self.supplier.is_some() {
            state.serialize_entry("supplier", &self.supplier)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.discovery_mode) {
            state.serialize_entry("discoveryMode", &self.discovery_mode)?;
        }
        if self.error_detail.is_some() {
            state.serialize_entry("errorDetail", &self.error_detail)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Dependency {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Dependency");
        debug_struct.field("name", &self.name);
        debug_struct.field("consumer", &self.consumer);
        debug_struct.field("supplier", &self.supplier);
        debug_struct.field("state", &self.state);
        debug_struct.field("description", &self.description);
        debug_struct.field("discovery_mode", &self.discovery_mode);
        debug_struct.field("error_detail", &self.error_detail);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("attributes", &self.attributes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Dependency].
pub mod dependency {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states for a dependency.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified,
        /// Dependency will be in a proposed state when it is newly identified by the
        /// API hub on its own.
        Proposed,
        /// Dependency will be in a validated state when it is validated by the
        /// admin or manually created in the API hub.
        Validated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Proposed => std::option::Option::Some(1),
                Self::Validated => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Proposed => std::option::Option::Some("PROPOSED"),
                Self::Validated => std::option::Option::Some("VALIDATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Proposed,
                2 => Self::Validated,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROPOSED" => Self::Proposed,
                "VALIDATED" => Self::Validated,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Proposed => serializer.serialize_i32(1),
                Self::Validated => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.apihub.v1.Dependency.State",
            ))
        }
    }

    /// Possible modes of discovering the dependency.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DiscoveryMode {
        /// Default value. This value is unused.
        Unspecified,
        /// Manual mode of discovery when the dependency is defined by the user.
        Manual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DiscoveryMode::value] or
        /// [DiscoveryMode::name].
        UnknownValue(discovery_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod discovery_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DiscoveryMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Manual => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DISCOVERY_MODE_UNSPECIFIED"),
                Self::Manual => std::option::Option::Some("MANUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DiscoveryMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DiscoveryMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DiscoveryMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Manual,
                _ => Self::UnknownValue(discovery_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DiscoveryMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISCOVERY_MODE_UNSPECIFIED" => Self::Unspecified,
                "MANUAL" => Self::Manual,
                _ => Self::UnknownValue(discovery_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DiscoveryMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Manual => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DiscoveryMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DiscoveryMode>::new(
                ".google.cloud.apihub.v1.Dependency.DiscoveryMode",
            ))
        }
    }
}

/// Reference to an entity participating in a dependency.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DependencyEntityReference {
    /// Output only. Display name of the entity.
    pub display_name: std::string::String,

    /// Required. Unique identifier for the participating entity.
    pub identifier: std::option::Option<crate::model::dependency_entity_reference::Identifier>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DependencyEntityReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::DependencyEntityReference::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [identifier][crate::model::DependencyEntityReference::identifier].
    ///
    /// Note that all the setters affecting `identifier` are mutually
    /// exclusive.
    pub fn set_identifier<
        T: std::convert::Into<
                std::option::Option<crate::model::dependency_entity_reference::Identifier>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier = v.into();
        self
    }

    /// The value of [identifier][crate::model::DependencyEntityReference::identifier]
    /// if it holds a `OperationResourceName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn operation_resource_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::dependency_entity_reference::Identifier::OperationResourceName(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [identifier][crate::model::DependencyEntityReference::identifier]
    /// to hold a `OperationResourceName`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_operation_resource_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.identifier = std::option::Option::Some(
            crate::model::dependency_entity_reference::Identifier::OperationResourceName(v.into()),
        );
        self
    }

    /// The value of [identifier][crate::model::DependencyEntityReference::identifier]
    /// if it holds a `ExternalApiResourceName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn external_api_resource_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::dependency_entity_reference::Identifier::ExternalApiResourceName(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [identifier][crate::model::DependencyEntityReference::identifier]
    /// to hold a `ExternalApiResourceName`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_external_api_resource_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.identifier = std::option::Option::Some(
            crate::model::dependency_entity_reference::Identifier::ExternalApiResourceName(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DependencyEntityReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DependencyEntityReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DependencyEntityReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operation_resource_name,
            __external_api_resource_name,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DependencyEntityReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operationResourceName" => Ok(__FieldTag::__operation_resource_name),
                            "operation_resource_name" => Ok(__FieldTag::__operation_resource_name),
                            "externalApiResourceName" => {
                                Ok(__FieldTag::__external_api_resource_name)
                            }
                            "external_api_resource_name" => {
                                Ok(__FieldTag::__external_api_resource_name)
                            }
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DependencyEntityReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DependencyEntityReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operation_resource_name => {
                            if !fields.insert(__FieldTag::__operation_resource_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_resource_name",
                                ));
                            }
                            if result.identifier.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `identifier`, a oneof with full ID .google.cloud.apihub.v1.DependencyEntityReference.operation_resource_name, latest field was operationResourceName",
                                ));
                            }
                            result.identifier = std::option::Option::Some(
                                crate::model::dependency_entity_reference::Identifier::OperationResourceName(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__external_api_resource_name => {
                            if !fields.insert(__FieldTag::__external_api_resource_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_api_resource_name",
                                ));
                            }
                            if result.identifier.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `identifier`, a oneof with full ID .google.cloud.apihub.v1.DependencyEntityReference.external_api_resource_name, latest field was externalApiResourceName",
                                ));
                            }
                            result.identifier = std::option::Option::Some(
                                crate::model::dependency_entity_reference::Identifier::ExternalApiResourceName(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DependencyEntityReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.operation_resource_name() {
            state.serialize_entry("operationResourceName", value)?;
        }
        if let Some(value) = self.external_api_resource_name() {
            state.serialize_entry("externalApiResourceName", value)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DependencyEntityReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DependencyEntityReference");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("identifier", &self.identifier);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DependencyEntityReference].
pub mod dependency_entity_reference {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Unique identifier for the participating entity.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Identifier {
        /// The resource name of an operation in the API Hub.
        ///
        /// Format:
        /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/operations/{operation}`
        OperationResourceName(std::string::String),
        /// The resource name of an external API in the API Hub.
        ///
        /// Format:
        /// `projects/{project}/locations/{location}/externalApis/{external_api}`
        ExternalApiResourceName(std::string::String),
    }
}

/// Details describing error condition of a dependency.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DependencyErrorDetail {
    /// Optional. Error in the dependency.
    pub error: crate::model::dependency_error_detail::Error,

    /// Optional. Timestamp at which the error was found.
    pub error_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DependencyErrorDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error][crate::model::DependencyErrorDetail::error].
    pub fn set_error<T: std::convert::Into<crate::model::dependency_error_detail::Error>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [error_time][crate::model::DependencyErrorDetail::error_time].
    pub fn set_error_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.error_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_time][crate::model::DependencyErrorDetail::error_time].
    pub fn set_or_clear_error_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.error_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DependencyErrorDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DependencyErrorDetail"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DependencyErrorDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error,
            __error_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DependencyErrorDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "error" => Ok(__FieldTag::__error),
                            "errorTime" => Ok(__FieldTag::__error_time),
                            "error_time" => Ok(__FieldTag::__error_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DependencyErrorDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DependencyErrorDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<
                                    crate::model::dependency_error_detail::Error,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_time => {
                            if !fields.insert(__FieldTag::__error_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_time",
                                ));
                            }
                            result.error_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DependencyErrorDetail {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.error) {
            state.serialize_entry("error", &self.error)?;
        }
        if self.error_time.is_some() {
            state.serialize_entry("errorTime", &self.error_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DependencyErrorDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DependencyErrorDetail");
        debug_struct.field("error", &self.error);
        debug_struct.field("error_time", &self.error_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DependencyErrorDetail].
pub mod dependency_error_detail {
    #[allow(unused_imports)]
    use super::*;

    /// Possible values representing an error in the dependency.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Error {
        /// Default value used for no error in the dependency.
        Unspecified,
        /// Supplier entity has been deleted.
        SupplierNotFound,
        /// Supplier entity has been recreated.
        SupplierRecreated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Error::value] or
        /// [Error::name].
        UnknownValue(error::UnknownValue),
    }

    #[doc(hidden)]
    pub mod error {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Error {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SupplierNotFound => std::option::Option::Some(1),
                Self::SupplierRecreated => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ERROR_UNSPECIFIED"),
                Self::SupplierNotFound => std::option::Option::Some("SUPPLIER_NOT_FOUND"),
                Self::SupplierRecreated => std::option::Option::Some("SUPPLIER_RECREATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Error {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Error {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SupplierNotFound,
                2 => Self::SupplierRecreated,
                _ => Self::UnknownValue(error::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Error {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ERROR_UNSPECIFIED" => Self::Unspecified,
                "SUPPLIER_NOT_FOUND" => Self::SupplierNotFound,
                "SUPPLIER_RECREATED" => Self::SupplierRecreated,
                _ => Self::UnknownValue(error::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Error {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SupplierNotFound => serializer.serialize_i32(1),
                Self::SupplierRecreated => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Error {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Error>::new(
                ".google.cloud.apihub.v1.DependencyErrorDetail.Error",
            ))
        }
    }
}

/// LintResponse contains the response from the linter.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LintResponse {
    /// Optional. Array of issues found in the analyzed document.
    pub issues: std::vec::Vec<crate::model::Issue>,

    /// Optional. Summary of all issue types and counts for each severity level.
    pub summary: std::vec::Vec<crate::model::lint_response::SummaryEntry>,

    /// Required. Lint state represents success or failure for linting.
    pub state: crate::model::LintState,

    /// Required. Name of the linting application.
    pub source: std::string::String,

    /// Required. Name of the linter used.
    pub linter: crate::model::Linter,

    /// Required. Timestamp when the linting response was generated.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LintResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issues][crate::model::LintResponse::issues].
    pub fn set_issues<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Issue>,
    {
        use std::iter::Iterator;
        self.issues = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [summary][crate::model::LintResponse::summary].
    pub fn set_summary<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::lint_response::SummaryEntry>,
    {
        use std::iter::Iterator;
        self.summary = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::LintResponse::state].
    pub fn set_state<T: std::convert::Into<crate::model::LintState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [source][crate::model::LintResponse::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [linter][crate::model::LintResponse::linter].
    pub fn set_linter<T: std::convert::Into<crate::model::Linter>>(mut self, v: T) -> Self {
        self.linter = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::LintResponse::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::LintResponse::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LintResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.LintResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LintResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issues,
            __summary,
            __state,
            __source,
            __linter,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LintResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issues" => Ok(__FieldTag::__issues),
                            "summary" => Ok(__FieldTag::__summary),
                            "state" => Ok(__FieldTag::__state),
                            "source" => Ok(__FieldTag::__source),
                            "linter" => Ok(__FieldTag::__linter),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LintResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LintResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issues => {
                            if !fields.insert(__FieldTag::__issues) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issues",
                                ));
                            }
                            result.issues = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Issue>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__summary => {
                            if !fields.insert(__FieldTag::__summary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for summary",
                                ));
                            }
                            result.summary = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::lint_response::SummaryEntry>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::LintState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__linter => {
                            if !fields.insert(__FieldTag::__linter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linter",
                                ));
                            }
                            result.linter = map
                                .next_value::<std::option::Option<crate::model::Linter>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LintResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.issues.is_empty() {
            state.serialize_entry("issues", &self.issues)?;
        }
        if !self.summary.is_empty() {
            state.serialize_entry("summary", &self.summary)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.source.is_empty() {
            state.serialize_entry("source", &self.source)?;
        }
        if !wkt::internal::is_default(&self.linter) {
            state.serialize_entry("linter", &self.linter)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LintResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LintResponse");
        debug_struct.field("issues", &self.issues);
        debug_struct.field("summary", &self.summary);
        debug_struct.field("state", &self.state);
        debug_struct.field("source", &self.source);
        debug_struct.field("linter", &self.linter);
        debug_struct.field("create_time", &self.create_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [LintResponse].
pub mod lint_response {
    #[allow(unused_imports)]
    use super::*;

    /// Count of issues with a given severity.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SummaryEntry {
        /// Required. Severity of the issue.
        pub severity: crate::model::Severity,

        /// Required. Count of issues with the given severity.
        pub count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SummaryEntry {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [severity][crate::model::lint_response::SummaryEntry::severity].
        pub fn set_severity<T: std::convert::Into<crate::model::Severity>>(mut self, v: T) -> Self {
            self.severity = v.into();
            self
        }

        /// Sets the value of [count][crate::model::lint_response::SummaryEntry::count].
        pub fn set_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.count = v.into();
            self
        }
    }

    impl wkt::message::Message for SummaryEntry {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.LintResponse.SummaryEntry"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SummaryEntry {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __severity,
                __count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SummaryEntry")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "severity" => Ok(__FieldTag::__severity),
                                "count" => Ok(__FieldTag::__count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SummaryEntry;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SummaryEntry")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__severity => {
                                if !fields.insert(__FieldTag::__severity) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for severity",
                                    ));
                                }
                                result.severity = map
                                    .next_value::<std::option::Option<crate::model::Severity>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__count => {
                                if !fields.insert(__FieldTag::__count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.count = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SummaryEntry {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.severity) {
                state.serialize_entry("severity", &self.severity)?;
            }
            if !wkt::internal::is_default(&self.count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("count", &__With(&self.count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SummaryEntry {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SummaryEntry");
            debug_struct.field("severity", &self.severity);
            debug_struct.field("count", &self.count);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Issue contains the details of a single issue found by the linter.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Issue {
    /// Required. Rule code unique to each rule defined in linter.
    pub code: std::string::String,

    /// Required. An array of strings indicating the location in the analyzed
    /// document where the rule was triggered.
    pub path: std::vec::Vec<std::string::String>,

    /// Required. Human-readable message describing the issue found by the linter.
    pub message: std::string::String,

    /// Required. Severity level of the rule violation.
    pub severity: crate::model::Severity,

    /// Required. Object describing where in the file the issue was found.
    pub range: std::option::Option<crate::model::Range>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Issue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::Issue::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [path][crate::model::Issue::path].
    pub fn set_path<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.path = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [message][crate::model::Issue::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::Issue::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::Severity>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [range][crate::model::Issue::range].
    pub fn set_range<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Range>,
    {
        self.range = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [range][crate::model::Issue::range].
    pub fn set_or_clear_range<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Range>,
    {
        self.range = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Issue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.Issue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Issue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __path,
            __message,
            __severity,
            __range,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Issue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "path" => Ok(__FieldTag::__path),
                            "message" => Ok(__FieldTag::__message),
                            "severity" => Ok(__FieldTag::__severity),
                            "range" => Ok(__FieldTag::__range),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Issue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Issue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<crate::model::Severity>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__range => {
                            if !fields.insert(__FieldTag::__range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range",
                                ));
                            }
                            result.range =
                                map.next_value::<std::option::Option<crate::model::Range>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Issue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.code.is_empty() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if self.range.is_some() {
            state.serialize_entry("range", &self.range)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Issue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Issue");
        debug_struct.field("code", &self.code);
        debug_struct.field("path", &self.path);
        debug_struct.field("message", &self.message);
        debug_struct.field("severity", &self.severity);
        debug_struct.field("range", &self.range);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Object describing where in the file the issue was found.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Range {
    /// Required. Start of the issue.
    pub start: std::option::Option<crate::model::Point>,

    /// Required. End of the issue.
    pub end: std::option::Option<crate::model::Point>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Range {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start][crate::model::Range::start].
    pub fn set_start<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Point>,
    {
        self.start = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start][crate::model::Range::start].
    pub fn set_or_clear_start<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Point>,
    {
        self.start = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end][crate::model::Range::end].
    pub fn set_end<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Point>,
    {
        self.end = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end][crate::model::Range::end].
    pub fn set_or_clear_end<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Point>,
    {
        self.end = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Range {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.Range"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Range {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start,
            __end,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Range")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "start" => Ok(__FieldTag::__start),
                            "end" => Ok(__FieldTag::__end),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Range;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Range")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start => {
                            if !fields.insert(__FieldTag::__start) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start",
                                ));
                            }
                            result.start =
                                map.next_value::<std::option::Option<crate::model::Point>>()?;
                        }
                        __FieldTag::__end => {
                            if !fields.insert(__FieldTag::__end) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end",
                                ));
                            }
                            result.end =
                                map.next_value::<std::option::Option<crate::model::Point>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Range {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start.is_some() {
            state.serialize_entry("start", &self.start)?;
        }
        if self.end.is_some() {
            state.serialize_entry("end", &self.end)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Range {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Range");
        debug_struct.field("start", &self.start);
        debug_struct.field("end", &self.end);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Point within the file (line and character).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Point {
    /// Required. Line number (zero-indexed).
    pub line: i32,

    /// Required. Character position within the line (zero-indexed).
    pub character: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Point {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [line][crate::model::Point::line].
    pub fn set_line<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.line = v.into();
        self
    }

    /// Sets the value of [character][crate::model::Point::character].
    pub fn set_character<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.character = v.into();
        self
    }
}

impl wkt::message::Message for Point {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.Point"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Point {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __line,
            __character,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Point")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "line" => Ok(__FieldTag::__line),
                            "character" => Ok(__FieldTag::__character),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Point;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Point")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__line => {
                            if !fields.insert(__FieldTag::__line) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for line",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.line = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__character => {
                            if !fields.insert(__FieldTag::__character) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for character",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.character = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Point {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.line) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("line", &__With(&self.line))?;
        }
        if !wkt::internal::is_default(&self.character) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("character", &__With(&self.character))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Point {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Point");
        debug_struct.field("line", &self.line);
        debug_struct.field("character", &self.character);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][google.longrunning.Operation.error] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("requested_cancellation", &self.requested_cancellation);
        debug_struct.field("api_version", &self.api_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An ApiHubInstance represents the instance resources of the API Hub.
/// Currently, only one ApiHub instance is allowed for each project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApiHubInstance {
    /// Identifier. Format:
    /// `projects/{project}/locations/{location}/apiHubInstances/{apiHubInstance}`.
    pub name: std::string::String,

    /// Output only. Creation timestamp.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Last update timestamp.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of the ApiHub instance.
    pub state: crate::model::api_hub_instance::State,

    /// Output only. Extra information about ApiHub instance state. Currently the
    /// message would be populated when state is `FAILED`.
    pub state_message: std::string::String,

    /// Required. Config of the ApiHub instance.
    pub config: std::option::Option<crate::model::api_hub_instance::Config>,

    /// Optional. Instance labels to represent user-provided metadata.
    /// Refer to cloud documentation on labels for more details.
    /// <https://cloud.google.com/compute/docs/labeling-resources>
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Description of the ApiHub instance.
    pub description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApiHubInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApiHubInstance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ApiHubInstance::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ApiHubInstance::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ApiHubInstance::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ApiHubInstance::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::ApiHubInstance::state].
    pub fn set_state<T: std::convert::Into<crate::model::api_hub_instance::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_message][crate::model::ApiHubInstance::state_message].
    pub fn set_state_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_message = v.into();
        self
    }

    /// Sets the value of [config][crate::model::ApiHubInstance::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::api_hub_instance::Config>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::ApiHubInstance::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::api_hub_instance::Config>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::ApiHubInstance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::ApiHubInstance::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for ApiHubInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ApiHubInstance"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApiHubInstance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __state,
            __state_message,
            __config,
            __labels,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApiHubInstance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "state" => Ok(__FieldTag::__state),
                            "stateMessage" => Ok(__FieldTag::__state_message),
                            "state_message" => Ok(__FieldTag::__state_message),
                            "config" => Ok(__FieldTag::__config),
                            "labels" => Ok(__FieldTag::__labels),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApiHubInstance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApiHubInstance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::api_hub_instance::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_message => {
                            if !fields.insert(__FieldTag::__state_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_message",
                                ));
                            }
                            result.state_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map.next_value::<std::option::Option<crate::model::api_hub_instance::Config>>()?
                                ;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApiHubInstance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_message.is_empty() {
            state.serialize_entry("stateMessage", &self.state_message)?;
        }
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApiHubInstance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApiHubInstance");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_message", &self.state_message);
        debug_struct.field("config", &self.config);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("description", &self.description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ApiHubInstance].
pub mod api_hub_instance {
    #[allow(unused_imports)]
    use super::*;

    /// Available configurations to provision an ApiHub Instance.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Config {
        /// Optional. The Customer Managed Encryption Key (CMEK) used for data
        /// encryption. The CMEK name should follow the format of
        /// `projects/([^/]+)/locations/([^/]+)/keyRings/([^/]+)/cryptoKeys/([^/]+)`,
        /// where the location must match the instance location.
        /// If the CMEK is not provided, a GMEK will be created for the instance.
        pub cmek_key_name: std::string::String,

        /// Optional. If true, the search will be disabled for the instance. The
        /// default value is false.
        pub disable_search: bool,

        /// Optional. The name of the Vertex AI location where the data store is
        /// stored.
        pub vertex_location: std::string::String,

        /// Optional. Encryption type for the region. If the encryption type is CMEK,
        /// the cmek_key_name must be provided. If no encryption type is provided,
        /// GMEK will be used.
        pub encryption_type: crate::model::api_hub_instance::config::EncryptionType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Config {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cmek_key_name][crate::model::api_hub_instance::Config::cmek_key_name].
        pub fn set_cmek_key_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.cmek_key_name = v.into();
            self
        }

        /// Sets the value of [disable_search][crate::model::api_hub_instance::Config::disable_search].
        pub fn set_disable_search<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.disable_search = v.into();
            self
        }

        /// Sets the value of [vertex_location][crate::model::api_hub_instance::Config::vertex_location].
        pub fn set_vertex_location<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.vertex_location = v.into();
            self
        }

        /// Sets the value of [encryption_type][crate::model::api_hub_instance::Config::encryption_type].
        pub fn set_encryption_type<
            T: std::convert::Into<crate::model::api_hub_instance::config::EncryptionType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encryption_type = v.into();
            self
        }
    }

    impl wkt::message::Message for Config {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.ApiHubInstance.Config"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Config {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cmek_key_name,
                __disable_search,
                __vertex_location,
                __encryption_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Config")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "cmekKeyName" => Ok(__FieldTag::__cmek_key_name),
                                "cmek_key_name" => Ok(__FieldTag::__cmek_key_name),
                                "disableSearch" => Ok(__FieldTag::__disable_search),
                                "disable_search" => Ok(__FieldTag::__disable_search),
                                "vertexLocation" => Ok(__FieldTag::__vertex_location),
                                "vertex_location" => Ok(__FieldTag::__vertex_location),
                                "encryptionType" => Ok(__FieldTag::__encryption_type),
                                "encryption_type" => Ok(__FieldTag::__encryption_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Config;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Config")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cmek_key_name => {
                                if !fields.insert(__FieldTag::__cmek_key_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cmek_key_name",
                                    ));
                                }
                                result.cmek_key_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__disable_search => {
                                if !fields.insert(__FieldTag::__disable_search) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disable_search",
                                    ));
                                }
                                result.disable_search = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__vertex_location => {
                                if !fields.insert(__FieldTag::__vertex_location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for vertex_location",
                                    ));
                                }
                                result.vertex_location = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__encryption_type => {
                                if !fields.insert(__FieldTag::__encryption_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for encryption_type",
                                    ));
                                }
                                result.encryption_type = map
                                    .next_value::<std::option::Option<
                                        crate::model::api_hub_instance::config::EncryptionType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Config {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.cmek_key_name.is_empty() {
                state.serialize_entry("cmekKeyName", &self.cmek_key_name)?;
            }
            if !wkt::internal::is_default(&self.disable_search) {
                state.serialize_entry("disableSearch", &self.disable_search)?;
            }
            if !self.vertex_location.is_empty() {
                state.serialize_entry("vertexLocation", &self.vertex_location)?;
            }
            if !wkt::internal::is_default(&self.encryption_type) {
                state.serialize_entry("encryptionType", &self.encryption_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Config {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Config");
            debug_struct.field("cmek_key_name", &self.cmek_key_name);
            debug_struct.field("disable_search", &self.disable_search);
            debug_struct.field("vertex_location", &self.vertex_location);
            debug_struct.field("encryption_type", &self.encryption_type);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Config].
    pub mod config {
        #[allow(unused_imports)]
        use super::*;

        /// Types of data encryption.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum EncryptionType {
            /// Encryption type unspecified.
            Unspecified,
            /// Default encryption using Google managed encryption key.
            Gmek,
            /// Encryption using customer managed encryption key.
            Cmek,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [EncryptionType::value] or
            /// [EncryptionType::name].
            UnknownValue(encryption_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod encryption_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl EncryptionType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Gmek => std::option::Option::Some(1),
                    Self::Cmek => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ENCRYPTION_TYPE_UNSPECIFIED"),
                    Self::Gmek => std::option::Option::Some("GMEK"),
                    Self::Cmek => std::option::Option::Some("CMEK"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for EncryptionType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for EncryptionType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for EncryptionType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Gmek,
                    2 => Self::Cmek,
                    _ => Self::UnknownValue(encryption_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for EncryptionType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ENCRYPTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "GMEK" => Self::Gmek,
                    "CMEK" => Self::Cmek,
                    _ => Self::UnknownValue(encryption_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for EncryptionType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Gmek => serializer.serialize_i32(1),
                    Self::Cmek => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for EncryptionType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<EncryptionType>::new(
                    ".google.cloud.apihub.v1.ApiHubInstance.Config.EncryptionType",
                ))
            }
        }
    }

    /// State of the ApiHub Instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified,
        /// The ApiHub instance has not been initialized or has been deleted.
        Inactive,
        /// The ApiHub instance is being created.
        Creating,
        /// The ApiHub instance has been created and is ready for use.
        Active,
        /// The ApiHub instance is being updated.
        Updating,
        /// The ApiHub instance is being deleted.
        Deleting,
        /// The ApiHub instance encountered an error during a state change.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Inactive => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Active => std::option::Option::Some(3),
                Self::Updating => std::option::Option::Some(4),
                Self::Deleting => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Inactive,
                2 => Self::Creating,
                3 => Self::Active,
                4 => Self::Updating,
                5 => Self::Deleting,
                6 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "INACTIVE" => Self::Inactive,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Inactive => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Active => serializer.serialize_i32(3),
                Self::Updating => serializer.serialize_i32(4),
                Self::Deleting => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.apihub.v1.ApiHubInstance.State",
            ))
        }
    }
}

/// An external API represents an API being provided by external sources. This
/// can be used to model third-party APIs and can be used to define dependencies.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExternalApi {
    /// Identifier. Format:
    /// `projects/{project}/locations/{location}/externalApi/{externalApi}`.
    pub name: std::string::String,

    /// Required. Display name of the external API. Max length is 63 characters
    /// (Unicode Code Points).
    pub display_name: std::string::String,

    /// Optional. Description of the external API. Max length is 2000 characters
    /// (Unicode Code Points).
    pub description: std::string::String,

    /// Optional. List of endpoints on which this API is accessible.
    pub endpoints: std::vec::Vec<std::string::String>,

    /// Optional. List of paths served by this API.
    pub paths: std::vec::Vec<std::string::String>,

    /// Optional. Documentation of the external API.
    pub documentation: std::option::Option<crate::model::Documentation>,

    /// Optional. The list of user defined attributes associated with the Version
    /// resource. The key is the attribute name. It will be of the format:
    /// `projects/{project}/locations/{location}/attributes/{attribute}`.
    /// The value is the attribute values associated with the resource.
    pub attributes: std::collections::HashMap<std::string::String, crate::model::AttributeValues>,

    /// Output only. Creation timestamp.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Last update timestamp.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExternalApi {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExternalApi::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ExternalApi::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ExternalApi::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [endpoints][crate::model::ExternalApi::endpoints].
    pub fn set_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [paths][crate::model::ExternalApi::paths].
    pub fn set_paths<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.paths = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [documentation][crate::model::ExternalApi::documentation].
    pub fn set_documentation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Documentation>,
    {
        self.documentation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [documentation][crate::model::ExternalApi::documentation].
    pub fn set_or_clear_documentation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Documentation>,
    {
        self.documentation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attributes][crate::model::ExternalApi::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::AttributeValues>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::ExternalApi::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ExternalApi::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ExternalApi::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ExternalApi::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExternalApi {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ExternalApi"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExternalApi {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __endpoints,
            __paths,
            __documentation,
            __attributes,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExternalApi")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "endpoints" => Ok(__FieldTag::__endpoints),
                            "paths" => Ok(__FieldTag::__paths),
                            "documentation" => Ok(__FieldTag::__documentation),
                            "attributes" => Ok(__FieldTag::__attributes),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExternalApi;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExternalApi")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__endpoints => {
                            if !fields.insert(__FieldTag::__endpoints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoints",
                                ));
                            }
                            result.endpoints = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__paths => {
                            if !fields.insert(__FieldTag::__paths) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for paths",
                                ));
                            }
                            result.paths = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__documentation => {
                            if !fields.insert(__FieldTag::__documentation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documentation",
                                ));
                            }
                            result.documentation = map
                                .next_value::<std::option::Option<crate::model::Documentation>>()?;
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::AttributeValues,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExternalApi {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.endpoints.is_empty() {
            state.serialize_entry("endpoints", &self.endpoints)?;
        }
        if !self.paths.is_empty() {
            state.serialize_entry("paths", &self.paths)?;
        }
        if self.documentation.is_some() {
            state.serialize_entry("documentation", &self.documentation)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExternalApi {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExternalApi");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("endpoints", &self.endpoints);
        debug_struct.field("paths", &self.paths);
        debug_struct.field("documentation", &self.documentation);
        debug_struct.field("attributes", &self.attributes);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ConfigValueOption represents an option for a config variable of type enum or
/// multi select.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConfigValueOption {
    /// Required. Id of the option.
    pub id: std::string::String,

    /// Required. Display name of the option.
    pub display_name: std::string::String,

    /// Optional. Description of the option.
    pub description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigValueOption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::ConfigValueOption::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ConfigValueOption::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ConfigValueOption::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for ConfigValueOption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ConfigValueOption"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConfigValueOption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __display_name,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfigValueOption")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConfigValueOption;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfigValueOption")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConfigValueOption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConfigValueOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfigValueOption");
        debug_struct.field("id", &self.id);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Secret provides a reference to entries in Secret Manager.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Secret {
    /// Required. The resource name of the secret version in the format,
    /// format as: `projects/*/secrets/*/versions/*`.
    pub secret_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Secret {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secret_version][crate::model::Secret::secret_version].
    pub fn set_secret_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret_version = v.into();
        self
    }
}

impl wkt::message::Message for Secret {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.Secret"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Secret {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __secret_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Secret")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "secretVersion" => Ok(__FieldTag::__secret_version),
                            "secret_version" => Ok(__FieldTag::__secret_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Secret;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Secret")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__secret_version => {
                            if !fields.insert(__FieldTag::__secret_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_version",
                                ));
                            }
                            result.secret_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Secret {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.secret_version.is_empty() {
            state.serialize_entry("secretVersion", &self.secret_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Secret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Secret");
        debug_struct.field("secret_version", &self.secret_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ConfigVariableTemplate represents a configuration variable template present
/// in a Plugin Config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConfigVariableTemplate {
    /// Required. ID of the config variable. Must be unique within the
    /// configuration.
    pub id: std::string::String,

    /// Required. Type of the parameter: string, int, bool etc.
    pub value_type: crate::model::config_variable_template::ValueType,

    /// Optional. Description.
    pub description: std::string::String,

    /// Optional. Regular expression in RE2 syntax used for validating the `value`
    /// of a `ConfigVariable`.
    pub validation_regex: std::string::String,

    /// Optional. Flag represents that this `ConfigVariable` must be provided for a
    /// PluginInstance.
    pub required: bool,

    /// Optional. Enum options. To be populated if `ValueType` is `ENUM`.
    pub enum_options: std::vec::Vec<crate::model::ConfigValueOption>,

    /// Optional. Multi select options. To be populated if `ValueType` is
    /// `MULTI_SELECT`.
    pub multi_select_options: std::vec::Vec<crate::model::ConfigValueOption>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigVariableTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::ConfigVariableTemplate::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [value_type][crate::model::ConfigVariableTemplate::value_type].
    pub fn set_value_type<
        T: std::convert::Into<crate::model::config_variable_template::ValueType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value_type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ConfigVariableTemplate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [validation_regex][crate::model::ConfigVariableTemplate::validation_regex].
    pub fn set_validation_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.validation_regex = v.into();
        self
    }

    /// Sets the value of [required][crate::model::ConfigVariableTemplate::required].
    pub fn set_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.required = v.into();
        self
    }

    /// Sets the value of [enum_options][crate::model::ConfigVariableTemplate::enum_options].
    pub fn set_enum_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConfigValueOption>,
    {
        use std::iter::Iterator;
        self.enum_options = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [multi_select_options][crate::model::ConfigVariableTemplate::multi_select_options].
    pub fn set_multi_select_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConfigValueOption>,
    {
        use std::iter::Iterator;
        self.multi_select_options = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ConfigVariableTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ConfigVariableTemplate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConfigVariableTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __value_type,
            __description,
            __validation_regex,
            __required,
            __enum_options,
            __multi_select_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfigVariableTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "valueType" => Ok(__FieldTag::__value_type),
                            "value_type" => Ok(__FieldTag::__value_type),
                            "description" => Ok(__FieldTag::__description),
                            "validationRegex" => Ok(__FieldTag::__validation_regex),
                            "validation_regex" => Ok(__FieldTag::__validation_regex),
                            "required" => Ok(__FieldTag::__required),
                            "enumOptions" => Ok(__FieldTag::__enum_options),
                            "enum_options" => Ok(__FieldTag::__enum_options),
                            "multiSelectOptions" => Ok(__FieldTag::__multi_select_options),
                            "multi_select_options" => Ok(__FieldTag::__multi_select_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConfigVariableTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfigVariableTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value_type => {
                            if !fields.insert(__FieldTag::__value_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value_type",
                                ));
                            }
                            result.value_type = map
                                .next_value::<std::option::Option<
                                    crate::model::config_variable_template::ValueType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validation_regex => {
                            if !fields.insert(__FieldTag::__validation_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validation_regex",
                                ));
                            }
                            result.validation_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__required => {
                            if !fields.insert(__FieldTag::__required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for required",
                                ));
                            }
                            result.required = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enum_options => {
                            if !fields.insert(__FieldTag::__enum_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enum_options",
                                ));
                            }
                            result.enum_options =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConfigValueOption>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__multi_select_options => {
                            if !fields.insert(__FieldTag::__multi_select_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_select_options",
                                ));
                            }
                            result.multi_select_options =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConfigValueOption>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConfigVariableTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !wkt::internal::is_default(&self.value_type) {
            state.serialize_entry("valueType", &self.value_type)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.validation_regex.is_empty() {
            state.serialize_entry("validationRegex", &self.validation_regex)?;
        }
        if !wkt::internal::is_default(&self.required) {
            state.serialize_entry("required", &self.required)?;
        }
        if !self.enum_options.is_empty() {
            state.serialize_entry("enumOptions", &self.enum_options)?;
        }
        if !self.multi_select_options.is_empty() {
            state.serialize_entry("multiSelectOptions", &self.multi_select_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConfigVariableTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfigVariableTemplate");
        debug_struct.field("id", &self.id);
        debug_struct.field("value_type", &self.value_type);
        debug_struct.field("description", &self.description);
        debug_struct.field("validation_regex", &self.validation_regex);
        debug_struct.field("required", &self.required);
        debug_struct.field("enum_options", &self.enum_options);
        debug_struct.field("multi_select_options", &self.multi_select_options);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ConfigVariableTemplate].
pub mod config_variable_template {
    #[allow(unused_imports)]
    use super::*;

    /// ValueType indicates the data type of the value.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ValueType {
        /// Value type is not specified.
        Unspecified,
        /// Value type is string.
        String,
        /// Value type is integer.
        Int,
        /// Value type is boolean.
        Bool,
        /// Value type is secret.
        Secret,
        /// Value type is enum.
        Enum,
        /// Value type is multi select.
        MultiSelect,
        /// Value type is multi string.
        MultiString,
        /// Value type is multi int.
        MultiInt,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ValueType::value] or
        /// [ValueType::name].
        UnknownValue(value_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod value_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ValueType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::String => std::option::Option::Some(1),
                Self::Int => std::option::Option::Some(2),
                Self::Bool => std::option::Option::Some(3),
                Self::Secret => std::option::Option::Some(4),
                Self::Enum => std::option::Option::Some(5),
                Self::MultiSelect => std::option::Option::Some(6),
                Self::MultiString => std::option::Option::Some(7),
                Self::MultiInt => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VALUE_TYPE_UNSPECIFIED"),
                Self::String => std::option::Option::Some("STRING"),
                Self::Int => std::option::Option::Some("INT"),
                Self::Bool => std::option::Option::Some("BOOL"),
                Self::Secret => std::option::Option::Some("SECRET"),
                Self::Enum => std::option::Option::Some("ENUM"),
                Self::MultiSelect => std::option::Option::Some("MULTI_SELECT"),
                Self::MultiString => std::option::Option::Some("MULTI_STRING"),
                Self::MultiInt => std::option::Option::Some("MULTI_INT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ValueType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ValueType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ValueType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::String,
                2 => Self::Int,
                3 => Self::Bool,
                4 => Self::Secret,
                5 => Self::Enum,
                6 => Self::MultiSelect,
                7 => Self::MultiString,
                8 => Self::MultiInt,
                _ => Self::UnknownValue(value_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ValueType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VALUE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "STRING" => Self::String,
                "INT" => Self::Int,
                "BOOL" => Self::Bool,
                "SECRET" => Self::Secret,
                "ENUM" => Self::Enum,
                "MULTI_SELECT" => Self::MultiSelect,
                "MULTI_STRING" => Self::MultiString,
                "MULTI_INT" => Self::MultiInt,
                _ => Self::UnknownValue(value_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ValueType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::String => serializer.serialize_i32(1),
                Self::Int => serializer.serialize_i32(2),
                Self::Bool => serializer.serialize_i32(3),
                Self::Secret => serializer.serialize_i32(4),
                Self::Enum => serializer.serialize_i32(5),
                Self::MultiSelect => serializer.serialize_i32(6),
                Self::MultiString => serializer.serialize_i32(7),
                Self::MultiInt => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ValueType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ValueType>::new(
                ".google.cloud.apihub.v1.ConfigVariableTemplate.ValueType",
            ))
        }
    }
}

/// ConfigVariable represents a additional configuration variable present in a
/// PluginInstance Config or AuthConfig, based on a ConfigVariableTemplate.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConfigVariable {
    /// Output only. Key will be the
    /// [id][google.cloud.apihub.v1.ConfigVariableTemplate.id] to uniquely identify
    /// the config variable.
    ///
    /// [google.cloud.apihub.v1.ConfigVariableTemplate.id]: crate::model::ConfigVariableTemplate::id
    pub key: std::string::String,

    /// The values associated with the config variable.
    pub value: std::option::Option<crate::model::config_variable::Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigVariable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::ConfigVariable::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::config_variable::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::ConfigVariable::value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::config_variable::Value::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::config_variable::Value::StringValue(v.into()));
        self
    }

    /// The value of [value][crate::model::ConfigVariable::value]
    /// if it holds a `IntValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn int_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::config_variable::Value::IntValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value]
    /// to hold a `IntValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::config_variable::Value::IntValue(v.into()));
        self
    }

    /// The value of [value][crate::model::ConfigVariable::value]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::config_variable::Value::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::config_variable::Value::BoolValue(v.into()));
        self
    }

    /// The value of [value][crate::model::ConfigVariable::value]
    /// if it holds a `SecretValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn secret_value(&self) -> std::option::Option<&std::boxed::Box<crate::model::Secret>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::config_variable::Value::SecretValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value]
    /// to hold a `SecretValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_secret_value<T: std::convert::Into<std::boxed::Box<crate::model::Secret>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value =
            std::option::Option::Some(crate::model::config_variable::Value::SecretValue(v.into()));
        self
    }

    /// The value of [value][crate::model::ConfigVariable::value]
    /// if it holds a `EnumValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn enum_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ConfigValueOption>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::config_variable::Value::EnumValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value]
    /// to hold a `EnumValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_enum_value<
        T: std::convert::Into<std::boxed::Box<crate::model::ConfigValueOption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value =
            std::option::Option::Some(crate::model::config_variable::Value::EnumValue(v.into()));
        self
    }

    /// The value of [value][crate::model::ConfigVariable::value]
    /// if it holds a `MultiSelectValues`, `None` if the field is not set or
    /// holds a different branch.
    pub fn multi_select_values(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::config_variable::MultiSelectValues>>
    {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::config_variable::Value::MultiSelectValues(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value]
    /// to hold a `MultiSelectValues`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_multi_select_values<
        T: std::convert::Into<std::boxed::Box<crate::model::config_variable::MultiSelectValues>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::config_variable::Value::MultiSelectValues(v.into()),
        );
        self
    }

    /// The value of [value][crate::model::ConfigVariable::value]
    /// if it holds a `MultiStringValues`, `None` if the field is not set or
    /// holds a different branch.
    pub fn multi_string_values(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::config_variable::MultiStringValues>>
    {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::config_variable::Value::MultiStringValues(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value]
    /// to hold a `MultiStringValues`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_multi_string_values<
        T: std::convert::Into<std::boxed::Box<crate::model::config_variable::MultiStringValues>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::config_variable::Value::MultiStringValues(v.into()),
        );
        self
    }

    /// The value of [value][crate::model::ConfigVariable::value]
    /// if it holds a `MultiIntValues`, `None` if the field is not set or
    /// holds a different branch.
    pub fn multi_int_values(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::config_variable::MultiIntValues>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::config_variable::Value::MultiIntValues(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::ConfigVariable::value]
    /// to hold a `MultiIntValues`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_multi_int_values<
        T: std::convert::Into<std::boxed::Box<crate::model::config_variable::MultiIntValues>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::config_variable::Value::MultiIntValues(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConfigVariable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ConfigVariable"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConfigVariable {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __string_value,
            __int_value,
            __bool_value,
            __secret_value,
            __enum_value,
            __multi_select_values,
            __multi_string_values,
            __multi_int_values,
            __key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfigVariable")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "stringValue" => Ok(__FieldTag::__string_value),
                            "string_value" => Ok(__FieldTag::__string_value),
                            "intValue" => Ok(__FieldTag::__int_value),
                            "int_value" => Ok(__FieldTag::__int_value),
                            "boolValue" => Ok(__FieldTag::__bool_value),
                            "bool_value" => Ok(__FieldTag::__bool_value),
                            "secretValue" => Ok(__FieldTag::__secret_value),
                            "secret_value" => Ok(__FieldTag::__secret_value),
                            "enumValue" => Ok(__FieldTag::__enum_value),
                            "enum_value" => Ok(__FieldTag::__enum_value),
                            "multiSelectValues" => Ok(__FieldTag::__multi_select_values),
                            "multi_select_values" => Ok(__FieldTag::__multi_select_values),
                            "multiStringValues" => Ok(__FieldTag::__multi_string_values),
                            "multi_string_values" => Ok(__FieldTag::__multi_string_values),
                            "multiIntValues" => Ok(__FieldTag::__multi_int_values),
                            "multi_int_values" => Ok(__FieldTag::__multi_int_values),
                            "key" => Ok(__FieldTag::__key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConfigVariable;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfigVariable")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__string_value => {
                            if !fields.insert(__FieldTag::__string_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.apihub.v1.ConfigVariable.string_value, latest field was stringValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::config_variable::Value::StringValue(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__int_value => {
                            if !fields.insert(__FieldTag::__int_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for int_value",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.apihub.v1.ConfigVariable.int_value, latest field was intValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::config_variable::Value::IntValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__bool_value => {
                            if !fields.insert(__FieldTag::__bool_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bool_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.apihub.v1.ConfigVariable.bool_value, latest field was boolValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::config_variable::Value::BoolValue(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__secret_value => {
                            if !fields.insert(__FieldTag::__secret_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.apihub.v1.ConfigVariable.secret_value, latest field was secretValue",
                                ));
                            }
                            result.value =
                                std::option::Option::Some(
                                    crate::model::config_variable::Value::SecretValue(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Secret>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__enum_value => {
                            if !fields.insert(__FieldTag::__enum_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enum_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.apihub.v1.ConfigVariable.enum_value, latest field was enumValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::config_variable::Value::EnumValue(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ConfigValueOption>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__multi_select_values => {
                            if !fields.insert(__FieldTag::__multi_select_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_select_values",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.apihub.v1.ConfigVariable.multi_select_values, latest field was multiSelectValues",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::config_variable::Value::MultiSelectValues(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::config_variable::MultiSelectValues,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__multi_string_values => {
                            if !fields.insert(__FieldTag::__multi_string_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_string_values",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.apihub.v1.ConfigVariable.multi_string_values, latest field was multiStringValues",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::config_variable::Value::MultiStringValues(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::config_variable::MultiStringValues,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__multi_int_values => {
                            if !fields.insert(__FieldTag::__multi_int_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_int_values",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.apihub.v1.ConfigVariable.multi_int_values, latest field was multiIntValues",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::config_variable::Value::MultiIntValues(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::config_variable::MultiIntValues,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConfigVariable {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.string_value() {
            state.serialize_entry("stringValue", value)?;
        }
        if let Some(value) = self.int_value() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("intValue", &__With(value))?;
        }
        if let Some(value) = self.bool_value() {
            state.serialize_entry("boolValue", value)?;
        }
        if let Some(value) = self.secret_value() {
            state.serialize_entry("secretValue", value)?;
        }
        if let Some(value) = self.enum_value() {
            state.serialize_entry("enumValue", value)?;
        }
        if let Some(value) = self.multi_select_values() {
            state.serialize_entry("multiSelectValues", value)?;
        }
        if let Some(value) = self.multi_string_values() {
            state.serialize_entry("multiStringValues", value)?;
        }
        if let Some(value) = self.multi_int_values() {
            state.serialize_entry("multiIntValues", value)?;
        }
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConfigVariable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfigVariable");
        debug_struct.field("key", &self.key);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ConfigVariable].
pub mod config_variable {
    #[allow(unused_imports)]
    use super::*;

    /// The config variable value of data type multi select.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MultiSelectValues {
        /// Optional. The config variable value of data type multi select.
        pub values: std::vec::Vec<crate::model::ConfigValueOption>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MultiSelectValues {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [values][crate::model::config_variable::MultiSelectValues::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ConfigValueOption>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for MultiSelectValues {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.ConfigVariable.MultiSelectValues"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MultiSelectValues {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __values,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MultiSelectValues")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "values" => Ok(__FieldTag::__values),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MultiSelectValues;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MultiSelectValues")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__values => {
                                if !fields.insert(__FieldTag::__values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for values",
                                    ));
                                }
                                result.values = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::ConfigValueOption>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MultiSelectValues {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.values.is_empty() {
                state.serialize_entry("values", &self.values)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for MultiSelectValues {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("MultiSelectValues");
            debug_struct.field("values", &self.values);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The config variable value of data type multi string.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MultiStringValues {
        /// Optional. The config variable value of data type multi string.
        pub values: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MultiStringValues {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [values][crate::model::config_variable::MultiStringValues::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for MultiStringValues {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.ConfigVariable.MultiStringValues"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MultiStringValues {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __values,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MultiStringValues")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "values" => Ok(__FieldTag::__values),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MultiStringValues;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MultiStringValues")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__values => {
                                if !fields.insert(__FieldTag::__values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for values",
                                    ));
                                }
                                result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MultiStringValues {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.values.is_empty() {
                state.serialize_entry("values", &self.values)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for MultiStringValues {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("MultiStringValues");
            debug_struct.field("values", &self.values);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The config variable value of data type multi int.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MultiIntValues {
        /// Optional. The config variable value of data type multi int.
        pub values: std::vec::Vec<i32>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MultiIntValues {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [values][crate::model::config_variable::MultiIntValues::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<i32>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for MultiIntValues {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.ConfigVariable.MultiIntValues"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MultiIntValues {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __values,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MultiIntValues")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "values" => Ok(__FieldTag::__values),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MultiIntValues;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MultiIntValues")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__values => {
                                if !fields.insert(__FieldTag::__values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for values",
                                    ));
                                }
                                struct __With(std::option::Option<std::vec::Vec<i32>>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.values = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MultiIntValues {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.values.is_empty() {
                struct __With<'a>(&'a std::vec::Vec<i32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("values", &__With(&self.values))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for MultiIntValues {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("MultiIntValues");
            debug_struct.field("values", &self.values);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The values associated with the config variable.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Value {
        /// Optional. The config variable value in case of config variable of type
        /// string.
        StringValue(std::string::String),
        /// Optional. The config variable value in case of config variable of type
        /// integer.
        IntValue(i64),
        /// Optional. The config variable value in case of config variable of type
        /// boolean.
        BoolValue(bool),
        /// Optional. The config variable value in case of config variable of type
        /// secret.
        SecretValue(std::boxed::Box<crate::model::Secret>),
        /// Optional. The config variable value in case of config variable of type
        /// enum.
        EnumValue(std::boxed::Box<crate::model::ConfigValueOption>),
        /// Optional. The config variable value in case of config variable of type
        /// multi select.
        MultiSelectValues(std::boxed::Box<crate::model::config_variable::MultiSelectValues>),
        /// Optional. The config variable value in case of config variable of type
        /// multi string.
        MultiStringValues(std::boxed::Box<crate::model::config_variable::MultiStringValues>),
        /// Optional. The config variable value in case of config variable of type
        /// multi integer.
        MultiIntValues(std::boxed::Box<crate::model::config_variable::MultiIntValues>),
    }
}

/// Config for Google service account authentication.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GoogleServiceAccountConfig {
    /// Required. The service account to be used for authenticating request.
    ///
    /// The `iam.serviceAccounts.getAccessToken` permission should be granted on
    /// this service account to the impersonator service account.
    pub service_account: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GoogleServiceAccountConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account][crate::model::GoogleServiceAccountConfig::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }
}

impl wkt::message::Message for GoogleServiceAccountConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GoogleServiceAccountConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GoogleServiceAccountConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_account,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleServiceAccountConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GoogleServiceAccountConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleServiceAccountConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GoogleServiceAccountConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GoogleServiceAccountConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GoogleServiceAccountConfig");
        debug_struct.field("service_account", &self.service_account);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AuthConfig represents the authentication information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AuthConfig {
    /// Required. The authentication type.
    pub auth_type: crate::model::AuthType,

    /// Supported auth types.
    pub config: std::option::Option<crate::model::auth_config::Config>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuthConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auth_type][crate::model::AuthConfig::auth_type].
    pub fn set_auth_type<T: std::convert::Into<crate::model::AuthType>>(mut self, v: T) -> Self {
        self.auth_type = v.into();
        self
    }

    /// Sets the value of [config][crate::model::AuthConfig::config].
    ///
    /// Note that all the setters affecting `config` are mutually
    /// exclusive.
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::auth_config::Config>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// The value of [config][crate::model::AuthConfig::config]
    /// if it holds a `GoogleServiceAccountConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn google_service_account_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GoogleServiceAccountConfig>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::auth_config::Config::GoogleServiceAccountConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::AuthConfig::config]
    /// to hold a `GoogleServiceAccountConfig`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_google_service_account_config<
        T: std::convert::Into<std::boxed::Box<crate::model::GoogleServiceAccountConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(
            crate::model::auth_config::Config::GoogleServiceAccountConfig(v.into()),
        );
        self
    }

    /// The value of [config][crate::model::AuthConfig::config]
    /// if it holds a `UserPasswordConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn user_password_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::auth_config::UserPasswordConfig>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::auth_config::Config::UserPasswordConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::AuthConfig::config]
    /// to hold a `UserPasswordConfig`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_user_password_config<
        T: std::convert::Into<std::boxed::Box<crate::model::auth_config::UserPasswordConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(
            crate::model::auth_config::Config::UserPasswordConfig(v.into()),
        );
        self
    }

    /// The value of [config][crate::model::AuthConfig::config]
    /// if it holds a `ApiKeyConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn api_key_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::auth_config::ApiKeyConfig>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::auth_config::Config::ApiKeyConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::AuthConfig::config]
    /// to hold a `ApiKeyConfig`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_api_key_config<
        T: std::convert::Into<std::boxed::Box<crate::model::auth_config::ApiKeyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config =
            std::option::Option::Some(crate::model::auth_config::Config::ApiKeyConfig(v.into()));
        self
    }

    /// The value of [config][crate::model::AuthConfig::config]
    /// if it holds a `Oauth2ClientCredentialsConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oauth2_client_credentials_config(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::auth_config::Oauth2ClientCredentialsConfig>,
    > {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::auth_config::Config::Oauth2ClientCredentialsConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::AuthConfig::config]
    /// to hold a `Oauth2ClientCredentialsConfig`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_oauth2_client_credentials_config<
        T: std::convert::Into<
                std::boxed::Box<crate::model::auth_config::Oauth2ClientCredentialsConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(
            crate::model::auth_config::Config::Oauth2ClientCredentialsConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AuthConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.AuthConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AuthConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __google_service_account_config,
            __user_password_config,
            __api_key_config,
            __oauth2_client_credentials_config,
            __auth_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AuthConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "googleServiceAccountConfig" => {
                                Ok(__FieldTag::__google_service_account_config)
                            }
                            "google_service_account_config" => {
                                Ok(__FieldTag::__google_service_account_config)
                            }
                            "userPasswordConfig" => Ok(__FieldTag::__user_password_config),
                            "user_password_config" => Ok(__FieldTag::__user_password_config),
                            "apiKeyConfig" => Ok(__FieldTag::__api_key_config),
                            "api_key_config" => Ok(__FieldTag::__api_key_config),
                            "oauth2ClientCredentialsConfig" => {
                                Ok(__FieldTag::__oauth2_client_credentials_config)
                            }
                            "oauth2_client_credentials_config" => {
                                Ok(__FieldTag::__oauth2_client_credentials_config)
                            }
                            "authType" => Ok(__FieldTag::__auth_type),
                            "auth_type" => Ok(__FieldTag::__auth_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AuthConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AuthConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__google_service_account_config => {
                            if !fields.insert(__FieldTag::__google_service_account_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_service_account_config",
                                ));
                            }
                            if result.config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `config`, a oneof with full ID .google.cloud.apihub.v1.AuthConfig.google_service_account_config, latest field was googleServiceAccountConfig",
                                ));
                            }
                            result.config = std::option::Option::Some(
                                crate::model::auth_config::Config::GoogleServiceAccountConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GoogleServiceAccountConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__user_password_config => {
                            if !fields.insert(__FieldTag::__user_password_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_password_config",
                                ));
                            }
                            if result.config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `config`, a oneof with full ID .google.cloud.apihub.v1.AuthConfig.user_password_config, latest field was userPasswordConfig",
                                ));
                            }
                            result.config = std::option::Option::Some(
                                crate::model::auth_config::Config::UserPasswordConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::auth_config::UserPasswordConfig,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__api_key_config => {
                            if !fields.insert(__FieldTag::__api_key_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_key_config",
                                ));
                            }
                            if result.config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `config`, a oneof with full ID .google.cloud.apihub.v1.AuthConfig.api_key_config, latest field was apiKeyConfig",
                                ));
                            }
                            result.config = std::option::Option::Some(
                                crate::model::auth_config::Config::ApiKeyConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::auth_config::ApiKeyConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__oauth2_client_credentials_config => {
                            if !fields.insert(__FieldTag::__oauth2_client_credentials_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth2_client_credentials_config",
                                ));
                            }
                            if result.config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `config`, a oneof with full ID .google.cloud.apihub.v1.AuthConfig.oauth2_client_credentials_config, latest field was oauth2ClientCredentialsConfig",
                                ));
                            }
                            result.config = std::option::Option::Some(
                                crate::model::auth_config::Config::Oauth2ClientCredentialsConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::auth_config::Oauth2ClientCredentialsConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__auth_type => {
                            if !fields.insert(__FieldTag::__auth_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auth_type",
                                ));
                            }
                            result.auth_type = map
                                .next_value::<std::option::Option<crate::model::AuthType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AuthConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.google_service_account_config() {
            state.serialize_entry("googleServiceAccountConfig", value)?;
        }
        if let Some(value) = self.user_password_config() {
            state.serialize_entry("userPasswordConfig", value)?;
        }
        if let Some(value) = self.api_key_config() {
            state.serialize_entry("apiKeyConfig", value)?;
        }
        if let Some(value) = self.oauth2_client_credentials_config() {
            state.serialize_entry("oauth2ClientCredentialsConfig", value)?;
        }
        if !wkt::internal::is_default(&self.auth_type) {
            state.serialize_entry("authType", &self.auth_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AuthConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AuthConfig");
        debug_struct.field("auth_type", &self.auth_type);
        debug_struct.field("config", &self.config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AuthConfig].
pub mod auth_config {
    #[allow(unused_imports)]
    use super::*;

    /// Parameters to support Username and Password Authentication.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UserPasswordConfig {
        /// Required. Username.
        pub username: std::string::String,

        /// Required. Secret version reference containing the password.
        /// The `secretmanager.versions.access` permission should be
        /// granted to the service account accessing the secret.
        pub password: std::option::Option<crate::model::Secret>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UserPasswordConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [username][crate::model::auth_config::UserPasswordConfig::username].
        pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.username = v.into();
            self
        }

        /// Sets the value of [password][crate::model::auth_config::UserPasswordConfig::password].
        pub fn set_password<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.password = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [password][crate::model::auth_config::UserPasswordConfig::password].
        pub fn set_or_clear_password<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.password = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for UserPasswordConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.AuthConfig.UserPasswordConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for UserPasswordConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __username,
                __password,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for UserPasswordConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "username" => Ok(__FieldTag::__username),
                                "password" => Ok(__FieldTag::__password),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = UserPasswordConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct UserPasswordConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__username => {
                                if !fields.insert(__FieldTag::__username) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for username",
                                    ));
                                }
                                result.username = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__password => {
                                if !fields.insert(__FieldTag::__password) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for password",
                                    ));
                                }
                                result.password =
                                    map.next_value::<std::option::Option<crate::model::Secret>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for UserPasswordConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.username.is_empty() {
                state.serialize_entry("username", &self.username)?;
            }
            if self.password.is_some() {
                state.serialize_entry("password", &self.password)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for UserPasswordConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("UserPasswordConfig");
            debug_struct.field("username", &self.username);
            debug_struct.field("password", &self.password);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Parameters to support Oauth 2.0 client credentials grant authentication.
    /// See <https://tools.ietf.org/html/rfc6749#section-1.3.4> for more details.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Oauth2ClientCredentialsConfig {
        /// Required. The client identifier.
        pub client_id: std::string::String,

        /// Required. Secret version reference containing the client secret.
        /// The `secretmanager.versions.access` permission should be
        /// granted to the service account accessing the secret.
        pub client_secret: std::option::Option<crate::model::Secret>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Oauth2ClientCredentialsConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [client_id][crate::model::auth_config::Oauth2ClientCredentialsConfig::client_id].
        pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client_id = v.into();
            self
        }

        /// Sets the value of [client_secret][crate::model::auth_config::Oauth2ClientCredentialsConfig::client_secret].
        pub fn set_client_secret<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.client_secret = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [client_secret][crate::model::auth_config::Oauth2ClientCredentialsConfig::client_secret].
        pub fn set_or_clear_client_secret<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.client_secret = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Oauth2ClientCredentialsConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.AuthConfig.Oauth2ClientCredentialsConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Oauth2ClientCredentialsConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __client_id,
                __client_secret,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Oauth2ClientCredentialsConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "clientId" => Ok(__FieldTag::__client_id),
                                "client_id" => Ok(__FieldTag::__client_id),
                                "clientSecret" => Ok(__FieldTag::__client_secret),
                                "client_secret" => Ok(__FieldTag::__client_secret),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Oauth2ClientCredentialsConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Oauth2ClientCredentialsConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__client_id => {
                                if !fields.insert(__FieldTag::__client_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for client_id",
                                    ));
                                }
                                result.client_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__client_secret => {
                                if !fields.insert(__FieldTag::__client_secret) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for client_secret",
                                    ));
                                }
                                result.client_secret =
                                    map.next_value::<std::option::Option<crate::model::Secret>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Oauth2ClientCredentialsConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.client_id.is_empty() {
                state.serialize_entry("clientId", &self.client_id)?;
            }
            if self.client_secret.is_some() {
                state.serialize_entry("clientSecret", &self.client_secret)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Oauth2ClientCredentialsConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Oauth2ClientCredentialsConfig");
            debug_struct.field("client_id", &self.client_id);
            debug_struct.field("client_secret", &self.client_secret);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Config for authentication with API key.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ApiKeyConfig {
        /// Required. The parameter name of the API key.
        /// E.g. If the API request is "<https://example.com/act?api_key=>\<API KEY\>",
        /// "api_key" would be the parameter name.
        pub name: std::string::String,

        /// Required. The name of the SecretManager secret version resource storing
        /// the API key. Format:
        /// `projects/{project}/secrets/{secrete}/versions/{version}`. The
        /// `secretmanager.versions.access` permission should be granted to the
        /// service account accessing the secret.
        pub api_key: std::option::Option<crate::model::Secret>,

        /// Required. The location of the API key.
        /// The default value is QUERY.
        pub http_element_location: crate::model::auth_config::api_key_config::HttpElementLocation,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ApiKeyConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::auth_config::ApiKeyConfig::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [api_key][crate::model::auth_config::ApiKeyConfig::api_key].
        pub fn set_api_key<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.api_key = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [api_key][crate::model::auth_config::ApiKeyConfig::api_key].
        pub fn set_or_clear_api_key<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Secret>,
        {
            self.api_key = v.map(|x| x.into());
            self
        }

        /// Sets the value of [http_element_location][crate::model::auth_config::ApiKeyConfig::http_element_location].
        pub fn set_http_element_location<
            T: std::convert::Into<crate::model::auth_config::api_key_config::HttpElementLocation>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.http_element_location = v.into();
            self
        }
    }

    impl wkt::message::Message for ApiKeyConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.AuthConfig.ApiKeyConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ApiKeyConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __api_key,
                __http_element_location,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ApiKeyConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "apiKey" => Ok(__FieldTag::__api_key),
                                "api_key" => Ok(__FieldTag::__api_key),
                                "httpElementLocation" => Ok(__FieldTag::__http_element_location),
                                "http_element_location" => Ok(__FieldTag::__http_element_location),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ApiKeyConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ApiKeyConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__api_key => {
                                if !fields.insert(__FieldTag::__api_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for api_key",
                                    ));
                                }
                                result.api_key =
                                    map.next_value::<std::option::Option<crate::model::Secret>>()?;
                            }
                            __FieldTag::__http_element_location => {
                                if !fields.insert(__FieldTag::__http_element_location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for http_element_location",
                                    ));
                                }
                                result.http_element_location = map.next_value::<std::option::Option<crate::model::auth_config::api_key_config::HttpElementLocation>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ApiKeyConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if self.api_key.is_some() {
                state.serialize_entry("apiKey", &self.api_key)?;
            }
            if !wkt::internal::is_default(&self.http_element_location) {
                state.serialize_entry("httpElementLocation", &self.http_element_location)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ApiKeyConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ApiKeyConfig");
            debug_struct.field("name", &self.name);
            debug_struct.field("api_key", &self.api_key);
            debug_struct.field("http_element_location", &self.http_element_location);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [ApiKeyConfig].
    pub mod api_key_config {
        #[allow(unused_imports)]
        use super::*;

        /// Enum of location an HTTP element can be.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum HttpElementLocation {
            /// HTTP element location not specified.
            Unspecified,
            /// Element is in the HTTP request query.
            Query,
            /// Element is in the HTTP request header.
            Header,
            /// Element is in the HTTP request path.
            Path,
            /// Element is in the HTTP request body.
            Body,
            /// Element is in the HTTP request cookie.
            Cookie,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [HttpElementLocation::value] or
            /// [HttpElementLocation::name].
            UnknownValue(http_element_location::UnknownValue),
        }

        #[doc(hidden)]
        pub mod http_element_location {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl HttpElementLocation {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Query => std::option::Option::Some(1),
                    Self::Header => std::option::Option::Some(2),
                    Self::Path => std::option::Option::Some(3),
                    Self::Body => std::option::Option::Some(4),
                    Self::Cookie => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("HTTP_ELEMENT_LOCATION_UNSPECIFIED")
                    }
                    Self::Query => std::option::Option::Some("QUERY"),
                    Self::Header => std::option::Option::Some("HEADER"),
                    Self::Path => std::option::Option::Some("PATH"),
                    Self::Body => std::option::Option::Some("BODY"),
                    Self::Cookie => std::option::Option::Some("COOKIE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for HttpElementLocation {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for HttpElementLocation {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for HttpElementLocation {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Query,
                    2 => Self::Header,
                    3 => Self::Path,
                    4 => Self::Body,
                    5 => Self::Cookie,
                    _ => Self::UnknownValue(http_element_location::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for HttpElementLocation {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "HTTP_ELEMENT_LOCATION_UNSPECIFIED" => Self::Unspecified,
                    "QUERY" => Self::Query,
                    "HEADER" => Self::Header,
                    "PATH" => Self::Path,
                    "BODY" => Self::Body,
                    "COOKIE" => Self::Cookie,
                    _ => Self::UnknownValue(http_element_location::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for HttpElementLocation {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Query => serializer.serialize_i32(1),
                    Self::Header => serializer.serialize_i32(2),
                    Self::Path => serializer.serialize_i32(3),
                    Self::Body => serializer.serialize_i32(4),
                    Self::Cookie => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for HttpElementLocation {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(
                    wkt::internal::EnumVisitor::<HttpElementLocation>::new(
                        ".google.cloud.apihub.v1.AuthConfig.ApiKeyConfig.HttpElementLocation",
                    ),
                )
            }
        }
    }

    /// Supported auth types.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Config {
        /// Google Service Account.
        GoogleServiceAccountConfig(std::boxed::Box<crate::model::GoogleServiceAccountConfig>),
        /// User Password.
        UserPasswordConfig(std::boxed::Box<crate::model::auth_config::UserPasswordConfig>),
        /// Api Key Config.
        ApiKeyConfig(std::boxed::Box<crate::model::auth_config::ApiKeyConfig>),
        /// Oauth2.0 Client Credentials.
        Oauth2ClientCredentialsConfig(
            std::boxed::Box<crate::model::auth_config::Oauth2ClientCredentialsConfig>,
        ),
    }
}

/// SourceMetadata represents the metadata for a resource at the source.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SourceMetadata {
    /// Output only. The type of the source.
    pub source_type: crate::model::source_metadata::SourceType,

    /// Output only. The unique identifier of the resource at the source.
    pub original_resource_id: std::string::String,

    /// Output only. The time at which the resource was created at the source.
    pub original_resource_create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the resource was last updated at the source.
    pub original_resource_update_time: std::option::Option<wkt::Timestamp>,

    /// The source of the resource.
    pub source: std::option::Option<crate::model::source_metadata::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_type][crate::model::SourceMetadata::source_type].
    pub fn set_source_type<T: std::convert::Into<crate::model::source_metadata::SourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }

    /// Sets the value of [original_resource_id][crate::model::SourceMetadata::original_resource_id].
    pub fn set_original_resource_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.original_resource_id = v.into();
        self
    }

    /// Sets the value of [original_resource_create_time][crate::model::SourceMetadata::original_resource_create_time].
    pub fn set_original_resource_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_resource_create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_resource_create_time][crate::model::SourceMetadata::original_resource_create_time].
    pub fn set_or_clear_original_resource_create_time<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_resource_create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [original_resource_update_time][crate::model::SourceMetadata::original_resource_update_time].
    pub fn set_original_resource_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_resource_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_resource_update_time][crate::model::SourceMetadata::original_resource_update_time].
    pub fn set_or_clear_original_resource_update_time<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.original_resource_update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::SourceMetadata::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::source_metadata::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::SourceMetadata::source]
    /// if it holds a `PluginInstanceActionSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn plugin_instance_action_source(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::source_metadata::PluginInstanceActionSource>,
    > {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source_metadata::Source::PluginInstanceActionSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::SourceMetadata::source]
    /// to hold a `PluginInstanceActionSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_plugin_instance_action_source<
        T: std::convert::Into<
                std::boxed::Box<crate::model::source_metadata::PluginInstanceActionSource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::source_metadata::Source::PluginInstanceActionSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SourceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.SourceMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SourceMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __plugin_instance_action_source,
            __source_type,
            __original_resource_id,
            __original_resource_create_time,
            __original_resource_update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SourceMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pluginInstanceActionSource" => {
                                Ok(__FieldTag::__plugin_instance_action_source)
                            }
                            "plugin_instance_action_source" => {
                                Ok(__FieldTag::__plugin_instance_action_source)
                            }
                            "sourceType" => Ok(__FieldTag::__source_type),
                            "source_type" => Ok(__FieldTag::__source_type),
                            "originalResourceId" => Ok(__FieldTag::__original_resource_id),
                            "original_resource_id" => Ok(__FieldTag::__original_resource_id),
                            "originalResourceCreateTime" => {
                                Ok(__FieldTag::__original_resource_create_time)
                            }
                            "original_resource_create_time" => {
                                Ok(__FieldTag::__original_resource_create_time)
                            }
                            "originalResourceUpdateTime" => {
                                Ok(__FieldTag::__original_resource_update_time)
                            }
                            "original_resource_update_time" => {
                                Ok(__FieldTag::__original_resource_update_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SourceMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SourceMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__plugin_instance_action_source => {
                            if !fields.insert(__FieldTag::__plugin_instance_action_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plugin_instance_action_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.apihub.v1.SourceMetadata.plugin_instance_action_source, latest field was pluginInstanceActionSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::source_metadata::Source::PluginInstanceActionSource(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::source_metadata::PluginInstanceActionSource>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__source_type => {
                            if !fields.insert(__FieldTag::__source_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_type",
                                ));
                            }
                            result.source_type = map.next_value::<std::option::Option<crate::model::source_metadata::SourceType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__original_resource_id => {
                            if !fields.insert(__FieldTag::__original_resource_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_resource_id",
                                ));
                            }
                            result.original_resource_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__original_resource_create_time => {
                            if !fields.insert(__FieldTag::__original_resource_create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_resource_create_time",
                                ));
                            }
                            result.original_resource_create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__original_resource_update_time => {
                            if !fields.insert(__FieldTag::__original_resource_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_resource_update_time",
                                ));
                            }
                            result.original_resource_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SourceMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.plugin_instance_action_source() {
            state.serialize_entry("pluginInstanceActionSource", value)?;
        }
        if !wkt::internal::is_default(&self.source_type) {
            state.serialize_entry("sourceType", &self.source_type)?;
        }
        if !self.original_resource_id.is_empty() {
            state.serialize_entry("originalResourceId", &self.original_resource_id)?;
        }
        if self.original_resource_create_time.is_some() {
            state.serialize_entry(
                "originalResourceCreateTime",
                &self.original_resource_create_time,
            )?;
        }
        if self.original_resource_update_time.is_some() {
            state.serialize_entry(
                "originalResourceUpdateTime",
                &self.original_resource_update_time,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SourceMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SourceMetadata");
        debug_struct.field("source_type", &self.source_type);
        debug_struct.field("original_resource_id", &self.original_resource_id);
        debug_struct.field(
            "original_resource_create_time",
            &self.original_resource_create_time,
        );
        debug_struct.field(
            "original_resource_update_time",
            &self.original_resource_update_time,
        );
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SourceMetadata].
pub mod source_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// PluginInstanceActionSource represents the plugin instance action source.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PluginInstanceActionSource {
        /// Output only. The resource name of the source plugin instance.
        /// Format is
        /// `projects/{project}/locations/{location}/plugins/{plugin}/instances/{instance}`
        pub plugin_instance: std::string::String,

        /// Output only. The id of the plugin instance action.
        pub action_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PluginInstanceActionSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [plugin_instance][crate::model::source_metadata::PluginInstanceActionSource::plugin_instance].
        pub fn set_plugin_instance<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.plugin_instance = v.into();
            self
        }

        /// Sets the value of [action_id][crate::model::source_metadata::PluginInstanceActionSource::action_id].
        pub fn set_action_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.action_id = v.into();
            self
        }
    }

    impl wkt::message::Message for PluginInstanceActionSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.SourceMetadata.PluginInstanceActionSource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PluginInstanceActionSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __plugin_instance,
                __action_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PluginInstanceActionSource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "pluginInstance" => Ok(__FieldTag::__plugin_instance),
                                "plugin_instance" => Ok(__FieldTag::__plugin_instance),
                                "actionId" => Ok(__FieldTag::__action_id),
                                "action_id" => Ok(__FieldTag::__action_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PluginInstanceActionSource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PluginInstanceActionSource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__plugin_instance => {
                                if !fields.insert(__FieldTag::__plugin_instance) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for plugin_instance",
                                    ));
                                }
                                result.plugin_instance = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__action_id => {
                                if !fields.insert(__FieldTag::__action_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for action_id",
                                    ));
                                }
                                result.action_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PluginInstanceActionSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.plugin_instance.is_empty() {
                state.serialize_entry("pluginInstance", &self.plugin_instance)?;
            }
            if !self.action_id.is_empty() {
                state.serialize_entry("actionId", &self.action_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PluginInstanceActionSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PluginInstanceActionSource");
            debug_struct.field("plugin_instance", &self.plugin_instance);
            debug_struct.field("action_id", &self.action_id);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The possible types of the source.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceType {
        /// Source type not specified.
        Unspecified,
        /// Source type plugin.
        Plugin,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SourceType::value] or
        /// [SourceType::name].
        UnknownValue(source_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod source_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SourceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Plugin => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SOURCE_TYPE_UNSPECIFIED"),
                Self::Plugin => std::option::Option::Some("PLUGIN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SourceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SourceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SourceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Plugin,
                _ => Self::UnknownValue(source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SourceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PLUGIN" => Self::Plugin,
                _ => Self::UnknownValue(source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SourceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Plugin => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SourceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SourceType>::new(
                ".google.cloud.apihub.v1.SourceMetadata.SourceType",
            ))
        }
    }

    /// The source of the resource.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Output only. The source of the resource is a plugin instance action.
        PluginInstanceActionSource(
            std::boxed::Box<crate::model::source_metadata::PluginInstanceActionSource>,
        ),
    }
}

/// Respresents an API Observation observed in one of the sources.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveredApiObservation {
    /// Identifier. The name of the discovered API Observation.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/discoveredApiObservations/{discovered_api_observation}`
    pub name: std::string::String,

    /// Optional. Style of ApiObservation
    pub style: crate::model::discovered_api_observation::Style,

    /// Optional. The IP address (IPv4 or IPv6) of the origin server that the
    /// request was sent to. This field can include port information. Examples:
    /// `"192.168.1.1"`, `"10.0.0.1:80"`, `"FE80::0202:B3FF:FE1E:8329"`.
    pub server_ips: std::vec::Vec<std::string::String>,

    /// Optional. The hostname of requests processed for this Observation.
    pub hostname: std::string::String,

    /// Optional. Last event detected time stamp
    pub last_event_detected_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The location of the observation source.
    pub source_locations: std::vec::Vec<std::string::String>,

    /// Optional. The number of observed API Operations.
    pub api_operation_count: i64,

    /// Optional. For an observation pushed from a gcp resource, this would be the
    /// gcp project id.
    pub origin: std::string::String,

    /// Optional. The type of the source from which the observation was collected.
    pub source_types: std::vec::Vec<crate::model::discovered_api_observation::SourceType>,

    /// Output only. The number of known API Operations.
    pub known_operations_count: i64,

    /// Output only. The number of unknown API Operations.
    pub unknown_operations_count: i64,

    /// Output only. Create time stamp of the observation in API Hub.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time stamp of the observation in API Hub.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The metadata of the source from which the observation was
    /// collected.
    pub source_metadata: std::option::Option<crate::model::SourceMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveredApiObservation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DiscoveredApiObservation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [style][crate::model::DiscoveredApiObservation::style].
    pub fn set_style<T: std::convert::Into<crate::model::discovered_api_observation::Style>>(
        mut self,
        v: T,
    ) -> Self {
        self.style = v.into();
        self
    }

    /// Sets the value of [server_ips][crate::model::DiscoveredApiObservation::server_ips].
    pub fn set_server_ips<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.server_ips = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hostname][crate::model::DiscoveredApiObservation::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [last_event_detected_time][crate::model::DiscoveredApiObservation::last_event_detected_time].
    pub fn set_last_event_detected_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_event_detected_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_event_detected_time][crate::model::DiscoveredApiObservation::last_event_detected_time].
    pub fn set_or_clear_last_event_detected_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_event_detected_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_locations][crate::model::DiscoveredApiObservation::source_locations].
    pub fn set_source_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.source_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [api_operation_count][crate::model::DiscoveredApiObservation::api_operation_count].
    pub fn set_api_operation_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.api_operation_count = v.into();
        self
    }

    /// Sets the value of [origin][crate::model::DiscoveredApiObservation::origin].
    pub fn set_origin<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.origin = v.into();
        self
    }

    /// Sets the value of [source_types][crate::model::DiscoveredApiObservation::source_types].
    pub fn set_source_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::discovered_api_observation::SourceType>,
    {
        use std::iter::Iterator;
        self.source_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [known_operations_count][crate::model::DiscoveredApiObservation::known_operations_count].
    pub fn set_known_operations_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.known_operations_count = v.into();
        self
    }

    /// Sets the value of [unknown_operations_count][crate::model::DiscoveredApiObservation::unknown_operations_count].
    pub fn set_unknown_operations_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.unknown_operations_count = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DiscoveredApiObservation::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DiscoveredApiObservation::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DiscoveredApiObservation::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DiscoveredApiObservation::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_metadata][crate::model::DiscoveredApiObservation::source_metadata].
    pub fn set_source_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceMetadata>,
    {
        self.source_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_metadata][crate::model::DiscoveredApiObservation::source_metadata].
    pub fn set_or_clear_source_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceMetadata>,
    {
        self.source_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DiscoveredApiObservation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DiscoveredApiObservation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveredApiObservation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __style,
            __server_ips,
            __hostname,
            __last_event_detected_time,
            __source_locations,
            __api_operation_count,
            __origin,
            __source_types,
            __known_operations_count,
            __unknown_operations_count,
            __create_time,
            __update_time,
            __source_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveredApiObservation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "style" => Ok(__FieldTag::__style),
                            "serverIps" => Ok(__FieldTag::__server_ips),
                            "server_ips" => Ok(__FieldTag::__server_ips),
                            "hostname" => Ok(__FieldTag::__hostname),
                            "lastEventDetectedTime" => Ok(__FieldTag::__last_event_detected_time),
                            "last_event_detected_time" => {
                                Ok(__FieldTag::__last_event_detected_time)
                            }
                            "sourceLocations" => Ok(__FieldTag::__source_locations),
                            "source_locations" => Ok(__FieldTag::__source_locations),
                            "apiOperationCount" => Ok(__FieldTag::__api_operation_count),
                            "api_operation_count" => Ok(__FieldTag::__api_operation_count),
                            "origin" => Ok(__FieldTag::__origin),
                            "sourceTypes" => Ok(__FieldTag::__source_types),
                            "source_types" => Ok(__FieldTag::__source_types),
                            "knownOperationsCount" => Ok(__FieldTag::__known_operations_count),
                            "known_operations_count" => Ok(__FieldTag::__known_operations_count),
                            "unknownOperationsCount" => Ok(__FieldTag::__unknown_operations_count),
                            "unknown_operations_count" => {
                                Ok(__FieldTag::__unknown_operations_count)
                            }
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "sourceMetadata" => Ok(__FieldTag::__source_metadata),
                            "source_metadata" => Ok(__FieldTag::__source_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveredApiObservation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveredApiObservation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__style => {
                            if !fields.insert(__FieldTag::__style) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for style",
                                ));
                            }
                            result.style = map
                                .next_value::<std::option::Option<
                                    crate::model::discovered_api_observation::Style,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__server_ips => {
                            if !fields.insert(__FieldTag::__server_ips) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server_ips",
                                ));
                            }
                            result.server_ips = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_event_detected_time => {
                            if !fields.insert(__FieldTag::__last_event_detected_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_event_detected_time",
                                ));
                            }
                            result.last_event_detected_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__source_locations => {
                            if !fields.insert(__FieldTag::__source_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_locations",
                                ));
                            }
                            result.source_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__api_operation_count => {
                            if !fields.insert(__FieldTag::__api_operation_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_operation_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.api_operation_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__origin => {
                            if !fields.insert(__FieldTag::__origin) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for origin",
                                ));
                            }
                            result.origin = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_types => {
                            if !fields.insert(__FieldTag::__source_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_types",
                                ));
                            }
                            result.source_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::discovered_api_observation::SourceType,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__known_operations_count => {
                            if !fields.insert(__FieldTag::__known_operations_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for known_operations_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.known_operations_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__unknown_operations_count => {
                            if !fields.insert(__FieldTag::__unknown_operations_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unknown_operations_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.unknown_operations_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__source_metadata => {
                            if !fields.insert(__FieldTag::__source_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_metadata",
                                ));
                            }
                            result.source_metadata = map
                                .next_value::<std::option::Option<crate::model::SourceMetadata>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveredApiObservation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.style) {
            state.serialize_entry("style", &self.style)?;
        }
        if !self.server_ips.is_empty() {
            state.serialize_entry("serverIps", &self.server_ips)?;
        }
        if !self.hostname.is_empty() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if self.last_event_detected_time.is_some() {
            state.serialize_entry("lastEventDetectedTime", &self.last_event_detected_time)?;
        }
        if !self.source_locations.is_empty() {
            state.serialize_entry("sourceLocations", &self.source_locations)?;
        }
        if !wkt::internal::is_default(&self.api_operation_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("apiOperationCount", &__With(&self.api_operation_count))?;
        }
        if !self.origin.is_empty() {
            state.serialize_entry("origin", &self.origin)?;
        }
        if !self.source_types.is_empty() {
            state.serialize_entry("sourceTypes", &self.source_types)?;
        }
        if !wkt::internal::is_default(&self.known_operations_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "knownOperationsCount",
                &__With(&self.known_operations_count),
            )?;
        }
        if !wkt::internal::is_default(&self.unknown_operations_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "unknownOperationsCount",
                &__With(&self.unknown_operations_count),
            )?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.source_metadata.is_some() {
            state.serialize_entry("sourceMetadata", &self.source_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DiscoveredApiObservation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiscoveredApiObservation");
        debug_struct.field("name", &self.name);
        debug_struct.field("style", &self.style);
        debug_struct.field("server_ips", &self.server_ips);
        debug_struct.field("hostname", &self.hostname);
        debug_struct.field("last_event_detected_time", &self.last_event_detected_time);
        debug_struct.field("source_locations", &self.source_locations);
        debug_struct.field("api_operation_count", &self.api_operation_count);
        debug_struct.field("origin", &self.origin);
        debug_struct.field("source_types", &self.source_types);
        debug_struct.field("known_operations_count", &self.known_operations_count);
        debug_struct.field("unknown_operations_count", &self.unknown_operations_count);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("source_metadata", &self.source_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DiscoveredApiObservation].
pub mod discovered_api_observation {
    #[allow(unused_imports)]
    use super::*;

    /// DiscoveredApiObservation protocol style
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Style {
        /// Unknown style
        Unspecified,
        /// Style is Rest API
        Rest,
        /// Style is Grpc API
        Grpc,
        /// Style is GraphQL API
        Graphql,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Style::value] or
        /// [Style::name].
        UnknownValue(style::UnknownValue),
    }

    #[doc(hidden)]
    pub mod style {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Style {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Rest => std::option::Option::Some(1),
                Self::Grpc => std::option::Option::Some(2),
                Self::Graphql => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STYLE_UNSPECIFIED"),
                Self::Rest => std::option::Option::Some("REST"),
                Self::Grpc => std::option::Option::Some("GRPC"),
                Self::Graphql => std::option::Option::Some("GRAPHQL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Style {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Style {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Style {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Rest,
                2 => Self::Grpc,
                3 => Self::Graphql,
                _ => Self::UnknownValue(style::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Style {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STYLE_UNSPECIFIED" => Self::Unspecified,
                "REST" => Self::Rest,
                "GRPC" => Self::Grpc,
                "GRAPHQL" => Self::Graphql,
                _ => Self::UnknownValue(style::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Style {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Rest => serializer.serialize_i32(1),
                Self::Grpc => serializer.serialize_i32(2),
                Self::Graphql => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Style {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Style>::new(
                ".google.cloud.apihub.v1.DiscoveredApiObservation.Style",
            ))
        }
    }

    /// The possible types of the source from which the observation was collected.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceType {
        /// Source type not specified.
        Unspecified,
        /// GCP external load balancer.
        GcpXlb,
        /// GCP internal load balancer.
        GcpIlb,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SourceType::value] or
        /// [SourceType::name].
        UnknownValue(source_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod source_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SourceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GcpXlb => std::option::Option::Some(1),
                Self::GcpIlb => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SOURCE_TYPE_UNSPECIFIED"),
                Self::GcpXlb => std::option::Option::Some("GCP_XLB"),
                Self::GcpIlb => std::option::Option::Some("GCP_ILB"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SourceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SourceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SourceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GcpXlb,
                2 => Self::GcpIlb,
                _ => Self::UnknownValue(source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SourceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "GCP_XLB" => Self::GcpXlb,
                "GCP_ILB" => Self::GcpIlb,
                _ => Self::UnknownValue(source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SourceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GcpXlb => serializer.serialize_i32(1),
                Self::GcpIlb => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SourceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SourceType>::new(
                ".google.cloud.apihub.v1.DiscoveredApiObservation.SourceType",
            ))
        }
    }
}

/// DiscoveredApiOperation represents an API Operation observed in one of the
/// sources.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveredApiOperation {
    /// Identifier. The name of the discovered API Operation.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/discoveredApiObservations/{discovered_api_observation}/discoveredApiOperations/{discovered_api_operation}`
    pub name: std::string::String,

    /// Optional. First seen time stamp
    pub first_seen_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Last seen time stamp
    pub last_seen_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The number of occurrences of this API Operation.
    pub count: i64,

    /// Output only. The classification of the discovered API operation.
    pub classification: crate::model::discovered_api_operation::Classification,

    /// Output only. The list of matched results for the discovered API operation.
    /// This will be populated only if the classification is known. The current
    /// usecase is for a single match. Keeping it repeated to support multiple
    /// matches in future.
    pub match_results: std::vec::Vec<crate::model::discovered_api_operation::MatchResult>,

    /// Output only. The metadata of the source from which the api operation was
    /// collected.
    pub source_metadata: std::option::Option<crate::model::SourceMetadata>,

    /// Output only. Create time stamp of the discovered API operation in API Hub.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time stamp of the discovered API operation in API Hub.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// ApiOperation protocol style
    pub operation: std::option::Option<crate::model::discovered_api_operation::Operation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveredApiOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DiscoveredApiOperation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [first_seen_time][crate::model::DiscoveredApiOperation::first_seen_time].
    pub fn set_first_seen_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.first_seen_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [first_seen_time][crate::model::DiscoveredApiOperation::first_seen_time].
    pub fn set_or_clear_first_seen_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.first_seen_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_seen_time][crate::model::DiscoveredApiOperation::last_seen_time].
    pub fn set_last_seen_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_seen_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_seen_time][crate::model::DiscoveredApiOperation::last_seen_time].
    pub fn set_or_clear_last_seen_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_seen_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [count][crate::model::DiscoveredApiOperation::count].
    pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.count = v.into();
        self
    }

    /// Sets the value of [classification][crate::model::DiscoveredApiOperation::classification].
    pub fn set_classification<
        T: std::convert::Into<crate::model::discovered_api_operation::Classification>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.classification = v.into();
        self
    }

    /// Sets the value of [match_results][crate::model::DiscoveredApiOperation::match_results].
    pub fn set_match_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::discovered_api_operation::MatchResult>,
    {
        use std::iter::Iterator;
        self.match_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source_metadata][crate::model::DiscoveredApiOperation::source_metadata].
    pub fn set_source_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceMetadata>,
    {
        self.source_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_metadata][crate::model::DiscoveredApiOperation::source_metadata].
    pub fn set_or_clear_source_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceMetadata>,
    {
        self.source_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::DiscoveredApiOperation::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DiscoveredApiOperation::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DiscoveredApiOperation::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DiscoveredApiOperation::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operation][crate::model::DiscoveredApiOperation::operation].
    ///
    /// Note that all the setters affecting `operation` are mutually
    /// exclusive.
    pub fn set_operation<
        T: std::convert::Into<std::option::Option<crate::model::discovered_api_operation::Operation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation = v.into();
        self
    }

    /// The value of [operation][crate::model::DiscoveredApiOperation::operation]
    /// if it holds a `HttpOperation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn http_operation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::HttpOperationDetails>> {
        #[allow(unreachable_patterns)]
        self.operation.as_ref().and_then(|v| match v {
            crate::model::discovered_api_operation::Operation::HttpOperation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [operation][crate::model::DiscoveredApiOperation::operation]
    /// to hold a `HttpOperation`.
    ///
    /// Note that all the setters affecting `operation` are
    /// mutually exclusive.
    pub fn set_http_operation<
        T: std::convert::Into<std::boxed::Box<crate::model::HttpOperationDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation = std::option::Option::Some(
            crate::model::discovered_api_operation::Operation::HttpOperation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveredApiOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DiscoveredApiOperation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveredApiOperation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __http_operation,
            __name,
            __first_seen_time,
            __last_seen_time,
            __count,
            __classification,
            __match_results,
            __source_metadata,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveredApiOperation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "httpOperation" => Ok(__FieldTag::__http_operation),
                            "http_operation" => Ok(__FieldTag::__http_operation),
                            "name" => Ok(__FieldTag::__name),
                            "firstSeenTime" => Ok(__FieldTag::__first_seen_time),
                            "first_seen_time" => Ok(__FieldTag::__first_seen_time),
                            "lastSeenTime" => Ok(__FieldTag::__last_seen_time),
                            "last_seen_time" => Ok(__FieldTag::__last_seen_time),
                            "count" => Ok(__FieldTag::__count),
                            "classification" => Ok(__FieldTag::__classification),
                            "matchResults" => Ok(__FieldTag::__match_results),
                            "match_results" => Ok(__FieldTag::__match_results),
                            "sourceMetadata" => Ok(__FieldTag::__source_metadata),
                            "source_metadata" => Ok(__FieldTag::__source_metadata),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveredApiOperation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveredApiOperation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__http_operation => {
                            if !fields.insert(__FieldTag::__http_operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_operation",
                                ));
                            }
                            if result.operation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `operation`, a oneof with full ID .google.cloud.apihub.v1.DiscoveredApiOperation.http_operation, latest field was httpOperation",
                                ));
                            }
                            result.operation = std::option::Option::Some(
                                crate::model::discovered_api_operation::Operation::HttpOperation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::HttpOperationDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__first_seen_time => {
                            if !fields.insert(__FieldTag::__first_seen_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for first_seen_time",
                                ));
                            }
                            result.first_seen_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_seen_time => {
                            if !fields.insert(__FieldTag::__last_seen_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_seen_time",
                                ));
                            }
                            result.last_seen_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__count => {
                            if !fields.insert(__FieldTag::__count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__classification => {
                            if !fields.insert(__FieldTag::__classification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for classification",
                                ));
                            }
                            result.classification = map
                                .next_value::<std::option::Option<
                                    crate::model::discovered_api_operation::Classification,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__match_results => {
                            if !fields.insert(__FieldTag::__match_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for match_results",
                                ));
                            }
                            result.match_results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::discovered_api_operation::MatchResult,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_metadata => {
                            if !fields.insert(__FieldTag::__source_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_metadata",
                                ));
                            }
                            result.source_metadata = map
                                .next_value::<std::option::Option<crate::model::SourceMetadata>>(
                                )?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveredApiOperation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.http_operation() {
            state.serialize_entry("httpOperation", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.first_seen_time.is_some() {
            state.serialize_entry("firstSeenTime", &self.first_seen_time)?;
        }
        if self.last_seen_time.is_some() {
            state.serialize_entry("lastSeenTime", &self.last_seen_time)?;
        }
        if !wkt::internal::is_default(&self.count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("count", &__With(&self.count))?;
        }
        if !wkt::internal::is_default(&self.classification) {
            state.serialize_entry("classification", &self.classification)?;
        }
        if !self.match_results.is_empty() {
            state.serialize_entry("matchResults", &self.match_results)?;
        }
        if self.source_metadata.is_some() {
            state.serialize_entry("sourceMetadata", &self.source_metadata)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DiscoveredApiOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiscoveredApiOperation");
        debug_struct.field("name", &self.name);
        debug_struct.field("first_seen_time", &self.first_seen_time);
        debug_struct.field("last_seen_time", &self.last_seen_time);
        debug_struct.field("count", &self.count);
        debug_struct.field("classification", &self.classification);
        debug_struct.field("match_results", &self.match_results);
        debug_struct.field("source_metadata", &self.source_metadata);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("operation", &self.operation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DiscoveredApiOperation].
pub mod discovered_api_operation {
    #[allow(unused_imports)]
    use super::*;

    /// MatchResult represents the result of matching a discovered API operation
    /// with a catalog API operation.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MatchResult {
        /// Output only. The name of the matched API Operation.
        ///
        /// Format:
        /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/operations/{operation}`
        pub name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MatchResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::discovered_api_operation::MatchResult::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }
    }

    impl wkt::message::Message for MatchResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.DiscoveredApiOperation.MatchResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MatchResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MatchResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MatchResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MatchResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MatchResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for MatchResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("MatchResult");
            debug_struct.field("name", &self.name);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The classification of the discovered API operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Classification {
        /// Operation is not classified as known or unknown.
        Unspecified,
        /// Operation has a matched catalog operation.
        Known,
        /// Operation does not have a matched catalog operation.
        Unknown,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Classification::value] or
        /// [Classification::name].
        UnknownValue(classification::UnknownValue),
    }

    #[doc(hidden)]
    pub mod classification {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Classification {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Known => std::option::Option::Some(1),
                Self::Unknown => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CLASSIFICATION_UNSPECIFIED"),
                Self::Known => std::option::Option::Some("KNOWN"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Classification {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Classification {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Classification {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Known,
                2 => Self::Unknown,
                _ => Self::UnknownValue(classification::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Classification {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLASSIFICATION_UNSPECIFIED" => Self::Unspecified,
                "KNOWN" => Self::Known,
                "UNKNOWN" => Self::Unknown,
                _ => Self::UnknownValue(classification::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Classification {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Known => serializer.serialize_i32(1),
                Self::Unknown => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Classification {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Classification>::new(
                ".google.cloud.apihub.v1.DiscoveredApiOperation.Classification",
            ))
        }
    }

    /// ApiOperation protocol style
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Operation {
        /// Optional. An HTTP Operation.
        HttpOperation(std::boxed::Box<crate::model::HttpOperationDetails>),
    }
}

/// An HTTP-based API Operation, sometimes called a "REST" Operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HttpOperationDetails {
    /// Required. An HTTP Operation.
    pub http_operation: std::option::Option<crate::model::HttpOperation>,

    /// Optional. Path params of HttpOperation
    pub path_params: std::vec::Vec<crate::model::http_operation_details::PathParam>,

    /// Optional. Query params of HttpOperation
    pub query_params: std::collections::HashMap<
        std::string::String,
        crate::model::http_operation_details::QueryParam,
    >,

    /// Optional. Request metadata.
    pub request: std::option::Option<crate::model::http_operation_details::HttpRequest>,

    /// Optional. Response metadata.
    pub response: std::option::Option<crate::model::http_operation_details::HttpResponse>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HttpOperationDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [http_operation][crate::model::HttpOperationDetails::http_operation].
    pub fn set_http_operation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HttpOperation>,
    {
        self.http_operation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [http_operation][crate::model::HttpOperationDetails::http_operation].
    pub fn set_or_clear_http_operation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HttpOperation>,
    {
        self.http_operation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [path_params][crate::model::HttpOperationDetails::path_params].
    pub fn set_path_params<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::http_operation_details::PathParam>,
    {
        use std::iter::Iterator;
        self.path_params = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [query_params][crate::model::HttpOperationDetails::query_params].
    pub fn set_query_params<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::http_operation_details::QueryParam>,
    {
        use std::iter::Iterator;
        self.query_params = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [request][crate::model::HttpOperationDetails::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::http_operation_details::HttpRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::HttpOperationDetails::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::http_operation_details::HttpRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [response][crate::model::HttpOperationDetails::response].
    pub fn set_response<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::http_operation_details::HttpResponse>,
    {
        self.response = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [response][crate::model::HttpOperationDetails::response].
    pub fn set_or_clear_response<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::http_operation_details::HttpResponse>,
    {
        self.response = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for HttpOperationDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.HttpOperationDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HttpOperationDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __http_operation,
            __path_params,
            __query_params,
            __request,
            __response,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HttpOperationDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "httpOperation" => Ok(__FieldTag::__http_operation),
                            "http_operation" => Ok(__FieldTag::__http_operation),
                            "pathParams" => Ok(__FieldTag::__path_params),
                            "path_params" => Ok(__FieldTag::__path_params),
                            "queryParams" => Ok(__FieldTag::__query_params),
                            "query_params" => Ok(__FieldTag::__query_params),
                            "request" => Ok(__FieldTag::__request),
                            "response" => Ok(__FieldTag::__response),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HttpOperationDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HttpOperationDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__http_operation => {
                            if !fields.insert(__FieldTag::__http_operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_operation",
                                ));
                            }
                            result.http_operation = map
                                .next_value::<std::option::Option<crate::model::HttpOperation>>()?;
                        }
                        __FieldTag::__path_params => {
                            if !fields.insert(__FieldTag::__path_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path_params",
                                ));
                            }
                            result.path_params = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::http_operation_details::PathParam>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_params => {
                            if !fields.insert(__FieldTag::__query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_params",
                                ));
                            }
                            result.query_params = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::http_operation_details::QueryParam,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<
                                crate::model::http_operation_details::HttpRequest,
                            >>()?;
                        }
                        __FieldTag::__response => {
                            if !fields.insert(__FieldTag::__response) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response",
                                ));
                            }
                            result.response = map.next_value::<std::option::Option<
                                crate::model::http_operation_details::HttpResponse,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HttpOperationDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.http_operation.is_some() {
            state.serialize_entry("httpOperation", &self.http_operation)?;
        }
        if !self.path_params.is_empty() {
            state.serialize_entry("pathParams", &self.path_params)?;
        }
        if !self.query_params.is_empty() {
            state.serialize_entry("queryParams", &self.query_params)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if self.response.is_some() {
            state.serialize_entry("response", &self.response)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HttpOperationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HttpOperationDetails");
        debug_struct.field("http_operation", &self.http_operation);
        debug_struct.field("path_params", &self.path_params);
        debug_struct.field("query_params", &self.query_params);
        debug_struct.field("request", &self.request);
        debug_struct.field("response", &self.response);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [HttpOperationDetails].
pub mod http_operation_details {
    #[allow(unused_imports)]
    use super::*;

    /// HTTP Path parameter.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PathParam {
        /// Optional. Segment location in the path, 1-indexed
        pub position: i32,

        /// Optional. Data type of path param
        pub data_type: crate::model::http_operation_details::DataType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PathParam {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [position][crate::model::http_operation_details::PathParam::position].
        pub fn set_position<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.position = v.into();
            self
        }

        /// Sets the value of [data_type][crate::model::http_operation_details::PathParam::data_type].
        pub fn set_data_type<
            T: std::convert::Into<crate::model::http_operation_details::DataType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.data_type = v.into();
            self
        }
    }

    impl wkt::message::Message for PathParam {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.HttpOperationDetails.PathParam"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PathParam {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __position,
                __data_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PathParam")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "position" => Ok(__FieldTag::__position),
                                "dataType" => Ok(__FieldTag::__data_type),
                                "data_type" => Ok(__FieldTag::__data_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PathParam;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PathParam")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__position => {
                                if !fields.insert(__FieldTag::__position) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for position",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.position = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__data_type => {
                                if !fields.insert(__FieldTag::__data_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for data_type",
                                    ));
                                }
                                result.data_type = map
                                    .next_value::<std::option::Option<
                                        crate::model::http_operation_details::DataType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PathParam {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.position) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("position", &__With(&self.position))?;
            }
            if !wkt::internal::is_default(&self.data_type) {
                state.serialize_entry("dataType", &self.data_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PathParam {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PathParam");
            debug_struct.field("position", &self.position);
            debug_struct.field("data_type", &self.data_type);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// An aggregation of HTTP query parameter occurrences.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QueryParam {
        /// Required. Name of query param
        pub name: std::string::String,

        /// Optional. The number of occurrences of this query parameter across
        /// transactions.
        pub count: i64,

        /// Optional. Data type of path param
        pub data_type: crate::model::http_operation_details::DataType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QueryParam {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::http_operation_details::QueryParam::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [count][crate::model::http_operation_details::QueryParam::count].
        pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.count = v.into();
            self
        }

        /// Sets the value of [data_type][crate::model::http_operation_details::QueryParam::data_type].
        pub fn set_data_type<
            T: std::convert::Into<crate::model::http_operation_details::DataType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.data_type = v.into();
            self
        }
    }

    impl wkt::message::Message for QueryParam {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.HttpOperationDetails.QueryParam"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QueryParam {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __count,
                __data_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for QueryParam")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "count" => Ok(__FieldTag::__count),
                                "dataType" => Ok(__FieldTag::__data_type),
                                "data_type" => Ok(__FieldTag::__data_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QueryParam;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QueryParam")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__count => {
                                if !fields.insert(__FieldTag::__count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.count = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__data_type => {
                                if !fields.insert(__FieldTag::__data_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for data_type",
                                    ));
                                }
                                result.data_type = map
                                    .next_value::<std::option::Option<
                                        crate::model::http_operation_details::DataType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QueryParam {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !wkt::internal::is_default(&self.count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("count", &__With(&self.count))?;
            }
            if !wkt::internal::is_default(&self.data_type) {
                state.serialize_entry("dataType", &self.data_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for QueryParam {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("QueryParam");
            debug_struct.field("name", &self.name);
            debug_struct.field("count", &self.count);
            debug_struct.field("data_type", &self.data_type);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// An aggregation of HTTP header occurrences.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Header {
        /// Header name.
        pub name: std::string::String,

        /// The number of occurrences of this Header across transactions.
        pub count: i64,

        /// Data type of header
        pub data_type: crate::model::http_operation_details::DataType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Header {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::http_operation_details::Header::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [count][crate::model::http_operation_details::Header::count].
        pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.count = v.into();
            self
        }

        /// Sets the value of [data_type][crate::model::http_operation_details::Header::data_type].
        pub fn set_data_type<
            T: std::convert::Into<crate::model::http_operation_details::DataType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.data_type = v.into();
            self
        }
    }

    impl wkt::message::Message for Header {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.HttpOperationDetails.Header"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Header {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __count,
                __data_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Header")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "count" => Ok(__FieldTag::__count),
                                "dataType" => Ok(__FieldTag::__data_type),
                                "data_type" => Ok(__FieldTag::__data_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Header;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Header")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__count => {
                                if !fields.insert(__FieldTag::__count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.count = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__data_type => {
                                if !fields.insert(__FieldTag::__data_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for data_type",
                                    ));
                                }
                                result.data_type = map
                                    .next_value::<std::option::Option<
                                        crate::model::http_operation_details::DataType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Header {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !wkt::internal::is_default(&self.count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("count", &__With(&self.count))?;
            }
            if !wkt::internal::is_default(&self.data_type) {
                state.serialize_entry("dataType", &self.data_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Header {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Header");
            debug_struct.field("name", &self.name);
            debug_struct.field("count", &self.count);
            debug_struct.field("data_type", &self.data_type);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// An aggregation of HTTP requests.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct HttpRequest {
        /// Optional. Unordered map from header name to header metadata
        pub headers: std::collections::HashMap<
            std::string::String,
            crate::model::http_operation_details::Header,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl HttpRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [headers][crate::model::http_operation_details::HttpRequest::headers].
        pub fn set_headers<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::http_operation_details::Header>,
        {
            use std::iter::Iterator;
            self.headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for HttpRequest {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.HttpOperationDetails.HttpRequest"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for HttpRequest {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __headers,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for HttpRequest")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "headers" => Ok(__FieldTag::__headers),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = HttpRequest;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct HttpRequest")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__headers => {
                                if !fields.insert(__FieldTag::__headers) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for headers",
                                    ));
                                }
                                result.headers = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            crate::model::http_operation_details::Header,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for HttpRequest {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.headers.is_empty() {
                state.serialize_entry("headers", &self.headers)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for HttpRequest {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("HttpRequest");
            debug_struct.field("headers", &self.headers);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// An aggregation of HTTP responses.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct HttpResponse {
        /// Optional. Unordered map from header name to header metadata
        pub headers: std::collections::HashMap<
            std::string::String,
            crate::model::http_operation_details::Header,
        >,

        /// Optional. Map of status code to observed count
        pub response_codes: std::collections::HashMap<i32, i64>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl HttpResponse {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [headers][crate::model::http_operation_details::HttpResponse::headers].
        pub fn set_headers<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::http_operation_details::Header>,
        {
            use std::iter::Iterator;
            self.headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [response_codes][crate::model::http_operation_details::HttpResponse::response_codes].
        pub fn set_response_codes<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<i32>,
            V: std::convert::Into<i64>,
        {
            use std::iter::Iterator;
            self.response_codes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for HttpResponse {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.HttpOperationDetails.HttpResponse"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for HttpResponse {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __headers,
                __response_codes,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for HttpResponse")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "headers" => Ok(__FieldTag::__headers),
                                "responseCodes" => Ok(__FieldTag::__response_codes),
                                "response_codes" => Ok(__FieldTag::__response_codes),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = HttpResponse;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct HttpResponse")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__headers => {
                                if !fields.insert(__FieldTag::__headers) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for headers",
                                    ));
                                }
                                result.headers = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            crate::model::http_operation_details::Header,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__response_codes => {
                                if !fields.insert(__FieldTag::__response_codes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for response_codes",
                                    ));
                                }
                                struct __With(
                                    std::option::Option<std::collections::HashMap<i32, i64>>,
                                );
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<
                                                std::collections::HashMap<
                                                    wkt::internal::I32,
                                                    wkt::internal::I64,
                                                >,
                                            >,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.response_codes =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for HttpResponse {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.headers.is_empty() {
                state.serialize_entry("headers", &self.headers)?;
            }
            if !self.response_codes.is_empty() {
                struct __With<'a>(&'a std::collections::HashMap<i32, i64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<
                            std::collections::HashMap<wkt::internal::I32, wkt::internal::I64>,
                        >::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("responseCodes", &__With(&self.response_codes))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for HttpResponse {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("HttpResponse");
            debug_struct.field("headers", &self.headers);
            debug_struct.field("response_codes", &self.response_codes);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Type of data
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataType {
        /// Unspecified data type
        Unspecified,
        /// Boolean data type
        Bool,
        /// Integer data type
        Integer,
        /// Float data type
        Float,
        /// String data type
        String,
        /// UUID data type
        Uuid,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataType::value] or
        /// [DataType::name].
        UnknownValue(data_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod data_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Bool => std::option::Option::Some(1),
                Self::Integer => std::option::Option::Some(2),
                Self::Float => std::option::Option::Some(3),
                Self::String => std::option::Option::Some(4),
                Self::Uuid => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_TYPE_UNSPECIFIED"),
                Self::Bool => std::option::Option::Some("BOOL"),
                Self::Integer => std::option::Option::Some("INTEGER"),
                Self::Float => std::option::Option::Some("FLOAT"),
                Self::String => std::option::Option::Some("STRING"),
                Self::Uuid => std::option::Option::Some("UUID"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Bool,
                2 => Self::Integer,
                3 => Self::Float,
                4 => Self::String,
                5 => Self::Uuid,
                _ => Self::UnknownValue(data_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DataType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BOOL" => Self::Bool,
                "INTEGER" => Self::Integer,
                "FLOAT" => Self::Float,
                "STRING" => Self::String,
                "UUID" => Self::Uuid,
                _ => Self::UnknownValue(data_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DataType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Bool => serializer.serialize_i32(1),
                Self::Integer => serializer.serialize_i32(2),
                Self::Float => serializer.serialize_i32(3),
                Self::String => serializer.serialize_i32(4),
                Self::Uuid => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataType>::new(
                ".google.cloud.apihub.v1.HttpOperationDetails.DataType",
            ))
        }
    }
}

/// The [CreateCuration][ApiHub.CreateCuration] method's request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCurationRequest {
    /// Required. The parent resource for the curation resource.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Optional. The ID to use for the curation resource, which will become the
    /// final component of the curations's resource name. This field is optional.
    ///
    /// * If provided, the same will be used. The service will throw an error if
    ///   the specified ID is already used by another curation resource in the API
    ///   hub.
    /// * If not provided, a system generated ID will be used.
    ///
    /// This value should be 4-500 characters, and valid characters
    /// are /[a-z][A-Z][0-9]-_/.
    pub curation_id: std::string::String,

    /// Required. The curation resource to create.
    pub curation: std::option::Option<crate::model::Curation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCurationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCurationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [curation_id][crate::model::CreateCurationRequest::curation_id].
    pub fn set_curation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.curation_id = v.into();
        self
    }

    /// Sets the value of [curation][crate::model::CreateCurationRequest::curation].
    pub fn set_curation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Curation>,
    {
        self.curation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [curation][crate::model::CreateCurationRequest::curation].
    pub fn set_or_clear_curation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Curation>,
    {
        self.curation = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateCurationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.CreateCurationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCurationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __curation_id,
            __curation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCurationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "curationId" => Ok(__FieldTag::__curation_id),
                            "curation_id" => Ok(__FieldTag::__curation_id),
                            "curation" => Ok(__FieldTag::__curation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCurationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCurationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__curation_id => {
                            if !fields.insert(__FieldTag::__curation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for curation_id",
                                ));
                            }
                            result.curation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__curation => {
                            if !fields.insert(__FieldTag::__curation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for curation",
                                ));
                            }
                            result.curation =
                                map.next_value::<std::option::Option<crate::model::Curation>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCurationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.curation_id.is_empty() {
            state.serialize_entry("curationId", &self.curation_id)?;
        }
        if self.curation.is_some() {
            state.serialize_entry("curation", &self.curation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateCurationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateCurationRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("curation_id", &self.curation_id);
        debug_struct.field("curation", &self.curation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [GetCuration][ApiHub.GetCuration] method's request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCurationRequest {
    /// Required. The name of the curation resource to retrieve.
    /// Format: `projects/{project}/locations/{location}/curations/{curation}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCurationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCurationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCurationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetCurationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCurationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCurationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCurationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCurationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCurationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetCurationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetCurationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [UpdateCuration][ApiHub.UpdateCuration] method's request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCurationRequest {
    /// Required. The curation resource to update.
    ///
    /// The curation resource's `name` field is used to identify the curation
    /// resource to update.
    /// Format: `projects/{project}/locations/{location}/curations/{curation}`
    pub curation: std::option::Option<crate::model::Curation>,

    /// Optional. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCurationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [curation][crate::model::UpdateCurationRequest::curation].
    pub fn set_curation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Curation>,
    {
        self.curation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [curation][crate::model::UpdateCurationRequest::curation].
    pub fn set_or_clear_curation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Curation>,
    {
        self.curation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCurationRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCurationRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateCurationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.UpdateCurationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCurationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __curation,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCurationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "curation" => Ok(__FieldTag::__curation),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCurationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCurationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__curation => {
                            if !fields.insert(__FieldTag::__curation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for curation",
                                ));
                            }
                            result.curation =
                                map.next_value::<std::option::Option<crate::model::Curation>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCurationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.curation.is_some() {
            state.serialize_entry("curation", &self.curation)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateCurationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateCurationRequest");
        debug_struct.field("curation", &self.curation);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [DeleteCuration][ApiHub.DeleteCuration] method's request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteCurationRequest {
    /// Required. The name of the curation resource to delete.
    /// Format: `projects/{project}/locations/{location}/curations/{curation}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCurationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCurationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCurationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DeleteCurationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteCurationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteCurationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteCurationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCurationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteCurationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteCurationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteCurationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [ListCurations][ApiHub.ListCurations] method's request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCurationsRequest {
    /// Required. The parent, which owns this collection of curation resources.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Optional. An expression that filters the list of curation resources.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string. The
    /// comparison operator must be one of: `<`, `>`, `:` or `=`. Filters are case
    /// insensitive.
    ///
    /// The following fields in the `curation resource` are eligible for filtering:
    ///
    /// * `create_time` - The time at which the curation was created.
    ///   The value should be in the (RFC3339)[<https://tools.ietf.org/html/rfc3339>]
    ///   format. Allowed comparison operators: `>` and `<`.
    /// * `display_name` - The display name of the curation. Allowed
    ///   comparison operators: `=`.
    /// * `state` - The state of the curation. Allowed comparison operators: `=`.
    ///
    /// Expressions are combined with either `AND` logic operator or `OR` logical
    /// operator but not both of them together i.e. only one of the `AND` or `OR`
    /// operator can be used throughout the filter string and both the operators
    /// cannot be used together. No other logical operators are supported. At most
    /// three filter fields are allowed in the filter string and if provided
    /// more than that then `INVALID_ARGUMENT` error is returned by the API.
    ///
    /// Here are a few examples:
    ///
    /// * `create_time < \"2021-08-15T14:50:00Z\" AND create_time >
    ///   \"2021-08-10T12:00:00Z\"` -
    ///   The curation resource was created before _2021-08-15 14:50:00 UTC_ and
    ///   after _2021-08-10 12:00:00 UTC_.
    pub filter: std::string::String,

    /// Optional. The maximum number of curation resources to return. The service
    /// may return fewer than this value. If unspecified, at most 50 curations will
    /// be returned. The maximum value is 1000; values above 1000 will be coerced
    /// to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListCurations` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters (except page_size) provided to
    /// `ListCurations` must match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCurationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCurationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCurationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCurationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCurationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCurationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListCurationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCurationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCurationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCurationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCurationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCurationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCurationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCurationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [ListCurations][ApiHub.ListCurations] method's response.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCurationsResponse {
    /// The curation resources present in the API hub.
    pub curations: std::vec::Vec<crate::model::Curation>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCurationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [curations][crate::model::ListCurationsResponse::curations].
    pub fn set_curations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Curation>,
    {
        use std::iter::Iterator;
        self.curations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCurationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCurationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListCurationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCurationsResponse {
    type PageItem = crate::model::Curation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.curations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCurationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __curations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCurationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "curations" => Ok(__FieldTag::__curations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCurationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCurationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__curations => {
                            if !fields.insert(__FieldTag::__curations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for curations",
                                ));
                            }
                            result.curations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Curation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCurationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.curations.is_empty() {
            state.serialize_entry("curations", &self.curations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCurationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCurationsResponse");
        debug_struct.field("curations", &self.curations);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A curation resource in the API Hub.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Curation {
    /// Identifier. The name of the curation.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/curations/{curation}`
    pub name: std::string::String,

    /// Required. The display name of the curation.
    pub display_name: std::string::String,

    /// Optional. The description of the curation.
    pub description: std::string::String,

    /// Required. The endpoint to be triggered for curation.
    pub endpoint: std::option::Option<crate::model::Endpoint>,

    /// Output only. The plugin instances and associated actions that are using the
    /// curation. Note: A particular curation could be used by multiple plugin
    /// instances or multiple actions in a plugin instance.
    pub plugin_instance_actions: std::vec::Vec<crate::model::curation::PluginInstanceActionID>,

    /// Output only. The last execution state of the curation.
    pub last_execution_state: crate::model::curation::LastExecutionState,

    /// Output only. The error code of the last execution of the curation. The
    /// error code is populated only when the last execution state is failed.
    pub last_execution_error_code: crate::model::curation::ErrorCode,

    /// Output only. Error message describing the failure, if any, during the last
    /// execution of the curation.
    pub last_execution_error_message: std::string::String,

    /// Output only. The time at which the curation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the curation was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Curation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Curation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Curation::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Curation::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::Curation::endpoint].
    pub fn set_endpoint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Endpoint>,
    {
        self.endpoint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [endpoint][crate::model::Curation::endpoint].
    pub fn set_or_clear_endpoint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Endpoint>,
    {
        self.endpoint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [plugin_instance_actions][crate::model::Curation::plugin_instance_actions].
    pub fn set_plugin_instance_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::curation::PluginInstanceActionID>,
    {
        use std::iter::Iterator;
        self.plugin_instance_actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [last_execution_state][crate::model::Curation::last_execution_state].
    pub fn set_last_execution_state<
        T: std::convert::Into<crate::model::curation::LastExecutionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.last_execution_state = v.into();
        self
    }

    /// Sets the value of [last_execution_error_code][crate::model::Curation::last_execution_error_code].
    pub fn set_last_execution_error_code<
        T: std::convert::Into<crate::model::curation::ErrorCode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.last_execution_error_code = v.into();
        self
    }

    /// Sets the value of [last_execution_error_message][crate::model::Curation::last_execution_error_message].
    pub fn set_last_execution_error_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_execution_error_message = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Curation::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Curation::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Curation::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Curation::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Curation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.Curation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Curation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __endpoint,
            __plugin_instance_actions,
            __last_execution_state,
            __last_execution_error_code,
            __last_execution_error_message,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Curation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            "pluginInstanceActions" => Ok(__FieldTag::__plugin_instance_actions),
                            "plugin_instance_actions" => Ok(__FieldTag::__plugin_instance_actions),
                            "lastExecutionState" => Ok(__FieldTag::__last_execution_state),
                            "last_execution_state" => Ok(__FieldTag::__last_execution_state),
                            "lastExecutionErrorCode" => Ok(__FieldTag::__last_execution_error_code),
                            "last_execution_error_code" => {
                                Ok(__FieldTag::__last_execution_error_code)
                            }
                            "lastExecutionErrorMessage" => {
                                Ok(__FieldTag::__last_execution_error_message)
                            }
                            "last_execution_error_message" => {
                                Ok(__FieldTag::__last_execution_error_message)
                            }
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Curation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Curation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint",
                                ));
                            }
                            result.endpoint =
                                map.next_value::<std::option::Option<crate::model::Endpoint>>()?;
                        }
                        __FieldTag::__plugin_instance_actions => {
                            if !fields.insert(__FieldTag::__plugin_instance_actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plugin_instance_actions",
                                ));
                            }
                            result.plugin_instance_actions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::curation::PluginInstanceActionID>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_execution_state => {
                            if !fields.insert(__FieldTag::__last_execution_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_execution_state",
                                ));
                            }
                            result.last_execution_state = map.next_value::<std::option::Option<crate::model::curation::LastExecutionState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__last_execution_error_code => {
                            if !fields.insert(__FieldTag::__last_execution_error_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_execution_error_code",
                                ));
                            }
                            result.last_execution_error_code = map.next_value::<std::option::Option<crate::model::curation::ErrorCode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__last_execution_error_message => {
                            if !fields.insert(__FieldTag::__last_execution_error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_execution_error_message",
                                ));
                            }
                            result.last_execution_error_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Curation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.endpoint.is_some() {
            state.serialize_entry("endpoint", &self.endpoint)?;
        }
        if !self.plugin_instance_actions.is_empty() {
            state.serialize_entry("pluginInstanceActions", &self.plugin_instance_actions)?;
        }
        if !wkt::internal::is_default(&self.last_execution_state) {
            state.serialize_entry("lastExecutionState", &self.last_execution_state)?;
        }
        if !wkt::internal::is_default(&self.last_execution_error_code) {
            state.serialize_entry("lastExecutionErrorCode", &self.last_execution_error_code)?;
        }
        if !self.last_execution_error_message.is_empty() {
            state.serialize_entry(
                "lastExecutionErrorMessage",
                &self.last_execution_error_message,
            )?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Curation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Curation");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("endpoint", &self.endpoint);
        debug_struct.field("plugin_instance_actions", &self.plugin_instance_actions);
        debug_struct.field("last_execution_state", &self.last_execution_state);
        debug_struct.field("last_execution_error_code", &self.last_execution_error_code);
        debug_struct.field(
            "last_execution_error_message",
            &self.last_execution_error_message,
        );
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Curation].
pub mod curation {
    #[allow(unused_imports)]
    use super::*;

    /// The plugin instance and associated action that is using the curation.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PluginInstanceActionID {
        /// Output only. Plugin instance that is using the curation.
        /// Format is
        /// `projects/{project}/locations/{location}/plugins/{plugin}/instances/{instance}`
        pub plugin_instance: std::string::String,

        /// Output only. The action ID that is using the curation.
        /// This should map to one of the action IDs specified
        /// in action configs in the plugin.
        pub action_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PluginInstanceActionID {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [plugin_instance][crate::model::curation::PluginInstanceActionID::plugin_instance].
        pub fn set_plugin_instance<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.plugin_instance = v.into();
            self
        }

        /// Sets the value of [action_id][crate::model::curation::PluginInstanceActionID::action_id].
        pub fn set_action_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.action_id = v.into();
            self
        }
    }

    impl wkt::message::Message for PluginInstanceActionID {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.Curation.PluginInstanceActionID"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PluginInstanceActionID {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __plugin_instance,
                __action_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PluginInstanceActionID")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "pluginInstance" => Ok(__FieldTag::__plugin_instance),
                                "plugin_instance" => Ok(__FieldTag::__plugin_instance),
                                "actionId" => Ok(__FieldTag::__action_id),
                                "action_id" => Ok(__FieldTag::__action_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PluginInstanceActionID;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PluginInstanceActionID")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__plugin_instance => {
                                if !fields.insert(__FieldTag::__plugin_instance) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for plugin_instance",
                                    ));
                                }
                                result.plugin_instance = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__action_id => {
                                if !fields.insert(__FieldTag::__action_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for action_id",
                                    ));
                                }
                                result.action_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PluginInstanceActionID {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.plugin_instance.is_empty() {
                state.serialize_entry("pluginInstance", &self.plugin_instance)?;
            }
            if !self.action_id.is_empty() {
                state.serialize_entry("actionId", &self.action_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PluginInstanceActionID {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PluginInstanceActionID");
            debug_struct.field("plugin_instance", &self.plugin_instance);
            debug_struct.field("action_id", &self.action_id);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The state of the last execution of the curation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LastExecutionState {
        /// Default unspecified state.
        Unspecified,
        /// The last curation execution was successful.
        Succeeded,
        /// The last curation execution failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LastExecutionState::value] or
        /// [LastExecutionState::name].
        UnknownValue(last_execution_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod last_execution_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LastExecutionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Succeeded => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LAST_EXECUTION_STATE_UNSPECIFIED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LastExecutionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LastExecutionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LastExecutionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Succeeded,
                2 => Self::Failed,
                _ => Self::UnknownValue(last_execution_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LastExecutionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LAST_EXECUTION_STATE_UNSPECIFIED" => Self::Unspecified,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(last_execution_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LastExecutionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Succeeded => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LastExecutionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LastExecutionState>::new(
                ".google.cloud.apihub.v1.Curation.LastExecutionState",
            ))
        }
    }

    /// The error codes for failed executions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ErrorCode {
        /// Default unspecified error code.
        Unspecified,
        /// The execution failed due to an internal error.
        InternalError,
        /// The curation is not authorized to trigger the endpoint uri.
        Unauthorized,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ErrorCode::value] or
        /// [ErrorCode::name].
        UnknownValue(error_code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod error_code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ErrorCode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InternalError => std::option::Option::Some(1),
                Self::Unauthorized => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ERROR_CODE_UNSPECIFIED"),
                Self::InternalError => std::option::Option::Some("INTERNAL_ERROR"),
                Self::Unauthorized => std::option::Option::Some("UNAUTHORIZED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ErrorCode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ErrorCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ErrorCode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InternalError,
                2 => Self::Unauthorized,
                _ => Self::UnknownValue(error_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ErrorCode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ERROR_CODE_UNSPECIFIED" => Self::Unspecified,
                "INTERNAL_ERROR" => Self::InternalError,
                "UNAUTHORIZED" => Self::Unauthorized,
                _ => Self::UnknownValue(error_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ErrorCode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InternalError => serializer.serialize_i32(1),
                Self::Unauthorized => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ErrorCode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ErrorCode>::new(
                ".google.cloud.apihub.v1.Curation.ErrorCode",
            ))
        }
    }
}

/// The endpoint to be triggered for curation.
/// The endpoint will be invoked with a request payload containing
/// [ApiMetadata][google.cloud.apihub.v1.ApiHub.ApiMetadata].
/// Response should contain curated data in the form of
/// [ApiMetadata][google.cloud.apihub.v1.ApiHub.ApiMetadata].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Endpoint {
    /// The details of the endpoint to be triggered for curation.
    pub endpoint_details: std::option::Option<crate::model::endpoint::EndpointDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Endpoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint_details][crate::model::Endpoint::endpoint_details].
    ///
    /// Note that all the setters affecting `endpoint_details` are mutually
    /// exclusive.
    pub fn set_endpoint_details<
        T: std::convert::Into<std::option::Option<crate::model::endpoint::EndpointDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint_details = v.into();
        self
    }

    /// The value of [endpoint_details][crate::model::Endpoint::endpoint_details]
    /// if it holds a `ApplicationIntegrationEndpointDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn application_integration_endpoint_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ApplicationIntegrationEndpointDetails>>
    {
        #[allow(unreachable_patterns)]
        self.endpoint_details.as_ref().and_then(|v| match v {
            crate::model::endpoint::EndpointDetails::ApplicationIntegrationEndpointDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [endpoint_details][crate::model::Endpoint::endpoint_details]
    /// to hold a `ApplicationIntegrationEndpointDetails`.
    ///
    /// Note that all the setters affecting `endpoint_details` are
    /// mutually exclusive.
    pub fn set_application_integration_endpoint_details<
        T: std::convert::Into<std::boxed::Box<crate::model::ApplicationIntegrationEndpointDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint_details = std::option::Option::Some(
            crate::model::endpoint::EndpointDetails::ApplicationIntegrationEndpointDetails(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for Endpoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.Endpoint"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Endpoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __application_integration_endpoint_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Endpoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "applicationIntegrationEndpointDetails" => {
                                Ok(__FieldTag::__application_integration_endpoint_details)
                            }
                            "application_integration_endpoint_details" => {
                                Ok(__FieldTag::__application_integration_endpoint_details)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Endpoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Endpoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__application_integration_endpoint_details => {
                            if !fields
                                .insert(__FieldTag::__application_integration_endpoint_details)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for application_integration_endpoint_details",
                                ));
                            }
                            if result.endpoint_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `endpoint_details`, a oneof with full ID .google.cloud.apihub.v1.Endpoint.application_integration_endpoint_details, latest field was applicationIntegrationEndpointDetails",
                                ));
                            }
                            result.endpoint_details = std::option::Option::Some(
                                crate::model::endpoint::EndpointDetails::ApplicationIntegrationEndpointDetails(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ApplicationIntegrationEndpointDetails>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Endpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.application_integration_endpoint_details() {
            state.serialize_entry("applicationIntegrationEndpointDetails", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Endpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Endpoint");
        debug_struct.field("endpoint_details", &self.endpoint_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Endpoint].
pub mod endpoint {
    #[allow(unused_imports)]
    use super::*;

    /// The details of the endpoint to be triggered for curation.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EndpointDetails {
        /// Required. The details of the Application Integration endpoint to be
        /// triggered for curation.
        ApplicationIntegrationEndpointDetails(
            std::boxed::Box<crate::model::ApplicationIntegrationEndpointDetails>,
        ),
    }
}

/// The details of the Application Integration endpoint to be triggered for
/// curation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApplicationIntegrationEndpointDetails {
    /// Required. The endpoint URI should be a valid REST URI for triggering an
    /// Application Integration. Format:
    /// `<https://integrations.googleapis.com/v1/{name=projects/>*/locations/*/integrations/*}:execute`
    /// or
    /// `https://{location}-integrations.googleapis.com/v1/{name=projects/*/locations/*/integrations/*}:execute`
    pub uri: std::string::String,

    /// Required. The API trigger ID of the Application Integration workflow.
    pub trigger_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApplicationIntegrationEndpointDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::ApplicationIntegrationEndpointDetails::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [trigger_id][crate::model::ApplicationIntegrationEndpointDetails::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }
}

impl wkt::message::Message for ApplicationIntegrationEndpointDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ApplicationIntegrationEndpointDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApplicationIntegrationEndpointDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __trigger_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ApplicationIntegrationEndpointDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "triggerId" => Ok(__FieldTag::__trigger_id),
                            "trigger_id" => Ok(__FieldTag::__trigger_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApplicationIntegrationEndpointDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApplicationIntegrationEndpointDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger_id => {
                            if !fields.insert(__FieldTag::__trigger_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_id",
                                ));
                            }
                            result.trigger_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApplicationIntegrationEndpointDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.trigger_id.is_empty() {
            state.serialize_entry("triggerId", &self.trigger_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApplicationIntegrationEndpointDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApplicationIntegrationEndpointDetails");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("trigger_id", &self.trigger_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for requesting list of DiscoveredApiObservations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDiscoveredApiObservationsRequest {
    /// Required. The parent, which owns this collection of ApiObservations.
    /// Format:
    /// projects/{project}/locations/{location}
    pub parent: std::string::String,

    /// Optional. The maximum number of ApiObservations to return. The service may
    /// return fewer than this value. If unspecified, at most 10
    /// ApiObservations will be returned. The maximum value is 1000; values
    /// above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListApiObservations`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListApiObservations` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDiscoveredApiObservationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDiscoveredApiObservationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDiscoveredApiObservationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDiscoveredApiObservationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDiscoveredApiObservationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListDiscoveredApiObservationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDiscoveredApiObservationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDiscoveredApiObservationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDiscoveredApiObservationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDiscoveredApiObservationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDiscoveredApiObservationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDiscoveredApiObservationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDiscoveredApiObservationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for response to listing DiscoveredApiObservations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDiscoveredApiObservationsResponse {
    /// The DiscoveredApiObservation from the specified project and location.
    pub discovered_api_observations: std::vec::Vec<crate::model::DiscoveredApiObservation>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDiscoveredApiObservationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [discovered_api_observations][crate::model::ListDiscoveredApiObservationsResponse::discovered_api_observations].
    pub fn set_discovered_api_observations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiscoveredApiObservation>,
    {
        use std::iter::Iterator;
        self.discovered_api_observations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDiscoveredApiObservationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDiscoveredApiObservationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListDiscoveredApiObservationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDiscoveredApiObservationsResponse {
    type PageItem = crate::model::DiscoveredApiObservation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.discovered_api_observations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDiscoveredApiObservationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __discovered_api_observations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListDiscoveredApiObservationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "discoveredApiObservations" => {
                                Ok(__FieldTag::__discovered_api_observations)
                            }
                            "discovered_api_observations" => {
                                Ok(__FieldTag::__discovered_api_observations)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDiscoveredApiObservationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDiscoveredApiObservationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__discovered_api_observations => {
                            if !fields.insert(__FieldTag::__discovered_api_observations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovered_api_observations",
                                ));
                            }
                            result.discovered_api_observations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DiscoveredApiObservation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDiscoveredApiObservationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.discovered_api_observations.is_empty() {
            state.serialize_entry(
                "discoveredApiObservations",
                &self.discovered_api_observations,
            )?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDiscoveredApiObservationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDiscoveredApiObservationsResponse");
        debug_struct.field(
            "discovered_api_observations",
            &self.discovered_api_observations,
        );
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for requesting list of DiscoveredApiOperations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDiscoveredApiOperationsRequest {
    /// Required. The parent, which owns this collection of
    /// DiscoveredApiOperations. Format:
    /// projects/{project}/locations/{location}/discoveredApiObservations/{discovered_api_observation}
    pub parent: std::string::String,

    /// Optional. DiscoveredApiOperations will be returned. The maximum value is
    /// 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous
    /// `ListDiscoveredApiApiOperations` call. Provide this to retrieve the
    /// subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListDiscoveredApiApiOperations` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDiscoveredApiOperationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDiscoveredApiOperationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDiscoveredApiOperationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDiscoveredApiOperationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDiscoveredApiOperationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListDiscoveredApiOperationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDiscoveredApiOperationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDiscoveredApiOperationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDiscoveredApiOperationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDiscoveredApiOperationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDiscoveredApiOperationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDiscoveredApiOperationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDiscoveredApiOperationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for response to listing DiscoveredApiOperations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDiscoveredApiOperationsResponse {
    /// The DiscoveredApiOperations from the specified project, location
    /// and DiscoveredApiObservation.
    pub discovered_api_operations: std::vec::Vec<crate::model::DiscoveredApiOperation>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDiscoveredApiOperationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [discovered_api_operations][crate::model::ListDiscoveredApiOperationsResponse::discovered_api_operations].
    pub fn set_discovered_api_operations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiscoveredApiOperation>,
    {
        use std::iter::Iterator;
        self.discovered_api_operations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDiscoveredApiOperationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDiscoveredApiOperationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListDiscoveredApiOperationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDiscoveredApiOperationsResponse {
    type PageItem = crate::model::DiscoveredApiOperation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.discovered_api_operations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDiscoveredApiOperationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __discovered_api_operations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDiscoveredApiOperationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "discoveredApiOperations" => {
                                Ok(__FieldTag::__discovered_api_operations)
                            }
                            "discovered_api_operations" => {
                                Ok(__FieldTag::__discovered_api_operations)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDiscoveredApiOperationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDiscoveredApiOperationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__discovered_api_operations => {
                            if !fields.insert(__FieldTag::__discovered_api_operations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovered_api_operations",
                                ));
                            }
                            result.discovered_api_operations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DiscoveredApiOperation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDiscoveredApiOperationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.discovered_api_operations.is_empty() {
            state.serialize_entry("discoveredApiOperations", &self.discovered_api_operations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDiscoveredApiOperationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDiscoveredApiOperationsResponse");
        debug_struct.field("discovered_api_operations", &self.discovered_api_operations);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for requesting a DiscoveredApiObservation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDiscoveredApiObservationRequest {
    /// Required. The name of the DiscoveredApiObservation to retrieve.
    /// Format:
    /// projects/{project}/locations/{location}/discoveredApiObservations/{discovered_api_observation}
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDiscoveredApiObservationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDiscoveredApiObservationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDiscoveredApiObservationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetDiscoveredApiObservationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDiscoveredApiObservationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDiscoveredApiObservationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDiscoveredApiObservationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDiscoveredApiObservationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDiscoveredApiObservationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetDiscoveredApiObservationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDiscoveredApiObservationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for requesting a DiscoveredApiOperation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDiscoveredApiOperationRequest {
    /// Required. The name of the DiscoveredApiOperation to retrieve.
    /// Format:
    /// projects/{project}/locations/{location}/discoveredApiObservations/{discovered_api_observation}/discoveredApiOperations/{discovered_api_operation}
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDiscoveredApiOperationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDiscoveredApiOperationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDiscoveredApiOperationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetDiscoveredApiOperationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDiscoveredApiOperationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDiscoveredApiOperationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDiscoveredApiOperationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDiscoveredApiOperationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDiscoveredApiOperationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetDiscoveredApiOperationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDiscoveredApiOperationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [CreateHostProjectRegistration][google.cloud.apihub.v1.HostProjectRegistrationService.CreateHostProjectRegistration]
/// method's request.
///
/// [google.cloud.apihub.v1.HostProjectRegistrationService.CreateHostProjectRegistration]: crate::client::HostProjectRegistrationService::create_host_project_registration
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateHostProjectRegistrationRequest {
    /// Required. The parent resource for the host project.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Required. The ID to use for the Host Project Registration, which will
    /// become the final component of the host project registration's resource
    /// name. The ID must be the same as the Google cloud project specified in the
    /// host_project_registration.gcp_project field.
    pub host_project_registration_id: std::string::String,

    /// Required. The host project registration to register.
    pub host_project_registration: std::option::Option<crate::model::HostProjectRegistration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateHostProjectRegistrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateHostProjectRegistrationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [host_project_registration_id][crate::model::CreateHostProjectRegistrationRequest::host_project_registration_id].
    pub fn set_host_project_registration_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.host_project_registration_id = v.into();
        self
    }

    /// Sets the value of [host_project_registration][crate::model::CreateHostProjectRegistrationRequest::host_project_registration].
    pub fn set_host_project_registration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HostProjectRegistration>,
    {
        self.host_project_registration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [host_project_registration][crate::model::CreateHostProjectRegistrationRequest::host_project_registration].
    pub fn set_or_clear_host_project_registration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HostProjectRegistration>,
    {
        self.host_project_registration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateHostProjectRegistrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.CreateHostProjectRegistrationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateHostProjectRegistrationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __host_project_registration_id,
            __host_project_registration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateHostProjectRegistrationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "hostProjectRegistrationId" => {
                                Ok(__FieldTag::__host_project_registration_id)
                            }
                            "host_project_registration_id" => {
                                Ok(__FieldTag::__host_project_registration_id)
                            }
                            "hostProjectRegistration" => {
                                Ok(__FieldTag::__host_project_registration)
                            }
                            "host_project_registration" => {
                                Ok(__FieldTag::__host_project_registration)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateHostProjectRegistrationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateHostProjectRegistrationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__host_project_registration_id => {
                            if !fields.insert(__FieldTag::__host_project_registration_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host_project_registration_id",
                                ));
                            }
                            result.host_project_registration_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__host_project_registration => {
                            if !fields.insert(__FieldTag::__host_project_registration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host_project_registration",
                                ));
                            }
                            result.host_project_registration = map.next_value::<std::option::Option<crate::model::HostProjectRegistration>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateHostProjectRegistrationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.host_project_registration_id.is_empty() {
            state.serialize_entry(
                "hostProjectRegistrationId",
                &self.host_project_registration_id,
            )?;
        }
        if self.host_project_registration.is_some() {
            state.serialize_entry("hostProjectRegistration", &self.host_project_registration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateHostProjectRegistrationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateHostProjectRegistrationRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field(
            "host_project_registration_id",
            &self.host_project_registration_id,
        );
        debug_struct.field("host_project_registration", &self.host_project_registration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [GetHostProjectRegistration][google.cloud.apihub.v1.HostProjectRegistrationService.GetHostProjectRegistration]
/// method's request.
///
/// [google.cloud.apihub.v1.HostProjectRegistrationService.GetHostProjectRegistration]: crate::client::HostProjectRegistrationService::get_host_project_registration
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetHostProjectRegistrationRequest {
    /// Required. Host project registration resource name.
    /// projects/{project}/locations/{location}/hostProjectRegistrations/{host_project_registration_id}
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetHostProjectRegistrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetHostProjectRegistrationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetHostProjectRegistrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetHostProjectRegistrationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetHostProjectRegistrationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetHostProjectRegistrationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetHostProjectRegistrationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetHostProjectRegistrationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetHostProjectRegistrationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetHostProjectRegistrationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetHostProjectRegistrationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [ListHostProjectRegistrations][google.cloud.apihub.v1.HostProjectRegistrationService.ListHostProjectRegistrations]
/// method's request.
///
/// [google.cloud.apihub.v1.HostProjectRegistrationService.ListHostProjectRegistrations]: crate::client::HostProjectRegistrationService::list_host_project_registrations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListHostProjectRegistrationsRequest {
    /// Required. The parent, which owns this collection of host projects.
    /// Format: `projects/*/locations/*`
    pub parent: std::string::String,

    /// Optional. The maximum number of host project registrations to return. The
    /// service may return fewer than this value. If unspecified, at most 50 host
    /// project registrations will be returned. The maximum value is 1000; values
    /// above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous
    /// `ListHostProjectRegistrations` call. Provide this to retrieve the
    /// subsequent page.
    ///
    /// When paginating, all other parameters (except page_size) provided to
    /// `ListHostProjectRegistrations` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    /// Optional. An expression that filters the list of HostProjectRegistrations.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string. All
    /// standard operators as documented at <https://google.aip.dev/160> are
    /// supported.
    ///
    /// The following fields in the `HostProjectRegistration` are eligible for
    /// filtering:
    ///
    /// * `name` - The name of the HostProjectRegistration.
    /// * `create_time` - The time at which the HostProjectRegistration was
    ///   created. The value should be in the
    ///   (RFC3339)[<https://tools.ietf.org/html/rfc3339>] format.
    /// * `gcp_project` - The Google cloud project associated with the
    ///   HostProjectRegistration.
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListHostProjectRegistrationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListHostProjectRegistrationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListHostProjectRegistrationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListHostProjectRegistrationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListHostProjectRegistrationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListHostProjectRegistrationsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListHostProjectRegistrationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListHostProjectRegistrationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListHostProjectRegistrationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListHostProjectRegistrationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListHostProjectRegistrationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListHostProjectRegistrationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListHostProjectRegistrationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListHostProjectRegistrationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListHostProjectRegistrationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [ListHostProjectRegistrations][google.cloud.apihub.v1.HostProjectRegistrationService.ListHostProjectRegistrations]
/// method's response.
///
/// [google.cloud.apihub.v1.HostProjectRegistrationService.ListHostProjectRegistrations]: crate::client::HostProjectRegistrationService::list_host_project_registrations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListHostProjectRegistrationsResponse {
    /// The list of host project registrations.
    pub host_project_registrations: std::vec::Vec<crate::model::HostProjectRegistration>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListHostProjectRegistrationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host_project_registrations][crate::model::ListHostProjectRegistrationsResponse::host_project_registrations].
    pub fn set_host_project_registrations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::HostProjectRegistration>,
    {
        use std::iter::Iterator;
        self.host_project_registrations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListHostProjectRegistrationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListHostProjectRegistrationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListHostProjectRegistrationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListHostProjectRegistrationsResponse {
    type PageItem = crate::model::HostProjectRegistration;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.host_project_registrations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListHostProjectRegistrationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __host_project_registrations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListHostProjectRegistrationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hostProjectRegistrations" => {
                                Ok(__FieldTag::__host_project_registrations)
                            }
                            "host_project_registrations" => {
                                Ok(__FieldTag::__host_project_registrations)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListHostProjectRegistrationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListHostProjectRegistrationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__host_project_registrations => {
                            if !fields.insert(__FieldTag::__host_project_registrations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host_project_registrations",
                                ));
                            }
                            result.host_project_registrations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::HostProjectRegistration>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListHostProjectRegistrationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.host_project_registrations.is_empty() {
            state.serialize_entry("hostProjectRegistrations", &self.host_project_registrations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListHostProjectRegistrationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListHostProjectRegistrationsResponse");
        debug_struct.field(
            "host_project_registrations",
            &self.host_project_registrations,
        );
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Host project registration refers to the registration of a Google cloud
/// project with Api Hub as a host project. This is the project where Api Hub is
/// provisioned. It acts as the consumer project for the Api Hub instance
/// provisioned. Multiple runtime projects can be attached to the host project
/// and these attachments define the scope of Api Hub.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HostProjectRegistration {
    /// Identifier. The name of the host project registration.
    /// Format:
    /// "projects/{project}/locations/{location}/hostProjectRegistrations/{host_project_registration}".
    pub name: std::string::String,

    /// Required. Immutable. Google cloud project name in the format:
    /// "projects/abc" or "projects/123". As input, project name with either
    /// project id or number are accepted. As output, this field will contain
    /// project number.
    pub gcp_project: std::string::String,

    /// Output only. The time at which the host project registration was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HostProjectRegistration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::HostProjectRegistration::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [gcp_project][crate::model::HostProjectRegistration::gcp_project].
    pub fn set_gcp_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_project = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::HostProjectRegistration::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::HostProjectRegistration::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for HostProjectRegistration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.HostProjectRegistration"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HostProjectRegistration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __gcp_project,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HostProjectRegistration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "gcpProject" => Ok(__FieldTag::__gcp_project),
                            "gcp_project" => Ok(__FieldTag::__gcp_project),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HostProjectRegistration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HostProjectRegistration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcp_project => {
                            if !fields.insert(__FieldTag::__gcp_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_project",
                                ));
                            }
                            result.gcp_project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HostProjectRegistration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.gcp_project.is_empty() {
            state.serialize_entry("gcpProject", &self.gcp_project)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HostProjectRegistration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HostProjectRegistration");
        debug_struct.field("name", &self.name);
        debug_struct.field("gcp_project", &self.gcp_project);
        debug_struct.field("create_time", &self.create_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [GetStyleGuide][google.cloud.apihub.v1.LintingService.GetStyleGuide]
/// method's request.
///
/// [google.cloud.apihub.v1.LintingService.GetStyleGuide]: crate::client::LintingService::get_style_guide
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetStyleGuideRequest {
    /// Required. The name of the spec to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/plugins/{plugin}/styleGuide`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetStyleGuideRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetStyleGuideRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetStyleGuideRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetStyleGuideRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetStyleGuideRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetStyleGuideRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetStyleGuideRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetStyleGuideRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetStyleGuideRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetStyleGuideRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetStyleGuideRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [UpdateStyleGuide][google.cloud.apihub.v1.LintingService.UpdateStyleGuide]
/// method's request.
///
/// [google.cloud.apihub.v1.LintingService.UpdateStyleGuide]: crate::client::LintingService::update_style_guide
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateStyleGuideRequest {
    /// Required. The Style guide resource to update.
    pub style_guide: std::option::Option<crate::model::StyleGuide>,

    /// Optional. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateStyleGuideRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [style_guide][crate::model::UpdateStyleGuideRequest::style_guide].
    pub fn set_style_guide<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StyleGuide>,
    {
        self.style_guide = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [style_guide][crate::model::UpdateStyleGuideRequest::style_guide].
    pub fn set_or_clear_style_guide<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StyleGuide>,
    {
        self.style_guide = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateStyleGuideRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateStyleGuideRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateStyleGuideRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.UpdateStyleGuideRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateStyleGuideRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __style_guide,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateStyleGuideRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "styleGuide" => Ok(__FieldTag::__style_guide),
                            "style_guide" => Ok(__FieldTag::__style_guide),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateStyleGuideRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateStyleGuideRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__style_guide => {
                            if !fields.insert(__FieldTag::__style_guide) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for style_guide",
                                ));
                            }
                            result.style_guide =
                                map.next_value::<std::option::Option<crate::model::StyleGuide>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateStyleGuideRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.style_guide.is_some() {
            state.serialize_entry("styleGuide", &self.style_guide)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateStyleGuideRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateStyleGuideRequest");
        debug_struct.field("style_guide", &self.style_guide);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [GetStyleGuideContents][google.cloud.apihub.v1.LintingService.GetStyleGuideContents]
/// method's request.
///
/// [google.cloud.apihub.v1.LintingService.GetStyleGuideContents]: crate::client::LintingService::get_style_guide_contents
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetStyleGuideContentsRequest {
    /// Required. The name of the StyleGuide whose contents need to be retrieved.
    /// There is exactly one style guide resource per project per location.
    /// The expected format is
    /// `projects/{project}/locations/{location}/plugins/{plugin}/styleGuide`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetStyleGuideContentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetStyleGuideContentsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetStyleGuideContentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetStyleGuideContentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetStyleGuideContentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetStyleGuideContentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetStyleGuideContentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetStyleGuideContentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetStyleGuideContentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetStyleGuideContentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetStyleGuideContentsRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [LintSpec][google.cloud.apihub.v1.LintingService.LintSpec] method's
/// request.
///
/// [google.cloud.apihub.v1.LintingService.LintSpec]: crate::client::LintingService::lint_spec
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LintSpecRequest {
    /// Required. The name of the spec to be linted.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LintSpecRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LintSpecRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for LintSpecRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.LintSpecRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LintSpecRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LintSpecRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LintSpecRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LintSpecRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LintSpecRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LintSpecRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LintSpecRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The style guide contents.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StyleGuideContents {
    /// Required. The contents of the style guide.
    pub contents: ::bytes::Bytes,

    /// Required. The mime type of the content.
    pub mime_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StyleGuideContents {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [contents][crate::model::StyleGuideContents::contents].
    pub fn set_contents<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.contents = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::StyleGuideContents::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }
}

impl wkt::message::Message for StyleGuideContents {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.StyleGuideContents"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StyleGuideContents {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __contents,
            __mime_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StyleGuideContents")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "contents" => Ok(__FieldTag::__contents),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StyleGuideContents;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StyleGuideContents")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__contents => {
                            if !fields.insert(__FieldTag::__contents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contents",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.contents = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StyleGuideContents {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.contents.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contents", &__With(&self.contents))?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StyleGuideContents {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StyleGuideContents");
        debug_struct.field("contents", &self.contents);
        debug_struct.field("mime_type", &self.mime_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a singleton style guide resource to be used for linting Open API
/// specs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StyleGuide {
    /// Identifier. The name of the style guide.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/plugins/{plugin}/styleGuide`
    pub name: std::string::String,

    /// Required. Target linter for the style guide.
    pub linter: crate::model::Linter,

    /// Required. Input only. The contents of the uploaded style guide.
    pub contents: std::option::Option<crate::model::StyleGuideContents>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StyleGuide {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StyleGuide::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [linter][crate::model::StyleGuide::linter].
    pub fn set_linter<T: std::convert::Into<crate::model::Linter>>(mut self, v: T) -> Self {
        self.linter = v.into();
        self
    }

    /// Sets the value of [contents][crate::model::StyleGuide::contents].
    pub fn set_contents<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StyleGuideContents>,
    {
        self.contents = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [contents][crate::model::StyleGuide::contents].
    pub fn set_or_clear_contents<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StyleGuideContents>,
    {
        self.contents = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for StyleGuide {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.StyleGuide"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StyleGuide {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __linter,
            __contents,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StyleGuide")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "linter" => Ok(__FieldTag::__linter),
                            "contents" => Ok(__FieldTag::__contents),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StyleGuide;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StyleGuide")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__linter => {
                            if !fields.insert(__FieldTag::__linter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linter",
                                ));
                            }
                            result.linter = map
                                .next_value::<std::option::Option<crate::model::Linter>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__contents => {
                            if !fields.insert(__FieldTag::__contents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contents",
                                ));
                            }
                            result.contents = map.next_value::<std::option::Option<crate::model::StyleGuideContents>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StyleGuide {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.linter) {
            state.serialize_entry("linter", &self.linter)?;
        }
        if self.contents.is_some() {
            state.serialize_entry("contents", &self.contents)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StyleGuide {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StyleGuide");
        debug_struct.field("name", &self.name);
        debug_struct.field("linter", &self.linter);
        debug_struct.field("contents", &self.contents);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A plugin resource in the API Hub.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Plugin {
    /// Identifier. The name of the plugin.
    /// Format: `projects/{project}/locations/{location}/plugins/{plugin}`
    pub name: std::string::String,

    /// Required. The display name of the plugin. Max length is 50 characters
    /// (Unicode code points).
    pub display_name: std::string::String,

    /// Optional. The type of the API.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-plugin-type`
    /// attribute.
    /// The number of allowed values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    /// Note this field is not required for plugins developed via plugin framework.
    pub r#type: std::option::Option<crate::model::AttributeValues>,

    /// Optional. The plugin description. Max length is 2000 characters (Unicode
    /// code points).
    pub description: std::string::String,

    /// Output only. Represents the state of the plugin.
    /// Note this field will not be set for plugins developed via plugin
    /// framework as the state will be managed at plugin instance level.
    pub state: crate::model::plugin::State,

    /// Output only. The type of the plugin, indicating whether it is
    /// 'SYSTEM_OWNED' or 'USER_OWNED'.
    pub ownership_type: crate::model::plugin::OwnershipType,

    /// Optional. This field is optional. It is used to notify the plugin hosting
    /// service for any lifecycle changes of the plugin instance and trigger
    /// execution of plugin instance actions in case of API hub managed actions.
    ///
    /// This field should be provided if the plugin instance lifecycle of the
    /// developed plugin needs to be managed from API hub. Also, in this case the
    /// plugin hosting service interface needs to be implemented.
    ///
    /// This field should not be provided if the plugin wants to manage plugin
    /// instance lifecycle events outside of hub interface and use plugin framework
    /// for only registering of plugin and plugin instances to capture the source
    /// of data into hub. Note, in this case the plugin hosting service interface
    /// is not required to be implemented. Also, the plugin instance lifecycle
    /// actions will be disabled from API hub's UI.
    pub hosting_service: std::option::Option<crate::model::plugin::HostingService>,

    /// Optional. The configuration of actions supported by the plugin.
    /// **REQUIRED**: This field must be provided when creating or updating a
    /// Plugin. The server will reject requests if this field is missing.
    pub actions_config: std::vec::Vec<crate::model::PluginActionConfig>,

    /// Optional. The documentation of the plugin, that explains how to set up and
    /// use the plugin.
    pub documentation: std::option::Option<crate::model::Documentation>,

    /// Optional. The category of the plugin, identifying its primary category or
    /// purpose. This field is required for all plugins.
    pub plugin_category: crate::model::PluginCategory,

    /// Optional. The configuration template for the plugin.
    pub config_template: std::option::Option<crate::model::plugin::ConfigTemplate>,

    /// Output only. Timestamp indicating when the plugin was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp indicating when the plugin was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The type of the gateway.
    pub gateway_type: crate::model::GatewayType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Plugin {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Plugin::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Plugin::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Plugin::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.r#type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#type][crate::model::Plugin::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributeValues>,
    {
        self.r#type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::Plugin::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Plugin::state].
    pub fn set_state<T: std::convert::Into<crate::model::plugin::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [ownership_type][crate::model::Plugin::ownership_type].
    pub fn set_ownership_type<T: std::convert::Into<crate::model::plugin::OwnershipType>>(
        mut self,
        v: T,
    ) -> Self {
        self.ownership_type = v.into();
        self
    }

    /// Sets the value of [hosting_service][crate::model::Plugin::hosting_service].
    pub fn set_hosting_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::plugin::HostingService>,
    {
        self.hosting_service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hosting_service][crate::model::Plugin::hosting_service].
    pub fn set_or_clear_hosting_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::plugin::HostingService>,
    {
        self.hosting_service = v.map(|x| x.into());
        self
    }

    /// Sets the value of [actions_config][crate::model::Plugin::actions_config].
    pub fn set_actions_config<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PluginActionConfig>,
    {
        use std::iter::Iterator;
        self.actions_config = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [documentation][crate::model::Plugin::documentation].
    pub fn set_documentation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Documentation>,
    {
        self.documentation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [documentation][crate::model::Plugin::documentation].
    pub fn set_or_clear_documentation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Documentation>,
    {
        self.documentation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [plugin_category][crate::model::Plugin::plugin_category].
    pub fn set_plugin_category<T: std::convert::Into<crate::model::PluginCategory>>(
        mut self,
        v: T,
    ) -> Self {
        self.plugin_category = v.into();
        self
    }

    /// Sets the value of [config_template][crate::model::Plugin::config_template].
    pub fn set_config_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::plugin::ConfigTemplate>,
    {
        self.config_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config_template][crate::model::Plugin::config_template].
    pub fn set_or_clear_config_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::plugin::ConfigTemplate>,
    {
        self.config_template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Plugin::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Plugin::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Plugin::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Plugin::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gateway_type][crate::model::Plugin::gateway_type].
    pub fn set_gateway_type<T: std::convert::Into<crate::model::GatewayType>>(
        mut self,
        v: T,
    ) -> Self {
        self.gateway_type = v.into();
        self
    }
}

impl wkt::message::Message for Plugin {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.Plugin"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Plugin {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __type,
            __description,
            __state,
            __ownership_type,
            __hosting_service,
            __actions_config,
            __documentation,
            __plugin_category,
            __config_template,
            __create_time,
            __update_time,
            __gateway_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Plugin")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "type" => Ok(__FieldTag::__type),
                            "description" => Ok(__FieldTag::__description),
                            "state" => Ok(__FieldTag::__state),
                            "ownershipType" => Ok(__FieldTag::__ownership_type),
                            "ownership_type" => Ok(__FieldTag::__ownership_type),
                            "hostingService" => Ok(__FieldTag::__hosting_service),
                            "hosting_service" => Ok(__FieldTag::__hosting_service),
                            "actionsConfig" => Ok(__FieldTag::__actions_config),
                            "actions_config" => Ok(__FieldTag::__actions_config),
                            "documentation" => Ok(__FieldTag::__documentation),
                            "pluginCategory" => Ok(__FieldTag::__plugin_category),
                            "plugin_category" => Ok(__FieldTag::__plugin_category),
                            "configTemplate" => Ok(__FieldTag::__config_template),
                            "config_template" => Ok(__FieldTag::__config_template),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "gatewayType" => Ok(__FieldTag::__gateway_type),
                            "gateway_type" => Ok(__FieldTag::__gateway_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Plugin;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Plugin")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::AttributeValues>>(
                                )?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::plugin::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ownership_type => {
                            if !fields.insert(__FieldTag::__ownership_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ownership_type",
                                ));
                            }
                            result.ownership_type = map.next_value::<std::option::Option<crate::model::plugin::OwnershipType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__hosting_service => {
                            if !fields.insert(__FieldTag::__hosting_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hosting_service",
                                ));
                            }
                            result.hosting_service = map.next_value::<std::option::Option<crate::model::plugin::HostingService>>()?
                                ;
                        }
                        __FieldTag::__actions_config => {
                            if !fields.insert(__FieldTag::__actions_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for actions_config",
                                ));
                            }
                            result.actions_config = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PluginActionConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__documentation => {
                            if !fields.insert(__FieldTag::__documentation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documentation",
                                ));
                            }
                            result.documentation = map
                                .next_value::<std::option::Option<crate::model::Documentation>>()?;
                        }
                        __FieldTag::__plugin_category => {
                            if !fields.insert(__FieldTag::__plugin_category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plugin_category",
                                ));
                            }
                            result.plugin_category = map
                                .next_value::<std::option::Option<crate::model::PluginCategory>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config_template => {
                            if !fields.insert(__FieldTag::__config_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_template",
                                ));
                            }
                            result.config_template = map.next_value::<std::option::Option<crate::model::plugin::ConfigTemplate>>()?
                                ;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__gateway_type => {
                            if !fields.insert(__FieldTag::__gateway_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gateway_type",
                                ));
                            }
                            result.gateway_type = map
                                .next_value::<std::option::Option<crate::model::GatewayType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Plugin {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.ownership_type) {
            state.serialize_entry("ownershipType", &self.ownership_type)?;
        }
        if self.hosting_service.is_some() {
            state.serialize_entry("hostingService", &self.hosting_service)?;
        }
        if !self.actions_config.is_empty() {
            state.serialize_entry("actionsConfig", &self.actions_config)?;
        }
        if self.documentation.is_some() {
            state.serialize_entry("documentation", &self.documentation)?;
        }
        if !wkt::internal::is_default(&self.plugin_category) {
            state.serialize_entry("pluginCategory", &self.plugin_category)?;
        }
        if self.config_template.is_some() {
            state.serialize_entry("configTemplate", &self.config_template)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.gateway_type) {
            state.serialize_entry("gatewayType", &self.gateway_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Plugin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Plugin");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("description", &self.description);
        debug_struct.field("state", &self.state);
        debug_struct.field("ownership_type", &self.ownership_type);
        debug_struct.field("hosting_service", &self.hosting_service);
        debug_struct.field("actions_config", &self.actions_config);
        debug_struct.field("documentation", &self.documentation);
        debug_struct.field("plugin_category", &self.plugin_category);
        debug_struct.field("config_template", &self.config_template);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("gateway_type", &self.gateway_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Plugin].
pub mod plugin {
    #[allow(unused_imports)]
    use super::*;

    /// The information related to the service implemented by the plugin
    /// developer, used to invoke the plugin's functionality.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct HostingService {
        /// Optional. The URI of the service implemented by the plugin developer,
        /// used to invoke the plugin's functionality. This information is only
        /// required for user defined plugins.
        pub service_uri: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl HostingService {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service_uri][crate::model::plugin::HostingService::service_uri].
        pub fn set_service_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.service_uri = v.into();
            self
        }
    }

    impl wkt::message::Message for HostingService {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.Plugin.HostingService"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for HostingService {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __service_uri,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for HostingService")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "serviceUri" => Ok(__FieldTag::__service_uri),
                                "service_uri" => Ok(__FieldTag::__service_uri),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = HostingService;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct HostingService")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__service_uri => {
                                if !fields.insert(__FieldTag::__service_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_uri",
                                    ));
                                }
                                result.service_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for HostingService {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.service_uri.is_empty() {
                state.serialize_entry("serviceUri", &self.service_uri)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for HostingService {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("HostingService");
            debug_struct.field("service_uri", &self.service_uri);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// ConfigTemplate represents the configuration template for a plugin.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConfigTemplate {
        /// Optional. The authentication template for the plugin.
        pub auth_config_template:
            std::option::Option<crate::model::plugin::config_template::AuthConfigTemplate>,

        /// Optional. The list of additional configuration variables for the plugin's
        /// configuration.
        pub additional_config_template: std::vec::Vec<crate::model::ConfigVariableTemplate>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConfigTemplate {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [auth_config_template][crate::model::plugin::ConfigTemplate::auth_config_template].
        pub fn set_auth_config_template<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::plugin::config_template::AuthConfigTemplate>,
        {
            self.auth_config_template = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [auth_config_template][crate::model::plugin::ConfigTemplate::auth_config_template].
        pub fn set_or_clear_auth_config_template<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::plugin::config_template::AuthConfigTemplate>,
        {
            self.auth_config_template = v.map(|x| x.into());
            self
        }

        /// Sets the value of [additional_config_template][crate::model::plugin::ConfigTemplate::additional_config_template].
        pub fn set_additional_config_template<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ConfigVariableTemplate>,
        {
            use std::iter::Iterator;
            self.additional_config_template = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ConfigTemplate {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.Plugin.ConfigTemplate"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConfigTemplate {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __auth_config_template,
                __additional_config_template,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConfigTemplate")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "authConfigTemplate" => Ok(__FieldTag::__auth_config_template),
                                "auth_config_template" => Ok(__FieldTag::__auth_config_template),
                                "additionalConfigTemplate" => {
                                    Ok(__FieldTag::__additional_config_template)
                                }
                                "additional_config_template" => {
                                    Ok(__FieldTag::__additional_config_template)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConfigTemplate;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConfigTemplate")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__auth_config_template => {
                                if !fields.insert(__FieldTag::__auth_config_template) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for auth_config_template",
                                    ));
                                }
                                result.auth_config_template = map
                                    .next_value::<std::option::Option<
                                        crate::model::plugin::config_template::AuthConfigTemplate,
                                    >>()?;
                            }
                            __FieldTag::__additional_config_template => {
                                if !fields.insert(__FieldTag::__additional_config_template) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for additional_config_template",
                                    ));
                                }
                                result.additional_config_template = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::ConfigVariableTemplate>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ConfigTemplate {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.auth_config_template.is_some() {
                state.serialize_entry("authConfigTemplate", &self.auth_config_template)?;
            }
            if !self.additional_config_template.is_empty() {
                state.serialize_entry(
                    "additionalConfigTemplate",
                    &self.additional_config_template,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ConfigTemplate {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ConfigTemplate");
            debug_struct.field("auth_config_template", &self.auth_config_template);
            debug_struct.field(
                "additional_config_template",
                &self.additional_config_template,
            );
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [ConfigTemplate].
    pub mod config_template {
        #[allow(unused_imports)]
        use super::*;

        /// AuthConfigTemplate represents the authentication template for a plugin.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct AuthConfigTemplate {
            /// Required. The list of authentication types supported by the plugin.
            pub supported_auth_types: std::vec::Vec<crate::model::AuthType>,

            /// Optional. The service account of the plugin hosting service.
            /// This service account should be granted the required permissions on the
            /// Auth Config parameters provided while creating the plugin instances
            /// corresponding to this plugin.
            ///
            /// For example, if the plugin instance auth config requires a secret
            /// manager secret, the service account should be granted the
            /// secretmanager.versions.access permission on the corresponding secret,
            /// if the plugin instance auth config contains a service account, the
            /// service account should be granted the
            /// iam.serviceAccounts.getAccessToken permission on the corresponding
            /// service account.
            pub service_account: std::option::Option<crate::model::GoogleServiceAccountConfig>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AuthConfigTemplate {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [supported_auth_types][crate::model::plugin::config_template::AuthConfigTemplate::supported_auth_types].
            pub fn set_supported_auth_types<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::AuthType>,
            {
                use std::iter::Iterator;
                self.supported_auth_types = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [service_account][crate::model::plugin::config_template::AuthConfigTemplate::service_account].
            pub fn set_service_account<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::GoogleServiceAccountConfig>,
            {
                self.service_account = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [service_account][crate::model::plugin::config_template::AuthConfigTemplate::service_account].
            pub fn set_or_clear_service_account<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::GoogleServiceAccountConfig>,
            {
                self.service_account = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for AuthConfigTemplate {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.apihub.v1.Plugin.ConfigTemplate.AuthConfigTemplate"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for AuthConfigTemplate {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __supported_auth_types,
                    __service_account,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for AuthConfigTemplate")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "supportedAuthTypes" => Ok(__FieldTag::__supported_auth_types),
                                    "supported_auth_types" => {
                                        Ok(__FieldTag::__supported_auth_types)
                                    }
                                    "serviceAccount" => Ok(__FieldTag::__service_account),
                                    "service_account" => Ok(__FieldTag::__service_account),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = AuthConfigTemplate;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct AuthConfigTemplate")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__supported_auth_types => {
                                    if !fields.insert(__FieldTag::__supported_auth_types) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for supported_auth_types",
                                            ),
                                        );
                                    }
                                    result.supported_auth_types =
                                        map.next_value::<std::option::Option<
                                            std::vec::Vec<crate::model::AuthType>,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__service_account => {
                                    if !fields.insert(__FieldTag::__service_account) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for service_account",
                                            ),
                                        );
                                    }
                                    result.service_account = map
                                        .next_value::<std::option::Option<
                                            crate::model::GoogleServiceAccountConfig,
                                        >>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for AuthConfigTemplate {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.supported_auth_types.is_empty() {
                    state.serialize_entry("supportedAuthTypes", &self.supported_auth_types)?;
                }
                if self.service_account.is_some() {
                    state.serialize_entry("serviceAccount", &self.service_account)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for AuthConfigTemplate {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("AuthConfigTemplate");
                debug_struct.field("supported_auth_types", &self.supported_auth_types);
                debug_struct.field("service_account", &self.service_account);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// Possible states a plugin can have. Note that this enum may receive new
    /// values in the future. Consumers are advised to always code against the
    /// enum values expecting new states can be added later on.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified,
        /// The plugin is enabled.
        Enabled,
        /// The plugin is disabled.
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.apihub.v1.Plugin.State",
            ))
        }
    }

    /// Ownership type of the plugin.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OwnershipType {
        /// Default unspecified type.
        Unspecified,
        /// System owned plugins are defined by API hub and are available out of the
        /// box in API hub.
        SystemOwned,
        /// User owned plugins are defined by the user and need to be explicitly
        /// added to API hub via
        /// [CreatePlugin][google.cloud.apihub.v1.ApiHubPlugin.CreatePlugin] method.
        ///
        /// [google.cloud.apihub.v1.ApiHubPlugin.CreatePlugin]: crate::client::ApiHubPlugin::create_plugin
        UserOwned,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OwnershipType::value] or
        /// [OwnershipType::name].
        UnknownValue(ownership_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ownership_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OwnershipType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SystemOwned => std::option::Option::Some(1),
                Self::UserOwned => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OWNERSHIP_TYPE_UNSPECIFIED"),
                Self::SystemOwned => std::option::Option::Some("SYSTEM_OWNED"),
                Self::UserOwned => std::option::Option::Some("USER_OWNED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OwnershipType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OwnershipType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OwnershipType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SystemOwned,
                2 => Self::UserOwned,
                _ => Self::UnknownValue(ownership_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OwnershipType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OWNERSHIP_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SYSTEM_OWNED" => Self::SystemOwned,
                "USER_OWNED" => Self::UserOwned,
                _ => Self::UnknownValue(ownership_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OwnershipType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SystemOwned => serializer.serialize_i32(1),
                Self::UserOwned => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OwnershipType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OwnershipType>::new(
                ".google.cloud.apihub.v1.Plugin.OwnershipType",
            ))
        }
    }
}

/// PluginActionConfig represents the configuration of an action supported by a
/// plugin.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PluginActionConfig {
    /// Required. The id of the action.
    pub id: std::string::String,

    /// Required. The display name of the action.
    pub display_name: std::string::String,

    /// Required. The description of the operation performed by the action.
    pub description: std::string::String,

    /// Required. The trigger mode supported by the action.
    pub trigger_mode: crate::model::plugin_action_config::TriggerMode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PluginActionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::PluginActionConfig::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PluginActionConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::PluginActionConfig::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [trigger_mode][crate::model::PluginActionConfig::trigger_mode].
    pub fn set_trigger_mode<
        T: std::convert::Into<crate::model::plugin_action_config::TriggerMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.trigger_mode = v.into();
        self
    }
}

impl wkt::message::Message for PluginActionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.PluginActionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PluginActionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __display_name,
            __description,
            __trigger_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PluginActionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "triggerMode" => Ok(__FieldTag::__trigger_mode),
                            "trigger_mode" => Ok(__FieldTag::__trigger_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PluginActionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PluginActionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger_mode => {
                            if !fields.insert(__FieldTag::__trigger_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_mode",
                                ));
                            }
                            result.trigger_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::plugin_action_config::TriggerMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PluginActionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.trigger_mode) {
            state.serialize_entry("triggerMode", &self.trigger_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PluginActionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PluginActionConfig");
        debug_struct.field("id", &self.id);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("trigger_mode", &self.trigger_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PluginActionConfig].
pub mod plugin_action_config {
    #[allow(unused_imports)]
    use super::*;

    /// Execution mode of the action.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TriggerMode {
        /// Default unspecified mode.
        Unspecified,
        /// This action can be executed by invoking
        /// [ExecutePluginInstanceAction][google.cloud.apihub.v1.ApiHubPlugin.ExecutePluginInstanceAction]
        /// API with the given action id. To support this, the plugin hosting service
        /// should handle this action id as part of execute call.
        ///
        /// [google.cloud.apihub.v1.ApiHubPlugin.ExecutePluginInstanceAction]: crate::client::ApiHubPlugin::execute_plugin_instance_action
        ApiHubOnDemandTrigger,
        /// This action will be executed on schedule by invoking
        /// [ExecutePluginInstanceAction][google.cloud.apihub.v1.ApiHubPlugin.ExecutePluginInstanceAction]
        /// API with the given action id. To set the schedule, the user can provide
        /// the cron expression in the
        /// [PluginAction][PluginAction.schedule_cron_expression] field for a given
        /// plugin instance. To support this, the plugin hosting service should
        /// handle this action id as part of execute call.
        /// Note, on demand execution will be supported by default in this trigger
        /// mode.
        ///
        /// [google.cloud.apihub.v1.ApiHubPlugin.ExecutePluginInstanceAction]: crate::client::ApiHubPlugin::execute_plugin_instance_action
        ApiHubScheduleTrigger,
        /// The execution of this plugin is not handled by API hub. In this case,
        /// the plugin hosting service need not handle this action id as part of
        /// the execute call.
        NonApiHubManaged,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TriggerMode::value] or
        /// [TriggerMode::name].
        UnknownValue(trigger_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod trigger_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TriggerMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ApiHubOnDemandTrigger => std::option::Option::Some(1),
                Self::ApiHubScheduleTrigger => std::option::Option::Some(2),
                Self::NonApiHubManaged => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TRIGGER_MODE_UNSPECIFIED"),
                Self::ApiHubOnDemandTrigger => {
                    std::option::Option::Some("API_HUB_ON_DEMAND_TRIGGER")
                }
                Self::ApiHubScheduleTrigger => {
                    std::option::Option::Some("API_HUB_SCHEDULE_TRIGGER")
                }
                Self::NonApiHubManaged => std::option::Option::Some("NON_API_HUB_MANAGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TriggerMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TriggerMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TriggerMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ApiHubOnDemandTrigger,
                2 => Self::ApiHubScheduleTrigger,
                3 => Self::NonApiHubManaged,
                _ => Self::UnknownValue(trigger_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TriggerMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRIGGER_MODE_UNSPECIFIED" => Self::Unspecified,
                "API_HUB_ON_DEMAND_TRIGGER" => Self::ApiHubOnDemandTrigger,
                "API_HUB_SCHEDULE_TRIGGER" => Self::ApiHubScheduleTrigger,
                "NON_API_HUB_MANAGED" => Self::NonApiHubManaged,
                _ => Self::UnknownValue(trigger_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TriggerMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ApiHubOnDemandTrigger => serializer.serialize_i32(1),
                Self::ApiHubScheduleTrigger => serializer.serialize_i32(2),
                Self::NonApiHubManaged => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TriggerMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TriggerMode>::new(
                ".google.cloud.apihub.v1.PluginActionConfig.TriggerMode",
            ))
        }
    }
}

/// The [GetPlugin][google.cloud.apihub.v1.ApiHubPlugin.GetPlugin] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHubPlugin.GetPlugin]: crate::client::ApiHubPlugin::get_plugin
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPluginRequest {
    /// Required. The name of the plugin to retrieve.
    /// Format: `projects/{project}/locations/{location}/plugins/{plugin}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPluginRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPluginRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPluginRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetPluginRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetPluginRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPluginRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetPluginRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPluginRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetPluginRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetPluginRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetPluginRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [EnablePlugin][google.cloud.apihub.v1.ApiHubPlugin.EnablePlugin] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHubPlugin.EnablePlugin]: crate::client::ApiHubPlugin::enable_plugin
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EnablePluginRequest {
    /// Required. The name of the plugin to enable.
    /// Format: `projects/{project}/locations/{location}/plugins/{plugin}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnablePluginRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EnablePluginRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EnablePluginRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.EnablePluginRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnablePluginRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnablePluginRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnablePluginRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnablePluginRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnablePluginRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EnablePluginRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnablePluginRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [DisablePlugin][google.cloud.apihub.v1.ApiHubPlugin.DisablePlugin]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHubPlugin.DisablePlugin]: crate::client::ApiHubPlugin::disable_plugin
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DisablePluginRequest {
    /// Required. The name of the plugin to disable.
    /// Format: `projects/{project}/locations/{location}/plugins/{plugin}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisablePluginRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DisablePluginRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DisablePluginRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DisablePluginRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DisablePluginRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DisablePluginRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DisablePluginRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisablePluginRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DisablePluginRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DisablePluginRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DisablePluginRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// PluginInstanceAction represents an action which can be executed in the plugin
/// instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PluginInstanceAction {
    /// Required. This should map to one of the [action
    /// id][google.cloud.apihub.v1.PluginActionConfig.id] specified in
    /// [actions_config][google.cloud.apihub.v1.Plugin.actions_config] in the
    /// plugin.
    ///
    /// [google.cloud.apihub.v1.Plugin.actions_config]: crate::model::Plugin::actions_config
    /// [google.cloud.apihub.v1.PluginActionConfig.id]: crate::model::PluginActionConfig::id
    pub action_id: std::string::String,

    /// Output only. The current state of the plugin action in the plugin instance.
    pub state: crate::model::plugin_instance_action::State,

    /// Optional. The schedule for this plugin instance action. This can only be
    /// set if the plugin supports API_HUB_SCHEDULE_TRIGGER mode for this action.
    pub schedule_cron_expression: std::string::String,

    /// Optional. This configuration should be provided if the plugin action is
    /// publishing data to API hub curate layer.
    pub curation_config: std::option::Option<crate::model::CurationConfig>,

    /// Optional. The time zone for the schedule cron expression. If not provided,
    /// UTC will be used.
    pub schedule_time_zone: std::string::String,

    /// Optional. The service account used to publish data. Note, the service
    /// account will only be accepted for non GCP plugins like OPDK.
    pub service_account: std::string::String,

    /// Output only. The configuration of resources created for a given plugin
    /// instance action. Note these will be returned only in case of Non-GCP
    /// plugins like OPDK.
    pub resource_config: std::option::Option<crate::model::plugin_instance_action::ResourceConfig>,

    /// The status of the plugin action.
    pub action_status: std::option::Option<crate::model::plugin_instance_action::ActionStatus>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PluginInstanceAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [action_id][crate::model::PluginInstanceAction::action_id].
    pub fn set_action_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action_id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PluginInstanceAction::state].
    pub fn set_state<T: std::convert::Into<crate::model::plugin_instance_action::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [schedule_cron_expression][crate::model::PluginInstanceAction::schedule_cron_expression].
    pub fn set_schedule_cron_expression<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.schedule_cron_expression = v.into();
        self
    }

    /// Sets the value of [curation_config][crate::model::PluginInstanceAction::curation_config].
    pub fn set_curation_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CurationConfig>,
    {
        self.curation_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [curation_config][crate::model::PluginInstanceAction::curation_config].
    pub fn set_or_clear_curation_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CurationConfig>,
    {
        self.curation_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schedule_time_zone][crate::model::PluginInstanceAction::schedule_time_zone].
    pub fn set_schedule_time_zone<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.schedule_time_zone = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::PluginInstanceAction::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [resource_config][crate::model::PluginInstanceAction::resource_config].
    pub fn set_resource_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::plugin_instance_action::ResourceConfig>,
    {
        self.resource_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_config][crate::model::PluginInstanceAction::resource_config].
    pub fn set_or_clear_resource_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::plugin_instance_action::ResourceConfig>,
    {
        self.resource_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [action_status][crate::model::PluginInstanceAction::action_status].
    ///
    /// Note that all the setters affecting `action_status` are mutually
    /// exclusive.
    pub fn set_action_status<
        T: std::convert::Into<std::option::Option<crate::model::plugin_instance_action::ActionStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action_status = v.into();
        self
    }

    /// The value of [action_status][crate::model::PluginInstanceAction::action_status]
    /// if it holds a `HubInstanceAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hub_instance_action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExecutionStatus>> {
        #[allow(unreachable_patterns)]
        self.action_status.as_ref().and_then(|v| match v {
            crate::model::plugin_instance_action::ActionStatus::HubInstanceAction(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action_status][crate::model::PluginInstanceAction::action_status]
    /// to hold a `HubInstanceAction`.
    ///
    /// Note that all the setters affecting `action_status` are
    /// mutually exclusive.
    pub fn set_hub_instance_action<
        T: std::convert::Into<std::boxed::Box<crate::model::ExecutionStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action_status = std::option::Option::Some(
            crate::model::plugin_instance_action::ActionStatus::HubInstanceAction(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PluginInstanceAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.PluginInstanceAction"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PluginInstanceAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hub_instance_action,
            __action_id,
            __state,
            __schedule_cron_expression,
            __curation_config,
            __schedule_time_zone,
            __service_account,
            __resource_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PluginInstanceAction")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hubInstanceAction" => Ok(__FieldTag::__hub_instance_action),
                            "hub_instance_action" => Ok(__FieldTag::__hub_instance_action),
                            "actionId" => Ok(__FieldTag::__action_id),
                            "action_id" => Ok(__FieldTag::__action_id),
                            "state" => Ok(__FieldTag::__state),
                            "scheduleCronExpression" => Ok(__FieldTag::__schedule_cron_expression),
                            "schedule_cron_expression" => {
                                Ok(__FieldTag::__schedule_cron_expression)
                            }
                            "curationConfig" => Ok(__FieldTag::__curation_config),
                            "curation_config" => Ok(__FieldTag::__curation_config),
                            "scheduleTimeZone" => Ok(__FieldTag::__schedule_time_zone),
                            "schedule_time_zone" => Ok(__FieldTag::__schedule_time_zone),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "resourceConfig" => Ok(__FieldTag::__resource_config),
                            "resource_config" => Ok(__FieldTag::__resource_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PluginInstanceAction;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PluginInstanceAction")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hub_instance_action => {
                            if !fields.insert(__FieldTag::__hub_instance_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hub_instance_action",
                                ));
                            }
                            if result.action_status.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action_status`, a oneof with full ID .google.cloud.apihub.v1.PluginInstanceAction.hub_instance_action, latest field was hubInstanceAction",
                                ));
                            }
                            result.action_status = std::option::Option::Some(
                                crate::model::plugin_instance_action::ActionStatus::HubInstanceAction(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ExecutionStatus>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__action_id => {
                            if !fields.insert(__FieldTag::__action_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action_id",
                                ));
                            }
                            result.action_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state =
                                map.next_value::<std::option::Option<
                                    crate::model::plugin_instance_action::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schedule_cron_expression => {
                            if !fields.insert(__FieldTag::__schedule_cron_expression) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule_cron_expression",
                                ));
                            }
                            result.schedule_cron_expression = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__curation_config => {
                            if !fields.insert(__FieldTag::__curation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for curation_config",
                                ));
                            }
                            result.curation_config = map
                                .next_value::<std::option::Option<crate::model::CurationConfig>>(
                                )?;
                        }
                        __FieldTag::__schedule_time_zone => {
                            if !fields.insert(__FieldTag::__schedule_time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule_time_zone",
                                ));
                            }
                            result.schedule_time_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_config => {
                            if !fields.insert(__FieldTag::__resource_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_config",
                                ));
                            }
                            result.resource_config = map.next_value::<std::option::Option<
                                crate::model::plugin_instance_action::ResourceConfig,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PluginInstanceAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.hub_instance_action() {
            state.serialize_entry("hubInstanceAction", value)?;
        }
        if !self.action_id.is_empty() {
            state.serialize_entry("actionId", &self.action_id)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.schedule_cron_expression.is_empty() {
            state.serialize_entry("scheduleCronExpression", &self.schedule_cron_expression)?;
        }
        if self.curation_config.is_some() {
            state.serialize_entry("curationConfig", &self.curation_config)?;
        }
        if !self.schedule_time_zone.is_empty() {
            state.serialize_entry("scheduleTimeZone", &self.schedule_time_zone)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if self.resource_config.is_some() {
            state.serialize_entry("resourceConfig", &self.resource_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PluginInstanceAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PluginInstanceAction");
        debug_struct.field("action_id", &self.action_id);
        debug_struct.field("state", &self.state);
        debug_struct.field("schedule_cron_expression", &self.schedule_cron_expression);
        debug_struct.field("curation_config", &self.curation_config);
        debug_struct.field("schedule_time_zone", &self.schedule_time_zone);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("resource_config", &self.resource_config);
        debug_struct.field("action_status", &self.action_status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PluginInstanceAction].
pub mod plugin_instance_action {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration of resources created for a given plugin instance action.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResourceConfig {
        /// Output only. The type of the action.
        pub action_type: crate::model::ActionType,

        /// Output only. The pubsub topic to publish the data to. Format is
        /// projects/{project}/topics/{topic}
        pub pubsub_topic: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResourceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [action_type][crate::model::plugin_instance_action::ResourceConfig::action_type].
        pub fn set_action_type<T: std::convert::Into<crate::model::ActionType>>(
            mut self,
            v: T,
        ) -> Self {
            self.action_type = v.into();
            self
        }

        /// Sets the value of [pubsub_topic][crate::model::plugin_instance_action::ResourceConfig::pubsub_topic].
        pub fn set_pubsub_topic<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.pubsub_topic = v.into();
            self
        }
    }

    impl wkt::message::Message for ResourceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.PluginInstanceAction.ResourceConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ResourceConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __action_type,
                __pubsub_topic,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ResourceConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "actionType" => Ok(__FieldTag::__action_type),
                                "action_type" => Ok(__FieldTag::__action_type),
                                "pubsubTopic" => Ok(__FieldTag::__pubsub_topic),
                                "pubsub_topic" => Ok(__FieldTag::__pubsub_topic),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ResourceConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ResourceConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__action_type => {
                                if !fields.insert(__FieldTag::__action_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for action_type",
                                    ));
                                }
                                result.action_type = map
                                    .next_value::<std::option::Option<crate::model::ActionType>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__pubsub_topic => {
                                if !fields.insert(__FieldTag::__pubsub_topic) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pubsub_topic",
                                    ));
                                }
                                result.pubsub_topic = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ResourceConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.action_type) {
                state.serialize_entry("actionType", &self.action_type)?;
            }
            if !self.pubsub_topic.is_empty() {
                state.serialize_entry("pubsubTopic", &self.pubsub_topic)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ResourceConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ResourceConfig");
            debug_struct.field("action_type", &self.action_type);
            debug_struct.field("pubsub_topic", &self.pubsub_topic);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// State represents the state of the plugin instance action.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified state.
        Unspecified,
        /// The action is enabled in the plugin instance i.e., executions can
        /// be triggered for this action.
        Enabled,
        /// The action is disabled in the plugin instance i.e., no executions
        /// can be triggered for this action. This state indicates that the user
        /// explicitly disabled the instance, and no further action is needed unless
        /// the user wants to re-enable it.
        Disabled,
        /// The action in the plugin instance is being enabled.
        Enabling,
        /// The action in the plugin instance is being disabled.
        Disabling,
        /// The ERROR state can come while enabling/disabling plugin instance action.
        /// Users can retrigger enable, disable via
        /// [EnablePluginInstanceAction][google.cloud.apihub.v1.ApiHubPlugin.EnablePluginInstanceAction]
        /// and
        /// [DisablePluginInstanceAction][google.cloud.apihub.v1.ApiHubPlugin.DisablePluginInstanceAction]
        /// to restore the action back to enabled/disabled state. Note enable/disable
        /// on actions can only be triggered if plugin instance is in Active state.
        ///
        /// [google.cloud.apihub.v1.ApiHubPlugin.DisablePluginInstanceAction]: crate::client::ApiHubPlugin::disable_plugin_instance_action
        /// [google.cloud.apihub.v1.ApiHubPlugin.EnablePluginInstanceAction]: crate::client::ApiHubPlugin::enable_plugin_instance_action
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::Enabling => std::option::Option::Some(3),
                Self::Disabling => std::option::Option::Some(4),
                Self::Error => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Enabling => std::option::Option::Some("ENABLING"),
                Self::Disabling => std::option::Option::Some("DISABLING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                3 => Self::Enabling,
                4 => Self::Disabling,
                5 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                "ENABLING" => Self::Enabling,
                "DISABLING" => Self::Disabling,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::Enabling => serializer.serialize_i32(3),
                Self::Disabling => serializer.serialize_i32(4),
                Self::Error => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.apihub.v1.PluginInstanceAction.State",
            ))
        }
    }

    /// The status of the plugin action.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ActionStatus {
        /// Optional. The execution information for the plugin instance action done
        /// corresponding to an API hub instance.
        HubInstanceAction(std::boxed::Box<crate::model::ExecutionStatus>),
    }
}

/// Represents a plugin instance resource in the API Hub.
/// A PluginInstance is a specific instance of a hub plugin with its own
/// configuration, state, and execution details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PluginInstance {
    /// Identifier. The unique name of the plugin instance resource.
    /// Format:
    /// `projects/{project}/locations/{location}/plugins/{plugin}/instances/{instance}`
    pub name: std::string::String,

    /// Required. The display name for this plugin instance. Max length is 255
    /// characters.
    pub display_name: std::string::String,

    /// Optional. The authentication information for this plugin instance.
    pub auth_config: std::option::Option<crate::model::AuthConfig>,

    /// Optional. The additional information for this plugin instance corresponding
    /// to the additional config template of the plugin. This information will be
    /// sent to plugin hosting service on each call to plugin hosted service. The
    /// key will be the config_variable_template.display_name to uniquely identify
    /// the config variable.
    pub additional_config:
        std::collections::HashMap<std::string::String, crate::model::ConfigVariable>,

    /// Output only. The current state of the plugin instance (e.g., enabled,
    /// disabled, provisioning).
    pub state: crate::model::plugin_instance::State,

    /// Output only. Error message describing the failure, if any, during Create,
    /// Delete or ApplyConfig operation corresponding to the plugin instance.This
    /// field will only be populated if the plugin instance is in the ERROR or
    /// FAILED state.
    pub error_message: std::string::String,

    /// Required. The action status for the plugin instance.
    pub actions: std::vec::Vec<crate::model::PluginInstanceAction>,

    /// Output only. Timestamp indicating when the plugin instance was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp indicating when the plugin instance was last
    /// updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The source project id of the plugin instance. This will be the id
    /// of runtime project in case of gcp based plugins and org id in case of non
    /// gcp based plugins. This field will be a required field for Google provided
    /// on-ramp plugins.
    pub source_project_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PluginInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PluginInstance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PluginInstance::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [auth_config][crate::model::PluginInstance::auth_config].
    pub fn set_auth_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AuthConfig>,
    {
        self.auth_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [auth_config][crate::model::PluginInstance::auth_config].
    pub fn set_or_clear_auth_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AuthConfig>,
    {
        self.auth_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [additional_config][crate::model::PluginInstance::additional_config].
    pub fn set_additional_config<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ConfigVariable>,
    {
        use std::iter::Iterator;
        self.additional_config = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::PluginInstance::state].
    pub fn set_state<T: std::convert::Into<crate::model::plugin_instance::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error_message][crate::model::PluginInstance::error_message].
    pub fn set_error_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_message = v.into();
        self
    }

    /// Sets the value of [actions][crate::model::PluginInstance::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PluginInstanceAction>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::PluginInstance::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::PluginInstance::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::PluginInstance::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PluginInstance::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_project_id][crate::model::PluginInstance::source_project_id].
    pub fn set_source_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_project_id = v.into();
        self
    }
}

impl wkt::message::Message for PluginInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.PluginInstance"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PluginInstance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __auth_config,
            __additional_config,
            __state,
            __error_message,
            __actions,
            __create_time,
            __update_time,
            __source_project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PluginInstance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "authConfig" => Ok(__FieldTag::__auth_config),
                            "auth_config" => Ok(__FieldTag::__auth_config),
                            "additionalConfig" => Ok(__FieldTag::__additional_config),
                            "additional_config" => Ok(__FieldTag::__additional_config),
                            "state" => Ok(__FieldTag::__state),
                            "errorMessage" => Ok(__FieldTag::__error_message),
                            "error_message" => Ok(__FieldTag::__error_message),
                            "actions" => Ok(__FieldTag::__actions),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "sourceProjectId" => Ok(__FieldTag::__source_project_id),
                            "source_project_id" => Ok(__FieldTag::__source_project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PluginInstance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PluginInstance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auth_config => {
                            if !fields.insert(__FieldTag::__auth_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auth_config",
                                ));
                            }
                            result.auth_config =
                                map.next_value::<std::option::Option<crate::model::AuthConfig>>()?;
                        }
                        __FieldTag::__additional_config => {
                            if !fields.insert(__FieldTag::__additional_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_config",
                                ));
                            }
                            result.additional_config = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::ConfigVariable,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::plugin_instance::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error_message => {
                            if !fields.insert(__FieldTag::__error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_message",
                                ));
                            }
                            result.error_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__actions => {
                            if !fields.insert(__FieldTag::__actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for actions",
                                ));
                            }
                            result.actions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PluginInstanceAction>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__source_project_id => {
                            if !fields.insert(__FieldTag::__source_project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_project_id",
                                ));
                            }
                            result.source_project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PluginInstance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.auth_config.is_some() {
            state.serialize_entry("authConfig", &self.auth_config)?;
        }
        if !self.additional_config.is_empty() {
            state.serialize_entry("additionalConfig", &self.additional_config)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.error_message.is_empty() {
            state.serialize_entry("errorMessage", &self.error_message)?;
        }
        if !self.actions.is_empty() {
            state.serialize_entry("actions", &self.actions)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.source_project_id.is_empty() {
            state.serialize_entry("sourceProjectId", &self.source_project_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PluginInstance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PluginInstance");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("auth_config", &self.auth_config);
        debug_struct.field("additional_config", &self.additional_config);
        debug_struct.field("state", &self.state);
        debug_struct.field("error_message", &self.error_message);
        debug_struct.field("actions", &self.actions);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("source_project_id", &self.source_project_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PluginInstance].
pub mod plugin_instance {
    #[allow(unused_imports)]
    use super::*;

    /// State represents the state of the plugin instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified state.
        Unspecified,
        /// The plugin instance is being created.
        Creating,
        /// The plugin instance is active and ready for executions. This is the only
        /// state where executions can run on the plugin instance.
        Active,
        /// The updated config that contains
        /// [additional_config][google.cloud.apihub.v1.PluginInstance.additional_config]
        /// and [auth_config][google.cloud.apihub.v1.PluginInstance.auth_config] is
        /// being applied.
        ///
        /// [google.cloud.apihub.v1.PluginInstance.additional_config]: crate::model::PluginInstance::additional_config
        /// [google.cloud.apihub.v1.PluginInstance.auth_config]: crate::model::PluginInstance::auth_config
        ApplyingConfig,
        /// The ERROR state can come while applying config. Users
        /// can retrigger
        /// [ApplyPluginInstanceConfig][google.cloud.apihub.v1.ApiHubPlugin.ApplyPluginInstanceConfig]
        /// to restore the plugin instance back to active state. Note, In case the
        /// ERROR state happens while applying config (auth_config,
        /// additional_config), the plugin instance will reflect the config which was
        /// trying to be applied while error happened. In order to overwrite, trigger
        /// ApplyConfig with a new config.
        Error,
        /// The plugin instance is in a failed state. This indicates that an
        /// unrecoverable error occurred during a previous operation (Create,
        /// Delete).
        Failed,
        /// The plugin instance is being deleted. Delete is only possible if there is
        /// no other operation running on the plugin instance and plugin instance
        /// action.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::ApplyingConfig => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::Deleting => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::ApplyingConfig => std::option::Option::Some("APPLYING_CONFIG"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::ApplyingConfig,
                4 => Self::Error,
                5 => Self::Failed,
                6 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "APPLYING_CONFIG" => Self::ApplyingConfig,
                "ERROR" => Self::Error,
                "FAILED" => Self::Failed,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::ApplyingConfig => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::Deleting => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.apihub.v1.PluginInstance.State",
            ))
        }
    }
}

/// The curation information for this plugin instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CurationConfig {
    /// Required. The curation type for this plugin instance.
    pub curation_type: crate::model::CurationType,

    /// The curation information for this plugin instance.
    pub curation_config: std::option::Option<crate::model::curation_config::CurationConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CurationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [curation_type][crate::model::CurationConfig::curation_type].
    pub fn set_curation_type<T: std::convert::Into<crate::model::CurationType>>(
        mut self,
        v: T,
    ) -> Self {
        self.curation_type = v.into();
        self
    }

    /// Sets the value of [curation_config][crate::model::CurationConfig::curation_config].
    ///
    /// Note that all the setters affecting `curation_config` are mutually
    /// exclusive.
    pub fn set_curation_config<
        T: std::convert::Into<std::option::Option<crate::model::curation_config::CurationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.curation_config = v.into();
        self
    }

    /// The value of [curation_config][crate::model::CurationConfig::curation_config]
    /// if it holds a `CustomCuration`, `None` if the field is not set or
    /// holds a different branch.
    pub fn custom_curation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::curation_config::CustomCuration>> {
        #[allow(unreachable_patterns)]
        self.curation_config.as_ref().and_then(|v| match v {
            crate::model::curation_config::CurationConfig::CustomCuration(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [curation_config][crate::model::CurationConfig::curation_config]
    /// to hold a `CustomCuration`.
    ///
    /// Note that all the setters affecting `curation_config` are
    /// mutually exclusive.
    pub fn set_custom_curation<
        T: std::convert::Into<std::boxed::Box<crate::model::curation_config::CustomCuration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.curation_config = std::option::Option::Some(
            crate::model::curation_config::CurationConfig::CustomCuration(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CurationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.CurationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CurationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __custom_curation,
            __curation_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CurationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "customCuration" => Ok(__FieldTag::__custom_curation),
                            "custom_curation" => Ok(__FieldTag::__custom_curation),
                            "curationType" => Ok(__FieldTag::__curation_type),
                            "curation_type" => Ok(__FieldTag::__curation_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CurationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CurationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__custom_curation => {
                            if !fields.insert(__FieldTag::__custom_curation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_curation",
                                ));
                            }
                            if result.curation_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `curation_config`, a oneof with full ID .google.cloud.apihub.v1.CurationConfig.custom_curation, latest field was customCuration",
                                ));
                            }
                            result.curation_config = std::option::Option::Some(
                                crate::model::curation_config::CurationConfig::CustomCuration(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::curation_config::CustomCuration,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__curation_type => {
                            if !fields.insert(__FieldTag::__curation_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for curation_type",
                                ));
                            }
                            result.curation_type = map
                                .next_value::<std::option::Option<crate::model::CurationType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CurationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.custom_curation() {
            state.serialize_entry("customCuration", value)?;
        }
        if !wkt::internal::is_default(&self.curation_type) {
            state.serialize_entry("curationType", &self.curation_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CurationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CurationConfig");
        debug_struct.field("curation_type", &self.curation_type);
        debug_struct.field("curation_config", &self.curation_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CurationConfig].
pub mod curation_config {
    #[allow(unused_imports)]
    use super::*;

    /// Custom curation information for this plugin instance.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CustomCuration {
        /// Required. The unique name of the curation resource. This will be the name
        /// of the curation resource in the format:
        /// `projects/{project}/locations/{location}/curations/{curation}`
        pub curation: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CustomCuration {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [curation][crate::model::curation_config::CustomCuration::curation].
        pub fn set_curation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.curation = v.into();
            self
        }
    }

    impl wkt::message::Message for CustomCuration {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.CurationConfig.CustomCuration"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CustomCuration {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __curation,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CustomCuration")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "curation" => Ok(__FieldTag::__curation),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CustomCuration;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CustomCuration")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__curation => {
                                if !fields.insert(__FieldTag::__curation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for curation",
                                    ));
                                }
                                result.curation = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CustomCuration {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.curation.is_empty() {
                state.serialize_entry("curation", &self.curation)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for CustomCuration {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("CustomCuration");
            debug_struct.field("curation", &self.curation);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The curation information for this plugin instance.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CurationConfig {
        /// Optional. Custom curation information for this plugin instance.
        CustomCuration(std::boxed::Box<crate::model::curation_config::CustomCuration>),
    }
}

/// The execution status for the plugin instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecutionStatus {
    /// Output only. The current state of the execution.
    pub current_execution_state: crate::model::execution_status::CurrentExecutionState,

    /// Output only. The last execution of the plugin instance.
    pub last_execution: std::option::Option<crate::model::execution_status::LastExecution>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecutionStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [current_execution_state][crate::model::ExecutionStatus::current_execution_state].
    pub fn set_current_execution_state<
        T: std::convert::Into<crate::model::execution_status::CurrentExecutionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.current_execution_state = v.into();
        self
    }

    /// Sets the value of [last_execution][crate::model::ExecutionStatus::last_execution].
    pub fn set_last_execution<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::execution_status::LastExecution>,
    {
        self.last_execution = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_execution][crate::model::ExecutionStatus::last_execution].
    pub fn set_or_clear_last_execution<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::execution_status::LastExecution>,
    {
        self.last_execution = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExecutionStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ExecutionStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExecutionStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __current_execution_state,
            __last_execution,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecutionStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "currentExecutionState" => Ok(__FieldTag::__current_execution_state),
                            "current_execution_state" => Ok(__FieldTag::__current_execution_state),
                            "lastExecution" => Ok(__FieldTag::__last_execution),
                            "last_execution" => Ok(__FieldTag::__last_execution),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExecutionStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecutionStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__current_execution_state => {
                            if !fields.insert(__FieldTag::__current_execution_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_execution_state",
                                ));
                            }
                            result.current_execution_state = map
                                .next_value::<std::option::Option<
                                    crate::model::execution_status::CurrentExecutionState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_execution => {
                            if !fields.insert(__FieldTag::__last_execution) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_execution",
                                ));
                            }
                            result.last_execution = map.next_value::<std::option::Option<
                                crate::model::execution_status::LastExecution,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExecutionStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.current_execution_state) {
            state.serialize_entry("currentExecutionState", &self.current_execution_state)?;
        }
        if self.last_execution.is_some() {
            state.serialize_entry("lastExecution", &self.last_execution)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExecutionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExecutionStatus");
        debug_struct.field("current_execution_state", &self.current_execution_state);
        debug_struct.field("last_execution", &self.last_execution);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ExecutionStatus].
pub mod execution_status {
    #[allow(unused_imports)]
    use super::*;

    /// The result of the last execution of the plugin instance.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LastExecution {
        /// Output only. The result of the last execution of the plugin instance.
        pub result: crate::model::execution_status::last_execution::Result,

        /// Output only. Error message describing the failure, if any, during the
        /// last execution.
        pub error_message: std::string::String,

        /// Output only. The last execution start time of the plugin instance.
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The last execution end time of the plugin instance.
        pub end_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LastExecution {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [result][crate::model::execution_status::LastExecution::result].
        pub fn set_result<
            T: std::convert::Into<crate::model::execution_status::last_execution::Result>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.result = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::execution_status::LastExecution::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }

        /// Sets the value of [start_time][crate::model::execution_status::LastExecution::start_time].
        pub fn set_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_time][crate::model::execution_status::LastExecution::start_time].
        pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [end_time][crate::model::execution_status::LastExecution::end_time].
        pub fn set_end_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.end_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [end_time][crate::model::execution_status::LastExecution::end_time].
        pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.end_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for LastExecution {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.apihub.v1.ExecutionStatus.LastExecution"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LastExecution {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __result,
                __error_message,
                __start_time,
                __end_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LastExecution")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "result" => Ok(__FieldTag::__result),
                                "errorMessage" => Ok(__FieldTag::__error_message),
                                "error_message" => Ok(__FieldTag::__error_message),
                                "startTime" => Ok(__FieldTag::__start_time),
                                "start_time" => Ok(__FieldTag::__start_time),
                                "endTime" => Ok(__FieldTag::__end_time),
                                "end_time" => Ok(__FieldTag::__end_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LastExecution;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LastExecution")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__result => {
                                if !fields.insert(__FieldTag::__result) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for result",
                                    ));
                                }
                                result.result = map
                                    .next_value::<std::option::Option<
                                        crate::model::execution_status::last_execution::Result,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__error_message => {
                                if !fields.insert(__FieldTag::__error_message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error_message",
                                    ));
                                }
                                result.error_message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__start_time => {
                                if !fields.insert(__FieldTag::__start_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for start_time",
                                    ));
                                }
                                result.start_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__end_time => {
                                if !fields.insert(__FieldTag::__end_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for end_time",
                                    ));
                                }
                                result.end_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for LastExecution {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.result) {
                state.serialize_entry("result", &self.result)?;
            }
            if !self.error_message.is_empty() {
                state.serialize_entry("errorMessage", &self.error_message)?;
            }
            if self.start_time.is_some() {
                state.serialize_entry("startTime", &self.start_time)?;
            }
            if self.end_time.is_some() {
                state.serialize_entry("endTime", &self.end_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for LastExecution {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("LastExecution");
            debug_struct.field("result", &self.result);
            debug_struct.field("error_message", &self.error_message);
            debug_struct.field("start_time", &self.start_time);
            debug_struct.field("end_time", &self.end_time);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [LastExecution].
    pub mod last_execution {
        #[allow(unused_imports)]
        use super::*;

        /// Enum for the result of the last execution of the plugin instance.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Result {
            /// Default unspecified execution result.
            Unspecified,
            /// The plugin instance executed successfully.
            Succeeded,
            /// The plugin instance execution failed.
            Failed,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Result::value] or
            /// [Result::name].
            UnknownValue(result::UnknownValue),
        }

        #[doc(hidden)]
        pub mod result {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Result {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Succeeded => std::option::Option::Some(1),
                    Self::Failed => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("RESULT_UNSPECIFIED"),
                    Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                    Self::Failed => std::option::Option::Some("FAILED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Result {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Result {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Result {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Succeeded,
                    2 => Self::Failed,
                    _ => Self::UnknownValue(result::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Result {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "RESULT_UNSPECIFIED" => Self::Unspecified,
                    "SUCCEEDED" => Self::Succeeded,
                    "FAILED" => Self::Failed,
                    _ => Self::UnknownValue(result::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Result {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Succeeded => serializer.serialize_i32(1),
                    Self::Failed => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Result {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Result>::new(
                    ".google.cloud.apihub.v1.ExecutionStatus.LastExecution.Result",
                ))
            }
        }
    }

    /// Enum for the current state of the execution.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CurrentExecutionState {
        /// Default unspecified execution state.
        Unspecified,
        /// The plugin instance is executing.
        Running,
        /// The plugin instance is not running an execution.
        NotRunning,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CurrentExecutionState::value] or
        /// [CurrentExecutionState::name].
        UnknownValue(current_execution_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod current_execution_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CurrentExecutionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::NotRunning => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("CURRENT_EXECUTION_STATE_UNSPECIFIED")
                }
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::NotRunning => std::option::Option::Some("NOT_RUNNING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CurrentExecutionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CurrentExecutionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CurrentExecutionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::NotRunning,
                _ => Self::UnknownValue(current_execution_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CurrentExecutionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CURRENT_EXECUTION_STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "NOT_RUNNING" => Self::NotRunning,
                _ => Self::UnknownValue(current_execution_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CurrentExecutionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::NotRunning => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CurrentExecutionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CurrentExecutionState>::new(
                ".google.cloud.apihub.v1.ExecutionStatus.CurrentExecutionState",
            ))
        }
    }
}

/// The [CreatePlugin][google.cloud.apihub.v1.ApiHubPlugin.CreatePlugin] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHubPlugin.CreatePlugin]: crate::client::ApiHubPlugin::create_plugin
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreatePluginRequest {
    /// Required. The parent resource where this plugin will be created.
    /// Format: `projects/{project}/locations/{location}`.
    pub parent: std::string::String,

    /// Optional. The ID to use for the Plugin resource, which will become the
    /// final component of the Plugin's resource name. This field is optional.
    ///
    /// * If provided, the same will be used. The service will throw an error if
    ///   the specified id is already used by another Plugin resource in the API hub
    ///   instance.
    /// * If not provided, a system generated id will be used.
    ///
    /// This value should be 4-63 characters, overall resource name which will be
    /// of format
    /// `projects/{project}/locations/{location}/plugins/{plugin}`,
    /// its length is limited to 1000 characters and valid characters are
    /// /[a-z][A-Z][0-9]-_/.
    pub plugin_id: std::string::String,

    /// Required. The plugin to create.
    pub plugin: std::option::Option<crate::model::Plugin>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePluginRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePluginRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [plugin_id][crate::model::CreatePluginRequest::plugin_id].
    pub fn set_plugin_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.plugin_id = v.into();
        self
    }

    /// Sets the value of [plugin][crate::model::CreatePluginRequest::plugin].
    pub fn set_plugin<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Plugin>,
    {
        self.plugin = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [plugin][crate::model::CreatePluginRequest::plugin].
    pub fn set_or_clear_plugin<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Plugin>,
    {
        self.plugin = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreatePluginRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.CreatePluginRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreatePluginRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __plugin_id,
            __plugin,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreatePluginRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pluginId" => Ok(__FieldTag::__plugin_id),
                            "plugin_id" => Ok(__FieldTag::__plugin_id),
                            "plugin" => Ok(__FieldTag::__plugin),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreatePluginRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreatePluginRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__plugin_id => {
                            if !fields.insert(__FieldTag::__plugin_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plugin_id",
                                ));
                            }
                            result.plugin_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__plugin => {
                            if !fields.insert(__FieldTag::__plugin) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plugin",
                                ));
                            }
                            result.plugin =
                                map.next_value::<std::option::Option<crate::model::Plugin>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreatePluginRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.plugin_id.is_empty() {
            state.serialize_entry("pluginId", &self.plugin_id)?;
        }
        if self.plugin.is_some() {
            state.serialize_entry("plugin", &self.plugin)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreatePluginRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreatePluginRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("plugin_id", &self.plugin_id);
        debug_struct.field("plugin", &self.plugin);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [DeletePlugin][ApiHub.DeletePlugin] method's request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeletePluginRequest {
    /// Required. The name of the Plugin resource to delete.
    /// Format: `projects/{project}/locations/{location}/plugins/{plugin}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePluginRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePluginRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeletePluginRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DeletePluginRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeletePluginRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeletePluginRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeletePluginRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeletePluginRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeletePluginRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeletePluginRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeletePluginRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [ListPlugins][google.cloud.apihub.v1.ApiHubPlugin.ListPlugins] method's
/// request.
///
/// [google.cloud.apihub.v1.ApiHubPlugin.ListPlugins]: crate::client::ApiHubPlugin::list_plugins
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPluginsRequest {
    /// Required. The parent resource where this plugin will be created.
    /// Format: `projects/{project}/locations/{location}`.
    pub parent: std::string::String,

    /// Optional. An expression that filters the list of plugins.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string. The
    /// comparison operator must be one of: `<`, `>` or
    /// `=`. Filters are not case sensitive.
    ///
    /// The following fields in the `Plugins` are eligible for filtering:
    ///
    /// * `plugin_category` - The category of the Plugin. Allowed
    ///   comparison operators: `=`.
    ///
    /// Expressions are combined with either `AND` logic operator or `OR` logical
    /// operator but not both of them together i.e. only one of the `AND` or `OR`
    /// operator can be used throughout the filter string and both the operators
    /// cannot be used together. No other logical operators are
    /// supported. At most three filter fields are allowed in the filter
    /// string and if provided more than that then `INVALID_ARGUMENT` error is
    /// returned by the API.
    /// Here are a few examples:
    ///
    /// * `plugin_category = ON_RAMP` - The plugin is of category
    ///   on ramp.
    pub filter: std::string::String,

    /// Optional. The maximum number of hub plugins to return. The service may
    /// return fewer than this value. If unspecified, at most 50 hub plugins will
    /// be returned. The maximum value is 1000; values above 1000 will be coerced
    /// to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListPlugins` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters (except page_size) provided to
    /// `ListPlugins` must match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPluginsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPluginsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPluginsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPluginsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPluginsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPluginsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListPluginsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPluginsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPluginsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPluginsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPluginsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPluginsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListPluginsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPluginsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [ListPlugins][google.cloud.apihub.v1.ApiHubPlugin.ListPlugins] method's
/// response.
///
/// [google.cloud.apihub.v1.ApiHubPlugin.ListPlugins]: crate::client::ApiHubPlugin::list_plugins
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPluginsResponse {
    /// The plugins from the specified parent resource.
    pub plugins: std::vec::Vec<crate::model::Plugin>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPluginsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [plugins][crate::model::ListPluginsResponse::plugins].
    pub fn set_plugins<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Plugin>,
    {
        use std::iter::Iterator;
        self.plugins = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPluginsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPluginsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListPluginsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPluginsResponse {
    type PageItem = crate::model::Plugin;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.plugins
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPluginsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __plugins,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPluginsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "plugins" => Ok(__FieldTag::__plugins),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPluginsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPluginsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__plugins => {
                            if !fields.insert(__FieldTag::__plugins) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plugins",
                                ));
                            }
                            result.plugins = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Plugin>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPluginsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.plugins.is_empty() {
            state.serialize_entry("plugins", &self.plugins)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListPluginsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPluginsResponse");
        debug_struct.field("plugins", &self.plugins);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [CreatePluginInstance][google.cloud.apihub.v1.ApiHubPlugin.CreatePluginInstance]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHubPlugin.CreatePluginInstance]: crate::client::ApiHubPlugin::create_plugin_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreatePluginInstanceRequest {
    /// Required. The parent of the plugin instance resource.
    /// Format: `projects/{project}/locations/{location}/plugins/{plugin}`
    pub parent: std::string::String,

    /// Optional. The ID to use for the plugin instance, which will become the
    /// final component of the plugin instance's resource name. This field is
    /// optional.
    ///
    /// * If provided, the same will be used. The service will throw an error if
    ///   the specified id is already used by another plugin instance in the plugin
    ///   resource.
    /// * If not provided, a system generated id will be used.
    ///
    /// This value should be 4-63 characters, and valid characters
    /// are /[a-z][A-Z][0-9]-_/.
    pub plugin_instance_id: std::string::String,

    /// Required. The plugin instance to create.
    pub plugin_instance: std::option::Option<crate::model::PluginInstance>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePluginInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePluginInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [plugin_instance_id][crate::model::CreatePluginInstanceRequest::plugin_instance_id].
    pub fn set_plugin_instance_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.plugin_instance_id = v.into();
        self
    }

    /// Sets the value of [plugin_instance][crate::model::CreatePluginInstanceRequest::plugin_instance].
    pub fn set_plugin_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PluginInstance>,
    {
        self.plugin_instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [plugin_instance][crate::model::CreatePluginInstanceRequest::plugin_instance].
    pub fn set_or_clear_plugin_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PluginInstance>,
    {
        self.plugin_instance = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreatePluginInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.CreatePluginInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreatePluginInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __plugin_instance_id,
            __plugin_instance,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreatePluginInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pluginInstanceId" => Ok(__FieldTag::__plugin_instance_id),
                            "plugin_instance_id" => Ok(__FieldTag::__plugin_instance_id),
                            "pluginInstance" => Ok(__FieldTag::__plugin_instance),
                            "plugin_instance" => Ok(__FieldTag::__plugin_instance),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreatePluginInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreatePluginInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__plugin_instance_id => {
                            if !fields.insert(__FieldTag::__plugin_instance_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plugin_instance_id",
                                ));
                            }
                            result.plugin_instance_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__plugin_instance => {
                            if !fields.insert(__FieldTag::__plugin_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plugin_instance",
                                ));
                            }
                            result.plugin_instance = map
                                .next_value::<std::option::Option<crate::model::PluginInstance>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreatePluginInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.plugin_instance_id.is_empty() {
            state.serialize_entry("pluginInstanceId", &self.plugin_instance_id)?;
        }
        if self.plugin_instance.is_some() {
            state.serialize_entry("pluginInstance", &self.plugin_instance)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreatePluginInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreatePluginInstanceRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("plugin_instance_id", &self.plugin_instance_id);
        debug_struct.field("plugin_instance", &self.plugin_instance);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [ExecutePluginInstanceAction][google.cloud.apihub.v1.ApiHubPlugin.ExecutePluginInstanceAction]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHubPlugin.ExecutePluginInstanceAction]: crate::client::ApiHubPlugin::execute_plugin_instance_action
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecutePluginInstanceActionRequest {
    /// Required. The name of the plugin instance to execute.
    /// Format:
    /// `projects/{project}/locations/{location}/plugins/{plugin}/instances/{instance}`
    pub name: std::string::String,

    /// Required. The execution details for the action to execute.
    pub action_execution_detail: std::option::Option<crate::model::ActionExecutionDetail>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecutePluginInstanceActionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExecutePluginInstanceActionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [action_execution_detail][crate::model::ExecutePluginInstanceActionRequest::action_execution_detail].
    pub fn set_action_execution_detail<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ActionExecutionDetail>,
    {
        self.action_execution_detail = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [action_execution_detail][crate::model::ExecutePluginInstanceActionRequest::action_execution_detail].
    pub fn set_or_clear_action_execution_detail<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ActionExecutionDetail>,
    {
        self.action_execution_detail = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExecutePluginInstanceActionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ExecutePluginInstanceActionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExecutePluginInstanceActionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __action_execution_detail,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecutePluginInstanceActionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "actionExecutionDetail" => Ok(__FieldTag::__action_execution_detail),
                            "action_execution_detail" => Ok(__FieldTag::__action_execution_detail),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExecutePluginInstanceActionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecutePluginInstanceActionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__action_execution_detail => {
                            if !fields.insert(__FieldTag::__action_execution_detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action_execution_detail",
                                ));
                            }
                            result.action_execution_detail = map.next_value::<std::option::Option<crate::model::ActionExecutionDetail>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExecutePluginInstanceActionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.action_execution_detail.is_some() {
            state.serialize_entry("actionExecutionDetail", &self.action_execution_detail)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExecutePluginInstanceActionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExecutePluginInstanceActionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("action_execution_detail", &self.action_execution_detail);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The details for the action to execute.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ActionExecutionDetail {
    /// Required. The action id of the plugin to execute.
    pub action_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ActionExecutionDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [action_id][crate::model::ActionExecutionDetail::action_id].
    pub fn set_action_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action_id = v.into();
        self
    }
}

impl wkt::message::Message for ActionExecutionDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ActionExecutionDetail"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ActionExecutionDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __action_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ActionExecutionDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "actionId" => Ok(__FieldTag::__action_id),
                            "action_id" => Ok(__FieldTag::__action_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ActionExecutionDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ActionExecutionDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__action_id => {
                            if !fields.insert(__FieldTag::__action_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action_id",
                                ));
                            }
                            result.action_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ActionExecutionDetail {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.action_id.is_empty() {
            state.serialize_entry("actionId", &self.action_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ActionExecutionDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ActionExecutionDetail");
        debug_struct.field("action_id", &self.action_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [ExecutePluginInstanceAction][google.cloud.apihub.v1.ApiHubPlugin.ExecutePluginInstanceAction]
/// method's response.
///
/// [google.cloud.apihub.v1.ApiHubPlugin.ExecutePluginInstanceAction]: crate::client::ApiHubPlugin::execute_plugin_instance_action
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecutePluginInstanceActionResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecutePluginInstanceActionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ExecutePluginInstanceActionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ExecutePluginInstanceActionResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExecutePluginInstanceActionResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecutePluginInstanceActionResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExecutePluginInstanceActionResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecutePluginInstanceActionResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExecutePluginInstanceActionResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExecutePluginInstanceActionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExecutePluginInstanceActionResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [GetPluginInstance][google.cloud.apihub.v1.ApiHubPlugin.GetPluginInstance]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHubPlugin.GetPluginInstance]: crate::client::ApiHubPlugin::get_plugin_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPluginInstanceRequest {
    /// Required. The name of the plugin instance to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/plugins/{plugin}/instances/{instance}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPluginInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPluginInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPluginInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetPluginInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetPluginInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPluginInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetPluginInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPluginInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetPluginInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetPluginInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetPluginInstanceRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [ListPluginInstances][google.cloud.apihub.v1.ApiHubPlugin.ListPluginInstances]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHubPlugin.ListPluginInstances]: crate::client::ApiHubPlugin::list_plugin_instances
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPluginInstancesRequest {
    /// Required. The parent resource where this plugin will be created.
    /// Format: `projects/{project}/locations/{location}/plugins/{plugin}`.
    /// To list plugin instances for multiple plugins,
    /// use the - character instead of the plugin ID.
    pub parent: std::string::String,

    /// Optional. An expression that filters the list of plugin instances.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string. The
    /// comparison operator must be one of: `<`, `>` or
    /// `=`. Filters are not case sensitive.
    ///
    /// The following fields in the `PluginInstances` are eligible for filtering:
    ///
    /// * `state` - The state of the Plugin Instance. Allowed
    ///   comparison operators: `=`.
    ///
    /// A filter function is also supported in the filter string. The filter
    /// function is `id(name)`. The `id(name)` function returns the id of the
    /// resource name. For example, `id(name) = \"plugin-instance-1\"` is
    /// equivalent to `name =
    /// \"projects/test-project-id/locations/test-location-id/plugins/plugin-1/instances/plugin-instance-1\"`
    /// provided the parent is
    /// `projects/test-project-id/locations/test-location-id/plugins/plugin-1`.
    ///
    /// Expressions are combined with either `AND` logic operator or `OR` logical
    /// operator but not both of them together i.e. only one of the `AND` or `OR`
    /// operator can be used throughout the filter string and both the operators
    /// cannot be used together. No other logical operators are
    /// supported. At most three filter fields are allowed in the filter
    /// string and if provided more than that then `INVALID_ARGUMENT` error is
    /// returned by the API.
    /// Here are a few examples:
    ///
    /// * `state = ENABLED` - The plugin instance is in enabled state.
    pub filter: std::string::String,

    /// Optional. The maximum number of hub plugins to return. The service may
    /// return fewer than this value. If unspecified, at most 50 hub plugins will
    /// be returned. The maximum value is 1000; values above 1000 will be coerced
    /// to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListPluginInstances`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListPluginInstances`
    /// must match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPluginInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPluginInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPluginInstancesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPluginInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPluginInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPluginInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListPluginInstancesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPluginInstancesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPluginInstancesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPluginInstancesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPluginInstancesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPluginInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListPluginInstancesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPluginInstancesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [ListPluginInstances][google.cloud.apihub.v1.ApiHubPlugin.ListPluginInstances]
/// method's response.
///
/// [google.cloud.apihub.v1.ApiHubPlugin.ListPluginInstances]: crate::client::ApiHubPlugin::list_plugin_instances
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPluginInstancesResponse {
    /// The plugin instances from the specified parent resource.
    pub plugin_instances: std::vec::Vec<crate::model::PluginInstance>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPluginInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [plugin_instances][crate::model::ListPluginInstancesResponse::plugin_instances].
    pub fn set_plugin_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PluginInstance>,
    {
        use std::iter::Iterator;
        self.plugin_instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPluginInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPluginInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListPluginInstancesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPluginInstancesResponse {
    type PageItem = crate::model::PluginInstance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.plugin_instances
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPluginInstancesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __plugin_instances,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPluginInstancesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pluginInstances" => Ok(__FieldTag::__plugin_instances),
                            "plugin_instances" => Ok(__FieldTag::__plugin_instances),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPluginInstancesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPluginInstancesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__plugin_instances => {
                            if !fields.insert(__FieldTag::__plugin_instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plugin_instances",
                                ));
                            }
                            result.plugin_instances =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PluginInstance>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPluginInstancesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.plugin_instances.is_empty() {
            state.serialize_entry("pluginInstances", &self.plugin_instances)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListPluginInstancesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPluginInstancesResponse");
        debug_struct.field("plugin_instances", &self.plugin_instances);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [EnablePluginInstanceAction][google.cloud.apihub.v1.ApiHubPlugin.EnablePluginInstanceAction]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHubPlugin.EnablePluginInstanceAction]: crate::client::ApiHubPlugin::enable_plugin_instance_action
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EnablePluginInstanceActionRequest {
    /// Required. The name of the plugin instance to enable.
    /// Format:
    /// `projects/{project}/locations/{location}/plugins/{plugin}/instances/{instance}`
    pub name: std::string::String,

    /// Required. The action id to enable.
    pub action_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnablePluginInstanceActionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EnablePluginInstanceActionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [action_id][crate::model::EnablePluginInstanceActionRequest::action_id].
    pub fn set_action_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action_id = v.into();
        self
    }
}

impl wkt::message::Message for EnablePluginInstanceActionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.EnablePluginInstanceActionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnablePluginInstanceActionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __action_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnablePluginInstanceActionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "actionId" => Ok(__FieldTag::__action_id),
                            "action_id" => Ok(__FieldTag::__action_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnablePluginInstanceActionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnablePluginInstanceActionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__action_id => {
                            if !fields.insert(__FieldTag::__action_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action_id",
                                ));
                            }
                            result.action_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnablePluginInstanceActionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.action_id.is_empty() {
            state.serialize_entry("actionId", &self.action_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EnablePluginInstanceActionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnablePluginInstanceActionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("action_id", &self.action_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [EnablePluginInstanceAction][google.cloud.apihub.v1.ApiHubPlugin.EnablePluginInstanceAction]
/// method's response.
///
/// [google.cloud.apihub.v1.ApiHubPlugin.EnablePluginInstanceAction]: crate::client::ApiHubPlugin::enable_plugin_instance_action
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EnablePluginInstanceActionResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnablePluginInstanceActionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for EnablePluginInstanceActionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.EnablePluginInstanceActionResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnablePluginInstanceActionResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnablePluginInstanceActionResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnablePluginInstanceActionResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnablePluginInstanceActionResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnablePluginInstanceActionResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EnablePluginInstanceActionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnablePluginInstanceActionResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [DisablePluginInstanceAction][google.cloud.apihub.v1.ApiHubPlugin.DisablePluginInstanceAction]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHubPlugin.DisablePluginInstanceAction]: crate::client::ApiHubPlugin::disable_plugin_instance_action
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DisablePluginInstanceActionRequest {
    /// Required. The name of the plugin instance to disable.
    /// Format:
    /// `projects/{project}/locations/{location}/plugins/{plugin}/instances/{instance}`
    pub name: std::string::String,

    /// Required. The action id to disable.
    pub action_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisablePluginInstanceActionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DisablePluginInstanceActionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [action_id][crate::model::DisablePluginInstanceActionRequest::action_id].
    pub fn set_action_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action_id = v.into();
        self
    }
}

impl wkt::message::Message for DisablePluginInstanceActionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DisablePluginInstanceActionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DisablePluginInstanceActionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __action_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DisablePluginInstanceActionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "actionId" => Ok(__FieldTag::__action_id),
                            "action_id" => Ok(__FieldTag::__action_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DisablePluginInstanceActionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisablePluginInstanceActionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__action_id => {
                            if !fields.insert(__FieldTag::__action_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action_id",
                                ));
                            }
                            result.action_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DisablePluginInstanceActionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.action_id.is_empty() {
            state.serialize_entry("actionId", &self.action_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DisablePluginInstanceActionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DisablePluginInstanceActionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("action_id", &self.action_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [DisablePluginInstanceAction][google.cloud.apihub.v1.ApiHubPlugin.DisablePluginInstanceAction]
/// method's response.
///
/// [google.cloud.apihub.v1.ApiHubPlugin.DisablePluginInstanceAction]: crate::client::ApiHubPlugin::disable_plugin_instance_action
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DisablePluginInstanceActionResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisablePluginInstanceActionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DisablePluginInstanceActionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DisablePluginInstanceActionResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DisablePluginInstanceActionResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DisablePluginInstanceActionResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DisablePluginInstanceActionResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisablePluginInstanceActionResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DisablePluginInstanceActionResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DisablePluginInstanceActionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DisablePluginInstanceActionResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [UpdatePluginInstance][google.cloud.apihub.v1.ApiHubPlugin.UpdatePluginInstance]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHubPlugin.UpdatePluginInstance]: crate::client::ApiHubPlugin::update_plugin_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdatePluginInstanceRequest {
    /// Required. The plugin instance to update.
    pub plugin_instance: std::option::Option<crate::model::PluginInstance>,

    /// Optional. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdatePluginInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [plugin_instance][crate::model::UpdatePluginInstanceRequest::plugin_instance].
    pub fn set_plugin_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PluginInstance>,
    {
        self.plugin_instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [plugin_instance][crate::model::UpdatePluginInstanceRequest::plugin_instance].
    pub fn set_or_clear_plugin_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PluginInstance>,
    {
        self.plugin_instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePluginInstanceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdatePluginInstanceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdatePluginInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.UpdatePluginInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdatePluginInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __plugin_instance,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdatePluginInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pluginInstance" => Ok(__FieldTag::__plugin_instance),
                            "plugin_instance" => Ok(__FieldTag::__plugin_instance),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdatePluginInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdatePluginInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__plugin_instance => {
                            if !fields.insert(__FieldTag::__plugin_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plugin_instance",
                                ));
                            }
                            result.plugin_instance = map
                                .next_value::<std::option::Option<crate::model::PluginInstance>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdatePluginInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.plugin_instance.is_some() {
            state.serialize_entry("pluginInstance", &self.plugin_instance)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdatePluginInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdatePluginInstanceRequest");
        debug_struct.field("plugin_instance", &self.plugin_instance);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [DeletePluginInstance][google.cloud.apihub.v1.ApiHubPlugin.DeletePluginInstance]
/// method's request.
///
/// [google.cloud.apihub.v1.ApiHubPlugin.DeletePluginInstance]: crate::client::ApiHubPlugin::delete_plugin_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeletePluginInstanceRequest {
    /// Required. The name of the plugin instance to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/plugins/{plugin}/instances/{instance}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePluginInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePluginInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeletePluginInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DeletePluginInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeletePluginInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeletePluginInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeletePluginInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeletePluginInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeletePluginInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeletePluginInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeletePluginInstanceRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [CreateApiHubInstance][google.cloud.apihub.v1.Provisioning.CreateApiHubInstance]
/// method's request.
///
/// [google.cloud.apihub.v1.Provisioning.CreateApiHubInstance]: crate::client::Provisioning::create_api_hub_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateApiHubInstanceRequest {
    /// Required. The parent resource for the Api Hub instance resource.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Optional. Identifier to assign to the Api Hub instance. Must be unique
    /// within scope of the parent resource. If the field is not provided, system
    /// generated id will be used.
    ///
    /// This value should be 4-40 characters, and valid characters
    /// are `/[a-z][A-Z][0-9]-_/`.
    pub api_hub_instance_id: std::string::String,

    /// Required. The ApiHub instance.
    pub api_hub_instance: std::option::Option<crate::model::ApiHubInstance>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateApiHubInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateApiHubInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [api_hub_instance_id][crate::model::CreateApiHubInstanceRequest::api_hub_instance_id].
    pub fn set_api_hub_instance_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.api_hub_instance_id = v.into();
        self
    }

    /// Sets the value of [api_hub_instance][crate::model::CreateApiHubInstanceRequest::api_hub_instance].
    pub fn set_api_hub_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApiHubInstance>,
    {
        self.api_hub_instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [api_hub_instance][crate::model::CreateApiHubInstanceRequest::api_hub_instance].
    pub fn set_or_clear_api_hub_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApiHubInstance>,
    {
        self.api_hub_instance = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateApiHubInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.CreateApiHubInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateApiHubInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __api_hub_instance_id,
            __api_hub_instance,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateApiHubInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "apiHubInstanceId" => Ok(__FieldTag::__api_hub_instance_id),
                            "api_hub_instance_id" => Ok(__FieldTag::__api_hub_instance_id),
                            "apiHubInstance" => Ok(__FieldTag::__api_hub_instance),
                            "api_hub_instance" => Ok(__FieldTag::__api_hub_instance),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateApiHubInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateApiHubInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_hub_instance_id => {
                            if !fields.insert(__FieldTag::__api_hub_instance_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_hub_instance_id",
                                ));
                            }
                            result.api_hub_instance_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_hub_instance => {
                            if !fields.insert(__FieldTag::__api_hub_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_hub_instance",
                                ));
                            }
                            result.api_hub_instance = map
                                .next_value::<std::option::Option<crate::model::ApiHubInstance>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateApiHubInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.api_hub_instance_id.is_empty() {
            state.serialize_entry("apiHubInstanceId", &self.api_hub_instance_id)?;
        }
        if self.api_hub_instance.is_some() {
            state.serialize_entry("apiHubInstance", &self.api_hub_instance)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateApiHubInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateApiHubInstanceRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("api_hub_instance_id", &self.api_hub_instance_id);
        debug_struct.field("api_hub_instance", &self.api_hub_instance);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [DeleteApiHubInstance][google.cloud.apihub.v1.Provisioning.DeleteApiHubInstance]
/// method's request.
///
/// [google.cloud.apihub.v1.Provisioning.DeleteApiHubInstance]: crate::client::Provisioning::delete_api_hub_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteApiHubInstanceRequest {
    /// Required. The name of the Api Hub instance to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/apiHubInstances/{apiHubInstance}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteApiHubInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteApiHubInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteApiHubInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DeleteApiHubInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteApiHubInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteApiHubInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteApiHubInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteApiHubInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteApiHubInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteApiHubInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteApiHubInstanceRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [GetApiHubInstance][google.cloud.apihub.v1.Provisioning.GetApiHubInstance]
/// method's request.
///
/// [google.cloud.apihub.v1.Provisioning.GetApiHubInstance]: crate::client::Provisioning::get_api_hub_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetApiHubInstanceRequest {
    /// Required. The name of the Api Hub instance to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/apiHubInstances/{apiHubInstance}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetApiHubInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetApiHubInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetApiHubInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetApiHubInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetApiHubInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetApiHubInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetApiHubInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetApiHubInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetApiHubInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetApiHubInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetApiHubInstanceRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [LookupApiHubInstance][google.cloud.apihub.v1.Provisioning.LookupApiHubInstance]
/// method's request.
///
/// [google.cloud.apihub.v1.Provisioning.LookupApiHubInstance]: crate::client::Provisioning::lookup_api_hub_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LookupApiHubInstanceRequest {
    /// Required. There will always be only one Api Hub instance for a GCP project
    /// across all locations.
    /// The parent resource for the Api Hub instance resource.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LookupApiHubInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::LookupApiHubInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for LookupApiHubInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.LookupApiHubInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LookupApiHubInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LookupApiHubInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LookupApiHubInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LookupApiHubInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LookupApiHubInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LookupApiHubInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LookupApiHubInstanceRequest");
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [LookupApiHubInstance][google.cloud.apihub.v1.Provisioning.LookupApiHubInstance]
/// method's response.`
///
/// [google.cloud.apihub.v1.Provisioning.LookupApiHubInstance]: crate::client::Provisioning::lookup_api_hub_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LookupApiHubInstanceResponse {
    /// API Hub instance for a project if it exists, empty otherwise.
    pub api_hub_instance: std::option::Option<crate::model::ApiHubInstance>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LookupApiHubInstanceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [api_hub_instance][crate::model::LookupApiHubInstanceResponse::api_hub_instance].
    pub fn set_api_hub_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApiHubInstance>,
    {
        self.api_hub_instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [api_hub_instance][crate::model::LookupApiHubInstanceResponse::api_hub_instance].
    pub fn set_or_clear_api_hub_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApiHubInstance>,
    {
        self.api_hub_instance = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LookupApiHubInstanceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.LookupApiHubInstanceResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LookupApiHubInstanceResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __api_hub_instance,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LookupApiHubInstanceResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "apiHubInstance" => Ok(__FieldTag::__api_hub_instance),
                            "api_hub_instance" => Ok(__FieldTag::__api_hub_instance),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LookupApiHubInstanceResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LookupApiHubInstanceResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__api_hub_instance => {
                            if !fields.insert(__FieldTag::__api_hub_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_hub_instance",
                                ));
                            }
                            result.api_hub_instance = map
                                .next_value::<std::option::Option<crate::model::ApiHubInstance>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LookupApiHubInstanceResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.api_hub_instance.is_some() {
            state.serialize_entry("apiHubInstance", &self.api_hub_instance)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LookupApiHubInstanceResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LookupApiHubInstanceResponse");
        debug_struct.field("api_hub_instance", &self.api_hub_instance);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [CreateRuntimeProjectAttachment][google.cloud.apihub.v1.RuntimeProjectAttachmentService.CreateRuntimeProjectAttachment]
/// method's request.
///
/// [google.cloud.apihub.v1.RuntimeProjectAttachmentService.CreateRuntimeProjectAttachment]: crate::client::RuntimeProjectAttachmentService::create_runtime_project_attachment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateRuntimeProjectAttachmentRequest {
    /// Required. The parent resource for the Runtime Project Attachment.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Required. The ID to use for the Runtime Project Attachment, which will
    /// become the final component of the Runtime Project Attachment's name. The ID
    /// must be the same as the project ID of the Google cloud project specified in
    /// the runtime_project_attachment.runtime_project field.
    pub runtime_project_attachment_id: std::string::String,

    /// Required. The Runtime Project Attachment to create.
    pub runtime_project_attachment: std::option::Option<crate::model::RuntimeProjectAttachment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateRuntimeProjectAttachmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateRuntimeProjectAttachmentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [runtime_project_attachment_id][crate::model::CreateRuntimeProjectAttachmentRequest::runtime_project_attachment_id].
    pub fn set_runtime_project_attachment_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_project_attachment_id = v.into();
        self
    }

    /// Sets the value of [runtime_project_attachment][crate::model::CreateRuntimeProjectAttachmentRequest::runtime_project_attachment].
    pub fn set_runtime_project_attachment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeProjectAttachment>,
    {
        self.runtime_project_attachment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [runtime_project_attachment][crate::model::CreateRuntimeProjectAttachmentRequest::runtime_project_attachment].
    pub fn set_or_clear_runtime_project_attachment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeProjectAttachment>,
    {
        self.runtime_project_attachment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateRuntimeProjectAttachmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.CreateRuntimeProjectAttachmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateRuntimeProjectAttachmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __runtime_project_attachment_id,
            __runtime_project_attachment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for CreateRuntimeProjectAttachmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "runtimeProjectAttachmentId" => {
                                Ok(__FieldTag::__runtime_project_attachment_id)
                            }
                            "runtime_project_attachment_id" => {
                                Ok(__FieldTag::__runtime_project_attachment_id)
                            }
                            "runtimeProjectAttachment" => {
                                Ok(__FieldTag::__runtime_project_attachment)
                            }
                            "runtime_project_attachment" => {
                                Ok(__FieldTag::__runtime_project_attachment)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateRuntimeProjectAttachmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateRuntimeProjectAttachmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__runtime_project_attachment_id => {
                            if !fields.insert(__FieldTag::__runtime_project_attachment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_project_attachment_id",
                                ));
                            }
                            result.runtime_project_attachment_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__runtime_project_attachment => {
                            if !fields.insert(__FieldTag::__runtime_project_attachment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_project_attachment",
                                ));
                            }
                            result.runtime_project_attachment = map.next_value::<std::option::Option<crate::model::RuntimeProjectAttachment>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateRuntimeProjectAttachmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.runtime_project_attachment_id.is_empty() {
            state.serialize_entry(
                "runtimeProjectAttachmentId",
                &self.runtime_project_attachment_id,
            )?;
        }
        if self.runtime_project_attachment.is_some() {
            state.serialize_entry("runtimeProjectAttachment", &self.runtime_project_attachment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateRuntimeProjectAttachmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateRuntimeProjectAttachmentRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field(
            "runtime_project_attachment_id",
            &self.runtime_project_attachment_id,
        );
        debug_struct.field(
            "runtime_project_attachment",
            &self.runtime_project_attachment,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [GetRuntimeProjectAttachment][google.cloud.apihub.v1.RuntimeProjectAttachmentService.GetRuntimeProjectAttachment]
/// method's request.
///
/// [google.cloud.apihub.v1.RuntimeProjectAttachmentService.GetRuntimeProjectAttachment]: crate::client::RuntimeProjectAttachmentService::get_runtime_project_attachment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetRuntimeProjectAttachmentRequest {
    /// Required. The name of the API resource to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/runtimeProjectAttachments/{runtime_project_attachment}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRuntimeProjectAttachmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRuntimeProjectAttachmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRuntimeProjectAttachmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.GetRuntimeProjectAttachmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetRuntimeProjectAttachmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetRuntimeProjectAttachmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetRuntimeProjectAttachmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetRuntimeProjectAttachmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetRuntimeProjectAttachmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetRuntimeProjectAttachmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetRuntimeProjectAttachmentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [ListRuntimeProjectAttachments][google.cloud.apihub.v1.RuntimeProjectAttachmentService.ListRuntimeProjectAttachments]
/// method's request.
///
/// [google.cloud.apihub.v1.RuntimeProjectAttachmentService.ListRuntimeProjectAttachments]: crate::client::RuntimeProjectAttachmentService::list_runtime_project_attachments
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRuntimeProjectAttachmentsRequest {
    /// Required. The parent, which owns this collection of runtime project
    /// attachments. Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Optional. The maximum number of runtime project attachments to return. The
    /// service may return fewer than this value. If unspecified, at most 50
    /// runtime project attachments will be returned. The maximum value is 1000;
    /// values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous
    /// `ListRuntimeProjectAttachments` call. Provide this to retrieve the
    /// subsequent page.
    ///
    /// When paginating, all other parameters (except page_size) provided to
    /// `ListRuntimeProjectAttachments` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    /// Optional. An expression that filters the list of RuntimeProjectAttachments.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string. All
    /// standard operators as documented at <https://google.aip.dev/160> are
    /// supported.
    ///
    /// The following fields in the `RuntimeProjectAttachment` are eligible for
    /// filtering:
    ///
    /// * `name` - The name of the RuntimeProjectAttachment.
    /// * `create_time` - The time at which the RuntimeProjectAttachment was
    ///   created. The value should be in the
    ///   (RFC3339)[<https://tools.ietf.org/html/rfc3339>] format.
    /// * `runtime_project` - The Google cloud project associated with the
    ///   RuntimeProjectAttachment.
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRuntimeProjectAttachmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRuntimeProjectAttachmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRuntimeProjectAttachmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRuntimeProjectAttachmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRuntimeProjectAttachmentsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListRuntimeProjectAttachmentsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListRuntimeProjectAttachmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListRuntimeProjectAttachmentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRuntimeProjectAttachmentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRuntimeProjectAttachmentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRuntimeProjectAttachmentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRuntimeProjectAttachmentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRuntimeProjectAttachmentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListRuntimeProjectAttachmentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRuntimeProjectAttachmentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [ListRuntimeProjectAttachments][google.cloud.apihub.v1.RuntimeProjectAttachmentService.ListRuntimeProjectAttachments]
/// method's response.
///
/// [google.cloud.apihub.v1.RuntimeProjectAttachmentService.ListRuntimeProjectAttachments]: crate::client::RuntimeProjectAttachmentService::list_runtime_project_attachments
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRuntimeProjectAttachmentsResponse {
    /// List of runtime project attachments.
    pub runtime_project_attachments: std::vec::Vec<crate::model::RuntimeProjectAttachment>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRuntimeProjectAttachmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [runtime_project_attachments][crate::model::ListRuntimeProjectAttachmentsResponse::runtime_project_attachments].
    pub fn set_runtime_project_attachments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RuntimeProjectAttachment>,
    {
        use std::iter::Iterator;
        self.runtime_project_attachments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRuntimeProjectAttachmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRuntimeProjectAttachmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.ListRuntimeProjectAttachmentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRuntimeProjectAttachmentsResponse {
    type PageItem = crate::model::RuntimeProjectAttachment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.runtime_project_attachments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRuntimeProjectAttachmentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __runtime_project_attachments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListRuntimeProjectAttachmentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "runtimeProjectAttachments" => {
                                Ok(__FieldTag::__runtime_project_attachments)
                            }
                            "runtime_project_attachments" => {
                                Ok(__FieldTag::__runtime_project_attachments)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRuntimeProjectAttachmentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRuntimeProjectAttachmentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__runtime_project_attachments => {
                            if !fields.insert(__FieldTag::__runtime_project_attachments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_project_attachments",
                                ));
                            }
                            result.runtime_project_attachments = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RuntimeProjectAttachment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRuntimeProjectAttachmentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.runtime_project_attachments.is_empty() {
            state.serialize_entry(
                "runtimeProjectAttachments",
                &self.runtime_project_attachments,
            )?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListRuntimeProjectAttachmentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRuntimeProjectAttachmentsResponse");
        debug_struct.field(
            "runtime_project_attachments",
            &self.runtime_project_attachments,
        );
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [DeleteRuntimeProjectAttachment][google.cloud.apihub.v1.RuntimeProjectAttachmentService.DeleteRuntimeProjectAttachment]
/// method's request.
///
/// [google.cloud.apihub.v1.RuntimeProjectAttachmentService.DeleteRuntimeProjectAttachment]: crate::client::RuntimeProjectAttachmentService::delete_runtime_project_attachment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteRuntimeProjectAttachmentRequest {
    /// Required. The name of the Runtime Project Attachment to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/runtimeProjectAttachments/{runtime_project_attachment}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRuntimeProjectAttachmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRuntimeProjectAttachmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRuntimeProjectAttachmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.DeleteRuntimeProjectAttachmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteRuntimeProjectAttachmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for DeleteRuntimeProjectAttachmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteRuntimeProjectAttachmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteRuntimeProjectAttachmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteRuntimeProjectAttachmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteRuntimeProjectAttachmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteRuntimeProjectAttachmentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [LookupRuntimeProjectAttachment][google.cloud.apihub.v1.RuntimeProjectAttachmentService.LookupRuntimeProjectAttachment]
/// method's request.
///
/// [google.cloud.apihub.v1.RuntimeProjectAttachmentService.LookupRuntimeProjectAttachment]: crate::client::RuntimeProjectAttachmentService::lookup_runtime_project_attachment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LookupRuntimeProjectAttachmentRequest {
    /// Required. Runtime project ID to look up runtime project attachment for.
    /// Lookup happens across all regions. Expected format:
    /// `projects/{project}/locations/{location}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LookupRuntimeProjectAttachmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LookupRuntimeProjectAttachmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for LookupRuntimeProjectAttachmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.LookupRuntimeProjectAttachmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LookupRuntimeProjectAttachmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for LookupRuntimeProjectAttachmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LookupRuntimeProjectAttachmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LookupRuntimeProjectAttachmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LookupRuntimeProjectAttachmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LookupRuntimeProjectAttachmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LookupRuntimeProjectAttachmentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The
/// [ListRuntimeProjectAttachments][google.cloud.apihub.v1.RuntimeProjectAttachmentService.ListRuntimeProjectAttachments]
/// method's response.
///
/// [google.cloud.apihub.v1.RuntimeProjectAttachmentService.ListRuntimeProjectAttachments]: crate::client::RuntimeProjectAttachmentService::list_runtime_project_attachments
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LookupRuntimeProjectAttachmentResponse {
    /// Runtime project attachment for a project if exists, empty otherwise.
    pub runtime_project_attachment: std::option::Option<crate::model::RuntimeProjectAttachment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LookupRuntimeProjectAttachmentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [runtime_project_attachment][crate::model::LookupRuntimeProjectAttachmentResponse::runtime_project_attachment].
    pub fn set_runtime_project_attachment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeProjectAttachment>,
    {
        self.runtime_project_attachment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [runtime_project_attachment][crate::model::LookupRuntimeProjectAttachmentResponse::runtime_project_attachment].
    pub fn set_or_clear_runtime_project_attachment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeProjectAttachment>,
    {
        self.runtime_project_attachment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LookupRuntimeProjectAttachmentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.LookupRuntimeProjectAttachmentResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LookupRuntimeProjectAttachmentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __runtime_project_attachment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for LookupRuntimeProjectAttachmentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "runtimeProjectAttachment" => {
                                Ok(__FieldTag::__runtime_project_attachment)
                            }
                            "runtime_project_attachment" => {
                                Ok(__FieldTag::__runtime_project_attachment)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LookupRuntimeProjectAttachmentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LookupRuntimeProjectAttachmentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__runtime_project_attachment => {
                            if !fields.insert(__FieldTag::__runtime_project_attachment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_project_attachment",
                                ));
                            }
                            result.runtime_project_attachment = map.next_value::<std::option::Option<crate::model::RuntimeProjectAttachment>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LookupRuntimeProjectAttachmentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.runtime_project_attachment.is_some() {
            state.serialize_entry("runtimeProjectAttachment", &self.runtime_project_attachment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LookupRuntimeProjectAttachmentResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LookupRuntimeProjectAttachmentResponse");
        debug_struct.field(
            "runtime_project_attachment",
            &self.runtime_project_attachment,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Runtime project attachment represents an attachment from the runtime project
/// to the host project. Api Hub looks for deployments in the attached runtime
/// projects and creates corresponding resources in Api Hub for the discovered
/// deployments.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RuntimeProjectAttachment {
    /// Identifier. The resource name of a runtime project attachment. Format:
    /// "projects/{project}/locations/{location}/runtimeProjectAttachments/{runtime_project_attachment}".
    pub name: std::string::String,

    /// Required. Immutable. Google cloud project name in the format:
    /// "projects/abc" or "projects/123". As input, project name with either
    /// project id or number are accepted. As output, this field will contain
    /// project number.
    pub runtime_project: std::string::String,

    /// Output only. Create time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuntimeProjectAttachment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RuntimeProjectAttachment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [runtime_project][crate::model::RuntimeProjectAttachment::runtime_project].
    pub fn set_runtime_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.runtime_project = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::RuntimeProjectAttachment::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::RuntimeProjectAttachment::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RuntimeProjectAttachment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apihub.v1.RuntimeProjectAttachment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RuntimeProjectAttachment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __runtime_project,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RuntimeProjectAttachment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "runtimeProject" => Ok(__FieldTag::__runtime_project),
                            "runtime_project" => Ok(__FieldTag::__runtime_project),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RuntimeProjectAttachment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RuntimeProjectAttachment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__runtime_project => {
                            if !fields.insert(__FieldTag::__runtime_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_project",
                                ));
                            }
                            result.runtime_project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RuntimeProjectAttachment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.runtime_project.is_empty() {
            state.serialize_entry("runtimeProject", &self.runtime_project)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RuntimeProjectAttachment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RuntimeProjectAttachment");
        debug_struct.field("name", &self.name);
        debug_struct.field("runtime_project", &self.runtime_project);
        debug_struct.field("create_time", &self.create_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The type of the collect request.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CollectionType {
    /// The default value. This value is used if the collection type is omitted.
    Unspecified,
    /// The collection type is upsert. This should be used when an API is created
    /// or updated at the source.
    Upsert,
    /// The collection type is delete. This should be used when an API is deleted
    /// at the source.
    Delete,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CollectionType::value] or
    /// [CollectionType::name].
    UnknownValue(collection_type::UnknownValue),
}

#[doc(hidden)]
pub mod collection_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CollectionType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Upsert => std::option::Option::Some(1),
            Self::Delete => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("COLLECTION_TYPE_UNSPECIFIED"),
            Self::Upsert => std::option::Option::Some("COLLECTION_TYPE_UPSERT"),
            Self::Delete => std::option::Option::Some("COLLECTION_TYPE_DELETE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CollectionType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CollectionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CollectionType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Upsert,
            2 => Self::Delete,
            _ => Self::UnknownValue(collection_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for CollectionType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COLLECTION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "COLLECTION_TYPE_UPSERT" => Self::Upsert,
            "COLLECTION_TYPE_DELETE" => Self::Delete,
            _ => Self::UnknownValue(collection_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for CollectionType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Upsert => serializer.serialize_i32(1),
            Self::Delete => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CollectionType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CollectionType>::new(
            ".google.cloud.apihub.v1.CollectionType",
        ))
    }
}

/// Lint state represents success or failure for linting.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum LintState {
    /// Lint state unspecified.
    Unspecified,
    /// Linting was completed successfully.
    Success,
    /// Linting encountered errors.
    Error,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [LintState::value] or
    /// [LintState::name].
    UnknownValue(lint_state::UnknownValue),
}

#[doc(hidden)]
pub mod lint_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl LintState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Success => std::option::Option::Some(1),
            Self::Error => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("LINT_STATE_UNSPECIFIED"),
            Self::Success => std::option::Option::Some("LINT_STATE_SUCCESS"),
            Self::Error => std::option::Option::Some("LINT_STATE_ERROR"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for LintState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for LintState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for LintState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Success,
            2 => Self::Error,
            _ => Self::UnknownValue(lint_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for LintState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "LINT_STATE_UNSPECIFIED" => Self::Unspecified,
            "LINT_STATE_SUCCESS" => Self::Success,
            "LINT_STATE_ERROR" => Self::Error,
            _ => Self::UnknownValue(lint_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for LintState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Success => serializer.serialize_i32(1),
            Self::Error => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for LintState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<LintState>::new(
            ".google.cloud.apihub.v1.LintState",
        ))
    }
}

/// Enumeration of linter types.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Linter {
    /// Linter type unspecified.
    Unspecified,
    /// Linter type spectral.
    Spectral,
    /// Linter type other.
    Other,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Linter::value] or
    /// [Linter::name].
    UnknownValue(linter::UnknownValue),
}

#[doc(hidden)]
pub mod linter {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Linter {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Spectral => std::option::Option::Some(1),
            Self::Other => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("LINTER_UNSPECIFIED"),
            Self::Spectral => std::option::Option::Some("SPECTRAL"),
            Self::Other => std::option::Option::Some("OTHER"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Linter {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Linter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Linter {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Spectral,
            2 => Self::Other,
            _ => Self::UnknownValue(linter::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Linter {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "LINTER_UNSPECIFIED" => Self::Unspecified,
            "SPECTRAL" => Self::Spectral,
            "OTHER" => Self::Other,
            _ => Self::UnknownValue(linter::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Linter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Spectral => serializer.serialize_i32(1),
            Self::Other => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Linter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Linter>::new(
            ".google.cloud.apihub.v1.Linter",
        ))
    }
}

/// Severity of the issue.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Severity {
    /// Severity unspecified.
    Unspecified,
    /// Severity error.
    Error,
    /// Severity warning.
    Warning,
    /// Severity info.
    Info,
    /// Severity hint.
    Hint,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Severity::value] or
    /// [Severity::name].
    UnknownValue(severity::UnknownValue),
}

#[doc(hidden)]
pub mod severity {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Severity {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Error => std::option::Option::Some(1),
            Self::Warning => std::option::Option::Some(2),
            Self::Info => std::option::Option::Some(3),
            Self::Hint => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
            Self::Error => std::option::Option::Some("SEVERITY_ERROR"),
            Self::Warning => std::option::Option::Some("SEVERITY_WARNING"),
            Self::Info => std::option::Option::Some("SEVERITY_INFO"),
            Self::Hint => std::option::Option::Some("SEVERITY_HINT"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Severity {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Severity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Severity {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Error,
            2 => Self::Warning,
            3 => Self::Info,
            4 => Self::Hint,
            _ => Self::UnknownValue(severity::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Severity {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SEVERITY_UNSPECIFIED" => Self::Unspecified,
            "SEVERITY_ERROR" => Self::Error,
            "SEVERITY_WARNING" => Self::Warning,
            "SEVERITY_INFO" => Self::Info,
            "SEVERITY_HINT" => Self::Hint,
            _ => Self::UnknownValue(severity::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Severity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Error => serializer.serialize_i32(1),
            Self::Warning => serializer.serialize_i32(2),
            Self::Info => serializer.serialize_i32(3),
            Self::Hint => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Severity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
            ".google.cloud.apihub.v1.Severity",
        ))
    }
}

/// AuthType represents the authentication type.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AuthType {
    /// Authentication type not specified.
    Unspecified,
    /// No authentication.
    NoAuth,
    /// Google service account authentication.
    GoogleServiceAccount,
    /// Username and password authentication.
    UserPassword,
    /// API Key authentication.
    ApiKey,
    /// Oauth 2.0 client credentials grant authentication.
    Oauth2ClientCredentials,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AuthType::value] or
    /// [AuthType::name].
    UnknownValue(auth_type::UnknownValue),
}

#[doc(hidden)]
pub mod auth_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl AuthType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::NoAuth => std::option::Option::Some(1),
            Self::GoogleServiceAccount => std::option::Option::Some(2),
            Self::UserPassword => std::option::Option::Some(3),
            Self::ApiKey => std::option::Option::Some(4),
            Self::Oauth2ClientCredentials => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("AUTH_TYPE_UNSPECIFIED"),
            Self::NoAuth => std::option::Option::Some("NO_AUTH"),
            Self::GoogleServiceAccount => std::option::Option::Some("GOOGLE_SERVICE_ACCOUNT"),
            Self::UserPassword => std::option::Option::Some("USER_PASSWORD"),
            Self::ApiKey => std::option::Option::Some("API_KEY"),
            Self::Oauth2ClientCredentials => std::option::Option::Some("OAUTH2_CLIENT_CREDENTIALS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for AuthType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for AuthType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for AuthType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::NoAuth,
            2 => Self::GoogleServiceAccount,
            3 => Self::UserPassword,
            4 => Self::ApiKey,
            5 => Self::Oauth2ClientCredentials,
            _ => Self::UnknownValue(auth_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for AuthType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "AUTH_TYPE_UNSPECIFIED" => Self::Unspecified,
            "NO_AUTH" => Self::NoAuth,
            "GOOGLE_SERVICE_ACCOUNT" => Self::GoogleServiceAccount,
            "USER_PASSWORD" => Self::UserPassword,
            "API_KEY" => Self::ApiKey,
            "OAUTH2_CLIENT_CREDENTIALS" => Self::Oauth2ClientCredentials,
            _ => Self::UnknownValue(auth_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for AuthType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::NoAuth => serializer.serialize_i32(1),
            Self::GoogleServiceAccount => serializer.serialize_i32(2),
            Self::UserPassword => serializer.serialize_i32(3),
            Self::ApiKey => serializer.serialize_i32(4),
            Self::Oauth2ClientCredentials => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for AuthType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AuthType>::new(
            ".google.cloud.apihub.v1.AuthType",
        ))
    }
}

/// Enum for the plugin category.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum PluginCategory {
    /// Default unspecified plugin type.
    Unspecified,
    /// API_GATEWAY plugins represent plugins built for API Gateways like Apigee.
    ApiGateway,
    /// API_PRODUCER plugins represent plugins built for API Producers like
    /// Cloud Run, Application Integration etc.
    ApiProducer,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [PluginCategory::value] or
    /// [PluginCategory::name].
    UnknownValue(plugin_category::UnknownValue),
}

#[doc(hidden)]
pub mod plugin_category {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl PluginCategory {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::ApiGateway => std::option::Option::Some(1),
            Self::ApiProducer => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("PLUGIN_CATEGORY_UNSPECIFIED"),
            Self::ApiGateway => std::option::Option::Some("API_GATEWAY"),
            Self::ApiProducer => std::option::Option::Some("API_PRODUCER"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for PluginCategory {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for PluginCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for PluginCategory {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::ApiGateway,
            2 => Self::ApiProducer,
            _ => Self::UnknownValue(plugin_category::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for PluginCategory {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "PLUGIN_CATEGORY_UNSPECIFIED" => Self::Unspecified,
            "API_GATEWAY" => Self::ApiGateway,
            "API_PRODUCER" => Self::ApiProducer,
            _ => Self::UnknownValue(plugin_category::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for PluginCategory {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::ApiGateway => serializer.serialize_i32(1),
            Self::ApiProducer => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for PluginCategory {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<PluginCategory>::new(
            ".google.cloud.apihub.v1.PluginCategory",
        ))
    }
}

/// Enum for the action type.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ActionType {
    /// Default unspecified action type.
    Unspecified,
    /// Action type for sync metadata.
    SyncMetadata,
    /// Action type for sync runtime data.
    SyncRuntimeData,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ActionType::value] or
    /// [ActionType::name].
    UnknownValue(action_type::UnknownValue),
}

#[doc(hidden)]
pub mod action_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ActionType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::SyncMetadata => std::option::Option::Some(1),
            Self::SyncRuntimeData => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ACTION_TYPE_UNSPECIFIED"),
            Self::SyncMetadata => std::option::Option::Some("SYNC_METADATA"),
            Self::SyncRuntimeData => std::option::Option::Some("SYNC_RUNTIME_DATA"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ActionType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ActionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ActionType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::SyncMetadata,
            2 => Self::SyncRuntimeData,
            _ => Self::UnknownValue(action_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ActionType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ACTION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "SYNC_METADATA" => Self::SyncMetadata,
            "SYNC_RUNTIME_DATA" => Self::SyncRuntimeData,
            _ => Self::UnknownValue(action_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ActionType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::SyncMetadata => serializer.serialize_i32(1),
            Self::SyncRuntimeData => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ActionType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ActionType>::new(
            ".google.cloud.apihub.v1.ActionType",
        ))
    }
}

/// Enum for the gateway type.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum GatewayType {
    /// The gateway type is not specified.
    Unspecified,
    /// The gateway type is Apigee X and Hybrid.
    ApigeeXAndHybrid,
    /// The gateway type is Apigee Edge Public Cloud.
    ApigeeEdgePublicCloud,
    /// The gateway type is Apigee Edge Private Cloud.
    ApigeeEdgePrivateCloud,
    /// The gateway type is Cloud API Gateway.
    CloudApiGateway,
    /// The gateway type is Cloud Endpoints.
    CloudEndpoints,
    /// The gateway type is API Discovery.
    ApiDiscovery,
    /// The gateway type for any other types of gateways.
    Others,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [GatewayType::value] or
    /// [GatewayType::name].
    UnknownValue(gateway_type::UnknownValue),
}

#[doc(hidden)]
pub mod gateway_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl GatewayType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::ApigeeXAndHybrid => std::option::Option::Some(1),
            Self::ApigeeEdgePublicCloud => std::option::Option::Some(2),
            Self::ApigeeEdgePrivateCloud => std::option::Option::Some(3),
            Self::CloudApiGateway => std::option::Option::Some(4),
            Self::CloudEndpoints => std::option::Option::Some(5),
            Self::ApiDiscovery => std::option::Option::Some(6),
            Self::Others => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("GATEWAY_TYPE_UNSPECIFIED"),
            Self::ApigeeXAndHybrid => std::option::Option::Some("APIGEE_X_AND_HYBRID"),
            Self::ApigeeEdgePublicCloud => std::option::Option::Some("APIGEE_EDGE_PUBLIC_CLOUD"),
            Self::ApigeeEdgePrivateCloud => std::option::Option::Some("APIGEE_EDGE_PRIVATE_CLOUD"),
            Self::CloudApiGateway => std::option::Option::Some("CLOUD_API_GATEWAY"),
            Self::CloudEndpoints => std::option::Option::Some("CLOUD_ENDPOINTS"),
            Self::ApiDiscovery => std::option::Option::Some("API_DISCOVERY"),
            Self::Others => std::option::Option::Some("OTHERS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for GatewayType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for GatewayType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for GatewayType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::ApigeeXAndHybrid,
            2 => Self::ApigeeEdgePublicCloud,
            3 => Self::ApigeeEdgePrivateCloud,
            4 => Self::CloudApiGateway,
            5 => Self::CloudEndpoints,
            6 => Self::ApiDiscovery,
            7 => Self::Others,
            _ => Self::UnknownValue(gateway_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for GatewayType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "GATEWAY_TYPE_UNSPECIFIED" => Self::Unspecified,
            "APIGEE_X_AND_HYBRID" => Self::ApigeeXAndHybrid,
            "APIGEE_EDGE_PUBLIC_CLOUD" => Self::ApigeeEdgePublicCloud,
            "APIGEE_EDGE_PRIVATE_CLOUD" => Self::ApigeeEdgePrivateCloud,
            "CLOUD_API_GATEWAY" => Self::CloudApiGateway,
            "CLOUD_ENDPOINTS" => Self::CloudEndpoints,
            "API_DISCOVERY" => Self::ApiDiscovery,
            "OTHERS" => Self::Others,
            _ => Self::UnknownValue(gateway_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for GatewayType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::ApigeeXAndHybrid => serializer.serialize_i32(1),
            Self::ApigeeEdgePublicCloud => serializer.serialize_i32(2),
            Self::ApigeeEdgePrivateCloud => serializer.serialize_i32(3),
            Self::CloudApiGateway => serializer.serialize_i32(4),
            Self::CloudEndpoints => serializer.serialize_i32(5),
            Self::ApiDiscovery => serializer.serialize_i32(6),
            Self::Others => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for GatewayType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<GatewayType>::new(
            ".google.cloud.apihub.v1.GatewayType",
        ))
    }
}

/// Enum for the curation type.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CurationType {
    /// Default unspecified curation type.
    Unspecified,
    /// Default curation for API metadata will be used.
    DefaultCurationForApiMetadata,
    /// Custom curation for API metadata will be used.
    CustomCurationForApiMetadata,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CurationType::value] or
    /// [CurationType::name].
    UnknownValue(curation_type::UnknownValue),
}

#[doc(hidden)]
pub mod curation_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CurationType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::DefaultCurationForApiMetadata => std::option::Option::Some(1),
            Self::CustomCurationForApiMetadata => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CURATION_TYPE_UNSPECIFIED"),
            Self::DefaultCurationForApiMetadata => {
                std::option::Option::Some("DEFAULT_CURATION_FOR_API_METADATA")
            }
            Self::CustomCurationForApiMetadata => {
                std::option::Option::Some("CUSTOM_CURATION_FOR_API_METADATA")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CurationType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CurationType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CurationType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::DefaultCurationForApiMetadata,
            2 => Self::CustomCurationForApiMetadata,
            _ => Self::UnknownValue(curation_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for CurationType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CURATION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "DEFAULT_CURATION_FOR_API_METADATA" => Self::DefaultCurationForApiMetadata,
            "CUSTOM_CURATION_FOR_API_METADATA" => Self::CustomCurationForApiMetadata,
            _ => Self::UnknownValue(curation_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for CurationType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::DefaultCurationForApiMetadata => serializer.serialize_i32(1),
            Self::CustomCurationForApiMetadata => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CurationType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CurationType>::new(
            ".google.cloud.apihub.v1.CurationType",
        ))
    }
}
