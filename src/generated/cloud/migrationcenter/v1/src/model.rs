// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// An asset represents a resource in your environment. Asset types include
/// virtual machines and databases.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Asset {
    /// Output only. The full name of the asset.
    pub name: std::string::String,

    /// Output only. The timestamp when the asset was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the asset was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels as key value pairs.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Generic asset attributes.
    pub attributes: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The list of insights associated with the asset.
    pub insight_list: std::option::Option<crate::model::InsightList>,

    /// Output only. Performance data for the asset.
    pub performance_data: std::option::Option<crate::model::AssetPerformanceData>,

    /// Output only. The list of sources contributing to the asset.
    pub sources: std::vec::Vec<std::string::String>,

    /// Output only. The list of groups that the asset is assigned to.
    pub assigned_groups: std::vec::Vec<std::string::String>,

    /// The internal information of an asset. Only one field can be specified
    /// with different attributes based on the type of the asset.
    pub asset_details: std::option::Option<crate::model::asset::AssetDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Asset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Asset::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Asset::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Asset::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Asset::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Asset::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Asset::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [attributes][crate::model::Asset::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [insight_list][crate::model::Asset::insight_list].
    pub fn set_insight_list<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InsightList>,
    {
        self.insight_list = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [insight_list][crate::model::Asset::insight_list].
    pub fn set_or_clear_insight_list<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InsightList>,
    {
        self.insight_list = v.map(|x| x.into());
        self
    }

    /// Sets the value of [performance_data][crate::model::Asset::performance_data].
    pub fn set_performance_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AssetPerformanceData>,
    {
        self.performance_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [performance_data][crate::model::Asset::performance_data].
    pub fn set_or_clear_performance_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AssetPerformanceData>,
    {
        self.performance_data = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sources][crate::model::Asset::sources].
    pub fn set_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.sources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [assigned_groups][crate::model::Asset::assigned_groups].
    pub fn set_assigned_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.assigned_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [asset_details][crate::model::Asset::asset_details].
    ///
    /// Note that all the setters affecting `asset_details` are mutually
    /// exclusive.
    pub fn set_asset_details<
        T: std::convert::Into<std::option::Option<crate::model::asset::AssetDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.asset_details = v.into();
        self
    }

    /// The value of [asset_details][crate::model::Asset::asset_details]
    /// if it holds a `MachineDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn machine_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MachineDetails>> {
        #[allow(unreachable_patterns)]
        self.asset_details.as_ref().and_then(|v| match v {
            crate::model::asset::AssetDetails::MachineDetails(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [asset_details][crate::model::Asset::asset_details]
    /// to hold a `MachineDetails`.
    ///
    /// Note that all the setters affecting `asset_details` are
    /// mutually exclusive.
    pub fn set_machine_details<
        T: std::convert::Into<std::boxed::Box<crate::model::MachineDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.asset_details =
            std::option::Option::Some(crate::model::asset::AssetDetails::MachineDetails(v.into()));
        self
    }
}

impl wkt::message::Message for Asset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.Asset"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Asset {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __attributes,
            __machine_details,
            __insight_list,
            __performance_data,
            __sources,
            __assigned_groups,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Asset")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "attributes" => Ok(__FieldTag::__attributes),
                            "machineDetails" => Ok(__FieldTag::__machine_details),
                            "machine_details" => Ok(__FieldTag::__machine_details),
                            "insightList" => Ok(__FieldTag::__insight_list),
                            "insight_list" => Ok(__FieldTag::__insight_list),
                            "performanceData" => Ok(__FieldTag::__performance_data),
                            "performance_data" => Ok(__FieldTag::__performance_data),
                            "sources" => Ok(__FieldTag::__sources),
                            "assignedGroups" => Ok(__FieldTag::__assigned_groups),
                            "assigned_groups" => Ok(__FieldTag::__assigned_groups),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Asset;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Asset")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_details => {
                            if !fields.insert(__FieldTag::__machine_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_details",
                                ));
                            }
                            if result.asset_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `asset_details`, a oneof with full ID .google.cloud.migrationcenter.v1.Asset.machine_details, latest field was machineDetails",
                                ));
                            }
                            result.asset_details = std::option::Option::Some(
                                crate::model::asset::AssetDetails::MachineDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MachineDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__insight_list => {
                            if !fields.insert(__FieldTag::__insight_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insight_list",
                                ));
                            }
                            result.insight_list =
                                map.next_value::<std::option::Option<crate::model::InsightList>>()?;
                        }
                        __FieldTag::__performance_data => {
                            if !fields.insert(__FieldTag::__performance_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for performance_data",
                                ));
                            }
                            result.performance_data = map.next_value::<std::option::Option<crate::model::AssetPerformanceData>>()?
                                ;
                        }
                        __FieldTag::__sources => {
                            if !fields.insert(__FieldTag::__sources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sources",
                                ));
                            }
                            result.sources = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__assigned_groups => {
                            if !fields.insert(__FieldTag::__assigned_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assigned_groups",
                                ));
                            }
                            result.assigned_groups = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Asset {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if let Some(value) = self.machine_details() {
            state.serialize_entry("machineDetails", value)?;
        }
        if self.insight_list.is_some() {
            state.serialize_entry("insightList", &self.insight_list)?;
        }
        if self.performance_data.is_some() {
            state.serialize_entry("performanceData", &self.performance_data)?;
        }
        if !self.sources.is_empty() {
            state.serialize_entry("sources", &self.sources)?;
        }
        if !self.assigned_groups.is_empty() {
            state.serialize_entry("assignedGroups", &self.assigned_groups)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Asset {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Asset");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("attributes", &self.attributes);
        debug_struct.field("insight_list", &self.insight_list);
        debug_struct.field("performance_data", &self.performance_data);
        debug_struct.field("sources", &self.sources);
        debug_struct.field("assigned_groups", &self.assigned_groups);
        debug_struct.field("asset_details", &self.asset_details);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Asset].
pub mod asset {
    #[allow(unused_imports)]
    use super::*;

    /// The internal information of an asset. Only one field can be specified
    /// with different attributes based on the type of the asset.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AssetDetails {
        /// Output only. Asset information specific for virtual and physical
        /// machines.
        MachineDetails(std::boxed::Box<crate::model::MachineDetails>),
    }
}

/// The preferences that apply to all assets in a given context.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PreferenceSet {
    /// Output only. Name of the preference set.
    pub name: std::string::String,

    /// Output only. The timestamp when the preference set was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the preference set was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// User-friendly display name. Maximum length is 63 characters.
    pub display_name: std::string::String,

    /// A description of the preference set.
    pub description: std::string::String,

    /// A set of preferences that applies to all virtual machines in the context.
    pub virtual_machine_preferences: std::option::Option<crate::model::VirtualMachinePreferences>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PreferenceSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PreferenceSet::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PreferenceSet::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::PreferenceSet::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::PreferenceSet::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PreferenceSet::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [display_name][crate::model::PreferenceSet::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::PreferenceSet::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [virtual_machine_preferences][crate::model::PreferenceSet::virtual_machine_preferences].
    pub fn set_virtual_machine_preferences<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VirtualMachinePreferences>,
    {
        self.virtual_machine_preferences = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [virtual_machine_preferences][crate::model::PreferenceSet::virtual_machine_preferences].
    pub fn set_or_clear_virtual_machine_preferences<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VirtualMachinePreferences>,
    {
        self.virtual_machine_preferences = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PreferenceSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.PreferenceSet"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PreferenceSet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __display_name,
            __description,
            __virtual_machine_preferences,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PreferenceSet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "virtualMachinePreferences" => {
                                Ok(__FieldTag::__virtual_machine_preferences)
                            }
                            "virtual_machine_preferences" => {
                                Ok(__FieldTag::__virtual_machine_preferences)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PreferenceSet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PreferenceSet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__virtual_machine_preferences => {
                            if !fields.insert(__FieldTag::__virtual_machine_preferences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for virtual_machine_preferences",
                                ));
                            }
                            result.virtual_machine_preferences = map.next_value::<std::option::Option<crate::model::VirtualMachinePreferences>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PreferenceSet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.virtual_machine_preferences.is_some() {
            state.serialize_entry(
                "virtualMachinePreferences",
                &self.virtual_machine_preferences,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PreferenceSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PreferenceSet");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field(
            "virtual_machine_preferences",
            &self.virtual_machine_preferences,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A resource that represents the background job that imports asset frames.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportJob {
    /// Output only. The full name of the import job.
    pub name: std::string::String,

    /// User-friendly display name. Maximum length is 63 characters.
    pub display_name: std::string::String,

    /// Output only. The timestamp when the import job was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the import job was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the import job was completed.
    pub complete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The state of the import job.
    pub state: crate::model::import_job::ImportJobState,

    /// Labels as key value pairs.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Reference to a source.
    pub asset_source: std::string::String,

    /// Holds the various report types of an import job.
    pub report: std::option::Option<crate::model::import_job::Report>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ImportJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ImportJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ImportJob::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ImportJob::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ImportJob::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ImportJob::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [complete_time][crate::model::ImportJob::complete_time].
    pub fn set_complete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [complete_time][crate::model::ImportJob::complete_time].
    pub fn set_or_clear_complete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::ImportJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::import_job::ImportJobState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ImportJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [asset_source][crate::model::ImportJob::asset_source].
    pub fn set_asset_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_source = v.into();
        self
    }

    /// Sets the value of [report][crate::model::ImportJob::report].
    ///
    /// Note that all the setters affecting `report` are mutually
    /// exclusive.
    pub fn set_report<
        T: std::convert::Into<std::option::Option<crate::model::import_job::Report>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.report = v.into();
        self
    }

    /// The value of [report][crate::model::ImportJob::report]
    /// if it holds a `ValidationReport`, `None` if the field is not set or
    /// holds a different branch.
    pub fn validation_report(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ValidationReport>> {
        #[allow(unreachable_patterns)]
        self.report.as_ref().and_then(|v| match v {
            crate::model::import_job::Report::ValidationReport(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [report][crate::model::ImportJob::report]
    /// to hold a `ValidationReport`.
    ///
    /// Note that all the setters affecting `report` are
    /// mutually exclusive.
    pub fn set_validation_report<
        T: std::convert::Into<std::boxed::Box<crate::model::ValidationReport>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.report =
            std::option::Option::Some(crate::model::import_job::Report::ValidationReport(v.into()));
        self
    }

    /// The value of [report][crate::model::ImportJob::report]
    /// if it holds a `ExecutionReport`, `None` if the field is not set or
    /// holds a different branch.
    pub fn execution_report(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExecutionReport>> {
        #[allow(unreachable_patterns)]
        self.report.as_ref().and_then(|v| match v {
            crate::model::import_job::Report::ExecutionReport(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [report][crate::model::ImportJob::report]
    /// to hold a `ExecutionReport`.
    ///
    /// Note that all the setters affecting `report` are
    /// mutually exclusive.
    pub fn set_execution_report<
        T: std::convert::Into<std::boxed::Box<crate::model::ExecutionReport>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.report =
            std::option::Option::Some(crate::model::import_job::Report::ExecutionReport(v.into()));
        self
    }
}

impl wkt::message::Message for ImportJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ImportJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __create_time,
            __update_time,
            __complete_time,
            __state,
            __labels,
            __asset_source,
            __validation_report,
            __execution_report,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "completeTime" => Ok(__FieldTag::__complete_time),
                            "complete_time" => Ok(__FieldTag::__complete_time),
                            "state" => Ok(__FieldTag::__state),
                            "labels" => Ok(__FieldTag::__labels),
                            "assetSource" => Ok(__FieldTag::__asset_source),
                            "asset_source" => Ok(__FieldTag::__asset_source),
                            "validationReport" => Ok(__FieldTag::__validation_report),
                            "validation_report" => Ok(__FieldTag::__validation_report),
                            "executionReport" => Ok(__FieldTag::__execution_report),
                            "execution_report" => Ok(__FieldTag::__execution_report),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__complete_time => {
                            if !fields.insert(__FieldTag::__complete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for complete_time",
                                ));
                            }
                            result.complete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::import_job::ImportJobState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asset_source => {
                            if !fields.insert(__FieldTag::__asset_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_source",
                                ));
                            }
                            result.asset_source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validation_report => {
                            if !fields.insert(__FieldTag::__validation_report) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validation_report",
                                ));
                            }
                            if result.report.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `report`, a oneof with full ID .google.cloud.migrationcenter.v1.ImportJob.validation_report, latest field was validationReport",
                                ));
                            }
                            result.report = std::option::Option::Some(
                                crate::model::import_job::Report::ValidationReport(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ValidationReport>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__execution_report => {
                            if !fields.insert(__FieldTag::__execution_report) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_report",
                                ));
                            }
                            if result.report.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `report`, a oneof with full ID .google.cloud.migrationcenter.v1.ImportJob.execution_report, latest field was executionReport",
                                ));
                            }
                            result.report = std::option::Option::Some(
                                crate::model::import_job::Report::ExecutionReport(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ExecutionReport>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.complete_time.is_some() {
            state.serialize_entry("completeTime", &self.complete_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.asset_source.is_empty() {
            state.serialize_entry("assetSource", &self.asset_source)?;
        }
        if let Some(value) = self.validation_report() {
            state.serialize_entry("validationReport", value)?;
        }
        if let Some(value) = self.execution_report() {
            state.serialize_entry("executionReport", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportJob");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("complete_time", &self.complete_time);
        debug_struct.field("state", &self.state);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("asset_source", &self.asset_source);
        debug_struct.field("report", &self.report);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ImportJob].
pub mod import_job {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerates possible states of an import job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ImportJobState {
        /// Default value.
        Unspecified,
        /// The import job is pending.
        Pending,
        /// The processing of the import job is ongoing.
        Running,
        /// The import job processing has completed.
        Completed,
        /// The import job failed to be processed.
        Failed,
        /// The import job is being validated.
        Validating,
        /// The import job contains blocking errors.
        FailedValidation,
        /// The validation of the job completed with no blocking errors.
        Ready,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ImportJobState::value] or
        /// [ImportJobState::name].
        UnknownValue(import_job_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod import_job_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ImportJobState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Completed => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Validating => std::option::Option::Some(5),
                Self::FailedValidation => std::option::Option::Some(6),
                Self::Ready => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("IMPORT_JOB_STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("IMPORT_JOB_STATE_PENDING"),
                Self::Running => std::option::Option::Some("IMPORT_JOB_STATE_RUNNING"),
                Self::Completed => std::option::Option::Some("IMPORT_JOB_STATE_COMPLETED"),
                Self::Failed => std::option::Option::Some("IMPORT_JOB_STATE_FAILED"),
                Self::Validating => std::option::Option::Some("IMPORT_JOB_STATE_VALIDATING"),
                Self::FailedValidation => {
                    std::option::Option::Some("IMPORT_JOB_STATE_FAILED_VALIDATION")
                }
                Self::Ready => std::option::Option::Some("IMPORT_JOB_STATE_READY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ImportJobState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ImportJobState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ImportJobState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::Completed,
                4 => Self::Failed,
                5 => Self::Validating,
                6 => Self::FailedValidation,
                7 => Self::Ready,
                _ => Self::UnknownValue(import_job_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ImportJobState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IMPORT_JOB_STATE_UNSPECIFIED" => Self::Unspecified,
                "IMPORT_JOB_STATE_PENDING" => Self::Pending,
                "IMPORT_JOB_STATE_RUNNING" => Self::Running,
                "IMPORT_JOB_STATE_COMPLETED" => Self::Completed,
                "IMPORT_JOB_STATE_FAILED" => Self::Failed,
                "IMPORT_JOB_STATE_VALIDATING" => Self::Validating,
                "IMPORT_JOB_STATE_FAILED_VALIDATION" => Self::FailedValidation,
                "IMPORT_JOB_STATE_READY" => Self::Ready,
                _ => Self::UnknownValue(import_job_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ImportJobState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Completed => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Validating => serializer.serialize_i32(5),
                Self::FailedValidation => serializer.serialize_i32(6),
                Self::Ready => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ImportJobState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ImportJobState>::new(
                ".google.cloud.migrationcenter.v1.ImportJob.ImportJobState",
            ))
        }
    }

    /// Holds the various report types of an import job.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Report {
        /// Output only. The report with the validation results of the import job.
        ValidationReport(std::boxed::Box<crate::model::ValidationReport>),
        /// Output only. The report with the results of running the import job.
        ExecutionReport(std::boxed::Box<crate::model::ExecutionReport>),
    }
}

/// A resource that represents a payload file in an import job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportDataFile {
    /// Output only. The name of the file.
    pub name: std::string::String,

    /// User-friendly display name. Maximum length is 63 characters.
    pub display_name: std::string::String,

    /// Required. The payload format.
    pub format: crate::model::ImportJobFormat,

    /// Output only. The timestamp when the file was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The state of the import data file.
    pub state: crate::model::import_data_file::State,

    pub file_info: std::option::Option<crate::model::import_data_file::FileInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportDataFile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ImportDataFile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ImportDataFile::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [format][crate::model::ImportDataFile::format].
    pub fn set_format<T: std::convert::Into<crate::model::ImportJobFormat>>(
        mut self,
        v: T,
    ) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ImportDataFile::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ImportDataFile::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::ImportDataFile::state].
    pub fn set_state<T: std::convert::Into<crate::model::import_data_file::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [file_info][crate::model::ImportDataFile::file_info].
    ///
    /// Note that all the setters affecting `file_info` are mutually
    /// exclusive.
    pub fn set_file_info<
        T: std::convert::Into<std::option::Option<crate::model::import_data_file::FileInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_info = v.into();
        self
    }

    /// The value of [file_info][crate::model::ImportDataFile::file_info]
    /// if it holds a `UploadFileInfo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn upload_file_info(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UploadFileInfo>> {
        #[allow(unreachable_patterns)]
        self.file_info.as_ref().and_then(|v| match v {
            crate::model::import_data_file::FileInfo::UploadFileInfo(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [file_info][crate::model::ImportDataFile::file_info]
    /// to hold a `UploadFileInfo`.
    ///
    /// Note that all the setters affecting `file_info` are
    /// mutually exclusive.
    pub fn set_upload_file_info<
        T: std::convert::Into<std::boxed::Box<crate::model::UploadFileInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_info = std::option::Option::Some(
            crate::model::import_data_file::FileInfo::UploadFileInfo(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportDataFile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ImportDataFile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportDataFile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __format,
            __create_time,
            __state,
            __upload_file_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportDataFile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "format" => Ok(__FieldTag::__format),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "state" => Ok(__FieldTag::__state),
                            "uploadFileInfo" => Ok(__FieldTag::__upload_file_info),
                            "upload_file_info" => Ok(__FieldTag::__upload_file_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportDataFile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportDataFile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__format => {
                            if !fields.insert(__FieldTag::__format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for format",
                                ));
                            }
                            result.format = map
                                .next_value::<std::option::Option<crate::model::ImportJobFormat>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::import_data_file::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__upload_file_info => {
                            if !fields.insert(__FieldTag::__upload_file_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upload_file_info",
                                ));
                            }
                            if result.file_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `file_info`, a oneof with full ID .google.cloud.migrationcenter.v1.ImportDataFile.upload_file_info, latest field was uploadFileInfo",
                                ));
                            }
                            result.file_info = std::option::Option::Some(
                                crate::model::import_data_file::FileInfo::UploadFileInfo(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::UploadFileInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportDataFile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.format) {
            state.serialize_entry("format", &self.format)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if let Some(value) = self.upload_file_info() {
            state.serialize_entry("uploadFileInfo", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportDataFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportDataFile");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("format", &self.format);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("state", &self.state);
        debug_struct.field("file_info", &self.file_info);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ImportDataFile].
pub mod import_data_file {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerates possible states of an import data file.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value.
        Unspecified,
        /// The data file is being created.
        Creating,
        /// The data file completed initialization.
        Active,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.migrationcenter.v1.ImportDataFile.State",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FileInfo {
        /// Information about a file that is uploaded to a storage service.
        UploadFileInfo(std::boxed::Box<crate::model::UploadFileInfo>),
    }
}

/// A resource that represents an asset group.
/// The purpose of an asset group is to bundle a set of assets that have
/// something in common, while allowing users to add annotations to the group.
/// An asset can belong to multiple groups.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Group {
    /// Output only. The name of the group.
    pub name: std::string::String,

    /// Output only. The timestamp when the group was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the group was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels as key value pairs.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// User-friendly display name.
    pub display_name: std::string::String,

    /// The description of the resource.
    pub description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Group {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Group::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Group::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Group::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Group::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Group::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Group::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::Group::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Group::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for Group {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.Group"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Group {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __display_name,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Group")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Group;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Group")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Group {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Group {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Group");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message representing a frame which failed to be processed due to an error.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ErrorFrame {
    /// Output only. The identifier of the ErrorFrame.
    pub name: std::string::String,

    /// Output only. All the violations that were detected for the frame.
    pub violations: std::vec::Vec<crate::model::FrameViolationEntry>,

    /// Output only. The frame that was originally reported.
    pub original_frame: std::option::Option<crate::model::AssetFrame>,

    /// Output only. Frame ingestion time.
    pub ingestion_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorFrame {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ErrorFrame::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [violations][crate::model::ErrorFrame::violations].
    pub fn set_violations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FrameViolationEntry>,
    {
        use std::iter::Iterator;
        self.violations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [original_frame][crate::model::ErrorFrame::original_frame].
    pub fn set_original_frame<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AssetFrame>,
    {
        self.original_frame = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_frame][crate::model::ErrorFrame::original_frame].
    pub fn set_or_clear_original_frame<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AssetFrame>,
    {
        self.original_frame = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ingestion_time][crate::model::ErrorFrame::ingestion_time].
    pub fn set_ingestion_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.ingestion_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ingestion_time][crate::model::ErrorFrame::ingestion_time].
    pub fn set_or_clear_ingestion_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.ingestion_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ErrorFrame {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ErrorFrame"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ErrorFrame {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __violations,
            __original_frame,
            __ingestion_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ErrorFrame")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "violations" => Ok(__FieldTag::__violations),
                            "originalFrame" => Ok(__FieldTag::__original_frame),
                            "original_frame" => Ok(__FieldTag::__original_frame),
                            "ingestionTime" => Ok(__FieldTag::__ingestion_time),
                            "ingestion_time" => Ok(__FieldTag::__ingestion_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ErrorFrame;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ErrorFrame")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__violations => {
                            if !fields.insert(__FieldTag::__violations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for violations",
                                ));
                            }
                            result.violations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FrameViolationEntry>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__original_frame => {
                            if !fields.insert(__FieldTag::__original_frame) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_frame",
                                ));
                            }
                            result.original_frame =
                                map.next_value::<std::option::Option<crate::model::AssetFrame>>()?;
                        }
                        __FieldTag::__ingestion_time => {
                            if !fields.insert(__FieldTag::__ingestion_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ingestion_time",
                                ));
                            }
                            result.ingestion_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ErrorFrame {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.violations.is_empty() {
            state.serialize_entry("violations", &self.violations)?;
        }
        if self.original_frame.is_some() {
            state.serialize_entry("originalFrame", &self.original_frame)?;
        }
        if self.ingestion_time.is_some() {
            state.serialize_entry("ingestionTime", &self.ingestion_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ErrorFrame {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ErrorFrame");
        debug_struct.field("name", &self.name);
        debug_struct.field("violations", &self.violations);
        debug_struct.field("original_frame", &self.original_frame);
        debug_struct.field("ingestion_time", &self.ingestion_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Source represents an object from which asset information is
/// streamed to Migration Center.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Source {
    /// Output only. The full name of the source.
    pub name: std::string::String,

    /// Output only. The timestamp when the source was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the source was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// User-friendly display name.
    pub display_name: std::string::String,

    /// Free-text description.
    pub description: std::string::String,

    /// Data source type.
    pub r#type: crate::model::source::SourceType,

    /// The information confidence of the source.
    /// The higher the value, the higher the confidence.
    pub priority: i32,

    /// If `true`, the source is managed by other service(s).
    pub managed: bool,

    /// Output only. Number of frames that are still being processed.
    pub pending_frame_count: i32,

    /// Output only. The number of frames that were reported by the source and
    /// contained errors.
    pub error_frame_count: i32,

    /// Output only. The state of the source.
    pub state: crate::model::source::State,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Source {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Source::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Source::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Source::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Source::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Source::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [display_name][crate::model::Source::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Source::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Source::type].
    pub fn set_type<T: std::convert::Into<crate::model::source::SourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [priority][crate::model::Source::priority].
    pub fn set_priority<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.priority = v.into();
        self
    }

    /// Sets the value of [managed][crate::model::Source::managed].
    pub fn set_managed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.managed = v.into();
        self
    }

    /// Sets the value of [pending_frame_count][crate::model::Source::pending_frame_count].
    pub fn set_pending_frame_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.pending_frame_count = v.into();
        self
    }

    /// Sets the value of [error_frame_count][crate::model::Source::error_frame_count].
    pub fn set_error_frame_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.error_frame_count = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Source::state].
    pub fn set_state<T: std::convert::Into<crate::model::source::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for Source {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.Source"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Source {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __display_name,
            __description,
            __type,
            __priority,
            __managed,
            __pending_frame_count,
            __error_frame_count,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Source")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "type" => Ok(__FieldTag::__type),
                            "priority" => Ok(__FieldTag::__priority),
                            "managed" => Ok(__FieldTag::__managed),
                            "pendingFrameCount" => Ok(__FieldTag::__pending_frame_count),
                            "pending_frame_count" => Ok(__FieldTag::__pending_frame_count),
                            "errorFrameCount" => Ok(__FieldTag::__error_frame_count),
                            "error_frame_count" => Ok(__FieldTag::__error_frame_count),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Source;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Source")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::source::SourceType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__priority => {
                            if !fields.insert(__FieldTag::__priority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for priority",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.priority = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__managed => {
                            if !fields.insert(__FieldTag::__managed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed",
                                ));
                            }
                            result.managed = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pending_frame_count => {
                            if !fields.insert(__FieldTag::__pending_frame_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pending_frame_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pending_frame_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__error_frame_count => {
                            if !fields.insert(__FieldTag::__error_frame_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_frame_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.error_frame_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::source::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Source {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.priority) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if !wkt::internal::is_default(&self.managed) {
            state.serialize_entry("managed", &self.managed)?;
        }
        if !wkt::internal::is_default(&self.pending_frame_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pendingFrameCount", &__With(&self.pending_frame_count))?;
        }
        if !wkt::internal::is_default(&self.error_frame_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("errorFrameCount", &__With(&self.error_frame_count))?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Source {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Source");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("priority", &self.priority);
        debug_struct.field("managed", &self.managed);
        debug_struct.field("pending_frame_count", &self.pending_frame_count);
        debug_struct.field("error_frame_count", &self.error_frame_count);
        debug_struct.field("state", &self.state);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Source].
pub mod source {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceType {
        /// Unspecified
        Unknown,
        /// Manually uploaded file (e.g. CSV)
        Upload,
        /// Guest-level info
        GuestOsScan,
        /// Inventory-level scan
        InventoryScan,
        /// Third-party owned sources.
        Custom,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SourceType::value] or
        /// [SourceType::name].
        UnknownValue(source_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod source_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SourceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Upload => std::option::Option::Some(1),
                Self::GuestOsScan => std::option::Option::Some(2),
                Self::InventoryScan => std::option::Option::Some(3),
                Self::Custom => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("SOURCE_TYPE_UNKNOWN"),
                Self::Upload => std::option::Option::Some("SOURCE_TYPE_UPLOAD"),
                Self::GuestOsScan => std::option::Option::Some("SOURCE_TYPE_GUEST_OS_SCAN"),
                Self::InventoryScan => std::option::Option::Some("SOURCE_TYPE_INVENTORY_SCAN"),
                Self::Custom => std::option::Option::Some("SOURCE_TYPE_CUSTOM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SourceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SourceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SourceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Upload,
                2 => Self::GuestOsScan,
                3 => Self::InventoryScan,
                4 => Self::Custom,
                _ => Self::UnknownValue(source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SourceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SOURCE_TYPE_UNKNOWN" => Self::Unknown,
                "SOURCE_TYPE_UPLOAD" => Self::Upload,
                "SOURCE_TYPE_GUEST_OS_SCAN" => Self::GuestOsScan,
                "SOURCE_TYPE_INVENTORY_SCAN" => Self::InventoryScan,
                "SOURCE_TYPE_CUSTOM" => Self::Custom,
                _ => Self::UnknownValue(source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SourceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Upload => serializer.serialize_i32(1),
                Self::GuestOsScan => serializer.serialize_i32(2),
                Self::InventoryScan => serializer.serialize_i32(3),
                Self::Custom => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SourceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SourceType>::new(
                ".google.cloud.migrationcenter.v1.Source.SourceType",
            ))
        }
    }

    /// Enumerates possible states of a source.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified.
        Unspecified,
        /// The source is active and ready to be used.
        Active,
        /// In the process of being deleted.
        Deleting,
        /// Source is in an invalid state. Asset frames reported to it will be
        /// ignored.
        Invalid,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Deleting => std::option::Option::Some(2),
                Self::Invalid => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Invalid => std::option::Option::Some("INVALID"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Deleting,
                3 => Self::Invalid,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "INVALID" => Self::Invalid,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Deleting => serializer.serialize_i32(2),
                Self::Invalid => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.migrationcenter.v1.Source.State",
            ))
        }
    }
}

/// The groups and associated preference sets on which
/// we can generate reports.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReportConfig {
    /// Output only. Name of resource.
    pub name: std::string::String,

    /// Output only. The timestamp when the resource was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the resource was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// User-friendly display name. Maximum length is 63 characters.
    pub display_name: std::string::String,

    /// Free-text description.
    pub description: std::string::String,

    /// Required. Collection of combinations of groups and preference sets.
    pub group_preferenceset_assignments:
        std::vec::Vec<crate::model::report_config::GroupPreferenceSetAssignment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReportConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReportConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ReportConfig::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ReportConfig::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ReportConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ReportConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [display_name][crate::model::ReportConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ReportConfig::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [group_preferenceset_assignments][crate::model::ReportConfig::group_preferenceset_assignments].
    pub fn set_group_preferenceset_assignments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::report_config::GroupPreferenceSetAssignment>,
    {
        use std::iter::Iterator;
        self.group_preferenceset_assignments = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReportConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ReportConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReportConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __display_name,
            __description,
            __group_preferenceset_assignments,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReportConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "groupPreferencesetAssignments" => {
                                Ok(__FieldTag::__group_preferenceset_assignments)
                            }
                            "group_preferenceset_assignments" => {
                                Ok(__FieldTag::__group_preferenceset_assignments)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReportConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReportConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__group_preferenceset_assignments => {
                            if !fields.insert(__FieldTag::__group_preferenceset_assignments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_preferenceset_assignments",
                                ));
                            }
                            result.group_preferenceset_assignments = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::report_config::GroupPreferenceSetAssignment,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReportConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.group_preferenceset_assignments.is_empty() {
            state.serialize_entry(
                "groupPreferencesetAssignments",
                &self.group_preferenceset_assignments,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReportConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReportConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field(
            "group_preferenceset_assignments",
            &self.group_preferenceset_assignments,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ReportConfig].
pub mod report_config {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a combination of a group with a preference set.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GroupPreferenceSetAssignment {
        /// Required. Name of the group.
        pub group: std::string::String,

        /// Required. Name of the Preference Set.
        pub preference_set: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GroupPreferenceSetAssignment {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [group][crate::model::report_config::GroupPreferenceSetAssignment::group].
        pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.group = v.into();
            self
        }

        /// Sets the value of [preference_set][crate::model::report_config::GroupPreferenceSetAssignment::preference_set].
        pub fn set_preference_set<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.preference_set = v.into();
            self
        }
    }

    impl wkt::message::Message for GroupPreferenceSetAssignment {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportConfig.GroupPreferenceSetAssignment"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GroupPreferenceSetAssignment {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __group,
                __preference_set,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GroupPreferenceSetAssignment")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "group" => Ok(__FieldTag::__group),
                                "preferenceSet" => Ok(__FieldTag::__preference_set),
                                "preference_set" => Ok(__FieldTag::__preference_set),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GroupPreferenceSetAssignment;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GroupPreferenceSetAssignment")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__group => {
                                if !fields.insert(__FieldTag::__group) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for group",
                                    ));
                                }
                                result.group = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__preference_set => {
                                if !fields.insert(__FieldTag::__preference_set) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for preference_set",
                                    ));
                                }
                                result.preference_set = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GroupPreferenceSetAssignment {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.group.is_empty() {
                state.serialize_entry("group", &self.group)?;
            }
            if !self.preference_set.is_empty() {
                state.serialize_entry("preferenceSet", &self.preference_set)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GroupPreferenceSetAssignment {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GroupPreferenceSetAssignment");
            debug_struct.field("group", &self.group);
            debug_struct.field("preference_set", &self.preference_set);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Report represents a point-in-time rendering of the ReportConfig results.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Report {
    /// Output only. Name of resource.
    pub name: std::string::String,

    /// Output only. Creation timestamp.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Last update timestamp.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// User-friendly display name. Maximum length is 63 characters.
    pub display_name: std::string::String,

    /// Free-text description.
    pub description: std::string::String,

    /// Report type.
    pub r#type: crate::model::report::Type,

    /// Report creation state.
    pub state: crate::model::report::State,

    /// Output only. Summary view of the Report.
    pub summary: std::option::Option<crate::model::ReportSummary>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Report {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Report::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Report::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Report::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Report::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Report::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [display_name][crate::model::Report::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Report::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Report::type].
    pub fn set_type<T: std::convert::Into<crate::model::report::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Report::state].
    pub fn set_state<T: std::convert::Into<crate::model::report::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [summary][crate::model::Report::summary].
    pub fn set_summary<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReportSummary>,
    {
        self.summary = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [summary][crate::model::Report::summary].
    pub fn set_or_clear_summary<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReportSummary>,
    {
        self.summary = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Report {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.Report"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Report {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __display_name,
            __description,
            __type,
            __state,
            __summary,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Report")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "type" => Ok(__FieldTag::__type),
                            "state" => Ok(__FieldTag::__state),
                            "summary" => Ok(__FieldTag::__summary),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Report;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Report")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::report::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::report::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__summary => {
                            if !fields.insert(__FieldTag::__summary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for summary",
                                ));
                            }
                            result.summary = map
                                .next_value::<std::option::Option<crate::model::ReportSummary>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Report {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.summary.is_some() {
            state.serialize_entry("summary", &self.summary)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Report {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Report");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("state", &self.state);
        debug_struct.field("summary", &self.summary);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Report].
pub mod report {
    #[allow(unused_imports)]
    use super::*;

    /// Report type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Default Report type.
        Unspecified,
        /// Total cost of ownership Report type.
        TotalCostOfOwnership,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TotalCostOfOwnership => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::TotalCostOfOwnership => std::option::Option::Some("TOTAL_COST_OF_OWNERSHIP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TotalCostOfOwnership,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "TOTAL_COST_OF_OWNERSHIP" => Self::TotalCostOfOwnership,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TotalCostOfOwnership => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.migrationcenter.v1.Report.Type",
            ))
        }
    }

    /// Report creation state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default Report creation state.
        Unspecified,
        /// Creating Report.
        Pending,
        /// Successfully created Report.
        Succeeded,
        /// Failed to create Report.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Succeeded,
                3 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.migrationcenter.v1.Report.State",
            ))
        }
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("requested_cancellation", &self.requested_cancellation);
        debug_struct.field("api_version", &self.api_version);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for requesting a list of assets.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAssetsRequest {
    /// Required. Parent value for `ListAssetsRequest`.
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Filtering results.
    pub filter: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    pub order_by: std::string::String,

    /// View of the assets. Defaults to BASIC.
    pub view: crate::model::AssetView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAssetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAssetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAssetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAssetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAssetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAssetsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListAssetsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::AssetView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListAssetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListAssetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAssetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAssetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAssetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAssetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::AssetView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAssetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAssetsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAssetsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for listing assets.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAssetsResponse {
    /// A list of assets.
    pub assets: std::vec::Vec<crate::model::Asset>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAssetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [assets][crate::model::ListAssetsResponse::assets].
    pub fn set_assets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Asset>,
    {
        use std::iter::Iterator;
        self.assets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAssetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListAssetsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAssetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListAssetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAssetsResponse {
    type PageItem = crate::model::Asset;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.assets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAssetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __assets,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAssetsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "assets" => Ok(__FieldTag::__assets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAssetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAssetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__assets => {
                            if !fields.insert(__FieldTag::__assets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assets",
                                ));
                            }
                            result.assets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Asset>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAssetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.assets.is_empty() {
            state.serialize_entry("assets", &self.assets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAssetsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAssetsResponse");
        debug_struct.field("assets", &self.assets);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for getting a Asset.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAssetRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    /// View of the assets. Defaults to BASIC.
    pub view: crate::model::AssetView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAssetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAssetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetAssetRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::AssetView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetAssetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetAssetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAssetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAssetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAssetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAssetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::AssetView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAssetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetAssetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetAssetRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to update an asset.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAssetRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `Asset` resource by the update.
    /// The values specified in the `update_mask` field are relative to the
    /// resource, not the full request.
    /// A field will be overwritten if it is in the mask.
    /// A single * value in the mask lets you to overwrite all fields.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated.
    pub asset: std::option::Option<crate::model::Asset>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAssetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateAssetRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAssetRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [asset][crate::model::UpdateAssetRequest::asset].
    pub fn set_asset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Asset>,
    {
        self.asset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [asset][crate::model::UpdateAssetRequest::asset].
    pub fn set_or_clear_asset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Asset>,
    {
        self.asset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateAssetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAssetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.UpdateAssetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAssetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __asset,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAssetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "asset" => Ok(__FieldTag::__asset),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAssetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAssetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__asset => {
                            if !fields.insert(__FieldTag::__asset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset",
                                ));
                            }
                            result.asset =
                                map.next_value::<std::option::Option<crate::model::Asset>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAssetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.asset.is_some() {
            state.serialize_entry("asset", &self.asset)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateAssetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateAssetRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("asset", &self.asset);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to update a list of assets.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchUpdateAssetsRequest {
    /// Required. Parent value for batch asset update.
    pub parent: std::string::String,

    /// Required. The request message specifying the resources to update.
    /// A maximum of 1000 assets can be modified in a batch.
    pub requests: std::vec::Vec<crate::model::UpdateAssetRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchUpdateAssetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchUpdateAssetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::BatchUpdateAssetsRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UpdateAssetRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchUpdateAssetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.BatchUpdateAssetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchUpdateAssetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __requests,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchUpdateAssetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "requests" => Ok(__FieldTag::__requests),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchUpdateAssetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchUpdateAssetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requests => {
                            if !fields.insert(__FieldTag::__requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requests",
                                ));
                            }
                            result.requests = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UpdateAssetRequest>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchUpdateAssetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.requests.is_empty() {
            state.serialize_entry("requests", &self.requests)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchUpdateAssetsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchUpdateAssetsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("requests", &self.requests);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for updating a list of assets.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchUpdateAssetsResponse {
    /// Update asset content.
    /// The content only includes values after field mask being applied.
    pub assets: std::vec::Vec<crate::model::Asset>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchUpdateAssetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [assets][crate::model::BatchUpdateAssetsResponse::assets].
    pub fn set_assets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Asset>,
    {
        use std::iter::Iterator;
        self.assets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchUpdateAssetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.BatchUpdateAssetsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchUpdateAssetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __assets,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchUpdateAssetsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "assets" => Ok(__FieldTag::__assets),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchUpdateAssetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchUpdateAssetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__assets => {
                            if !fields.insert(__FieldTag::__assets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assets",
                                ));
                            }
                            result.assets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Asset>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchUpdateAssetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.assets.is_empty() {
            state.serialize_entry("assets", &self.assets)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchUpdateAssetsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchUpdateAssetsResponse");
        debug_struct.field("assets", &self.assets);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to delete an asset.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAssetRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAssetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAssetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteAssetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAssetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DeleteAssetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAssetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAssetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAssetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAssetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAssetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteAssetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteAssetRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to delete a list of  asset.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchDeleteAssetsRequest {
    /// Required. Parent value for batch asset delete.
    pub parent: std::string::String,

    /// Required. The IDs of the assets to delete.
    /// A maximum of 1000 assets can be deleted in a batch.
    /// Format: projects/{project}/locations/{location}/assets/{name}.
    pub names: std::vec::Vec<std::string::String>,

    /// Optional. When this value is set to `true` the request is a no-op for
    /// non-existing assets. See <https://google.aip.dev/135#delete-if-existing> for
    /// additional details. Default value is `false`.
    pub allow_missing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchDeleteAssetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchDeleteAssetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [names][crate::model::BatchDeleteAssetsRequest::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [allow_missing][crate::model::BatchDeleteAssetsRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for BatchDeleteAssetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.BatchDeleteAssetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchDeleteAssetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __names,
            __allow_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchDeleteAssetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "names" => Ok(__FieldTag::__names),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchDeleteAssetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchDeleteAssetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__names => {
                            if !fields.insert(__FieldTag::__names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for names",
                                ));
                            }
                            result.names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchDeleteAssetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.names.is_empty() {
            state.serialize_entry("names", &self.names)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchDeleteAssetsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchDeleteAssetsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("names", &self.names);
        debug_struct.field("allow_missing", &self.allow_missing);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to report a set of asset frames.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReportAssetFramesRequest {
    /// Required. Parent of the resource.
    pub parent: std::string::String,

    /// Collection of frames data.
    pub frames: std::option::Option<crate::model::Frames>,

    /// Required. Reference to a source.
    pub source: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReportAssetFramesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ReportAssetFramesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [frames][crate::model::ReportAssetFramesRequest::frames].
    pub fn set_frames<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Frames>,
    {
        self.frames = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [frames][crate::model::ReportAssetFramesRequest::frames].
    pub fn set_or_clear_frames<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Frames>,
    {
        self.frames = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::ReportAssetFramesRequest::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }
}

impl wkt::message::Message for ReportAssetFramesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ReportAssetFramesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReportAssetFramesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __frames,
            __source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReportAssetFramesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "frames" => Ok(__FieldTag::__frames),
                            "source" => Ok(__FieldTag::__source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReportAssetFramesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReportAssetFramesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__frames => {
                            if !fields.insert(__FieldTag::__frames) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frames",
                                ));
                            }
                            result.frames =
                                map.next_value::<std::option::Option<crate::model::Frames>>()?;
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReportAssetFramesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.frames.is_some() {
            state.serialize_entry("frames", &self.frames)?;
        }
        if !self.source.is_empty() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReportAssetFramesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReportAssetFramesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("frames", &self.frames);
        debug_struct.field("source", &self.source);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A response to a call to `ReportAssetFrame`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReportAssetFramesResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReportAssetFramesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ReportAssetFramesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ReportAssetFramesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReportAssetFramesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReportAssetFramesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReportAssetFramesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReportAssetFramesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReportAssetFramesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReportAssetFramesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReportAssetFramesResponse");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to aggregate one or more values.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AggregateAssetsValuesRequest {
    /// Required. Parent value for `AggregateAssetsValuesRequest`.
    pub parent: std::string::String,

    /// Array of aggregations to perform.
    /// Up to 25 aggregations can be defined.
    pub aggregations: std::vec::Vec<crate::model::Aggregation>,

    /// The aggregation will be performed on assets that match the provided filter.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AggregateAssetsValuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::AggregateAssetsValuesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [aggregations][crate::model::AggregateAssetsValuesRequest::aggregations].
    pub fn set_aggregations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Aggregation>,
    {
        use std::iter::Iterator;
        self.aggregations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [filter][crate::model::AggregateAssetsValuesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for AggregateAssetsValuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.AggregateAssetsValuesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AggregateAssetsValuesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __aggregations,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AggregateAssetsValuesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "aggregations" => Ok(__FieldTag::__aggregations),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AggregateAssetsValuesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AggregateAssetsValuesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__aggregations => {
                            if !fields.insert(__FieldTag::__aggregations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregations",
                                ));
                            }
                            result.aggregations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Aggregation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AggregateAssetsValuesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.aggregations.is_empty() {
            state.serialize_entry("aggregations", &self.aggregations)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AggregateAssetsValuesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AggregateAssetsValuesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("aggregations", &self.aggregations);
        debug_struct.field("filter", &self.filter);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A response to a request to aggregated assets values.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AggregateAssetsValuesResponse {
    /// The aggregation results.
    pub results: std::vec::Vec<crate::model::AggregationResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AggregateAssetsValuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [results][crate::model::AggregateAssetsValuesResponse::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AggregationResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AggregateAssetsValuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.AggregateAssetsValuesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AggregateAssetsValuesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AggregateAssetsValuesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "results" => Ok(__FieldTag::__results),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AggregateAssetsValuesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AggregateAssetsValuesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__results => {
                            if !fields.insert(__FieldTag::__results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for results",
                                ));
                            }
                            result.results =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AggregationResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AggregateAssetsValuesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.results.is_empty() {
            state.serialize_entry("results", &self.results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AggregateAssetsValuesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AggregateAssetsValuesResponse");
        debug_struct.field("results", &self.results);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to create an import job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateImportJobRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. ID of the import job.
    pub import_job_id: std::string::String,

    /// Required. The resource being created.
    pub import_job: std::option::Option<crate::model::ImportJob>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateImportJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateImportJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [import_job_id][crate::model::CreateImportJobRequest::import_job_id].
    pub fn set_import_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.import_job_id = v.into();
        self
    }

    /// Sets the value of [import_job][crate::model::CreateImportJobRequest::import_job].
    pub fn set_import_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportJob>,
    {
        self.import_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [import_job][crate::model::CreateImportJobRequest::import_job].
    pub fn set_or_clear_import_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportJob>,
    {
        self.import_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateImportJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateImportJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.CreateImportJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateImportJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __import_job_id,
            __import_job,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateImportJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "importJobId" => Ok(__FieldTag::__import_job_id),
                            "import_job_id" => Ok(__FieldTag::__import_job_id),
                            "importJob" => Ok(__FieldTag::__import_job),
                            "import_job" => Ok(__FieldTag::__import_job),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateImportJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateImportJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__import_job_id => {
                            if !fields.insert(__FieldTag::__import_job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_job_id",
                                ));
                            }
                            result.import_job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__import_job => {
                            if !fields.insert(__FieldTag::__import_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_job",
                                ));
                            }
                            result.import_job =
                                map.next_value::<std::option::Option<crate::model::ImportJob>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateImportJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.import_job_id.is_empty() {
            state.serialize_entry("importJobId", &self.import_job_id)?;
        }
        if self.import_job.is_some() {
            state.serialize_entry("importJob", &self.import_job)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateImportJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateImportJobRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("import_job_id", &self.import_job_id);
        debug_struct.field("import_job", &self.import_job);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to list import jobs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListImportJobsRequest {
    /// Required. Parent value for `ListImportJobsRequest`.
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Filtering results.
    pub filter: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    pub order_by: std::string::String,

    /// Optional. The level of details of each import job.
    /// Default value is BASIC.
    pub view: crate::model::ImportJobView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListImportJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListImportJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListImportJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListImportJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListImportJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListImportJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListImportJobsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ImportJobView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListImportJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListImportJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListImportJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListImportJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListImportJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListImportJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::ImportJobView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListImportJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListImportJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListImportJobsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A response for listing import jobs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListImportJobsResponse {
    /// The list of import jobs.
    pub import_jobs: std::vec::Vec<crate::model::ImportJob>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListImportJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [import_jobs][crate::model::ListImportJobsResponse::import_jobs].
    pub fn set_import_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportJob>,
    {
        use std::iter::Iterator;
        self.import_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListImportJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListImportJobsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListImportJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListImportJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListImportJobsResponse {
    type PageItem = crate::model::ImportJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.import_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListImportJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __import_jobs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListImportJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "importJobs" => Ok(__FieldTag::__import_jobs),
                            "import_jobs" => Ok(__FieldTag::__import_jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListImportJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListImportJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__import_jobs => {
                            if !fields.insert(__FieldTag::__import_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_jobs",
                                ));
                            }
                            result.import_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ImportJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListImportJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.import_jobs.is_empty() {
            state.serialize_entry("importJobs", &self.import_jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListImportJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListImportJobsResponse");
        debug_struct.field("import_jobs", &self.import_jobs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to get an import job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetImportJobRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    /// Optional. The level of details of the import job.
    /// Default value is FULL.
    pub view: crate::model::ImportJobView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetImportJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetImportJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetImportJobRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ImportJobView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetImportJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetImportJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetImportJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetImportJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetImportJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetImportJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::ImportJobView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetImportJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetImportJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetImportJobRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to delete an import job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteImportJobRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to `true`, any `ImportDataFiles` of this job will also be
    /// deleted If set to `false`, the request only works if the job has no data
    /// files.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteImportJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteImportJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteImportJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteImportJobRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteImportJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DeleteImportJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteImportJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteImportJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteImportJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteImportJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteImportJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteImportJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteImportJobRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("force", &self.force);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to update an import job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateImportJobRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `Asset` resource by the update.
    /// The values specified in the `update_mask` field are relative to the
    /// resource, not the full request.
    /// A field will be overwritten if it is in the mask.
    /// A single * value in the mask lets you to overwrite all fields.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub import_job: std::option::Option<crate::model::ImportJob>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateImportJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateImportJobRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateImportJobRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [import_job][crate::model::UpdateImportJobRequest::import_job].
    pub fn set_import_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportJob>,
    {
        self.import_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [import_job][crate::model::UpdateImportJobRequest::import_job].
    pub fn set_or_clear_import_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportJob>,
    {
        self.import_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateImportJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateImportJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.UpdateImportJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateImportJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __import_job,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateImportJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "importJob" => Ok(__FieldTag::__import_job),
                            "import_job" => Ok(__FieldTag::__import_job),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateImportJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateImportJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__import_job => {
                            if !fields.insert(__FieldTag::__import_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_job",
                                ));
                            }
                            result.import_job =
                                map.next_value::<std::option::Option<crate::model::ImportJob>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateImportJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.import_job.is_some() {
            state.serialize_entry("importJob", &self.import_job)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateImportJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateImportJobRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("import_job", &self.import_job);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to validate an import job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidateImportJobRequest {
    /// Required. The name of the import job to validate.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidateImportJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ValidateImportJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::ValidateImportJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for ValidateImportJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ValidateImportJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValidateImportJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValidateImportJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValidateImportJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidateImportJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ValidateImportJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ValidateImportJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValidateImportJobRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to run an import job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RunImportJobRequest {
    /// Required. The name of the import job to run.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunImportJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RunImportJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::RunImportJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for RunImportJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.RunImportJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunImportJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunImportJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunImportJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunImportJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RunImportJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RunImportJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunImportJobRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to get an import data file.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetImportDataFileRequest {
    /// Required. Name of the ImportDataFile.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetImportDataFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetImportDataFileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetImportDataFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetImportDataFileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetImportDataFileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetImportDataFileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetImportDataFileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetImportDataFileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetImportDataFileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetImportDataFileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetImportDataFileRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to list import data files of an import job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListImportDataFilesRequest {
    /// Required. Name of the parent of the `ImportDataFiles` resource.
    pub parent: std::string::String,

    /// The maximum number of data files to return. The service may return
    /// fewer than this value. If unspecified, at most 500 data files will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// A page token, received from a previous `ListImportDataFiles` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListImportDataFiles`
    /// must match the call that provided the page token.
    pub page_token: std::string::String,

    /// Filtering results.
    pub filter: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListImportDataFilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListImportDataFilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListImportDataFilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListImportDataFilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListImportDataFilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListImportDataFilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListImportDataFilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListImportDataFilesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListImportDataFilesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListImportDataFilesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListImportDataFilesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListImportDataFilesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListImportDataFilesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListImportDataFilesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListImportDataFilesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for listing payload files of an import job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListImportDataFilesResponse {
    /// The list of import data files.
    pub import_data_files: std::vec::Vec<crate::model::ImportDataFile>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListImportDataFilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [import_data_files][crate::model::ListImportDataFilesResponse::import_data_files].
    pub fn set_import_data_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportDataFile>,
    {
        use std::iter::Iterator;
        self.import_data_files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListImportDataFilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListImportDataFilesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListImportDataFilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListImportDataFilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListImportDataFilesResponse {
    type PageItem = crate::model::ImportDataFile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.import_data_files
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListImportDataFilesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __import_data_files,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListImportDataFilesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "importDataFiles" => Ok(__FieldTag::__import_data_files),
                            "import_data_files" => Ok(__FieldTag::__import_data_files),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListImportDataFilesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListImportDataFilesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__import_data_files => {
                            if !fields.insert(__FieldTag::__import_data_files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_data_files",
                                ));
                            }
                            result.import_data_files =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ImportDataFile>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListImportDataFilesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.import_data_files.is_empty() {
            state.serialize_entry("importDataFiles", &self.import_data_files)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListImportDataFilesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListImportDataFilesResponse");
        debug_struct.field("import_data_files", &self.import_data_files);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to create an `ImportDataFile` resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateImportDataFileRequest {
    /// Required. Name of the parent of the ImportDataFile.
    pub parent: std::string::String,

    /// Required. The ID of the new data file.
    pub import_data_file_id: std::string::String,

    /// Required. The resource being created.
    pub import_data_file: std::option::Option<crate::model::ImportDataFile>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateImportDataFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateImportDataFileRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [import_data_file_id][crate::model::CreateImportDataFileRequest::import_data_file_id].
    pub fn set_import_data_file_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.import_data_file_id = v.into();
        self
    }

    /// Sets the value of [import_data_file][crate::model::CreateImportDataFileRequest::import_data_file].
    pub fn set_import_data_file<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportDataFile>,
    {
        self.import_data_file = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [import_data_file][crate::model::CreateImportDataFileRequest::import_data_file].
    pub fn set_or_clear_import_data_file<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportDataFile>,
    {
        self.import_data_file = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateImportDataFileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateImportDataFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.CreateImportDataFileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateImportDataFileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __import_data_file_id,
            __import_data_file,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateImportDataFileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "importDataFileId" => Ok(__FieldTag::__import_data_file_id),
                            "import_data_file_id" => Ok(__FieldTag::__import_data_file_id),
                            "importDataFile" => Ok(__FieldTag::__import_data_file),
                            "import_data_file" => Ok(__FieldTag::__import_data_file),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateImportDataFileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateImportDataFileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__import_data_file_id => {
                            if !fields.insert(__FieldTag::__import_data_file_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_data_file_id",
                                ));
                            }
                            result.import_data_file_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__import_data_file => {
                            if !fields.insert(__FieldTag::__import_data_file) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_data_file",
                                ));
                            }
                            result.import_data_file = map
                                .next_value::<std::option::Option<crate::model::ImportDataFile>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateImportDataFileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.import_data_file_id.is_empty() {
            state.serialize_entry("importDataFileId", &self.import_data_file_id)?;
        }
        if self.import_data_file.is_some() {
            state.serialize_entry("importDataFile", &self.import_data_file)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateImportDataFileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateImportDataFileRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("import_data_file_id", &self.import_data_file_id);
        debug_struct.field("import_data_file", &self.import_data_file);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to delete an `ImportDataFile` resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteImportDataFileRequest {
    /// Required. Name of the ImportDataFile to delete.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteImportDataFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteImportDataFileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteImportDataFileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteImportDataFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DeleteImportDataFileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteImportDataFileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteImportDataFileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteImportDataFileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteImportDataFileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteImportDataFileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteImportDataFileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteImportDataFileRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to list groups.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGroupsRequest {
    /// Required. Parent value for `ListGroupsRequest`.
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Filtering results.
    pub filter: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGroupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListGroupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListGroupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListGroupsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGroupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGroupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGroupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGroupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGroupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListGroupsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListGroupsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A response for listing groups.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGroupsResponse {
    /// The list of Group
    pub groups: std::vec::Vec<crate::model::Group>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [groups][crate::model::ListGroupsResponse::groups].
    pub fn set_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Group>,
    {
        use std::iter::Iterator;
        self.groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListGroupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListGroupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListGroupsResponse {
    type PageItem = crate::model::Group;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.groups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGroupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __groups,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGroupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "groups" => Ok(__FieldTag::__groups),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGroupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGroupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__groups => {
                            if !fields.insert(__FieldTag::__groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for groups",
                                ));
                            }
                            result.groups = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Group>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGroupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.groups.is_empty() {
            state.serialize_entry("groups", &self.groups)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListGroupsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListGroupsResponse");
        debug_struct.field("groups", &self.groups);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to get a group.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetGroupRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetGroupRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to create a group.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateGroupRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. User specified ID for the group. It will become the last
    /// component of the group name. The ID must be unique within the project, must
    /// conform with RFC-1034, is restricted to lower-cased letters, and has a
    /// maximum length of 63 characters. The ID must match the regular expression:
    /// `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
    pub group_id: std::string::String,

    /// Required. The group resource being created.
    pub group: std::option::Option<crate::model::Group>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateGroupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [group_id][crate::model::CreateGroupRequest::group_id].
    pub fn set_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group_id = v.into();
        self
    }

    /// Sets the value of [group][crate::model::CreateGroupRequest::group].
    pub fn set_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [group][crate::model::CreateGroupRequest::group].
    pub fn set_or_clear_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.CreateGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __group_id,
            __group,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "groupId" => Ok(__FieldTag::__group_id),
                            "group_id" => Ok(__FieldTag::__group_id),
                            "group" => Ok(__FieldTag::__group),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__group_id => {
                            if !fields.insert(__FieldTag::__group_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_id",
                                ));
                            }
                            result.group_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group =
                                map.next_value::<std::option::Option<crate::model::Group>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.group_id.is_empty() {
            state.serialize_entry("groupId", &self.group_id)?;
        }
        if self.group.is_some() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateGroupRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("group_id", &self.group_id);
        debug_struct.field("group", &self.group);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to update a group.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateGroupRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `Group` resource by the update.
    /// The values specified in the `update_mask` are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    /// A single * value in the mask lets you to overwrite all fields.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The group resource being updated.
    pub group: std::option::Option<crate::model::Group>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateGroupRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateGroupRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [group][crate::model::UpdateGroupRequest::group].
    pub fn set_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [group][crate::model::UpdateGroupRequest::group].
    pub fn set_or_clear_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.UpdateGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __group,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "group" => Ok(__FieldTag::__group),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group =
                                map.next_value::<std::option::Option<crate::model::Group>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.group.is_some() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateGroupRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("group", &self.group);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to delete a group.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteGroupRequest {
    /// Required. Name of the group resource.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DeleteGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteGroupRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to add assets to a group.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AddAssetsToGroupRequest {
    /// Required. Group reference.
    pub group: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Required. List of assets to be added.
    /// The maximum number of assets that can be added in a single request is
    /// 1000.
    pub assets: std::option::Option<crate::model::AssetList>,

    /// Optional. When this value is set to `false` and one of the given assets is
    /// already an existing member of the group, the operation fails with an
    /// `Already Exists` error. When set to `true` this situation is silently
    /// ignored by the server.
    ///
    /// Default value is `false`.
    pub allow_existing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddAssetsToGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::AddAssetsToGroupRequest::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::AddAssetsToGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [assets][crate::model::AddAssetsToGroupRequest::assets].
    pub fn set_assets<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AssetList>,
    {
        self.assets = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [assets][crate::model::AddAssetsToGroupRequest::assets].
    pub fn set_or_clear_assets<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AssetList>,
    {
        self.assets = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_existing][crate::model::AddAssetsToGroupRequest::allow_existing].
    pub fn set_allow_existing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_existing = v.into();
        self
    }
}

impl wkt::message::Message for AddAssetsToGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.AddAssetsToGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AddAssetsToGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __group,
            __request_id,
            __assets,
            __allow_existing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddAssetsToGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "group" => Ok(__FieldTag::__group),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "assets" => Ok(__FieldTag::__assets),
                            "allowExisting" => Ok(__FieldTag::__allow_existing),
                            "allow_existing" => Ok(__FieldTag::__allow_existing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AddAssetsToGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddAssetsToGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__assets => {
                            if !fields.insert(__FieldTag::__assets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assets",
                                ));
                            }
                            result.assets =
                                map.next_value::<std::option::Option<crate::model::AssetList>>()?;
                        }
                        __FieldTag::__allow_existing => {
                            if !fields.insert(__FieldTag::__allow_existing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_existing",
                                ));
                            }
                            result.allow_existing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AddAssetsToGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.group.is_empty() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if self.assets.is_some() {
            state.serialize_entry("assets", &self.assets)?;
        }
        if !wkt::internal::is_default(&self.allow_existing) {
            state.serialize_entry("allowExisting", &self.allow_existing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AddAssetsToGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AddAssetsToGroupRequest");
        debug_struct.field("group", &self.group);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("assets", &self.assets);
        debug_struct.field("allow_existing", &self.allow_existing);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to remove assets from a group.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveAssetsFromGroupRequest {
    /// Required. Group reference.
    pub group: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Required. List of assets to be removed.
    /// The maximum number of assets that can be removed in a single request is
    /// 1000.
    pub assets: std::option::Option<crate::model::AssetList>,

    /// Optional. When this value is set to `false` and one of the given assets is
    /// not an existing member of the group, the operation fails with a `Not Found`
    /// error. When set to `true` this situation is silently ignored by the server.
    ///
    /// Default value is `false`.
    pub allow_missing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveAssetsFromGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::RemoveAssetsFromGroupRequest::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::RemoveAssetsFromGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [assets][crate::model::RemoveAssetsFromGroupRequest::assets].
    pub fn set_assets<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AssetList>,
    {
        self.assets = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [assets][crate::model::RemoveAssetsFromGroupRequest::assets].
    pub fn set_or_clear_assets<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AssetList>,
    {
        self.assets = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_missing][crate::model::RemoveAssetsFromGroupRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for RemoveAssetsFromGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.RemoveAssetsFromGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveAssetsFromGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __group,
            __request_id,
            __assets,
            __allow_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveAssetsFromGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "group" => Ok(__FieldTag::__group),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "assets" => Ok(__FieldTag::__assets),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveAssetsFromGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveAssetsFromGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__assets => {
                            if !fields.insert(__FieldTag::__assets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assets",
                                ));
                            }
                            result.assets =
                                map.next_value::<std::option::Option<crate::model::AssetList>>()?;
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveAssetsFromGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.group.is_empty() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if self.assets.is_some() {
            state.serialize_entry("assets", &self.assets)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RemoveAssetsFromGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RemoveAssetsFromGroupRequest");
        debug_struct.field("group", &self.group);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("assets", &self.assets);
        debug_struct.field("allow_missing", &self.allow_missing);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to list error frames for a source.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListErrorFramesRequest {
    /// Required. Parent value (the source) for `ListErrorFramesRequest`.
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. An optional view mode to control the level of details of each
    /// error frame. The default is a BASIC frame view.
    pub view: crate::model::ErrorFrameView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListErrorFramesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListErrorFramesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListErrorFramesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListErrorFramesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListErrorFramesRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ErrorFrameView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListErrorFramesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListErrorFramesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListErrorFramesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListErrorFramesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListErrorFramesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListErrorFramesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::ErrorFrameView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListErrorFramesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListErrorFramesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListErrorFramesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A response for listing error frames.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListErrorFramesResponse {
    /// The list of error frames.
    pub error_frames: std::vec::Vec<crate::model::ErrorFrame>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListErrorFramesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_frames][crate::model::ListErrorFramesResponse::error_frames].
    pub fn set_error_frames<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ErrorFrame>,
    {
        use std::iter::Iterator;
        self.error_frames = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListErrorFramesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListErrorFramesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListErrorFramesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListErrorFramesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListErrorFramesResponse {
    type PageItem = crate::model::ErrorFrame;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.error_frames
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListErrorFramesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error_frames,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListErrorFramesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "errorFrames" => Ok(__FieldTag::__error_frames),
                            "error_frames" => Ok(__FieldTag::__error_frames),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListErrorFramesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListErrorFramesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error_frames => {
                            if !fields.insert(__FieldTag::__error_frames) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_frames",
                                ));
                            }
                            result.error_frames = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ErrorFrame>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListErrorFramesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.error_frames.is_empty() {
            state.serialize_entry("errorFrames", &self.error_frames)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListErrorFramesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListErrorFramesResponse");
        debug_struct.field("error_frames", &self.error_frames);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetErrorFrameRequest {
    /// Required. The name of the frame to retrieve.
    /// Format:
    /// projects/{project}/locations/{location}/sources/{source}/errorFrames/{error_frame}
    pub name: std::string::String,

    /// Optional. An optional view mode to control the level of details for the
    /// frame. The default is a basic frame view.
    pub view: crate::model::ErrorFrameView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetErrorFrameRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetErrorFrameRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetErrorFrameRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ErrorFrameView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetErrorFrameRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetErrorFrameRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetErrorFrameRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetErrorFrameRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetErrorFrameRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetErrorFrameRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::ErrorFrameView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetErrorFrameRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetErrorFrameRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetErrorFrameRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request for a list of sources.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSourcesRequest {
    /// Required. Parent value for `ListSourcesRequest`.
    pub parent: std::string::String,

    /// Requested page size. The server may return fewer items than requested.
    /// If unspecified, the server will pick an appropriate default value.
    pub page_size: i32,

    /// A token identifying a page of results that the server should return.
    pub page_token: std::string::String,

    /// Filtering results.
    pub filter: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSourcesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSourcesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSourcesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSourcesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListSourcesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListSourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListSourcesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSourcesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSourcesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSourcesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSourcesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSourcesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSourcesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSourcesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for listing sources.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSourcesResponse {
    /// The list of sources.
    pub sources: std::vec::Vec<crate::model::Source>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sources][crate::model::ListSourcesResponse::sources].
    pub fn set_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Source>,
    {
        use std::iter::Iterator;
        self.sources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSourcesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListSourcesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListSourcesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSourcesResponse {
    type PageItem = crate::model::Source;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.sources
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSourcesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sources,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSourcesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sources" => Ok(__FieldTag::__sources),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSourcesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSourcesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sources => {
                            if !fields.insert(__FieldTag::__sources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sources",
                                ));
                            }
                            result.sources = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Source>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSourcesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sources.is_empty() {
            state.serialize_entry("sources", &self.sources)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSourcesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSourcesResponse");
        debug_struct.field("sources", &self.sources);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to get a source.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSourceRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSourceRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to create a source.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSourceRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. User specified ID for the source. It will become the last
    /// component of the source name. The ID must be unique within the project,
    /// must conform with RFC-1034, is restricted to lower-cased letters, and has a
    /// maximum length of 63 characters. The ID must match the regular expression:
    /// `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
    pub source_id: std::string::String,

    /// Required. The resource being created.
    pub source: std::option::Option<crate::model::Source>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSourceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source_id][crate::model::CreateSourceRequest::source_id].
    pub fn set_source_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_id = v.into();
        self
    }

    /// Sets the value of [source][crate::model::CreateSourceRequest::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::CreateSourceRequest::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateSourceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.CreateSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __source_id,
            __source,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "sourceId" => Ok(__FieldTag::__source_id),
                            "source_id" => Ok(__FieldTag::__source_id),
                            "source" => Ok(__FieldTag::__source),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_id => {
                            if !fields.insert(__FieldTag::__source_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_id",
                                ));
                            }
                            result.source_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source =
                                map.next_value::<std::option::Option<crate::model::Source>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.source_id.is_empty() {
            state.serialize_entry("sourceId", &self.source_id)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateSourceRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("source_id", &self.source_id);
        debug_struct.field("source", &self.source);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to update a source.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSourceRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `Source` resource by the update.
    /// The values specified in the `update_mask` field are relative to the
    /// resource, not the full request.
    /// A field will be overwritten if it is in the mask.
    /// A single * value in the mask lets you to overwrite all fields.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub source: std::option::Option<crate::model::Source>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateSourceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSourceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::UpdateSourceRequest::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::UpdateSourceRequest::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateSourceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.UpdateSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __source,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "source" => Ok(__FieldTag::__source),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source =
                                map.next_value::<std::option::Option<crate::model::Source>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateSourceRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("source", &self.source);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to delete a source.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSourceRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteSourceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DeleteSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSourceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for listing preference sets.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPreferenceSetsRequest {
    /// Required. Parent value for `ListPreferenceSetsRequest`.
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, at most 500 preference sets will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPreferenceSetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPreferenceSetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPreferenceSetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPreferenceSetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListPreferenceSetsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListPreferenceSetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListPreferenceSetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPreferenceSetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPreferenceSetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPreferenceSetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPreferenceSetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPreferenceSetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListPreferenceSetsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPreferenceSetsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for listing preference sets.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPreferenceSetsResponse {
    /// The list of PreferenceSets
    pub preference_sets: std::vec::Vec<crate::model::PreferenceSet>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPreferenceSetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [preference_sets][crate::model::ListPreferenceSetsResponse::preference_sets].
    pub fn set_preference_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PreferenceSet>,
    {
        use std::iter::Iterator;
        self.preference_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPreferenceSetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListPreferenceSetsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPreferenceSetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListPreferenceSetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPreferenceSetsResponse {
    type PageItem = crate::model::PreferenceSet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.preference_sets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPreferenceSetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __preference_sets,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPreferenceSetsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "preferenceSets" => Ok(__FieldTag::__preference_sets),
                            "preference_sets" => Ok(__FieldTag::__preference_sets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPreferenceSetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPreferenceSetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__preference_sets => {
                            if !fields.insert(__FieldTag::__preference_sets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preference_sets",
                                ));
                            }
                            result.preference_sets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::PreferenceSet>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPreferenceSetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.preference_sets.is_empty() {
            state.serialize_entry("preferenceSets", &self.preference_sets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListPreferenceSetsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPreferenceSetsResponse");
        debug_struct.field("preference_sets", &self.preference_sets);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to get a preference set.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPreferenceSetRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPreferenceSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPreferenceSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPreferenceSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetPreferenceSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetPreferenceSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPreferenceSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetPreferenceSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPreferenceSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetPreferenceSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetPreferenceSetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetPreferenceSetRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to create a preference set.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreatePreferenceSetRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. User specified ID for the preference set. It will become the last
    /// component of the preference set name. The ID must be unique within the
    /// project, must conform with RFC-1034, is restricted to lower-cased letters,
    /// and has a maximum length of 63 characters. The ID must match the regular
    /// expression
    /// `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
    pub preference_set_id: std::string::String,

    /// Required. The preference set resource being created.
    pub preference_set: std::option::Option<crate::model::PreferenceSet>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePreferenceSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePreferenceSetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [preference_set_id][crate::model::CreatePreferenceSetRequest::preference_set_id].
    pub fn set_preference_set_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.preference_set_id = v.into();
        self
    }

    /// Sets the value of [preference_set][crate::model::CreatePreferenceSetRequest::preference_set].
    pub fn set_preference_set<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PreferenceSet>,
    {
        self.preference_set = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [preference_set][crate::model::CreatePreferenceSetRequest::preference_set].
    pub fn set_or_clear_preference_set<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PreferenceSet>,
    {
        self.preference_set = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreatePreferenceSetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreatePreferenceSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.CreatePreferenceSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreatePreferenceSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __preference_set_id,
            __preference_set,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreatePreferenceSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "preferenceSetId" => Ok(__FieldTag::__preference_set_id),
                            "preference_set_id" => Ok(__FieldTag::__preference_set_id),
                            "preferenceSet" => Ok(__FieldTag::__preference_set),
                            "preference_set" => Ok(__FieldTag::__preference_set),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreatePreferenceSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreatePreferenceSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__preference_set_id => {
                            if !fields.insert(__FieldTag::__preference_set_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preference_set_id",
                                ));
                            }
                            result.preference_set_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__preference_set => {
                            if !fields.insert(__FieldTag::__preference_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preference_set",
                                ));
                            }
                            result.preference_set = map
                                .next_value::<std::option::Option<crate::model::PreferenceSet>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreatePreferenceSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.preference_set_id.is_empty() {
            state.serialize_entry("preferenceSetId", &self.preference_set_id)?;
        }
        if self.preference_set.is_some() {
            state.serialize_entry("preferenceSet", &self.preference_set)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreatePreferenceSetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreatePreferenceSetRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("preference_set_id", &self.preference_set_id);
        debug_struct.field("preference_set", &self.preference_set);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to update a preference set.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdatePreferenceSetRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `PreferenceSet` resource by the update.
    /// The values specified in the `update_mask` field are relative to the
    /// resource, not the full request.
    /// A field will be overwritten if it is in the mask.
    /// A single * value in the mask lets you to overwrite all fields.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The preference set resource being updated.
    pub preference_set: std::option::Option<crate::model::PreferenceSet>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdatePreferenceSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdatePreferenceSetRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdatePreferenceSetRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [preference_set][crate::model::UpdatePreferenceSetRequest::preference_set].
    pub fn set_preference_set<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PreferenceSet>,
    {
        self.preference_set = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [preference_set][crate::model::UpdatePreferenceSetRequest::preference_set].
    pub fn set_or_clear_preference_set<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PreferenceSet>,
    {
        self.preference_set = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdatePreferenceSetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePreferenceSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.UpdatePreferenceSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdatePreferenceSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __preference_set,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdatePreferenceSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "preferenceSet" => Ok(__FieldTag::__preference_set),
                            "preference_set" => Ok(__FieldTag::__preference_set),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdatePreferenceSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdatePreferenceSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__preference_set => {
                            if !fields.insert(__FieldTag::__preference_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preference_set",
                                ));
                            }
                            result.preference_set = map
                                .next_value::<std::option::Option<crate::model::PreferenceSet>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdatePreferenceSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.preference_set.is_some() {
            state.serialize_entry("preferenceSet", &self.preference_set)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdatePreferenceSetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdatePreferenceSetRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("preference_set", &self.preference_set);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to delete a preference set.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeletePreferenceSetRequest {
    /// Required. Name of the group resource.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePreferenceSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePreferenceSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeletePreferenceSetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeletePreferenceSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DeletePreferenceSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeletePreferenceSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeletePreferenceSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeletePreferenceSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeletePreferenceSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeletePreferenceSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeletePreferenceSetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeletePreferenceSetRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to get the settings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSettingsRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetSettingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetSettingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSettingsRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to update the settings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSettingsRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `Settings` resource by the update.
    /// The values specified in the `update_mask` field are relative to the
    /// resource, not the full request.
    /// A field will be overwritten if it is in the mask.
    /// A single * value in the mask lets you to overwrite all fields.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The project settings resource being updated.
    pub settings: std::option::Option<crate::model::Settings>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateSettingsRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSettingsRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [settings][crate::model::UpdateSettingsRequest::settings].
    pub fn set_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Settings>,
    {
        self.settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [settings][crate::model::UpdateSettingsRequest::settings].
    pub fn set_or_clear_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Settings>,
    {
        self.settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateSettingsRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.UpdateSettingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __settings,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "settings" => Ok(__FieldTag::__settings),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__settings => {
                            if !fields.insert(__FieldTag::__settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for settings",
                                ));
                            }
                            result.settings =
                                map.next_value::<std::option::Option<crate::model::Settings>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.settings.is_some() {
            state.serialize_entry("settings", &self.settings)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateSettingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateSettingsRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("settings", &self.settings);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to create a `ReportConfig` resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateReportConfigRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. User specified ID for the report config. It will become the last
    /// component of the report config name. The ID must be unique within the
    /// project, must conform with RFC-1034, is restricted to lower-cased letters,
    /// and has a maximum length of 63 characters. The ID must match the regular
    /// expression: [a-z]([a-z0-9-]{0,61}[a-z0-9])?.
    pub report_config_id: std::string::String,

    /// Required. The report config set resource being created.
    pub report_config: std::option::Option<crate::model::ReportConfig>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateReportConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateReportConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [report_config_id][crate::model::CreateReportConfigRequest::report_config_id].
    pub fn set_report_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.report_config_id = v.into();
        self
    }

    /// Sets the value of [report_config][crate::model::CreateReportConfigRequest::report_config].
    pub fn set_report_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReportConfig>,
    {
        self.report_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [report_config][crate::model::CreateReportConfigRequest::report_config].
    pub fn set_or_clear_report_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReportConfig>,
    {
        self.report_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateReportConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateReportConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.CreateReportConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateReportConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __report_config_id,
            __report_config,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateReportConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "reportConfigId" => Ok(__FieldTag::__report_config_id),
                            "report_config_id" => Ok(__FieldTag::__report_config_id),
                            "reportConfig" => Ok(__FieldTag::__report_config),
                            "report_config" => Ok(__FieldTag::__report_config),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateReportConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateReportConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__report_config_id => {
                            if !fields.insert(__FieldTag::__report_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for report_config_id",
                                ));
                            }
                            result.report_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__report_config => {
                            if !fields.insert(__FieldTag::__report_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for report_config",
                                ));
                            }
                            result.report_config = map
                                .next_value::<std::option::Option<crate::model::ReportConfig>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateReportConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.report_config_id.is_empty() {
            state.serialize_entry("reportConfigId", &self.report_config_id)?;
        }
        if self.report_config.is_some() {
            state.serialize_entry("reportConfig", &self.report_config)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateReportConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateReportConfigRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("report_config_id", &self.report_config_id);
        debug_struct.field("report_config", &self.report_config);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to delete a ReportConfig.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteReportConfigRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to `true`, any child `Reports` of this entity will also be
    /// deleted. If set to `false`, the request only works if the resource has no
    /// children.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteReportConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteReportConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteReportConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteReportConfigRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteReportConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DeleteReportConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteReportConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteReportConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteReportConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteReportConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteReportConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteReportConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteReportConfigRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("force", &self.force);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to get a Report.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetReportRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    /// Determines what information to retrieve for the Report.
    pub view: crate::model::ReportView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetReportRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ReportView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetReportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetReportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetReportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetReportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetReportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::ReportView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetReportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetReportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetReportRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request for a list of Reports.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReportsRequest {
    /// Required. Parent value for `ListReportsRequest`.
    pub parent: std::string::String,

    /// Requested page size. The server may return fewer items than requested.
    /// If unspecified, the server will pick an appropriate default value.
    pub page_size: i32,

    /// A token identifying a page of results that the server should return.
    pub page_token: std::string::String,

    /// Filtering results.
    pub filter: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    pub order_by: std::string::String,

    /// Determines what information to retrieve for each Report.
    pub view: crate::model::ReportView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReportsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReportsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReportsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReportsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListReportsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListReportsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListReportsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ReportView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListReportsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListReportsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReportsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReportsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReportsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReportsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::ReportView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReportsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListReportsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReportsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for listing Reports.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReportsResponse {
    /// The list of Reports.
    pub reports: std::vec::Vec<crate::model::Report>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReportsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reports][crate::model::ListReportsResponse::reports].
    pub fn set_reports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Report>,
    {
        use std::iter::Iterator;
        self.reports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListReportsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListReportsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListReportsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListReportsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListReportsResponse {
    type PageItem = crate::model::Report;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.reports
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReportsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reports,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReportsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reports" => Ok(__FieldTag::__reports),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReportsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReportsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reports => {
                            if !fields.insert(__FieldTag::__reports) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reports",
                                ));
                            }
                            result.reports = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Report>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReportsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.reports.is_empty() {
            state.serialize_entry("reports", &self.reports)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListReportsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReportsResponse");
        debug_struct.field("reports", &self.reports);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to delete a Report.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteReportRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteReportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteReportRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DeleteReportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteReportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteReportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteReportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteReportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteReportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteReportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteReportRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to get a `ReportConfig` resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetReportConfigRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetReportConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReportConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetReportConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetReportConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetReportConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetReportConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetReportConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetReportConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetReportConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetReportConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetReportConfigRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to get a list of `ReportConfig` resources.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReportConfigsRequest {
    /// Required. Parent value for `ListReportConfigsRequest`.
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Filtering results.
    pub filter: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReportConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReportConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReportConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReportConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListReportConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListReportConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListReportConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListReportConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReportConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReportConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReportConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReportConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReportConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListReportConfigsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReportConfigsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for listing report configs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReportConfigsResponse {
    /// A list of report configs.
    pub report_configs: std::vec::Vec<crate::model::ReportConfig>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReportConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [report_configs][crate::model::ListReportConfigsResponse::report_configs].
    pub fn set_report_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReportConfig>,
    {
        use std::iter::Iterator;
        self.report_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListReportConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListReportConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListReportConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListReportConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListReportConfigsResponse {
    type PageItem = crate::model::ReportConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.report_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReportConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __report_configs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReportConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reportConfigs" => Ok(__FieldTag::__report_configs),
                            "report_configs" => Ok(__FieldTag::__report_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReportConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReportConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__report_configs => {
                            if !fields.insert(__FieldTag::__report_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for report_configs",
                                ));
                            }
                            result.report_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ReportConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReportConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.report_configs.is_empty() {
            state.serialize_entry("reportConfigs", &self.report_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListReportConfigsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReportConfigsResponse");
        debug_struct.field("report_configs", &self.report_configs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for creating a Report.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateReportRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. User specified id for the report. It will become the last
    /// component of the report name. The id must be unique within the project,
    /// must conform with RFC-1034, is restricted to lower-cased letters, and has a
    /// maximum length of 63 characters. The id must match the regular expression:
    /// [a-z]([a-z0-9-]{0,61}[a-z0-9])?.
    pub report_id: std::string::String,

    /// Required. The report resource being created.
    pub report: std::option::Option<crate::model::Report>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateReportRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [report_id][crate::model::CreateReportRequest::report_id].
    pub fn set_report_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.report_id = v.into();
        self
    }

    /// Sets the value of [report][crate::model::CreateReportRequest::report].
    pub fn set_report<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Report>,
    {
        self.report = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [report][crate::model::CreateReportRequest::report].
    pub fn set_or_clear_report<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Report>,
    {
        self.report = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateReportRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.CreateReportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateReportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __report_id,
            __report,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateReportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "reportId" => Ok(__FieldTag::__report_id),
                            "report_id" => Ok(__FieldTag::__report_id),
                            "report" => Ok(__FieldTag::__report),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateReportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateReportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__report_id => {
                            if !fields.insert(__FieldTag::__report_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for report_id",
                                ));
                            }
                            result.report_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__report => {
                            if !fields.insert(__FieldTag::__report) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for report",
                                ));
                            }
                            result.report =
                                map.next_value::<std::option::Option<crate::model::Report>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateReportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.report_id.is_empty() {
            state.serialize_entry("reportId", &self.report_id)?;
        }
        if self.report.is_some() {
            state.serialize_entry("report", &self.report)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateReportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateReportRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("report_id", &self.report_id);
        debug_struct.field("report", &self.report);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Collection of frame data.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Frames {
    /// A repeated field of asset data.
    pub frames_data: std::vec::Vec<crate::model::AssetFrame>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Frames {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [frames_data][crate::model::Frames::frames_data].
    pub fn set_frames_data<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AssetFrame>,
    {
        use std::iter::Iterator;
        self.frames_data = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Frames {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.Frames"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Frames {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __frames_data,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Frames")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "framesData" => Ok(__FieldTag::__frames_data),
                            "frames_data" => Ok(__FieldTag::__frames_data),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Frames;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Frames")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__frames_data => {
                            if !fields.insert(__FieldTag::__frames_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frames_data",
                                ));
                            }
                            result.frames_data = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AssetFrame>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Frames {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.frames_data.is_empty() {
            state.serialize_entry("framesData", &self.frames_data)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Frames {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Frames");
        debug_struct.field("frames_data", &self.frames_data);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains data reported from an inventory source on an asset.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AssetFrame {
    /// The time the data was reported.
    pub report_time: std::option::Option<wkt::Timestamp>,

    /// Labels as key value pairs.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Generic asset attributes.
    pub attributes: std::collections::HashMap<std::string::String, std::string::String>,

    /// Asset performance data samples.
    /// Samples that are from more than 40 days ago or after tomorrow are ignored.
    pub performance_samples: std::vec::Vec<crate::model::PerformanceSample>,

    /// Optional. Trace token is optionally provided to assist with debugging and
    /// traceability.
    pub trace_token: std::string::String,

    /// The internal data of the frame is a oneof field depending on the type
    /// of asset information in the frame.
    pub frame_data: std::option::Option<crate::model::asset_frame::FrameData>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssetFrame {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [report_time][crate::model::AssetFrame::report_time].
    pub fn set_report_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.report_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [report_time][crate::model::AssetFrame::report_time].
    pub fn set_or_clear_report_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.report_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::AssetFrame::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [attributes][crate::model::AssetFrame::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [performance_samples][crate::model::AssetFrame::performance_samples].
    pub fn set_performance_samples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PerformanceSample>,
    {
        use std::iter::Iterator;
        self.performance_samples = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [trace_token][crate::model::AssetFrame::trace_token].
    pub fn set_trace_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trace_token = v.into();
        self
    }

    /// Sets the value of [frame_data][crate::model::AssetFrame::frame_data].
    ///
    /// Note that all the setters affecting `frame_data` are mutually
    /// exclusive.
    pub fn set_frame_data<
        T: std::convert::Into<std::option::Option<crate::model::asset_frame::FrameData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.frame_data = v.into();
        self
    }

    /// The value of [frame_data][crate::model::AssetFrame::frame_data]
    /// if it holds a `MachineDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn machine_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MachineDetails>> {
        #[allow(unreachable_patterns)]
        self.frame_data.as_ref().and_then(|v| match v {
            crate::model::asset_frame::FrameData::MachineDetails(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [frame_data][crate::model::AssetFrame::frame_data]
    /// to hold a `MachineDetails`.
    ///
    /// Note that all the setters affecting `frame_data` are
    /// mutually exclusive.
    pub fn set_machine_details<
        T: std::convert::Into<std::boxed::Box<crate::model::MachineDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.frame_data = std::option::Option::Some(
            crate::model::asset_frame::FrameData::MachineDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AssetFrame {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.AssetFrame"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AssetFrame {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __machine_details,
            __report_time,
            __labels,
            __attributes,
            __performance_samples,
            __trace_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AssetFrame")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "machineDetails" => Ok(__FieldTag::__machine_details),
                            "machine_details" => Ok(__FieldTag::__machine_details),
                            "reportTime" => Ok(__FieldTag::__report_time),
                            "report_time" => Ok(__FieldTag::__report_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "attributes" => Ok(__FieldTag::__attributes),
                            "performanceSamples" => Ok(__FieldTag::__performance_samples),
                            "performance_samples" => Ok(__FieldTag::__performance_samples),
                            "traceToken" => Ok(__FieldTag::__trace_token),
                            "trace_token" => Ok(__FieldTag::__trace_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AssetFrame;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AssetFrame")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__machine_details => {
                            if !fields.insert(__FieldTag::__machine_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_details",
                                ));
                            }
                            if result.frame_data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `frame_data`, a oneof with full ID .google.cloud.migrationcenter.v1.AssetFrame.machine_details, latest field was machineDetails",
                                ));
                            }
                            result.frame_data = std::option::Option::Some(
                                crate::model::asset_frame::FrameData::MachineDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MachineDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__report_time => {
                            if !fields.insert(__FieldTag::__report_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for report_time",
                                ));
                            }
                            result.report_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__performance_samples => {
                            if !fields.insert(__FieldTag::__performance_samples) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for performance_samples",
                                ));
                            }
                            result.performance_samples =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PerformanceSample>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trace_token => {
                            if !fields.insert(__FieldTag::__trace_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trace_token",
                                ));
                            }
                            result.trace_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AssetFrame {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.machine_details() {
            state.serialize_entry("machineDetails", value)?;
        }
        if self.report_time.is_some() {
            state.serialize_entry("reportTime", &self.report_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if !self.performance_samples.is_empty() {
            state.serialize_entry("performanceSamples", &self.performance_samples)?;
        }
        if !self.trace_token.is_empty() {
            state.serialize_entry("traceToken", &self.trace_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AssetFrame {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AssetFrame");
        debug_struct.field("report_time", &self.report_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("attributes", &self.attributes);
        debug_struct.field("performance_samples", &self.performance_samples);
        debug_struct.field("trace_token", &self.trace_token);
        debug_struct.field("frame_data", &self.frame_data);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AssetFrame].
pub mod asset_frame {
    #[allow(unused_imports)]
    use super::*;

    /// The internal data of the frame is a oneof field depending on the type
    /// of asset information in the frame.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FrameData {
        /// Asset information specific for virtual machines.
        MachineDetails(std::boxed::Box<crate::model::MachineDetails>),
    }
}

/// Details of a machine.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MachineDetails {
    /// Machine unique identifier.
    pub uuid: std::string::String,

    /// Machine name.
    pub machine_name: std::string::String,

    /// Machine creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Number of CPU cores in the machine. Must be non-negative.
    pub core_count: i32,

    /// The amount of memory in the machine. Must be non-negative.
    pub memory_mb: i32,

    /// Power state of the machine.
    pub power_state: crate::model::machine_details::PowerState,

    /// Architecture details (vendor, CPU architecture).
    pub architecture: std::option::Option<crate::model::MachineArchitectureDetails>,

    /// Guest OS information.
    pub guest_os: std::option::Option<crate::model::GuestOsDetails>,

    /// Network details.
    pub network: std::option::Option<crate::model::MachineNetworkDetails>,

    /// Disk details.
    pub disks: std::option::Option<crate::model::MachineDiskDetails>,

    /// Platform specific information.
    pub platform: std::option::Option<crate::model::PlatformDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MachineDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uuid][crate::model::MachineDetails::uuid].
    pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uuid = v.into();
        self
    }

    /// Sets the value of [machine_name][crate::model::MachineDetails::machine_name].
    pub fn set_machine_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MachineDetails::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::MachineDetails::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [core_count][crate::model::MachineDetails::core_count].
    pub fn set_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.core_count = v.into();
        self
    }

    /// Sets the value of [memory_mb][crate::model::MachineDetails::memory_mb].
    pub fn set_memory_mb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_mb = v.into();
        self
    }

    /// Sets the value of [power_state][crate::model::MachineDetails::power_state].
    pub fn set_power_state<T: std::convert::Into<crate::model::machine_details::PowerState>>(
        mut self,
        v: T,
    ) -> Self {
        self.power_state = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::MachineDetails::architecture].
    pub fn set_architecture<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MachineArchitectureDetails>,
    {
        self.architecture = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [architecture][crate::model::MachineDetails::architecture].
    pub fn set_or_clear_architecture<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MachineArchitectureDetails>,
    {
        self.architecture = v.map(|x| x.into());
        self
    }

    /// Sets the value of [guest_os][crate::model::MachineDetails::guest_os].
    pub fn set_guest_os<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GuestOsDetails>,
    {
        self.guest_os = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [guest_os][crate::model::MachineDetails::guest_os].
    pub fn set_or_clear_guest_os<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GuestOsDetails>,
    {
        self.guest_os = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network][crate::model::MachineDetails::network].
    pub fn set_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MachineNetworkDetails>,
    {
        self.network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network][crate::model::MachineDetails::network].
    pub fn set_or_clear_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MachineNetworkDetails>,
    {
        self.network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disks][crate::model::MachineDetails::disks].
    pub fn set_disks<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MachineDiskDetails>,
    {
        self.disks = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disks][crate::model::MachineDetails::disks].
    pub fn set_or_clear_disks<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MachineDiskDetails>,
    {
        self.disks = v.map(|x| x.into());
        self
    }

    /// Sets the value of [platform][crate::model::MachineDetails::platform].
    pub fn set_platform<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PlatformDetails>,
    {
        self.platform = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [platform][crate::model::MachineDetails::platform].
    pub fn set_or_clear_platform<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PlatformDetails>,
    {
        self.platform = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MachineDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.MachineDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MachineDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uuid,
            __machine_name,
            __create_time,
            __core_count,
            __memory_mb,
            __power_state,
            __architecture,
            __guest_os,
            __network,
            __disks,
            __platform,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MachineDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uuid" => Ok(__FieldTag::__uuid),
                            "machineName" => Ok(__FieldTag::__machine_name),
                            "machine_name" => Ok(__FieldTag::__machine_name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "coreCount" => Ok(__FieldTag::__core_count),
                            "core_count" => Ok(__FieldTag::__core_count),
                            "memoryMb" => Ok(__FieldTag::__memory_mb),
                            "memory_mb" => Ok(__FieldTag::__memory_mb),
                            "powerState" => Ok(__FieldTag::__power_state),
                            "power_state" => Ok(__FieldTag::__power_state),
                            "architecture" => Ok(__FieldTag::__architecture),
                            "guestOs" => Ok(__FieldTag::__guest_os),
                            "guest_os" => Ok(__FieldTag::__guest_os),
                            "network" => Ok(__FieldTag::__network),
                            "disks" => Ok(__FieldTag::__disks),
                            "platform" => Ok(__FieldTag::__platform),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MachineDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MachineDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uuid => {
                            if !fields.insert(__FieldTag::__uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uuid",
                                ));
                            }
                            result.uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_name => {
                            if !fields.insert(__FieldTag::__machine_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_name",
                                ));
                            }
                            result.machine_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__core_count => {
                            if !fields.insert(__FieldTag::__core_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for core_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.core_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_mb => {
                            if !fields.insert(__FieldTag::__memory_mb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_mb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_mb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__power_state => {
                            if !fields.insert(__FieldTag::__power_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for power_state",
                                ));
                            }
                            result.power_state = map.next_value::<std::option::Option<crate::model::machine_details::PowerState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__architecture => {
                            if !fields.insert(__FieldTag::__architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for architecture",
                                ));
                            }
                            result.architecture = map.next_value::<std::option::Option<crate::model::MachineArchitectureDetails>>()?
                                ;
                        }
                        __FieldTag::__guest_os => {
                            if !fields.insert(__FieldTag::__guest_os) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for guest_os",
                                ));
                            }
                            result.guest_os = map
                                .next_value::<std::option::Option<crate::model::GuestOsDetails>>(
                                )?;
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map.next_value::<std::option::Option<crate::model::MachineNetworkDetails>>()?
                                ;
                        }
                        __FieldTag::__disks => {
                            if !fields.insert(__FieldTag::__disks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disks",
                                ));
                            }
                            result.disks = map.next_value::<std::option::Option<crate::model::MachineDiskDetails>>()?
                                ;
                        }
                        __FieldTag::__platform => {
                            if !fields.insert(__FieldTag::__platform) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for platform",
                                ));
                            }
                            result.platform = map
                                .next_value::<std::option::Option<crate::model::PlatformDetails>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MachineDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uuid.is_empty() {
            state.serialize_entry("uuid", &self.uuid)?;
        }
        if !self.machine_name.is_empty() {
            state.serialize_entry("machineName", &self.machine_name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.core_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("coreCount", &__With(&self.core_count))?;
        }
        if !wkt::internal::is_default(&self.memory_mb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("memoryMb", &__With(&self.memory_mb))?;
        }
        if !wkt::internal::is_default(&self.power_state) {
            state.serialize_entry("powerState", &self.power_state)?;
        }
        if self.architecture.is_some() {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if self.guest_os.is_some() {
            state.serialize_entry("guestOs", &self.guest_os)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.disks.is_some() {
            state.serialize_entry("disks", &self.disks)?;
        }
        if self.platform.is_some() {
            state.serialize_entry("platform", &self.platform)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MachineDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MachineDetails");
        debug_struct.field("uuid", &self.uuid);
        debug_struct.field("machine_name", &self.machine_name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("core_count", &self.core_count);
        debug_struct.field("memory_mb", &self.memory_mb);
        debug_struct.field("power_state", &self.power_state);
        debug_struct.field("architecture", &self.architecture);
        debug_struct.field("guest_os", &self.guest_os);
        debug_struct.field("network", &self.network);
        debug_struct.field("disks", &self.disks);
        debug_struct.field("platform", &self.platform);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MachineDetails].
pub mod machine_details {
    #[allow(unused_imports)]
    use super::*;

    /// Machine power state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PowerState {
        /// Power state is unknown.
        Unspecified,
        /// The machine is preparing to enter the ACTIVE state. An instance may enter
        /// the PENDING state when it launches for the first time, or when it is
        /// started after being in the SUSPENDED state.
        Pending,
        /// The machine is active.
        Active,
        /// The machine is being turned off.
        Suspending,
        /// The machine is off.
        Suspended,
        /// The machine is being deleted from the hosting platform.
        Deleting,
        /// The machine is deleted from the hosting platform.
        Deleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PowerState::value] or
        /// [PowerState::name].
        UnknownValue(power_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod power_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PowerState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Suspending => std::option::Option::Some(3),
                Self::Suspended => std::option::Option::Some(4),
                Self::Deleting => std::option::Option::Some(5),
                Self::Deleted => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("POWER_STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Suspending => std::option::Option::Some("SUSPENDING"),
                Self::Suspended => std::option::Option::Some("SUSPENDED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PowerState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PowerState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PowerState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Active,
                3 => Self::Suspending,
                4 => Self::Suspended,
                5 => Self::Deleting,
                6 => Self::Deleted,
                _ => Self::UnknownValue(power_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PowerState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "POWER_STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "ACTIVE" => Self::Active,
                "SUSPENDING" => Self::Suspending,
                "SUSPENDED" => Self::Suspended,
                "DELETING" => Self::Deleting,
                "DELETED" => Self::Deleted,
                _ => Self::UnknownValue(power_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PowerState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Suspending => serializer.serialize_i32(3),
                Self::Suspended => serializer.serialize_i32(4),
                Self::Deleting => serializer.serialize_i32(5),
                Self::Deleted => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PowerState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PowerState>::new(
                ".google.cloud.migrationcenter.v1.MachineDetails.PowerState",
            ))
        }
    }
}

/// Details of the machine architecture.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MachineArchitectureDetails {
    /// CPU architecture, e.g., "x64-based PC", "x86_64", "i686" etc.
    pub cpu_architecture: std::string::String,

    /// CPU name, e.g., "Intel Xeon E5-2690", "AMD EPYC 7571" etc.
    pub cpu_name: std::string::String,

    /// Hardware vendor.
    pub vendor: std::string::String,

    /// Number of CPU threads allocated to the machine.
    pub cpu_thread_count: i32,

    /// Number of processor sockets allocated to the machine.
    pub cpu_socket_count: i32,

    /// BIOS Details.
    pub bios: std::option::Option<crate::model::BiosDetails>,

    /// Firmware type.
    pub firmware_type: crate::model::machine_architecture_details::FirmwareType,

    /// CPU hyper-threading support.
    pub hyperthreading: crate::model::machine_architecture_details::CpuHyperThreading,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MachineArchitectureDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpu_architecture][crate::model::MachineArchitectureDetails::cpu_architecture].
    pub fn set_cpu_architecture<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cpu_architecture = v.into();
        self
    }

    /// Sets the value of [cpu_name][crate::model::MachineArchitectureDetails::cpu_name].
    pub fn set_cpu_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpu_name = v.into();
        self
    }

    /// Sets the value of [vendor][crate::model::MachineArchitectureDetails::vendor].
    pub fn set_vendor<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vendor = v.into();
        self
    }

    /// Sets the value of [cpu_thread_count][crate::model::MachineArchitectureDetails::cpu_thread_count].
    pub fn set_cpu_thread_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_thread_count = v.into();
        self
    }

    /// Sets the value of [cpu_socket_count][crate::model::MachineArchitectureDetails::cpu_socket_count].
    pub fn set_cpu_socket_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_socket_count = v.into();
        self
    }

    /// Sets the value of [bios][crate::model::MachineArchitectureDetails::bios].
    pub fn set_bios<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BiosDetails>,
    {
        self.bios = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bios][crate::model::MachineArchitectureDetails::bios].
    pub fn set_or_clear_bios<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BiosDetails>,
    {
        self.bios = v.map(|x| x.into());
        self
    }

    /// Sets the value of [firmware_type][crate::model::MachineArchitectureDetails::firmware_type].
    pub fn set_firmware_type<
        T: std::convert::Into<crate::model::machine_architecture_details::FirmwareType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firmware_type = v.into();
        self
    }

    /// Sets the value of [hyperthreading][crate::model::MachineArchitectureDetails::hyperthreading].
    pub fn set_hyperthreading<
        T: std::convert::Into<crate::model::machine_architecture_details::CpuHyperThreading>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hyperthreading = v.into();
        self
    }
}

impl wkt::message::Message for MachineArchitectureDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.MachineArchitectureDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MachineArchitectureDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cpu_architecture,
            __cpu_name,
            __vendor,
            __cpu_thread_count,
            __cpu_socket_count,
            __bios,
            __firmware_type,
            __hyperthreading,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MachineArchitectureDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cpuArchitecture" => Ok(__FieldTag::__cpu_architecture),
                            "cpu_architecture" => Ok(__FieldTag::__cpu_architecture),
                            "cpuName" => Ok(__FieldTag::__cpu_name),
                            "cpu_name" => Ok(__FieldTag::__cpu_name),
                            "vendor" => Ok(__FieldTag::__vendor),
                            "cpuThreadCount" => Ok(__FieldTag::__cpu_thread_count),
                            "cpu_thread_count" => Ok(__FieldTag::__cpu_thread_count),
                            "cpuSocketCount" => Ok(__FieldTag::__cpu_socket_count),
                            "cpu_socket_count" => Ok(__FieldTag::__cpu_socket_count),
                            "bios" => Ok(__FieldTag::__bios),
                            "firmwareType" => Ok(__FieldTag::__firmware_type),
                            "firmware_type" => Ok(__FieldTag::__firmware_type),
                            "hyperthreading" => Ok(__FieldTag::__hyperthreading),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MachineArchitectureDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MachineArchitectureDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cpu_architecture => {
                            if !fields.insert(__FieldTag::__cpu_architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_architecture",
                                ));
                            }
                            result.cpu_architecture = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cpu_name => {
                            if !fields.insert(__FieldTag::__cpu_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_name",
                                ));
                            }
                            result.cpu_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vendor => {
                            if !fields.insert(__FieldTag::__vendor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vendor",
                                ));
                            }
                            result.vendor = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cpu_thread_count => {
                            if !fields.insert(__FieldTag::__cpu_thread_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_thread_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_thread_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cpu_socket_count => {
                            if !fields.insert(__FieldTag::__cpu_socket_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_socket_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_socket_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bios => {
                            if !fields.insert(__FieldTag::__bios) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bios",
                                ));
                            }
                            result.bios =
                                map.next_value::<std::option::Option<crate::model::BiosDetails>>()?;
                        }
                        __FieldTag::__firmware_type => {
                            if !fields.insert(__FieldTag::__firmware_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for firmware_type",
                                ));
                            }
                            result.firmware_type = map
                                .next_value::<std::option::Option<
                                    crate::model::machine_architecture_details::FirmwareType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hyperthreading => {
                            if !fields.insert(__FieldTag::__hyperthreading) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hyperthreading",
                                ));
                            }
                            result.hyperthreading = map
                                .next_value::<std::option::Option<
                                    crate::model::machine_architecture_details::CpuHyperThreading,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MachineArchitectureDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cpu_architecture.is_empty() {
            state.serialize_entry("cpuArchitecture", &self.cpu_architecture)?;
        }
        if !self.cpu_name.is_empty() {
            state.serialize_entry("cpuName", &self.cpu_name)?;
        }
        if !self.vendor.is_empty() {
            state.serialize_entry("vendor", &self.vendor)?;
        }
        if !wkt::internal::is_default(&self.cpu_thread_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cpuThreadCount", &__With(&self.cpu_thread_count))?;
        }
        if !wkt::internal::is_default(&self.cpu_socket_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cpuSocketCount", &__With(&self.cpu_socket_count))?;
        }
        if self.bios.is_some() {
            state.serialize_entry("bios", &self.bios)?;
        }
        if !wkt::internal::is_default(&self.firmware_type) {
            state.serialize_entry("firmwareType", &self.firmware_type)?;
        }
        if !wkt::internal::is_default(&self.hyperthreading) {
            state.serialize_entry("hyperthreading", &self.hyperthreading)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MachineArchitectureDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MachineArchitectureDetails");
        debug_struct.field("cpu_architecture", &self.cpu_architecture);
        debug_struct.field("cpu_name", &self.cpu_name);
        debug_struct.field("vendor", &self.vendor);
        debug_struct.field("cpu_thread_count", &self.cpu_thread_count);
        debug_struct.field("cpu_socket_count", &self.cpu_socket_count);
        debug_struct.field("bios", &self.bios);
        debug_struct.field("firmware_type", &self.firmware_type);
        debug_struct.field("hyperthreading", &self.hyperthreading);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MachineArchitectureDetails].
pub mod machine_architecture_details {
    #[allow(unused_imports)]
    use super::*;

    /// Firmware type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FirmwareType {
        /// Unspecified or unknown.
        Unspecified,
        /// BIOS firmware.
        Bios,
        /// EFI firmware.
        Efi,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FirmwareType::value] or
        /// [FirmwareType::name].
        UnknownValue(firmware_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod firmware_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FirmwareType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Bios => std::option::Option::Some(1),
                Self::Efi => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FIRMWARE_TYPE_UNSPECIFIED"),
                Self::Bios => std::option::Option::Some("BIOS"),
                Self::Efi => std::option::Option::Some("EFI"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FirmwareType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FirmwareType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FirmwareType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Bios,
                2 => Self::Efi,
                _ => Self::UnknownValue(firmware_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FirmwareType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FIRMWARE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BIOS" => Self::Bios,
                "EFI" => Self::Efi,
                _ => Self::UnknownValue(firmware_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FirmwareType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Bios => serializer.serialize_i32(1),
                Self::Efi => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FirmwareType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FirmwareType>::new(
                ".google.cloud.migrationcenter.v1.MachineArchitectureDetails.FirmwareType",
            ))
        }
    }

    /// CPU hyper-threading support.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CpuHyperThreading {
        /// Unspecified or unknown.
        Unspecified,
        /// Hyper-threading is disabled.
        Disabled,
        /// Hyper-threading is enabled.
        Enabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CpuHyperThreading::value] or
        /// [CpuHyperThreading::name].
        UnknownValue(cpu_hyper_threading::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cpu_hyper_threading {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CpuHyperThreading {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::Enabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CPU_HYPER_THREADING_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CpuHyperThreading {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CpuHyperThreading {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CpuHyperThreading {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::Enabled,
                _ => Self::UnknownValue(cpu_hyper_threading::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CpuHyperThreading {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CPU_HYPER_THREADING_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "ENABLED" => Self::Enabled,
                _ => Self::UnknownValue(cpu_hyper_threading::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CpuHyperThreading {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::Enabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CpuHyperThreading {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CpuHyperThreading>::new(
                ".google.cloud.migrationcenter.v1.MachineArchitectureDetails.CpuHyperThreading",
            ))
        }
    }
}

/// Details about the BIOS.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BiosDetails {
    /// BIOS name.
    /// This fields is deprecated. Please use the `id` field instead.
    #[deprecated]
    pub bios_name: std::string::String,

    /// BIOS ID.
    pub id: std::string::String,

    /// BIOS manufacturer.
    pub manufacturer: std::string::String,

    /// BIOS version.
    pub version: std::string::String,

    /// BIOS release date.
    pub release_date: std::option::Option<gtype::model::Date>,

    /// SMBIOS UUID.
    pub smbios_uuid: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BiosDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bios_name][crate::model::BiosDetails::bios_name].
    #[deprecated]
    pub fn set_bios_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bios_name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::BiosDetails::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [manufacturer][crate::model::BiosDetails::manufacturer].
    pub fn set_manufacturer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.manufacturer = v.into();
        self
    }

    /// Sets the value of [version][crate::model::BiosDetails::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [release_date][crate::model::BiosDetails::release_date].
    pub fn set_release_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.release_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [release_date][crate::model::BiosDetails::release_date].
    pub fn set_or_clear_release_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.release_date = v.map(|x| x.into());
        self
    }

    /// Sets the value of [smbios_uuid][crate::model::BiosDetails::smbios_uuid].
    pub fn set_smbios_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.smbios_uuid = v.into();
        self
    }
}

impl wkt::message::Message for BiosDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.BiosDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BiosDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bios_name,
            __id,
            __manufacturer,
            __version,
            __release_date,
            __smbios_uuid,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BiosDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "biosName" => Ok(__FieldTag::__bios_name),
                            "bios_name" => Ok(__FieldTag::__bios_name),
                            "id" => Ok(__FieldTag::__id),
                            "manufacturer" => Ok(__FieldTag::__manufacturer),
                            "version" => Ok(__FieldTag::__version),
                            "releaseDate" => Ok(__FieldTag::__release_date),
                            "release_date" => Ok(__FieldTag::__release_date),
                            "smbiosUuid" => Ok(__FieldTag::__smbios_uuid),
                            "smbios_uuid" => Ok(__FieldTag::__smbios_uuid),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BiosDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BiosDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bios_name => {
                            if !fields.insert(__FieldTag::__bios_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bios_name",
                                ));
                            }
                            result.bios_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__manufacturer => {
                            if !fields.insert(__FieldTag::__manufacturer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for manufacturer",
                                ));
                            }
                            result.manufacturer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release_date => {
                            if !fields.insert(__FieldTag::__release_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_date",
                                ));
                            }
                            result.release_date =
                                map.next_value::<std::option::Option<gtype::model::Date>>()?;
                        }
                        __FieldTag::__smbios_uuid => {
                            if !fields.insert(__FieldTag::__smbios_uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for smbios_uuid",
                                ));
                            }
                            result.smbios_uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BiosDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bios_name.is_empty() {
            state.serialize_entry("biosName", &self.bios_name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.manufacturer.is_empty() {
            state.serialize_entry("manufacturer", &self.manufacturer)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.release_date.is_some() {
            state.serialize_entry("releaseDate", &self.release_date)?;
        }
        if !self.smbios_uuid.is_empty() {
            state.serialize_entry("smbiosUuid", &self.smbios_uuid)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BiosDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BiosDetails");
        debug_struct.field("bios_name", &self.bios_name);
        debug_struct.field("id", &self.id);
        debug_struct.field("manufacturer", &self.manufacturer);
        debug_struct.field("version", &self.version);
        debug_struct.field("release_date", &self.release_date);
        debug_struct.field("smbios_uuid", &self.smbios_uuid);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details of network adapters and settings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MachineNetworkDetails {
    /// The primary IP address of the machine.
    pub primary_ip_address: std::string::String,

    /// The public IP address of the machine.
    pub public_ip_address: std::string::String,

    /// MAC address of the machine.
    /// This property is used to uniqly identify the machine.
    pub primary_mac_address: std::string::String,

    /// List of network adapters.
    pub adapters: std::option::Option<crate::model::NetworkAdapterList>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MachineNetworkDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [primary_ip_address][crate::model::MachineNetworkDetails::primary_ip_address].
    pub fn set_primary_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.primary_ip_address = v.into();
        self
    }

    /// Sets the value of [public_ip_address][crate::model::MachineNetworkDetails::public_ip_address].
    pub fn set_public_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.public_ip_address = v.into();
        self
    }

    /// Sets the value of [primary_mac_address][crate::model::MachineNetworkDetails::primary_mac_address].
    pub fn set_primary_mac_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.primary_mac_address = v.into();
        self
    }

    /// Sets the value of [adapters][crate::model::MachineNetworkDetails::adapters].
    pub fn set_adapters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkAdapterList>,
    {
        self.adapters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [adapters][crate::model::MachineNetworkDetails::adapters].
    pub fn set_or_clear_adapters<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkAdapterList>,
    {
        self.adapters = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MachineNetworkDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.MachineNetworkDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MachineNetworkDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __primary_ip_address,
            __public_ip_address,
            __primary_mac_address,
            __adapters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MachineNetworkDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "primaryIpAddress" => Ok(__FieldTag::__primary_ip_address),
                            "primary_ip_address" => Ok(__FieldTag::__primary_ip_address),
                            "publicIpAddress" => Ok(__FieldTag::__public_ip_address),
                            "public_ip_address" => Ok(__FieldTag::__public_ip_address),
                            "primaryMacAddress" => Ok(__FieldTag::__primary_mac_address),
                            "primary_mac_address" => Ok(__FieldTag::__primary_mac_address),
                            "adapters" => Ok(__FieldTag::__adapters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MachineNetworkDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MachineNetworkDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__primary_ip_address => {
                            if !fields.insert(__FieldTag::__primary_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_ip_address",
                                ));
                            }
                            result.primary_ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__public_ip_address => {
                            if !fields.insert(__FieldTag::__public_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_ip_address",
                                ));
                            }
                            result.public_ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__primary_mac_address => {
                            if !fields.insert(__FieldTag::__primary_mac_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_mac_address",
                                ));
                            }
                            result.primary_mac_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__adapters => {
                            if !fields.insert(__FieldTag::__adapters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for adapters",
                                ));
                            }
                            result.adapters = map.next_value::<std::option::Option<crate::model::NetworkAdapterList>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MachineNetworkDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.primary_ip_address.is_empty() {
            state.serialize_entry("primaryIpAddress", &self.primary_ip_address)?;
        }
        if !self.public_ip_address.is_empty() {
            state.serialize_entry("publicIpAddress", &self.public_ip_address)?;
        }
        if !self.primary_mac_address.is_empty() {
            state.serialize_entry("primaryMacAddress", &self.primary_mac_address)?;
        }
        if self.adapters.is_some() {
            state.serialize_entry("adapters", &self.adapters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MachineNetworkDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MachineNetworkDetails");
        debug_struct.field("primary_ip_address", &self.primary_ip_address);
        debug_struct.field("public_ip_address", &self.public_ip_address);
        debug_struct.field("primary_mac_address", &self.primary_mac_address);
        debug_struct.field("adapters", &self.adapters);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// List of network adapters.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkAdapterList {
    /// Network adapter entries.
    pub entries: std::vec::Vec<crate::model::NetworkAdapterDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkAdapterList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::NetworkAdapterList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkAdapterDetails>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NetworkAdapterList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.NetworkAdapterList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkAdapterList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkAdapterList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entries" => Ok(__FieldTag::__entries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkAdapterList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkAdapterList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NetworkAdapterDetails>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkAdapterList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NetworkAdapterList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkAdapterList");
        debug_struct.field("entries", &self.entries);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details of network adapter.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkAdapterDetails {
    /// Network adapter type (e.g. VMXNET3).
    pub adapter_type: std::string::String,

    /// MAC address.
    pub mac_address: std::string::String,

    /// NetworkAddressList
    pub addresses: std::option::Option<crate::model::NetworkAddressList>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkAdapterDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [adapter_type][crate::model::NetworkAdapterDetails::adapter_type].
    pub fn set_adapter_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.adapter_type = v.into();
        self
    }

    /// Sets the value of [mac_address][crate::model::NetworkAdapterDetails::mac_address].
    pub fn set_mac_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mac_address = v.into();
        self
    }

    /// Sets the value of [addresses][crate::model::NetworkAdapterDetails::addresses].
    pub fn set_addresses<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkAddressList>,
    {
        self.addresses = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [addresses][crate::model::NetworkAdapterDetails::addresses].
    pub fn set_or_clear_addresses<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkAddressList>,
    {
        self.addresses = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NetworkAdapterDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.NetworkAdapterDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkAdapterDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __adapter_type,
            __mac_address,
            __addresses,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkAdapterDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "adapterType" => Ok(__FieldTag::__adapter_type),
                            "adapter_type" => Ok(__FieldTag::__adapter_type),
                            "macAddress" => Ok(__FieldTag::__mac_address),
                            "mac_address" => Ok(__FieldTag::__mac_address),
                            "addresses" => Ok(__FieldTag::__addresses),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkAdapterDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkAdapterDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__adapter_type => {
                            if !fields.insert(__FieldTag::__adapter_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for adapter_type",
                                ));
                            }
                            result.adapter_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mac_address => {
                            if !fields.insert(__FieldTag::__mac_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mac_address",
                                ));
                            }
                            result.mac_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__addresses => {
                            if !fields.insert(__FieldTag::__addresses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for addresses",
                                ));
                            }
                            result.addresses = map.next_value::<std::option::Option<crate::model::NetworkAddressList>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkAdapterDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.adapter_type.is_empty() {
            state.serialize_entry("adapterType", &self.adapter_type)?;
        }
        if !self.mac_address.is_empty() {
            state.serialize_entry("macAddress", &self.mac_address)?;
        }
        if self.addresses.is_some() {
            state.serialize_entry("addresses", &self.addresses)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NetworkAdapterDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkAdapterDetails");
        debug_struct.field("adapter_type", &self.adapter_type);
        debug_struct.field("mac_address", &self.mac_address);
        debug_struct.field("addresses", &self.addresses);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// List of allocated/assigned network addresses.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkAddressList {
    /// Network address entries.
    pub entries: std::vec::Vec<crate::model::NetworkAddress>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkAddressList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::NetworkAddressList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkAddress>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NetworkAddressList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.NetworkAddressList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkAddressList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkAddressList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entries" => Ok(__FieldTag::__entries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkAddressList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkAddressList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NetworkAddress>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkAddressList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NetworkAddressList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkAddressList");
        debug_struct.field("entries", &self.entries);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details of network address.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkAddress {
    /// Assigned or configured IP Address.
    pub ip_address: std::string::String,

    /// Subnet mask.
    pub subnet_mask: std::string::String,

    /// Broadcast address.
    pub bcast: std::string::String,

    /// Fully qualified domain name.
    pub fqdn: std::string::String,

    /// Whether DHCP is used to assign addresses.
    pub assignment: crate::model::network_address::AddressAssignment,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkAddress {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip_address][crate::model::NetworkAddress::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [subnet_mask][crate::model::NetworkAddress::subnet_mask].
    pub fn set_subnet_mask<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet_mask = v.into();
        self
    }

    /// Sets the value of [bcast][crate::model::NetworkAddress::bcast].
    pub fn set_bcast<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bcast = v.into();
        self
    }

    /// Sets the value of [fqdn][crate::model::NetworkAddress::fqdn].
    pub fn set_fqdn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fqdn = v.into();
        self
    }

    /// Sets the value of [assignment][crate::model::NetworkAddress::assignment].
    pub fn set_assignment<
        T: std::convert::Into<crate::model::network_address::AddressAssignment>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.assignment = v.into();
        self
    }
}

impl wkt::message::Message for NetworkAddress {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.NetworkAddress"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkAddress {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ip_address,
            __subnet_mask,
            __bcast,
            __fqdn,
            __assignment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkAddress")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "subnetMask" => Ok(__FieldTag::__subnet_mask),
                            "subnet_mask" => Ok(__FieldTag::__subnet_mask),
                            "bcast" => Ok(__FieldTag::__bcast),
                            "fqdn" => Ok(__FieldTag::__fqdn),
                            "assignment" => Ok(__FieldTag::__assignment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkAddress;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkAddress")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnet_mask => {
                            if !fields.insert(__FieldTag::__subnet_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnet_mask",
                                ));
                            }
                            result.subnet_mask = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bcast => {
                            if !fields.insert(__FieldTag::__bcast) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bcast",
                                ));
                            }
                            result.bcast = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fqdn => {
                            if !fields.insert(__FieldTag::__fqdn) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fqdn",
                                ));
                            }
                            result.fqdn = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__assignment => {
                            if !fields.insert(__FieldTag::__assignment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assignment",
                                ));
                            }
                            result.assignment = map
                                .next_value::<std::option::Option<
                                    crate::model::network_address::AddressAssignment,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkAddress {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !self.subnet_mask.is_empty() {
            state.serialize_entry("subnetMask", &self.subnet_mask)?;
        }
        if !self.bcast.is_empty() {
            state.serialize_entry("bcast", &self.bcast)?;
        }
        if !self.fqdn.is_empty() {
            state.serialize_entry("fqdn", &self.fqdn)?;
        }
        if !wkt::internal::is_default(&self.assignment) {
            state.serialize_entry("assignment", &self.assignment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NetworkAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkAddress");
        debug_struct.field("ip_address", &self.ip_address);
        debug_struct.field("subnet_mask", &self.subnet_mask);
        debug_struct.field("bcast", &self.bcast);
        debug_struct.field("fqdn", &self.fqdn);
        debug_struct.field("assignment", &self.assignment);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [NetworkAddress].
pub mod network_address {
    #[allow(unused_imports)]
    use super::*;

    /// Network address assignment.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AddressAssignment {
        /// Unknown (default value).
        Unspecified,
        /// Staticly assigned IP.
        Static,
        /// Dynamically assigned IP (DHCP).
        Dhcp,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AddressAssignment::value] or
        /// [AddressAssignment::name].
        UnknownValue(address_assignment::UnknownValue),
    }

    #[doc(hidden)]
    pub mod address_assignment {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AddressAssignment {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Static => std::option::Option::Some(1),
                Self::Dhcp => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ADDRESS_ASSIGNMENT_UNSPECIFIED"),
                Self::Static => std::option::Option::Some("ADDRESS_ASSIGNMENT_STATIC"),
                Self::Dhcp => std::option::Option::Some("ADDRESS_ASSIGNMENT_DHCP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AddressAssignment {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AddressAssignment {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AddressAssignment {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Static,
                2 => Self::Dhcp,
                _ => Self::UnknownValue(address_assignment::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AddressAssignment {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ADDRESS_ASSIGNMENT_UNSPECIFIED" => Self::Unspecified,
                "ADDRESS_ASSIGNMENT_STATIC" => Self::Static,
                "ADDRESS_ASSIGNMENT_DHCP" => Self::Dhcp,
                _ => Self::UnknownValue(address_assignment::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AddressAssignment {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Static => serializer.serialize_i32(1),
                Self::Dhcp => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AddressAssignment {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AddressAssignment>::new(
                ".google.cloud.migrationcenter.v1.NetworkAddress.AddressAssignment",
            ))
        }
    }
}

/// Details of machine disks.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MachineDiskDetails {
    /// Disk total Capacity.
    pub total_capacity_bytes: i64,

    /// Total disk free space.
    pub total_free_bytes: i64,

    /// List of disks.
    pub disks: std::option::Option<crate::model::DiskEntryList>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MachineDiskDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_capacity_bytes][crate::model::MachineDiskDetails::total_capacity_bytes].
    pub fn set_total_capacity_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_capacity_bytes = v.into();
        self
    }

    /// Sets the value of [total_free_bytes][crate::model::MachineDiskDetails::total_free_bytes].
    pub fn set_total_free_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_free_bytes = v.into();
        self
    }

    /// Sets the value of [disks][crate::model::MachineDiskDetails::disks].
    pub fn set_disks<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiskEntryList>,
    {
        self.disks = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disks][crate::model::MachineDiskDetails::disks].
    pub fn set_or_clear_disks<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiskEntryList>,
    {
        self.disks = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MachineDiskDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.MachineDiskDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MachineDiskDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __total_capacity_bytes,
            __total_free_bytes,
            __disks,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MachineDiskDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "totalCapacityBytes" => Ok(__FieldTag::__total_capacity_bytes),
                            "total_capacity_bytes" => Ok(__FieldTag::__total_capacity_bytes),
                            "totalFreeBytes" => Ok(__FieldTag::__total_free_bytes),
                            "total_free_bytes" => Ok(__FieldTag::__total_free_bytes),
                            "disks" => Ok(__FieldTag::__disks),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MachineDiskDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MachineDiskDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__total_capacity_bytes => {
                            if !fields.insert(__FieldTag::__total_capacity_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_capacity_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_capacity_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_free_bytes => {
                            if !fields.insert(__FieldTag::__total_free_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_free_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_free_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disks => {
                            if !fields.insert(__FieldTag::__disks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disks",
                                ));
                            }
                            result.disks = map
                                .next_value::<std::option::Option<crate::model::DiskEntryList>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MachineDiskDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.total_capacity_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalCapacityBytes", &__With(&self.total_capacity_bytes))?;
        }
        if !wkt::internal::is_default(&self.total_free_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalFreeBytes", &__With(&self.total_free_bytes))?;
        }
        if self.disks.is_some() {
            state.serialize_entry("disks", &self.disks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MachineDiskDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MachineDiskDetails");
        debug_struct.field("total_capacity_bytes", &self.total_capacity_bytes);
        debug_struct.field("total_free_bytes", &self.total_free_bytes);
        debug_struct.field("disks", &self.disks);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// VM disks.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DiskEntryList {
    /// Disk entries.
    pub entries: std::vec::Vec<crate::model::DiskEntry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiskEntryList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::DiskEntryList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiskEntry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DiskEntryList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DiskEntryList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiskEntryList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiskEntryList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entries" => Ok(__FieldTag::__entries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiskEntryList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiskEntryList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DiskEntry>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiskEntryList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DiskEntryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiskEntryList");
        debug_struct.field("entries", &self.entries);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Single disk entry.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DiskEntry {
    /// Disk capacity.
    pub capacity_bytes: i64,

    /// Disk free space.
    pub free_bytes: i64,

    /// Disk label.
    pub disk_label: std::string::String,

    /// Disk label type (e.g. BIOS/GPT)
    pub disk_label_type: std::string::String,

    /// Disks interface type.
    pub interface_type: crate::model::disk_entry::InterfaceType,

    /// Partition layout.
    pub partitions: std::option::Option<crate::model::DiskPartitionList>,

    /// Disk hardware address (e.g. 0:1 for SCSI).
    pub hw_address: std::string::String,

    /// Additional details for specific platforms.
    pub platform_specific: std::option::Option<crate::model::disk_entry::PlatformSpecific>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiskEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [capacity_bytes][crate::model::DiskEntry::capacity_bytes].
    pub fn set_capacity_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.capacity_bytes = v.into();
        self
    }

    /// Sets the value of [free_bytes][crate::model::DiskEntry::free_bytes].
    pub fn set_free_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.free_bytes = v.into();
        self
    }

    /// Sets the value of [disk_label][crate::model::DiskEntry::disk_label].
    pub fn set_disk_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_label = v.into();
        self
    }

    /// Sets the value of [disk_label_type][crate::model::DiskEntry::disk_label_type].
    pub fn set_disk_label_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_label_type = v.into();
        self
    }

    /// Sets the value of [interface_type][crate::model::DiskEntry::interface_type].
    pub fn set_interface_type<T: std::convert::Into<crate::model::disk_entry::InterfaceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.interface_type = v.into();
        self
    }

    /// Sets the value of [partitions][crate::model::DiskEntry::partitions].
    pub fn set_partitions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiskPartitionList>,
    {
        self.partitions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [partitions][crate::model::DiskEntry::partitions].
    pub fn set_or_clear_partitions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiskPartitionList>,
    {
        self.partitions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [hw_address][crate::model::DiskEntry::hw_address].
    pub fn set_hw_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hw_address = v.into();
        self
    }

    /// Sets the value of [platform_specific][crate::model::DiskEntry::platform_specific].
    ///
    /// Note that all the setters affecting `platform_specific` are mutually
    /// exclusive.
    pub fn set_platform_specific<
        T: std::convert::Into<std::option::Option<crate::model::disk_entry::PlatformSpecific>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_specific = v.into();
        self
    }

    /// The value of [platform_specific][crate::model::DiskEntry::platform_specific]
    /// if it holds a `Vmware`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vmware(&self) -> std::option::Option<&std::boxed::Box<crate::model::VmwareDiskConfig>> {
        #[allow(unreachable_patterns)]
        self.platform_specific.as_ref().and_then(|v| match v {
            crate::model::disk_entry::PlatformSpecific::Vmware(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [platform_specific][crate::model::DiskEntry::platform_specific]
    /// to hold a `Vmware`.
    ///
    /// Note that all the setters affecting `platform_specific` are
    /// mutually exclusive.
    pub fn set_vmware<T: std::convert::Into<std::boxed::Box<crate::model::VmwareDiskConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.platform_specific =
            std::option::Option::Some(crate::model::disk_entry::PlatformSpecific::Vmware(v.into()));
        self
    }
}

impl wkt::message::Message for DiskEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DiskEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiskEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __capacity_bytes,
            __free_bytes,
            __disk_label,
            __disk_label_type,
            __interface_type,
            __partitions,
            __hw_address,
            __vmware,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiskEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "capacityBytes" => Ok(__FieldTag::__capacity_bytes),
                            "capacity_bytes" => Ok(__FieldTag::__capacity_bytes),
                            "freeBytes" => Ok(__FieldTag::__free_bytes),
                            "free_bytes" => Ok(__FieldTag::__free_bytes),
                            "diskLabel" => Ok(__FieldTag::__disk_label),
                            "disk_label" => Ok(__FieldTag::__disk_label),
                            "diskLabelType" => Ok(__FieldTag::__disk_label_type),
                            "disk_label_type" => Ok(__FieldTag::__disk_label_type),
                            "interfaceType" => Ok(__FieldTag::__interface_type),
                            "interface_type" => Ok(__FieldTag::__interface_type),
                            "partitions" => Ok(__FieldTag::__partitions),
                            "hwAddress" => Ok(__FieldTag::__hw_address),
                            "hw_address" => Ok(__FieldTag::__hw_address),
                            "vmware" => Ok(__FieldTag::__vmware),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiskEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiskEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__capacity_bytes => {
                            if !fields.insert(__FieldTag::__capacity_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for capacity_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.capacity_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__free_bytes => {
                            if !fields.insert(__FieldTag::__free_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for free_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.free_bytes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_label => {
                            if !fields.insert(__FieldTag::__disk_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_label",
                                ));
                            }
                            result.disk_label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_label_type => {
                            if !fields.insert(__FieldTag::__disk_label_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_label_type",
                                ));
                            }
                            result.disk_label_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__interface_type => {
                            if !fields.insert(__FieldTag::__interface_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interface_type",
                                ));
                            }
                            result.interface_type = map.next_value::<std::option::Option<crate::model::disk_entry::InterfaceType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__partitions => {
                            if !fields.insert(__FieldTag::__partitions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partitions",
                                ));
                            }
                            result.partitions = map
                                .next_value::<std::option::Option<crate::model::DiskPartitionList>>(
                                )?;
                        }
                        __FieldTag::__hw_address => {
                            if !fields.insert(__FieldTag::__hw_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hw_address",
                                ));
                            }
                            result.hw_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vmware => {
                            if !fields.insert(__FieldTag::__vmware) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vmware",
                                ));
                            }
                            if result.platform_specific.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `platform_specific`, a oneof with full ID .google.cloud.migrationcenter.v1.DiskEntry.vmware, latest field was vmware",
                                ));
                            }
                            result.platform_specific = std::option::Option::Some(
                                crate::model::disk_entry::PlatformSpecific::Vmware(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VmwareDiskConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiskEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.capacity_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("capacityBytes", &__With(&self.capacity_bytes))?;
        }
        if !wkt::internal::is_default(&self.free_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("freeBytes", &__With(&self.free_bytes))?;
        }
        if !self.disk_label.is_empty() {
            state.serialize_entry("diskLabel", &self.disk_label)?;
        }
        if !self.disk_label_type.is_empty() {
            state.serialize_entry("diskLabelType", &self.disk_label_type)?;
        }
        if !wkt::internal::is_default(&self.interface_type) {
            state.serialize_entry("interfaceType", &self.interface_type)?;
        }
        if self.partitions.is_some() {
            state.serialize_entry("partitions", &self.partitions)?;
        }
        if !self.hw_address.is_empty() {
            state.serialize_entry("hwAddress", &self.hw_address)?;
        }
        if let Some(value) = self.vmware() {
            state.serialize_entry("vmware", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DiskEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiskEntry");
        debug_struct.field("capacity_bytes", &self.capacity_bytes);
        debug_struct.field("free_bytes", &self.free_bytes);
        debug_struct.field("disk_label", &self.disk_label);
        debug_struct.field("disk_label_type", &self.disk_label_type);
        debug_struct.field("interface_type", &self.interface_type);
        debug_struct.field("partitions", &self.partitions);
        debug_struct.field("hw_address", &self.hw_address);
        debug_struct.field("platform_specific", &self.platform_specific);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DiskEntry].
pub mod disk_entry {
    #[allow(unused_imports)]
    use super::*;

    /// Disks interface type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InterfaceType {
        /// Interface type unknown or unspecified.
        Unspecified,
        /// IDE interface type.
        Ide,
        /// SATA interface type.
        Sata,
        /// SAS interface type.
        Sas,
        /// SCSI interface type.
        Scsi,
        /// NVME interface type.
        Nvme,
        /// FC interface type.
        Fc,
        /// iSCSI interface type.
        Iscsi,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InterfaceType::value] or
        /// [InterfaceType::name].
        UnknownValue(interface_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod interface_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl InterfaceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ide => std::option::Option::Some(1),
                Self::Sata => std::option::Option::Some(2),
                Self::Sas => std::option::Option::Some(3),
                Self::Scsi => std::option::Option::Some(4),
                Self::Nvme => std::option::Option::Some(5),
                Self::Fc => std::option::Option::Some(6),
                Self::Iscsi => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INTERFACE_TYPE_UNSPECIFIED"),
                Self::Ide => std::option::Option::Some("IDE"),
                Self::Sata => std::option::Option::Some("SATA"),
                Self::Sas => std::option::Option::Some("SAS"),
                Self::Scsi => std::option::Option::Some("SCSI"),
                Self::Nvme => std::option::Option::Some("NVME"),
                Self::Fc => std::option::Option::Some("FC"),
                Self::Iscsi => std::option::Option::Some("ISCSI"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for InterfaceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for InterfaceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for InterfaceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ide,
                2 => Self::Sata,
                3 => Self::Sas,
                4 => Self::Scsi,
                5 => Self::Nvme,
                6 => Self::Fc,
                7 => Self::Iscsi,
                _ => Self::UnknownValue(interface_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for InterfaceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INTERFACE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "IDE" => Self::Ide,
                "SATA" => Self::Sata,
                "SAS" => Self::Sas,
                "SCSI" => Self::Scsi,
                "NVME" => Self::Nvme,
                "FC" => Self::Fc,
                "ISCSI" => Self::Iscsi,
                _ => Self::UnknownValue(interface_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for InterfaceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ide => serializer.serialize_i32(1),
                Self::Sata => serializer.serialize_i32(2),
                Self::Sas => serializer.serialize_i32(3),
                Self::Scsi => serializer.serialize_i32(4),
                Self::Nvme => serializer.serialize_i32(5),
                Self::Fc => serializer.serialize_i32(6),
                Self::Iscsi => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for InterfaceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InterfaceType>::new(
                ".google.cloud.migrationcenter.v1.DiskEntry.InterfaceType",
            ))
        }
    }

    /// Additional details for specific platforms.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PlatformSpecific {
        /// VMware disk details.
        Vmware(std::boxed::Box<crate::model::VmwareDiskConfig>),
    }
}

/// Disk partition list.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DiskPartitionList {
    /// Partition entries.
    pub entries: std::vec::Vec<crate::model::DiskPartition>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiskPartitionList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::DiskPartitionList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiskPartition>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DiskPartitionList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DiskPartitionList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiskPartitionList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiskPartitionList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entries" => Ok(__FieldTag::__entries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiskPartitionList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiskPartitionList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DiskPartition>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiskPartitionList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DiskPartitionList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiskPartitionList");
        debug_struct.field("entries", &self.entries);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Disk Partition details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DiskPartition {
    /// Partition type.
    pub r#type: std::string::String,

    /// Partition file system.
    pub file_system: std::string::String,

    /// Mount pount (Linux/Windows) or drive letter (Windows).
    pub mount_point: std::string::String,

    /// Partition capacity.
    pub capacity_bytes: i64,

    /// Partition free space.
    pub free_bytes: i64,

    /// Partition UUID.
    pub uuid: std::string::String,

    /// Sub-partitions.
    pub sub_partitions: std::option::Option<std::boxed::Box<crate::model::DiskPartitionList>>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiskPartition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::DiskPartition::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [file_system][crate::model::DiskPartition::file_system].
    pub fn set_file_system<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_system = v.into();
        self
    }

    /// Sets the value of [mount_point][crate::model::DiskPartition::mount_point].
    pub fn set_mount_point<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mount_point = v.into();
        self
    }

    /// Sets the value of [capacity_bytes][crate::model::DiskPartition::capacity_bytes].
    pub fn set_capacity_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.capacity_bytes = v.into();
        self
    }

    /// Sets the value of [free_bytes][crate::model::DiskPartition::free_bytes].
    pub fn set_free_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.free_bytes = v.into();
        self
    }

    /// Sets the value of [uuid][crate::model::DiskPartition::uuid].
    pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uuid = v.into();
        self
    }

    /// Sets the value of [sub_partitions][crate::model::DiskPartition::sub_partitions].
    pub fn set_sub_partitions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiskPartitionList>,
    {
        self.sub_partitions = std::option::Option::Some(std::boxed::Box::new(v.into()));
        self
    }

    /// Sets or clears the value of [sub_partitions][crate::model::DiskPartition::sub_partitions].
    pub fn set_or_clear_sub_partitions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiskPartitionList>,
    {
        self.sub_partitions = v.map(|x| std::boxed::Box::new(x.into()));
        self
    }
}

impl wkt::message::Message for DiskPartition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DiskPartition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiskPartition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __file_system,
            __mount_point,
            __capacity_bytes,
            __free_bytes,
            __uuid,
            __sub_partitions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiskPartition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "fileSystem" => Ok(__FieldTag::__file_system),
                            "file_system" => Ok(__FieldTag::__file_system),
                            "mountPoint" => Ok(__FieldTag::__mount_point),
                            "mount_point" => Ok(__FieldTag::__mount_point),
                            "capacityBytes" => Ok(__FieldTag::__capacity_bytes),
                            "capacity_bytes" => Ok(__FieldTag::__capacity_bytes),
                            "freeBytes" => Ok(__FieldTag::__free_bytes),
                            "free_bytes" => Ok(__FieldTag::__free_bytes),
                            "uuid" => Ok(__FieldTag::__uuid),
                            "subPartitions" => Ok(__FieldTag::__sub_partitions),
                            "sub_partitions" => Ok(__FieldTag::__sub_partitions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiskPartition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiskPartition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_system => {
                            if !fields.insert(__FieldTag::__file_system) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_system",
                                ));
                            }
                            result.file_system = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mount_point => {
                            if !fields.insert(__FieldTag::__mount_point) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mount_point",
                                ));
                            }
                            result.mount_point = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__capacity_bytes => {
                            if !fields.insert(__FieldTag::__capacity_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for capacity_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.capacity_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__free_bytes => {
                            if !fields.insert(__FieldTag::__free_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for free_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.free_bytes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__uuid => {
                            if !fields.insert(__FieldTag::__uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uuid",
                                ));
                            }
                            result.uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sub_partitions => {
                            if !fields.insert(__FieldTag::__sub_partitions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sub_partitions",
                                ));
                            }
                            result.sub_partitions = map.next_value::<std::option::Option<
                                std::boxed::Box<crate::model::DiskPartitionList>,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiskPartition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.file_system.is_empty() {
            state.serialize_entry("fileSystem", &self.file_system)?;
        }
        if !self.mount_point.is_empty() {
            state.serialize_entry("mountPoint", &self.mount_point)?;
        }
        if !wkt::internal::is_default(&self.capacity_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("capacityBytes", &__With(&self.capacity_bytes))?;
        }
        if !wkt::internal::is_default(&self.free_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("freeBytes", &__With(&self.free_bytes))?;
        }
        if !self.uuid.is_empty() {
            state.serialize_entry("uuid", &self.uuid)?;
        }
        if self.sub_partitions.is_some() {
            state.serialize_entry("subPartitions", &self.sub_partitions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DiskPartition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiskPartition");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("file_system", &self.file_system);
        debug_struct.field("mount_point", &self.mount_point);
        debug_struct.field("capacity_bytes", &self.capacity_bytes);
        debug_struct.field("free_bytes", &self.free_bytes);
        debug_struct.field("uuid", &self.uuid);
        debug_struct.field("sub_partitions", &self.sub_partitions);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// VMware disk config details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VmwareDiskConfig {
    /// VMDK backing type.
    pub backing_type: crate::model::vmware_disk_config::BackingType,

    /// Is VMDK shared with other VMs.
    pub shared: bool,

    /// VMDK disk mode.
    pub vmdk_mode: crate::model::vmware_disk_config::VmdkMode,

    /// RDM compatibility mode.
    pub rdm_compatibility: crate::model::vmware_disk_config::RdmCompatibility,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmwareDiskConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backing_type][crate::model::VmwareDiskConfig::backing_type].
    pub fn set_backing_type<
        T: std::convert::Into<crate::model::vmware_disk_config::BackingType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backing_type = v.into();
        self
    }

    /// Sets the value of [shared][crate::model::VmwareDiskConfig::shared].
    pub fn set_shared<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.shared = v.into();
        self
    }

    /// Sets the value of [vmdk_mode][crate::model::VmwareDiskConfig::vmdk_mode].
    pub fn set_vmdk_mode<T: std::convert::Into<crate::model::vmware_disk_config::VmdkMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.vmdk_mode = v.into();
        self
    }

    /// Sets the value of [rdm_compatibility][crate::model::VmwareDiskConfig::rdm_compatibility].
    pub fn set_rdm_compatibility<
        T: std::convert::Into<crate::model::vmware_disk_config::RdmCompatibility>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rdm_compatibility = v.into();
        self
    }
}

impl wkt::message::Message for VmwareDiskConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.VmwareDiskConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmwareDiskConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backing_type,
            __shared,
            __vmdk_mode,
            __rdm_compatibility,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmwareDiskConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backingType" => Ok(__FieldTag::__backing_type),
                            "backing_type" => Ok(__FieldTag::__backing_type),
                            "shared" => Ok(__FieldTag::__shared),
                            "vmdkMode" => Ok(__FieldTag::__vmdk_mode),
                            "vmdk_mode" => Ok(__FieldTag::__vmdk_mode),
                            "rdmCompatibility" => Ok(__FieldTag::__rdm_compatibility),
                            "rdm_compatibility" => Ok(__FieldTag::__rdm_compatibility),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmwareDiskConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmwareDiskConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backing_type => {
                            if !fields.insert(__FieldTag::__backing_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backing_type",
                                ));
                            }
                            result.backing_type =
                                map.next_value::<std::option::Option<
                                    crate::model::vmware_disk_config::BackingType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__shared => {
                            if !fields.insert(__FieldTag::__shared) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shared",
                                ));
                            }
                            result.shared = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vmdk_mode => {
                            if !fields.insert(__FieldTag::__vmdk_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vmdk_mode",
                                ));
                            }
                            result.vmdk_mode = map.next_value::<std::option::Option<crate::model::vmware_disk_config::VmdkMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__rdm_compatibility => {
                            if !fields.insert(__FieldTag::__rdm_compatibility) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rdm_compatibility",
                                ));
                            }
                            result.rdm_compatibility = map
                                .next_value::<std::option::Option<
                                    crate::model::vmware_disk_config::RdmCompatibility,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmwareDiskConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.backing_type) {
            state.serialize_entry("backingType", &self.backing_type)?;
        }
        if !wkt::internal::is_default(&self.shared) {
            state.serialize_entry("shared", &self.shared)?;
        }
        if !wkt::internal::is_default(&self.vmdk_mode) {
            state.serialize_entry("vmdkMode", &self.vmdk_mode)?;
        }
        if !wkt::internal::is_default(&self.rdm_compatibility) {
            state.serialize_entry("rdmCompatibility", &self.rdm_compatibility)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VmwareDiskConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmwareDiskConfig");
        debug_struct.field("backing_type", &self.backing_type);
        debug_struct.field("shared", &self.shared);
        debug_struct.field("vmdk_mode", &self.vmdk_mode);
        debug_struct.field("rdm_compatibility", &self.rdm_compatibility);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [VmwareDiskConfig].
pub mod vmware_disk_config {
    #[allow(unused_imports)]
    use super::*;

    /// VMDK backing type possible values.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BackingType {
        /// Default value.
        Unspecified,
        /// Flat v1.
        FlatV1,
        /// Flat v2.
        FlatV2,
        /// Persistent memory, also known as Non-Volatile Memory (NVM).
        Pmem,
        /// Raw Disk Memory v1.
        RdmV1,
        /// Raw Disk Memory v2.
        RdmV2,
        /// SEsparse is a snapshot format introduced in vSphere 5.5 for large disks.
        Sesparse,
        /// SEsparse v1.
        SesparseV1,
        /// SEsparse v1.
        SesparseV2,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BackingType::value] or
        /// [BackingType::name].
        UnknownValue(backing_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod backing_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BackingType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FlatV1 => std::option::Option::Some(1),
                Self::FlatV2 => std::option::Option::Some(2),
                Self::Pmem => std::option::Option::Some(3),
                Self::RdmV1 => std::option::Option::Some(4),
                Self::RdmV2 => std::option::Option::Some(5),
                Self::Sesparse => std::option::Option::Some(6),
                Self::SesparseV1 => std::option::Option::Some(7),
                Self::SesparseV2 => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BACKING_TYPE_UNSPECIFIED"),
                Self::FlatV1 => std::option::Option::Some("BACKING_TYPE_FLAT_V1"),
                Self::FlatV2 => std::option::Option::Some("BACKING_TYPE_FLAT_V2"),
                Self::Pmem => std::option::Option::Some("BACKING_TYPE_PMEM"),
                Self::RdmV1 => std::option::Option::Some("BACKING_TYPE_RDM_V1"),
                Self::RdmV2 => std::option::Option::Some("BACKING_TYPE_RDM_V2"),
                Self::Sesparse => std::option::Option::Some("BACKING_TYPE_SESPARSE"),
                Self::SesparseV1 => std::option::Option::Some("BACKING_TYPE_SESPARSE_V1"),
                Self::SesparseV2 => std::option::Option::Some("BACKING_TYPE_SESPARSE_V2"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BackingType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BackingType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BackingType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FlatV1,
                2 => Self::FlatV2,
                3 => Self::Pmem,
                4 => Self::RdmV1,
                5 => Self::RdmV2,
                6 => Self::Sesparse,
                7 => Self::SesparseV1,
                8 => Self::SesparseV2,
                _ => Self::UnknownValue(backing_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BackingType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BACKING_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BACKING_TYPE_FLAT_V1" => Self::FlatV1,
                "BACKING_TYPE_FLAT_V2" => Self::FlatV2,
                "BACKING_TYPE_PMEM" => Self::Pmem,
                "BACKING_TYPE_RDM_V1" => Self::RdmV1,
                "BACKING_TYPE_RDM_V2" => Self::RdmV2,
                "BACKING_TYPE_SESPARSE" => Self::Sesparse,
                "BACKING_TYPE_SESPARSE_V1" => Self::SesparseV1,
                "BACKING_TYPE_SESPARSE_V2" => Self::SesparseV2,
                _ => Self::UnknownValue(backing_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BackingType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FlatV1 => serializer.serialize_i32(1),
                Self::FlatV2 => serializer.serialize_i32(2),
                Self::Pmem => serializer.serialize_i32(3),
                Self::RdmV1 => serializer.serialize_i32(4),
                Self::RdmV2 => serializer.serialize_i32(5),
                Self::Sesparse => serializer.serialize_i32(6),
                Self::SesparseV1 => serializer.serialize_i32(7),
                Self::SesparseV2 => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BackingType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackingType>::new(
                ".google.cloud.migrationcenter.v1.VmwareDiskConfig.BackingType",
            ))
        }
    }

    /// VMDK disk mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VmdkMode {
        /// VMDK disk mode unspecified or unknown.
        Unspecified,
        /// Dependent disk mode.
        Dependent,
        /// Independent - Persistent disk mode.
        IndependentPersistent,
        /// Independent - Nonpersistent disk mode.
        IndependentNonpersistent,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VmdkMode::value] or
        /// [VmdkMode::name].
        UnknownValue(vmdk_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod vmdk_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VmdkMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Dependent => std::option::Option::Some(1),
                Self::IndependentPersistent => std::option::Option::Some(2),
                Self::IndependentNonpersistent => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VMDK_MODE_UNSPECIFIED"),
                Self::Dependent => std::option::Option::Some("DEPENDENT"),
                Self::IndependentPersistent => std::option::Option::Some("INDEPENDENT_PERSISTENT"),
                Self::IndependentNonpersistent => {
                    std::option::Option::Some("INDEPENDENT_NONPERSISTENT")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VmdkMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VmdkMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VmdkMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Dependent,
                2 => Self::IndependentPersistent,
                3 => Self::IndependentNonpersistent,
                _ => Self::UnknownValue(vmdk_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VmdkMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VMDK_MODE_UNSPECIFIED" => Self::Unspecified,
                "DEPENDENT" => Self::Dependent,
                "INDEPENDENT_PERSISTENT" => Self::IndependentPersistent,
                "INDEPENDENT_NONPERSISTENT" => Self::IndependentNonpersistent,
                _ => Self::UnknownValue(vmdk_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VmdkMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Dependent => serializer.serialize_i32(1),
                Self::IndependentPersistent => serializer.serialize_i32(2),
                Self::IndependentNonpersistent => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VmdkMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VmdkMode>::new(
                ".google.cloud.migrationcenter.v1.VmwareDiskConfig.VmdkMode",
            ))
        }
    }

    /// RDM compatibility mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RdmCompatibility {
        /// Compatibility mode unspecified or unknown.
        Unspecified,
        /// Physical compatibility mode.
        PhysicalCompatibility,
        /// Virtual compatibility mode.
        VirtualCompatibility,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RdmCompatibility::value] or
        /// [RdmCompatibility::name].
        UnknownValue(rdm_compatibility::UnknownValue),
    }

    #[doc(hidden)]
    pub mod rdm_compatibility {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RdmCompatibility {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PhysicalCompatibility => std::option::Option::Some(1),
                Self::VirtualCompatibility => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RDM_COMPATIBILITY_UNSPECIFIED"),
                Self::PhysicalCompatibility => std::option::Option::Some("PHYSICAL_COMPATIBILITY"),
                Self::VirtualCompatibility => std::option::Option::Some("VIRTUAL_COMPATIBILITY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RdmCompatibility {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RdmCompatibility {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RdmCompatibility {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PhysicalCompatibility,
                2 => Self::VirtualCompatibility,
                _ => Self::UnknownValue(rdm_compatibility::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RdmCompatibility {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RDM_COMPATIBILITY_UNSPECIFIED" => Self::Unspecified,
                "PHYSICAL_COMPATIBILITY" => Self::PhysicalCompatibility,
                "VIRTUAL_COMPATIBILITY" => Self::VirtualCompatibility,
                _ => Self::UnknownValue(rdm_compatibility::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RdmCompatibility {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PhysicalCompatibility => serializer.serialize_i32(1),
                Self::VirtualCompatibility => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RdmCompatibility {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RdmCompatibility>::new(
                ".google.cloud.migrationcenter.v1.VmwareDiskConfig.RdmCompatibility",
            ))
        }
    }
}

/// Information from Guest-level collections.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GuestOsDetails {
    /// The name of the operating system.
    pub os_name: std::string::String,

    /// What family the OS belong to, if known.
    pub family: crate::model::OperatingSystemFamily,

    /// The version of the operating system.
    pub version: std::string::String,

    /// OS and app configuration.
    pub config: std::option::Option<crate::model::GuestConfigDetails>,

    /// Runtime information.
    pub runtime: std::option::Option<crate::model::GuestRuntimeDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GuestOsDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [os_name][crate::model::GuestOsDetails::os_name].
    pub fn set_os_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.os_name = v.into();
        self
    }

    /// Sets the value of [family][crate::model::GuestOsDetails::family].
    pub fn set_family<T: std::convert::Into<crate::model::OperatingSystemFamily>>(
        mut self,
        v: T,
    ) -> Self {
        self.family = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GuestOsDetails::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [config][crate::model::GuestOsDetails::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GuestConfigDetails>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::GuestOsDetails::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GuestConfigDetails>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [runtime][crate::model::GuestOsDetails::runtime].
    pub fn set_runtime<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GuestRuntimeDetails>,
    {
        self.runtime = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [runtime][crate::model::GuestOsDetails::runtime].
    pub fn set_or_clear_runtime<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GuestRuntimeDetails>,
    {
        self.runtime = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GuestOsDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GuestOsDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GuestOsDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_name,
            __family,
            __version,
            __config,
            __runtime,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GuestOsDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osName" => Ok(__FieldTag::__os_name),
                            "os_name" => Ok(__FieldTag::__os_name),
                            "family" => Ok(__FieldTag::__family),
                            "version" => Ok(__FieldTag::__version),
                            "config" => Ok(__FieldTag::__config),
                            "runtime" => Ok(__FieldTag::__runtime),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GuestOsDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GuestOsDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_name => {
                            if !fields.insert(__FieldTag::__os_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_name",
                                ));
                            }
                            result.os_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__family => {
                            if !fields.insert(__FieldTag::__family) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for family",
                                ));
                            }
                            result.family = map.next_value::<std::option::Option<crate::model::OperatingSystemFamily>>()?.unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map.next_value::<std::option::Option<crate::model::GuestConfigDetails>>()?
                                ;
                        }
                        __FieldTag::__runtime => {
                            if !fields.insert(__FieldTag::__runtime) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime",
                                ));
                            }
                            result.runtime = map.next_value::<std::option::Option<crate::model::GuestRuntimeDetails>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GuestOsDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.os_name.is_empty() {
            state.serialize_entry("osName", &self.os_name)?;
        }
        if !wkt::internal::is_default(&self.family) {
            state.serialize_entry("family", &self.family)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if self.runtime.is_some() {
            state.serialize_entry("runtime", &self.runtime)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GuestOsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GuestOsDetails");
        debug_struct.field("os_name", &self.os_name);
        debug_struct.field("family", &self.family);
        debug_struct.field("version", &self.version);
        debug_struct.field("config", &self.config);
        debug_struct.field("runtime", &self.runtime);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Guest OS config information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GuestConfigDetails {
    /// OS issue (typically /etc/issue in Linux).
    pub issue: std::string::String,

    /// Mount list (Linux fstab).
    pub fstab: std::option::Option<crate::model::FstabEntryList>,

    /// Hosts file (/etc/hosts).
    pub hosts: std::option::Option<crate::model::HostsEntryList>,

    /// NFS exports.
    pub nfs_exports: std::option::Option<crate::model::NfsExportList>,

    /// Security-Enhanced Linux (SELinux) mode.
    pub selinux_mode: crate::model::guest_config_details::SeLinuxMode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GuestConfigDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue][crate::model::GuestConfigDetails::issue].
    pub fn set_issue<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issue = v.into();
        self
    }

    /// Sets the value of [fstab][crate::model::GuestConfigDetails::fstab].
    pub fn set_fstab<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FstabEntryList>,
    {
        self.fstab = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fstab][crate::model::GuestConfigDetails::fstab].
    pub fn set_or_clear_fstab<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FstabEntryList>,
    {
        self.fstab = v.map(|x| x.into());
        self
    }

    /// Sets the value of [hosts][crate::model::GuestConfigDetails::hosts].
    pub fn set_hosts<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HostsEntryList>,
    {
        self.hosts = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hosts][crate::model::GuestConfigDetails::hosts].
    pub fn set_or_clear_hosts<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HostsEntryList>,
    {
        self.hosts = v.map(|x| x.into());
        self
    }

    /// Sets the value of [nfs_exports][crate::model::GuestConfigDetails::nfs_exports].
    pub fn set_nfs_exports<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NfsExportList>,
    {
        self.nfs_exports = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nfs_exports][crate::model::GuestConfigDetails::nfs_exports].
    pub fn set_or_clear_nfs_exports<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NfsExportList>,
    {
        self.nfs_exports = v.map(|x| x.into());
        self
    }

    /// Sets the value of [selinux_mode][crate::model::GuestConfigDetails::selinux_mode].
    pub fn set_selinux_mode<
        T: std::convert::Into<crate::model::guest_config_details::SeLinuxMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.selinux_mode = v.into();
        self
    }
}

impl wkt::message::Message for GuestConfigDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GuestConfigDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GuestConfigDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issue,
            __fstab,
            __hosts,
            __nfs_exports,
            __selinux_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GuestConfigDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issue" => Ok(__FieldTag::__issue),
                            "fstab" => Ok(__FieldTag::__fstab),
                            "hosts" => Ok(__FieldTag::__hosts),
                            "nfsExports" => Ok(__FieldTag::__nfs_exports),
                            "nfs_exports" => Ok(__FieldTag::__nfs_exports),
                            "selinuxMode" => Ok(__FieldTag::__selinux_mode),
                            "selinux_mode" => Ok(__FieldTag::__selinux_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GuestConfigDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GuestConfigDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issue => {
                            if !fields.insert(__FieldTag::__issue) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue",
                                ));
                            }
                            result.issue = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fstab => {
                            if !fields.insert(__FieldTag::__fstab) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fstab",
                                ));
                            }
                            result.fstab = map
                                .next_value::<std::option::Option<crate::model::FstabEntryList>>(
                                )?;
                        }
                        __FieldTag::__hosts => {
                            if !fields.insert(__FieldTag::__hosts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hosts",
                                ));
                            }
                            result.hosts = map
                                .next_value::<std::option::Option<crate::model::HostsEntryList>>(
                                )?;
                        }
                        __FieldTag::__nfs_exports => {
                            if !fields.insert(__FieldTag::__nfs_exports) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nfs_exports",
                                ));
                            }
                            result.nfs_exports = map
                                .next_value::<std::option::Option<crate::model::NfsExportList>>()?;
                        }
                        __FieldTag::__selinux_mode => {
                            if !fields.insert(__FieldTag::__selinux_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selinux_mode",
                                ));
                            }
                            result.selinux_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::guest_config_details::SeLinuxMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GuestConfigDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.issue.is_empty() {
            state.serialize_entry("issue", &self.issue)?;
        }
        if self.fstab.is_some() {
            state.serialize_entry("fstab", &self.fstab)?;
        }
        if self.hosts.is_some() {
            state.serialize_entry("hosts", &self.hosts)?;
        }
        if self.nfs_exports.is_some() {
            state.serialize_entry("nfsExports", &self.nfs_exports)?;
        }
        if !wkt::internal::is_default(&self.selinux_mode) {
            state.serialize_entry("selinuxMode", &self.selinux_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GuestConfigDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GuestConfigDetails");
        debug_struct.field("issue", &self.issue);
        debug_struct.field("fstab", &self.fstab);
        debug_struct.field("hosts", &self.hosts);
        debug_struct.field("nfs_exports", &self.nfs_exports);
        debug_struct.field("selinux_mode", &self.selinux_mode);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [GuestConfigDetails].
pub mod guest_config_details {
    #[allow(unused_imports)]
    use super::*;

    /// Security-Enhanced Linux (SELinux) mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SeLinuxMode {
        /// SELinux mode unknown or unspecified.
        Unspecified,
        /// SELinux is disabled.
        Disabled,
        /// SELinux permissive mode.
        Permissive,
        /// SELinux enforcing mode.
        Enforcing,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SeLinuxMode::value] or
        /// [SeLinuxMode::name].
        UnknownValue(se_linux_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod se_linux_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SeLinuxMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::Permissive => std::option::Option::Some(2),
                Self::Enforcing => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SE_LINUX_MODE_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("SE_LINUX_MODE_DISABLED"),
                Self::Permissive => std::option::Option::Some("SE_LINUX_MODE_PERMISSIVE"),
                Self::Enforcing => std::option::Option::Some("SE_LINUX_MODE_ENFORCING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SeLinuxMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SeLinuxMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SeLinuxMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::Permissive,
                3 => Self::Enforcing,
                _ => Self::UnknownValue(se_linux_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SeLinuxMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SE_LINUX_MODE_UNSPECIFIED" => Self::Unspecified,
                "SE_LINUX_MODE_DISABLED" => Self::Disabled,
                "SE_LINUX_MODE_PERMISSIVE" => Self::Permissive,
                "SE_LINUX_MODE_ENFORCING" => Self::Enforcing,
                _ => Self::UnknownValue(se_linux_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SeLinuxMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::Permissive => serializer.serialize_i32(2),
                Self::Enforcing => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SeLinuxMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SeLinuxMode>::new(
                ".google.cloud.migrationcenter.v1.GuestConfigDetails.SeLinuxMode",
            ))
        }
    }
}

/// Fstab content.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FstabEntryList {
    /// Fstab entries.
    pub entries: std::vec::Vec<crate::model::FstabEntry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FstabEntryList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::FstabEntryList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FstabEntry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FstabEntryList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.FstabEntryList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FstabEntryList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FstabEntryList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entries" => Ok(__FieldTag::__entries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FstabEntryList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FstabEntryList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FstabEntry>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FstabEntryList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FstabEntryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FstabEntryList");
        debug_struct.field("entries", &self.entries);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Single fstab entry.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FstabEntry {
    /// The block special device or remote filesystem to be mounted.
    pub spec: std::string::String,

    /// The mount point for the filesystem.
    pub file: std::string::String,

    /// The type of the filesystem.
    pub vfstype: std::string::String,

    /// Mount options associated with the filesystem.
    pub mntops: std::string::String,

    /// Used by dump to determine which filesystems need to be dumped.
    pub freq: i32,

    /// Used by the fsck(8) program to determine the order in which filesystem
    /// checks are done at reboot time.
    pub passno: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FstabEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [spec][crate::model::FstabEntry::spec].
    pub fn set_spec<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.spec = v.into();
        self
    }

    /// Sets the value of [file][crate::model::FstabEntry::file].
    pub fn set_file<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file = v.into();
        self
    }

    /// Sets the value of [vfstype][crate::model::FstabEntry::vfstype].
    pub fn set_vfstype<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vfstype = v.into();
        self
    }

    /// Sets the value of [mntops][crate::model::FstabEntry::mntops].
    pub fn set_mntops<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mntops = v.into();
        self
    }

    /// Sets the value of [freq][crate::model::FstabEntry::freq].
    pub fn set_freq<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.freq = v.into();
        self
    }

    /// Sets the value of [passno][crate::model::FstabEntry::passno].
    pub fn set_passno<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.passno = v.into();
        self
    }
}

impl wkt::message::Message for FstabEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.FstabEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FstabEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __spec,
            __file,
            __vfstype,
            __mntops,
            __freq,
            __passno,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FstabEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "spec" => Ok(__FieldTag::__spec),
                            "file" => Ok(__FieldTag::__file),
                            "vfstype" => Ok(__FieldTag::__vfstype),
                            "mntops" => Ok(__FieldTag::__mntops),
                            "freq" => Ok(__FieldTag::__freq),
                            "passno" => Ok(__FieldTag::__passno),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FstabEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FstabEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__spec => {
                            if !fields.insert(__FieldTag::__spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spec",
                                ));
                            }
                            result.spec = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file => {
                            if !fields.insert(__FieldTag::__file) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file",
                                ));
                            }
                            result.file = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vfstype => {
                            if !fields.insert(__FieldTag::__vfstype) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vfstype",
                                ));
                            }
                            result.vfstype = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mntops => {
                            if !fields.insert(__FieldTag::__mntops) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mntops",
                                ));
                            }
                            result.mntops = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__freq => {
                            if !fields.insert(__FieldTag::__freq) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for freq",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.freq = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__passno => {
                            if !fields.insert(__FieldTag::__passno) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for passno",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.passno = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FstabEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.spec.is_empty() {
            state.serialize_entry("spec", &self.spec)?;
        }
        if !self.file.is_empty() {
            state.serialize_entry("file", &self.file)?;
        }
        if !self.vfstype.is_empty() {
            state.serialize_entry("vfstype", &self.vfstype)?;
        }
        if !self.mntops.is_empty() {
            state.serialize_entry("mntops", &self.mntops)?;
        }
        if !wkt::internal::is_default(&self.freq) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("freq", &__With(&self.freq))?;
        }
        if !wkt::internal::is_default(&self.passno) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("passno", &__With(&self.passno))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FstabEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FstabEntry");
        debug_struct.field("spec", &self.spec);
        debug_struct.field("file", &self.file);
        debug_struct.field("vfstype", &self.vfstype);
        debug_struct.field("mntops", &self.mntops);
        debug_struct.field("freq", &self.freq);
        debug_struct.field("passno", &self.passno);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Hosts content.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HostsEntryList {
    /// Hosts entries.
    pub entries: std::vec::Vec<crate::model::HostsEntry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HostsEntryList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::HostsEntryList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::HostsEntry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for HostsEntryList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.HostsEntryList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HostsEntryList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HostsEntryList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entries" => Ok(__FieldTag::__entries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HostsEntryList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HostsEntryList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::HostsEntry>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HostsEntryList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HostsEntryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HostsEntryList");
        debug_struct.field("entries", &self.entries);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Single /etc/hosts entry.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HostsEntry {
    /// IP (raw, IPv4/6 agnostic).
    pub ip: std::string::String,

    /// List of host names / aliases.
    pub host_names: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HostsEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip][crate::model::HostsEntry::ip].
    pub fn set_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip = v.into();
        self
    }

    /// Sets the value of [host_names][crate::model::HostsEntry::host_names].
    pub fn set_host_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.host_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for HostsEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.HostsEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HostsEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ip,
            __host_names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HostsEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ip" => Ok(__FieldTag::__ip),
                            "hostNames" => Ok(__FieldTag::__host_names),
                            "host_names" => Ok(__FieldTag::__host_names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HostsEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HostsEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ip => {
                            if !fields.insert(__FieldTag::__ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip",
                                ));
                            }
                            result.ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__host_names => {
                            if !fields.insert(__FieldTag::__host_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host_names",
                                ));
                            }
                            result.host_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HostsEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ip.is_empty() {
            state.serialize_entry("ip", &self.ip)?;
        }
        if !self.host_names.is_empty() {
            state.serialize_entry("hostNames", &self.host_names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HostsEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HostsEntry");
        debug_struct.field("ip", &self.ip);
        debug_struct.field("host_names", &self.host_names);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// NFS exports.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NfsExportList {
    /// NFS export entries.
    pub entries: std::vec::Vec<crate::model::NfsExport>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NfsExportList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::NfsExportList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NfsExport>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NfsExportList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.NfsExportList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NfsExportList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NfsExportList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entries" => Ok(__FieldTag::__entries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NfsExportList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NfsExportList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::NfsExport>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NfsExportList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NfsExportList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NfsExportList");
        debug_struct.field("entries", &self.entries);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// NFS export.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NfsExport {
    /// The directory being exported.
    pub export_directory: std::string::String,

    /// The hosts or networks to which the export is being shared.
    pub hosts: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NfsExport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [export_directory][crate::model::NfsExport::export_directory].
    pub fn set_export_directory<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.export_directory = v.into();
        self
    }

    /// Sets the value of [hosts][crate::model::NfsExport::hosts].
    pub fn set_hosts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.hosts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NfsExport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.NfsExport"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NfsExport {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __export_directory,
            __hosts,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NfsExport")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "exportDirectory" => Ok(__FieldTag::__export_directory),
                            "export_directory" => Ok(__FieldTag::__export_directory),
                            "hosts" => Ok(__FieldTag::__hosts),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NfsExport;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NfsExport")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__export_directory => {
                            if !fields.insert(__FieldTag::__export_directory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for export_directory",
                                ));
                            }
                            result.export_directory = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hosts => {
                            if !fields.insert(__FieldTag::__hosts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hosts",
                                ));
                            }
                            result.hosts = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NfsExport {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.export_directory.is_empty() {
            state.serialize_entry("exportDirectory", &self.export_directory)?;
        }
        if !self.hosts.is_empty() {
            state.serialize_entry("hosts", &self.hosts)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NfsExport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NfsExport");
        debug_struct.field("export_directory", &self.export_directory);
        debug_struct.field("hosts", &self.hosts);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Guest OS runtime information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GuestRuntimeDetails {
    /// Running background services.
    pub services: std::option::Option<crate::model::RunningServiceList>,

    /// Running processes.
    pub processes: std::option::Option<crate::model::RunningProcessList>,

    /// Runtime network information (connections, ports).
    pub network: std::option::Option<crate::model::RuntimeNetworkInfo>,

    /// Last time the OS was booted.
    pub last_boot_time: std::option::Option<wkt::Timestamp>,

    /// Domain, e.g. c.stratozone-development.internal.
    pub domain: std::string::String,

    /// Machine name.
    pub machine_name: std::string::String,

    /// Installed applications information.
    pub installed_apps: std::option::Option<crate::model::GuestInstalledApplicationList>,

    /// Open files information.
    pub open_file_list: std::option::Option<crate::model::OpenFileList>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GuestRuntimeDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [services][crate::model::GuestRuntimeDetails::services].
    pub fn set_services<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RunningServiceList>,
    {
        self.services = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [services][crate::model::GuestRuntimeDetails::services].
    pub fn set_or_clear_services<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RunningServiceList>,
    {
        self.services = v.map(|x| x.into());
        self
    }

    /// Sets the value of [processes][crate::model::GuestRuntimeDetails::processes].
    pub fn set_processes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RunningProcessList>,
    {
        self.processes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [processes][crate::model::GuestRuntimeDetails::processes].
    pub fn set_or_clear_processes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RunningProcessList>,
    {
        self.processes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network][crate::model::GuestRuntimeDetails::network].
    pub fn set_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeNetworkInfo>,
    {
        self.network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network][crate::model::GuestRuntimeDetails::network].
    pub fn set_or_clear_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeNetworkInfo>,
    {
        self.network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_boot_time][crate::model::GuestRuntimeDetails::last_boot_time].
    pub fn set_last_boot_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_boot_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_boot_time][crate::model::GuestRuntimeDetails::last_boot_time].
    pub fn set_or_clear_last_boot_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_boot_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [domain][crate::model::GuestRuntimeDetails::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [machine_name][crate::model::GuestRuntimeDetails::machine_name].
    pub fn set_machine_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_name = v.into();
        self
    }

    /// Sets the value of [installed_apps][crate::model::GuestRuntimeDetails::installed_apps].
    pub fn set_installed_apps<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GuestInstalledApplicationList>,
    {
        self.installed_apps = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [installed_apps][crate::model::GuestRuntimeDetails::installed_apps].
    pub fn set_or_clear_installed_apps<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GuestInstalledApplicationList>,
    {
        self.installed_apps = v.map(|x| x.into());
        self
    }

    /// Sets the value of [open_file_list][crate::model::GuestRuntimeDetails::open_file_list].
    pub fn set_open_file_list<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OpenFileList>,
    {
        self.open_file_list = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [open_file_list][crate::model::GuestRuntimeDetails::open_file_list].
    pub fn set_or_clear_open_file_list<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OpenFileList>,
    {
        self.open_file_list = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GuestRuntimeDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GuestRuntimeDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GuestRuntimeDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __services,
            __processes,
            __network,
            __last_boot_time,
            __domain,
            __machine_name,
            __installed_apps,
            __open_file_list,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GuestRuntimeDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "services" => Ok(__FieldTag::__services),
                            "processes" => Ok(__FieldTag::__processes),
                            "network" => Ok(__FieldTag::__network),
                            "lastBootTime" => Ok(__FieldTag::__last_boot_time),
                            "last_boot_time" => Ok(__FieldTag::__last_boot_time),
                            "domain" => Ok(__FieldTag::__domain),
                            "machineName" => Ok(__FieldTag::__machine_name),
                            "machine_name" => Ok(__FieldTag::__machine_name),
                            "installedApps" => Ok(__FieldTag::__installed_apps),
                            "installed_apps" => Ok(__FieldTag::__installed_apps),
                            "openFileList" => Ok(__FieldTag::__open_file_list),
                            "open_file_list" => Ok(__FieldTag::__open_file_list),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GuestRuntimeDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GuestRuntimeDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__services => {
                            if !fields.insert(__FieldTag::__services) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services",
                                ));
                            }
                            result.services = map.next_value::<std::option::Option<crate::model::RunningServiceList>>()?
                                ;
                        }
                        __FieldTag::__processes => {
                            if !fields.insert(__FieldTag::__processes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processes",
                                ));
                            }
                            result.processes = map.next_value::<std::option::Option<crate::model::RunningProcessList>>()?
                                ;
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map.next_value::<std::option::Option<crate::model::RuntimeNetworkInfo>>()?
                                ;
                        }
                        __FieldTag::__last_boot_time => {
                            if !fields.insert(__FieldTag::__last_boot_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_boot_time",
                                ));
                            }
                            result.last_boot_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__domain => {
                            if !fields.insert(__FieldTag::__domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain",
                                ));
                            }
                            result.domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_name => {
                            if !fields.insert(__FieldTag::__machine_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_name",
                                ));
                            }
                            result.machine_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__installed_apps => {
                            if !fields.insert(__FieldTag::__installed_apps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for installed_apps",
                                ));
                            }
                            result.installed_apps =
                                map.next_value::<std::option::Option<
                                    crate::model::GuestInstalledApplicationList,
                                >>()?;
                        }
                        __FieldTag::__open_file_list => {
                            if !fields.insert(__FieldTag::__open_file_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for open_file_list",
                                ));
                            }
                            result.open_file_list = map
                                .next_value::<std::option::Option<crate::model::OpenFileList>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GuestRuntimeDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.services.is_some() {
            state.serialize_entry("services", &self.services)?;
        }
        if self.processes.is_some() {
            state.serialize_entry("processes", &self.processes)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.last_boot_time.is_some() {
            state.serialize_entry("lastBootTime", &self.last_boot_time)?;
        }
        if !self.domain.is_empty() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if !self.machine_name.is_empty() {
            state.serialize_entry("machineName", &self.machine_name)?;
        }
        if self.installed_apps.is_some() {
            state.serialize_entry("installedApps", &self.installed_apps)?;
        }
        if self.open_file_list.is_some() {
            state.serialize_entry("openFileList", &self.open_file_list)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GuestRuntimeDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GuestRuntimeDetails");
        debug_struct.field("services", &self.services);
        debug_struct.field("processes", &self.processes);
        debug_struct.field("network", &self.network);
        debug_struct.field("last_boot_time", &self.last_boot_time);
        debug_struct.field("domain", &self.domain);
        debug_struct.field("machine_name", &self.machine_name);
        debug_struct.field("installed_apps", &self.installed_apps);
        debug_struct.field("open_file_list", &self.open_file_list);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// List of running guest OS services.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RunningServiceList {
    /// Running service entries.
    pub entries: std::vec::Vec<crate::model::RunningService>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunningServiceList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::RunningServiceList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RunningService>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RunningServiceList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.RunningServiceList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunningServiceList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunningServiceList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entries" => Ok(__FieldTag::__entries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunningServiceList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunningServiceList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RunningService>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RunningServiceList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RunningServiceList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunningServiceList");
        debug_struct.field("entries", &self.entries);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Guest OS running service details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RunningService {
    /// Service name.
    pub service_name: std::string::String,

    /// Service state (OS-agnostic).
    pub state: crate::model::running_service::State,

    /// Service start mode (OS-agnostic).
    pub start_mode: crate::model::running_service::StartMode,

    /// Service binary path.
    pub exe_path: std::string::String,

    /// Service command line.
    pub cmdline: std::string::String,

    /// Service pid.
    pub pid: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunningService {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::RunningService::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::RunningService::state].
    pub fn set_state<T: std::convert::Into<crate::model::running_service::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [start_mode][crate::model::RunningService::start_mode].
    pub fn set_start_mode<T: std::convert::Into<crate::model::running_service::StartMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_mode = v.into();
        self
    }

    /// Sets the value of [exe_path][crate::model::RunningService::exe_path].
    pub fn set_exe_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.exe_path = v.into();
        self
    }

    /// Sets the value of [cmdline][crate::model::RunningService::cmdline].
    pub fn set_cmdline<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cmdline = v.into();
        self
    }

    /// Sets the value of [pid][crate::model::RunningService::pid].
    pub fn set_pid<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.pid = v.into();
        self
    }
}

impl wkt::message::Message for RunningService {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.RunningService"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunningService {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_name,
            __state,
            __start_mode,
            __exe_path,
            __cmdline,
            __pid,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunningService")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceName" => Ok(__FieldTag::__service_name),
                            "service_name" => Ok(__FieldTag::__service_name),
                            "state" => Ok(__FieldTag::__state),
                            "startMode" => Ok(__FieldTag::__start_mode),
                            "start_mode" => Ok(__FieldTag::__start_mode),
                            "exePath" => Ok(__FieldTag::__exe_path),
                            "exe_path" => Ok(__FieldTag::__exe_path),
                            "cmdline" => Ok(__FieldTag::__cmdline),
                            "pid" => Ok(__FieldTag::__pid),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunningService;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunningService")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_name => {
                            if !fields.insert(__FieldTag::__service_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_name",
                                ));
                            }
                            result.service_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::running_service::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__start_mode => {
                            if !fields.insert(__FieldTag::__start_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_mode",
                                ));
                            }
                            result.start_mode = map.next_value::<std::option::Option<crate::model::running_service::StartMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__exe_path => {
                            if !fields.insert(__FieldTag::__exe_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exe_path",
                                ));
                            }
                            result.exe_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cmdline => {
                            if !fields.insert(__FieldTag::__cmdline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cmdline",
                                ));
                            }
                            result.cmdline = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pid => {
                            if !fields.insert(__FieldTag::__pid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pid",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pid = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RunningService {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_name.is_empty() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.start_mode) {
            state.serialize_entry("startMode", &self.start_mode)?;
        }
        if !self.exe_path.is_empty() {
            state.serialize_entry("exePath", &self.exe_path)?;
        }
        if !self.cmdline.is_empty() {
            state.serialize_entry("cmdline", &self.cmdline)?;
        }
        if !wkt::internal::is_default(&self.pid) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pid", &__With(&self.pid))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RunningService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunningService");
        debug_struct.field("service_name", &self.service_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("start_mode", &self.start_mode);
        debug_struct.field("exe_path", &self.exe_path);
        debug_struct.field("cmdline", &self.cmdline);
        debug_struct.field("pid", &self.pid);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RunningService].
pub mod running_service {
    #[allow(unused_imports)]
    use super::*;

    /// Service state (OS-agnostic).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Service state unspecified.
        Unspecified,
        /// Service is active.
        Active,
        /// Service is paused.
        Paused,
        /// Service is stopped.
        Stopped,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Paused => std::option::Option::Some(2),
                Self::Stopped => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Paused,
                3 => Self::Stopped,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "PAUSED" => Self::Paused,
                "STOPPED" => Self::Stopped,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Paused => serializer.serialize_i32(2),
                Self::Stopped => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.migrationcenter.v1.RunningService.State",
            ))
        }
    }

    /// Service start mode (OS-agnostic).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StartMode {
        /// Start mode unspecified.
        Unspecified,
        /// The service is a device driver started by the system loader.
        Boot,
        /// The service is a device driver started by the IOInitSystem function.
        System,
        /// The service is started by the operating system, at system start-up
        Auto,
        /// The service is started only manually, by a user.
        Manual,
        /// The service is disabled.
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StartMode::value] or
        /// [StartMode::name].
        UnknownValue(start_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod start_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StartMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Boot => std::option::Option::Some(1),
                Self::System => std::option::Option::Some(2),
                Self::Auto => std::option::Option::Some(3),
                Self::Manual => std::option::Option::Some(4),
                Self::Disabled => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("START_MODE_UNSPECIFIED"),
                Self::Boot => std::option::Option::Some("BOOT"),
                Self::System => std::option::Option::Some("SYSTEM"),
                Self::Auto => std::option::Option::Some("AUTO"),
                Self::Manual => std::option::Option::Some("MANUAL"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StartMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StartMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StartMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Boot,
                2 => Self::System,
                3 => Self::Auto,
                4 => Self::Manual,
                5 => Self::Disabled,
                _ => Self::UnknownValue(start_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StartMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "START_MODE_UNSPECIFIED" => Self::Unspecified,
                "BOOT" => Self::Boot,
                "SYSTEM" => Self::System,
                "AUTO" => Self::Auto,
                "MANUAL" => Self::Manual,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(start_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StartMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Boot => serializer.serialize_i32(1),
                Self::System => serializer.serialize_i32(2),
                Self::Auto => serializer.serialize_i32(3),
                Self::Manual => serializer.serialize_i32(4),
                Self::Disabled => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StartMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StartMode>::new(
                ".google.cloud.migrationcenter.v1.RunningService.StartMode",
            ))
        }
    }
}

/// List of running guest OS processes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RunningProcessList {
    /// Running process entries.
    pub entries: std::vec::Vec<crate::model::RunningProcess>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunningProcessList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::RunningProcessList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RunningProcess>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RunningProcessList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.RunningProcessList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunningProcessList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunningProcessList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entries" => Ok(__FieldTag::__entries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunningProcessList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunningProcessList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RunningProcess>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RunningProcessList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RunningProcessList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunningProcessList");
        debug_struct.field("entries", &self.entries);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Guest OS running process details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RunningProcess {
    /// Process ID.
    pub pid: i64,

    /// Process binary path.
    pub exe_path: std::string::String,

    /// Process full command line.
    pub cmdline: std::string::String,

    /// User running the process.
    pub user: std::string::String,

    /// Process extended attributes.
    pub attributes: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunningProcess {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pid][crate::model::RunningProcess::pid].
    pub fn set_pid<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.pid = v.into();
        self
    }

    /// Sets the value of [exe_path][crate::model::RunningProcess::exe_path].
    pub fn set_exe_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.exe_path = v.into();
        self
    }

    /// Sets the value of [cmdline][crate::model::RunningProcess::cmdline].
    pub fn set_cmdline<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cmdline = v.into();
        self
    }

    /// Sets the value of [user][crate::model::RunningProcess::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [attributes][crate::model::RunningProcess::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for RunningProcess {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.RunningProcess"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunningProcess {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pid,
            __exe_path,
            __cmdline,
            __user,
            __attributes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunningProcess")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pid" => Ok(__FieldTag::__pid),
                            "exePath" => Ok(__FieldTag::__exe_path),
                            "exe_path" => Ok(__FieldTag::__exe_path),
                            "cmdline" => Ok(__FieldTag::__cmdline),
                            "user" => Ok(__FieldTag::__user),
                            "attributes" => Ok(__FieldTag::__attributes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunningProcess;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunningProcess")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pid => {
                            if !fields.insert(__FieldTag::__pid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pid",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pid = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__exe_path => {
                            if !fields.insert(__FieldTag::__exe_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exe_path",
                                ));
                            }
                            result.exe_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cmdline => {
                            if !fields.insert(__FieldTag::__cmdline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cmdline",
                                ));
                            }
                            result.cmdline = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user => {
                            if !fields.insert(__FieldTag::__user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user",
                                ));
                            }
                            result.user = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RunningProcess {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.pid) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pid", &__With(&self.pid))?;
        }
        if !self.exe_path.is_empty() {
            state.serialize_entry("exePath", &self.exe_path)?;
        }
        if !self.cmdline.is_empty() {
            state.serialize_entry("cmdline", &self.cmdline)?;
        }
        if !self.user.is_empty() {
            state.serialize_entry("user", &self.user)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RunningProcess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunningProcess");
        debug_struct.field("pid", &self.pid);
        debug_struct.field("exe_path", &self.exe_path);
        debug_struct.field("cmdline", &self.cmdline);
        debug_struct.field("user", &self.user);
        debug_struct.field("attributes", &self.attributes);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Runtime networking information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RuntimeNetworkInfo {
    /// Time of the last network scan.
    pub scan_time: std::option::Option<wkt::Timestamp>,

    /// Network connections.
    pub connections: std::option::Option<crate::model::NetworkConnectionList>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuntimeNetworkInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scan_time][crate::model::RuntimeNetworkInfo::scan_time].
    pub fn set_scan_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.scan_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scan_time][crate::model::RuntimeNetworkInfo::scan_time].
    pub fn set_or_clear_scan_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.scan_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connections][crate::model::RuntimeNetworkInfo::connections].
    pub fn set_connections<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkConnectionList>,
    {
        self.connections = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connections][crate::model::RuntimeNetworkInfo::connections].
    pub fn set_or_clear_connections<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkConnectionList>,
    {
        self.connections = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RuntimeNetworkInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.RuntimeNetworkInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RuntimeNetworkInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scan_time,
            __connections,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RuntimeNetworkInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scanTime" => Ok(__FieldTag::__scan_time),
                            "scan_time" => Ok(__FieldTag::__scan_time),
                            "connections" => Ok(__FieldTag::__connections),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RuntimeNetworkInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RuntimeNetworkInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scan_time => {
                            if !fields.insert(__FieldTag::__scan_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_time",
                                ));
                            }
                            result.scan_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__connections => {
                            if !fields.insert(__FieldTag::__connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connections",
                                ));
                            }
                            result.connections = map.next_value::<std::option::Option<crate::model::NetworkConnectionList>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RuntimeNetworkInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.scan_time.is_some() {
            state.serialize_entry("scanTime", &self.scan_time)?;
        }
        if self.connections.is_some() {
            state.serialize_entry("connections", &self.connections)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RuntimeNetworkInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RuntimeNetworkInfo");
        debug_struct.field("scan_time", &self.scan_time);
        debug_struct.field("connections", &self.connections);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Network connection list.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkConnectionList {
    /// Network connection entries.
    pub entries: std::vec::Vec<crate::model::NetworkConnection>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkConnectionList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::NetworkConnectionList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkConnection>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NetworkConnectionList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.NetworkConnectionList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkConnectionList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkConnectionList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entries" => Ok(__FieldTag::__entries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkConnectionList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkConnectionList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NetworkConnection>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkConnectionList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NetworkConnectionList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkConnectionList");
        debug_struct.field("entries", &self.entries);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkConnection {
    /// Connection protocol (e.g. TCP/UDP).
    pub protocol: std::string::String,

    /// Local IP address.
    pub local_ip_address: std::string::String,

    /// Local port.
    pub local_port: i32,

    /// Remote IP address.
    pub remote_ip_address: std::string::String,

    /// Remote port.
    pub remote_port: i32,

    /// Network connection state.
    pub state: crate::model::network_connection::State,

    /// Process ID.
    pub pid: i64,

    /// Process or service name.
    pub process_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [protocol][crate::model::NetworkConnection::protocol].
    pub fn set_protocol<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [local_ip_address][crate::model::NetworkConnection::local_ip_address].
    pub fn set_local_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.local_ip_address = v.into();
        self
    }

    /// Sets the value of [local_port][crate::model::NetworkConnection::local_port].
    pub fn set_local_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.local_port = v.into();
        self
    }

    /// Sets the value of [remote_ip_address][crate::model::NetworkConnection::remote_ip_address].
    pub fn set_remote_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.remote_ip_address = v.into();
        self
    }

    /// Sets the value of [remote_port][crate::model::NetworkConnection::remote_port].
    pub fn set_remote_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.remote_port = v.into();
        self
    }

    /// Sets the value of [state][crate::model::NetworkConnection::state].
    pub fn set_state<T: std::convert::Into<crate::model::network_connection::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [pid][crate::model::NetworkConnection::pid].
    pub fn set_pid<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.pid = v.into();
        self
    }

    /// Sets the value of [process_name][crate::model::NetworkConnection::process_name].
    pub fn set_process_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.process_name = v.into();
        self
    }
}

impl wkt::message::Message for NetworkConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.NetworkConnection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkConnection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __protocol,
            __local_ip_address,
            __local_port,
            __remote_ip_address,
            __remote_port,
            __state,
            __pid,
            __process_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkConnection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "protocol" => Ok(__FieldTag::__protocol),
                            "localIpAddress" => Ok(__FieldTag::__local_ip_address),
                            "local_ip_address" => Ok(__FieldTag::__local_ip_address),
                            "localPort" => Ok(__FieldTag::__local_port),
                            "local_port" => Ok(__FieldTag::__local_port),
                            "remoteIpAddress" => Ok(__FieldTag::__remote_ip_address),
                            "remote_ip_address" => Ok(__FieldTag::__remote_ip_address),
                            "remotePort" => Ok(__FieldTag::__remote_port),
                            "remote_port" => Ok(__FieldTag::__remote_port),
                            "state" => Ok(__FieldTag::__state),
                            "pid" => Ok(__FieldTag::__pid),
                            "processName" => Ok(__FieldTag::__process_name),
                            "process_name" => Ok(__FieldTag::__process_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkConnection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkConnection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__local_ip_address => {
                            if !fields.insert(__FieldTag::__local_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_ip_address",
                                ));
                            }
                            result.local_ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__local_port => {
                            if !fields.insert(__FieldTag::__local_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.local_port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__remote_ip_address => {
                            if !fields.insert(__FieldTag::__remote_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote_ip_address",
                                ));
                            }
                            result.remote_ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__remote_port => {
                            if !fields.insert(__FieldTag::__remote_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.remote_port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::network_connection::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__pid => {
                            if !fields.insert(__FieldTag::__pid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pid",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pid = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__process_name => {
                            if !fields.insert(__FieldTag::__process_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for process_name",
                                ));
                            }
                            result.process_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkConnection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.protocol.is_empty() {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if !self.local_ip_address.is_empty() {
            state.serialize_entry("localIpAddress", &self.local_ip_address)?;
        }
        if !wkt::internal::is_default(&self.local_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("localPort", &__With(&self.local_port))?;
        }
        if !self.remote_ip_address.is_empty() {
            state.serialize_entry("remoteIpAddress", &self.remote_ip_address)?;
        }
        if !wkt::internal::is_default(&self.remote_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("remotePort", &__With(&self.remote_port))?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.pid) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pid", &__With(&self.pid))?;
        }
        if !self.process_name.is_empty() {
            state.serialize_entry("processName", &self.process_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NetworkConnection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkConnection");
        debug_struct.field("protocol", &self.protocol);
        debug_struct.field("local_ip_address", &self.local_ip_address);
        debug_struct.field("local_port", &self.local_port);
        debug_struct.field("remote_ip_address", &self.remote_ip_address);
        debug_struct.field("remote_port", &self.remote_port);
        debug_struct.field("state", &self.state);
        debug_struct.field("pid", &self.pid);
        debug_struct.field("process_name", &self.process_name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [NetworkConnection].
pub mod network_connection {
    #[allow(unused_imports)]
    use super::*;

    /// Network connection state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Connection state is unknown or unspecified.
        Unspecified,
        /// The connection is being opened.
        Opening,
        /// The connection is open.
        Open,
        /// Listening for incoming connections.
        Listen,
        /// The connection is being closed.
        Closing,
        /// The connection is closed.
        Closed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Opening => std::option::Option::Some(1),
                Self::Open => std::option::Option::Some(2),
                Self::Listen => std::option::Option::Some(3),
                Self::Closing => std::option::Option::Some(4),
                Self::Closed => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Opening => std::option::Option::Some("OPENING"),
                Self::Open => std::option::Option::Some("OPEN"),
                Self::Listen => std::option::Option::Some("LISTEN"),
                Self::Closing => std::option::Option::Some("CLOSING"),
                Self::Closed => std::option::Option::Some("CLOSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Opening,
                2 => Self::Open,
                3 => Self::Listen,
                4 => Self::Closing,
                5 => Self::Closed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "OPENING" => Self::Opening,
                "OPEN" => Self::Open,
                "LISTEN" => Self::Listen,
                "CLOSING" => Self::Closing,
                "CLOSED" => Self::Closed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Opening => serializer.serialize_i32(1),
                Self::Open => serializer.serialize_i32(2),
                Self::Listen => serializer.serialize_i32(3),
                Self::Closing => serializer.serialize_i32(4),
                Self::Closed => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.migrationcenter.v1.NetworkConnection.State",
            ))
        }
    }
}

/// Guest installed application list.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GuestInstalledApplicationList {
    /// Application entries.
    pub entries: std::vec::Vec<crate::model::GuestInstalledApplication>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GuestInstalledApplicationList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::GuestInstalledApplicationList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GuestInstalledApplication>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GuestInstalledApplicationList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GuestInstalledApplicationList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GuestInstalledApplicationList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GuestInstalledApplicationList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entries" => Ok(__FieldTag::__entries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GuestInstalledApplicationList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GuestInstalledApplicationList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::GuestInstalledApplication>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GuestInstalledApplicationList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GuestInstalledApplicationList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GuestInstalledApplicationList");
        debug_struct.field("entries", &self.entries);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Guest installed application information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GuestInstalledApplication {
    /// Installed application name.
    pub application_name: std::string::String,

    /// Installed application vendor.
    pub vendor: std::string::String,

    /// The time when the application was installed.
    pub install_time: std::option::Option<wkt::Timestamp>,

    /// Source path.
    pub path: std::string::String,

    /// Installed application version.
    pub version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GuestInstalledApplication {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [application_name][crate::model::GuestInstalledApplication::application_name].
    pub fn set_application_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.application_name = v.into();
        self
    }

    /// Sets the value of [vendor][crate::model::GuestInstalledApplication::vendor].
    pub fn set_vendor<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vendor = v.into();
        self
    }

    /// Sets the value of [install_time][crate::model::GuestInstalledApplication::install_time].
    pub fn set_install_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.install_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [install_time][crate::model::GuestInstalledApplication::install_time].
    pub fn set_or_clear_install_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.install_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [path][crate::model::GuestInstalledApplication::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GuestInstalledApplication::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for GuestInstalledApplication {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GuestInstalledApplication"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GuestInstalledApplication {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __application_name,
            __vendor,
            __install_time,
            __path,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GuestInstalledApplication")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "applicationName" => Ok(__FieldTag::__application_name),
                            "application_name" => Ok(__FieldTag::__application_name),
                            "vendor" => Ok(__FieldTag::__vendor),
                            "installTime" => Ok(__FieldTag::__install_time),
                            "install_time" => Ok(__FieldTag::__install_time),
                            "path" => Ok(__FieldTag::__path),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GuestInstalledApplication;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GuestInstalledApplication")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__application_name => {
                            if !fields.insert(__FieldTag::__application_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for application_name",
                                ));
                            }
                            result.application_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vendor => {
                            if !fields.insert(__FieldTag::__vendor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vendor",
                                ));
                            }
                            result.vendor = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__install_time => {
                            if !fields.insert(__FieldTag::__install_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for install_time",
                                ));
                            }
                            result.install_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GuestInstalledApplication {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.application_name.is_empty() {
            state.serialize_entry("applicationName", &self.application_name)?;
        }
        if !self.vendor.is_empty() {
            state.serialize_entry("vendor", &self.vendor)?;
        }
        if self.install_time.is_some() {
            state.serialize_entry("installTime", &self.install_time)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GuestInstalledApplication {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GuestInstalledApplication");
        debug_struct.field("application_name", &self.application_name);
        debug_struct.field("vendor", &self.vendor);
        debug_struct.field("install_time", &self.install_time);
        debug_struct.field("path", &self.path);
        debug_struct.field("version", &self.version);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Open file list.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OpenFileList {
    /// Open file details entries.
    pub entries: std::vec::Vec<crate::model::OpenFileDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OpenFileList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::OpenFileList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OpenFileDetails>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OpenFileList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.OpenFileList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OpenFileList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OpenFileList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entries" => Ok(__FieldTag::__entries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OpenFileList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OpenFileList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::OpenFileDetails>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OpenFileList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OpenFileList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OpenFileList");
        debug_struct.field("entries", &self.entries);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Open file Information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OpenFileDetails {
    /// Opened file command.
    pub command: std::string::String,

    /// Opened file user.
    pub user: std::string::String,

    /// Opened file file type.
    pub file_type: std::string::String,

    /// Opened file file path.
    pub file_path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OpenFileDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [command][crate::model::OpenFileDetails::command].
    pub fn set_command<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.command = v.into();
        self
    }

    /// Sets the value of [user][crate::model::OpenFileDetails::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [file_type][crate::model::OpenFileDetails::file_type].
    pub fn set_file_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_type = v.into();
        self
    }

    /// Sets the value of [file_path][crate::model::OpenFileDetails::file_path].
    pub fn set_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_path = v.into();
        self
    }
}

impl wkt::message::Message for OpenFileDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.OpenFileDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OpenFileDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __command,
            __user,
            __file_type,
            __file_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OpenFileDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "command" => Ok(__FieldTag::__command),
                            "user" => Ok(__FieldTag::__user),
                            "fileType" => Ok(__FieldTag::__file_type),
                            "file_type" => Ok(__FieldTag::__file_type),
                            "filePath" => Ok(__FieldTag::__file_path),
                            "file_path" => Ok(__FieldTag::__file_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OpenFileDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OpenFileDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__command => {
                            if !fields.insert(__FieldTag::__command) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for command",
                                ));
                            }
                            result.command = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user => {
                            if !fields.insert(__FieldTag::__user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user",
                                ));
                            }
                            result.user = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_type => {
                            if !fields.insert(__FieldTag::__file_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_type",
                                ));
                            }
                            result.file_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_path => {
                            if !fields.insert(__FieldTag::__file_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_path",
                                ));
                            }
                            result.file_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OpenFileDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.command.is_empty() {
            state.serialize_entry("command", &self.command)?;
        }
        if !self.user.is_empty() {
            state.serialize_entry("user", &self.user)?;
        }
        if !self.file_type.is_empty() {
            state.serialize_entry("fileType", &self.file_type)?;
        }
        if !self.file_path.is_empty() {
            state.serialize_entry("filePath", &self.file_path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OpenFileDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OpenFileDetails");
        debug_struct.field("command", &self.command);
        debug_struct.field("user", &self.user);
        debug_struct.field("file_type", &self.file_type);
        debug_struct.field("file_path", &self.file_path);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Information about the platform.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PlatformDetails {
    pub vendor_details: std::option::Option<crate::model::platform_details::VendorDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PlatformDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vendor_details][crate::model::PlatformDetails::vendor_details].
    ///
    /// Note that all the setters affecting `vendor_details` are mutually
    /// exclusive.
    pub fn set_vendor_details<
        T: std::convert::Into<std::option::Option<crate::model::platform_details::VendorDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vendor_details = v.into();
        self
    }

    /// The value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// if it holds a `VmwareDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vmware_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmwarePlatformDetails>> {
        #[allow(unreachable_patterns)]
        self.vendor_details.as_ref().and_then(|v| match v {
            crate::model::platform_details::VendorDetails::VmwareDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// to hold a `VmwareDetails`.
    ///
    /// Note that all the setters affecting `vendor_details` are
    /// mutually exclusive.
    pub fn set_vmware_details<
        T: std::convert::Into<std::boxed::Box<crate::model::VmwarePlatformDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vendor_details = std::option::Option::Some(
            crate::model::platform_details::VendorDetails::VmwareDetails(v.into()),
        );
        self
    }

    /// The value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// if it holds a `AwsEc2Details`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_ec2_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AwsEc2PlatformDetails>> {
        #[allow(unreachable_patterns)]
        self.vendor_details.as_ref().and_then(|v| match v {
            crate::model::platform_details::VendorDetails::AwsEc2Details(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// to hold a `AwsEc2Details`.
    ///
    /// Note that all the setters affecting `vendor_details` are
    /// mutually exclusive.
    pub fn set_aws_ec2_details<
        T: std::convert::Into<std::boxed::Box<crate::model::AwsEc2PlatformDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vendor_details = std::option::Option::Some(
            crate::model::platform_details::VendorDetails::AwsEc2Details(v.into()),
        );
        self
    }

    /// The value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// if it holds a `AzureVmDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn azure_vm_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AzureVmPlatformDetails>> {
        #[allow(unreachable_patterns)]
        self.vendor_details.as_ref().and_then(|v| match v {
            crate::model::platform_details::VendorDetails::AzureVmDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// to hold a `AzureVmDetails`.
    ///
    /// Note that all the setters affecting `vendor_details` are
    /// mutually exclusive.
    pub fn set_azure_vm_details<
        T: std::convert::Into<std::boxed::Box<crate::model::AzureVmPlatformDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vendor_details = std::option::Option::Some(
            crate::model::platform_details::VendorDetails::AzureVmDetails(v.into()),
        );
        self
    }

    /// The value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// if it holds a `GenericDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn generic_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GenericPlatformDetails>> {
        #[allow(unreachable_patterns)]
        self.vendor_details.as_ref().and_then(|v| match v {
            crate::model::platform_details::VendorDetails::GenericDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// to hold a `GenericDetails`.
    ///
    /// Note that all the setters affecting `vendor_details` are
    /// mutually exclusive.
    pub fn set_generic_details<
        T: std::convert::Into<std::boxed::Box<crate::model::GenericPlatformDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vendor_details = std::option::Option::Some(
            crate::model::platform_details::VendorDetails::GenericDetails(v.into()),
        );
        self
    }

    /// The value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// if it holds a `PhysicalDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn physical_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PhysicalPlatformDetails>> {
        #[allow(unreachable_patterns)]
        self.vendor_details.as_ref().and_then(|v| match v {
            crate::model::platform_details::VendorDetails::PhysicalDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// to hold a `PhysicalDetails`.
    ///
    /// Note that all the setters affecting `vendor_details` are
    /// mutually exclusive.
    pub fn set_physical_details<
        T: std::convert::Into<std::boxed::Box<crate::model::PhysicalPlatformDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vendor_details = std::option::Option::Some(
            crate::model::platform_details::VendorDetails::PhysicalDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PlatformDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.PlatformDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PlatformDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vmware_details,
            __aws_ec2_details,
            __azure_vm_details,
            __generic_details,
            __physical_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PlatformDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmwareDetails" => Ok(__FieldTag::__vmware_details),
                            "vmware_details" => Ok(__FieldTag::__vmware_details),
                            "awsEc2Details" => Ok(__FieldTag::__aws_ec2_details),
                            "aws_ec2_details" => Ok(__FieldTag::__aws_ec2_details),
                            "azureVmDetails" => Ok(__FieldTag::__azure_vm_details),
                            "azure_vm_details" => Ok(__FieldTag::__azure_vm_details),
                            "genericDetails" => Ok(__FieldTag::__generic_details),
                            "generic_details" => Ok(__FieldTag::__generic_details),
                            "physicalDetails" => Ok(__FieldTag::__physical_details),
                            "physical_details" => Ok(__FieldTag::__physical_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PlatformDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PlatformDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vmware_details => {
                            if !fields.insert(__FieldTag::__vmware_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vmware_details",
                                ));
                            }
                            if result.vendor_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `vendor_details`, a oneof with full ID .google.cloud.migrationcenter.v1.PlatformDetails.vmware_details, latest field was vmwareDetails",
                                ));
                            }
                            result.vendor_details = std::option::Option::Some(
                                crate::model::platform_details::VendorDetails::VmwareDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VmwarePlatformDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__aws_ec2_details => {
                            if !fields.insert(__FieldTag::__aws_ec2_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_ec2_details",
                                ));
                            }
                            if result.vendor_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `vendor_details`, a oneof with full ID .google.cloud.migrationcenter.v1.PlatformDetails.aws_ec2_details, latest field was awsEc2Details",
                                ));
                            }
                            result.vendor_details = std::option::Option::Some(
                                crate::model::platform_details::VendorDetails::AwsEc2Details(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AwsEc2PlatformDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__azure_vm_details => {
                            if !fields.insert(__FieldTag::__azure_vm_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_vm_details",
                                ));
                            }
                            if result.vendor_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `vendor_details`, a oneof with full ID .google.cloud.migrationcenter.v1.PlatformDetails.azure_vm_details, latest field was azureVmDetails",
                                ));
                            }
                            result.vendor_details = std::option::Option::Some(
                                crate::model::platform_details::VendorDetails::AzureVmDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AzureVmPlatformDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__generic_details => {
                            if !fields.insert(__FieldTag::__generic_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generic_details",
                                ));
                            }
                            if result.vendor_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `vendor_details`, a oneof with full ID .google.cloud.migrationcenter.v1.PlatformDetails.generic_details, latest field was genericDetails",
                                ));
                            }
                            result.vendor_details = std::option::Option::Some(
                                crate::model::platform_details::VendorDetails::GenericDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GenericPlatformDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__physical_details => {
                            if !fields.insert(__FieldTag::__physical_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for physical_details",
                                ));
                            }
                            if result.vendor_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `vendor_details`, a oneof with full ID .google.cloud.migrationcenter.v1.PlatformDetails.physical_details, latest field was physicalDetails",
                                ));
                            }
                            result.vendor_details = std::option::Option::Some(
                                crate::model::platform_details::VendorDetails::PhysicalDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PhysicalPlatformDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PlatformDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.vmware_details() {
            state.serialize_entry("vmwareDetails", value)?;
        }
        if let Some(value) = self.aws_ec2_details() {
            state.serialize_entry("awsEc2Details", value)?;
        }
        if let Some(value) = self.azure_vm_details() {
            state.serialize_entry("azureVmDetails", value)?;
        }
        if let Some(value) = self.generic_details() {
            state.serialize_entry("genericDetails", value)?;
        }
        if let Some(value) = self.physical_details() {
            state.serialize_entry("physicalDetails", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PlatformDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PlatformDetails");
        debug_struct.field("vendor_details", &self.vendor_details);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PlatformDetails].
pub mod platform_details {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VendorDetails {
        /// VMware specific details.
        VmwareDetails(std::boxed::Box<crate::model::VmwarePlatformDetails>),
        /// AWS EC2 specific details.
        AwsEc2Details(std::boxed::Box<crate::model::AwsEc2PlatformDetails>),
        /// Azure VM specific details.
        AzureVmDetails(std::boxed::Box<crate::model::AzureVmPlatformDetails>),
        /// Generic platform details.
        GenericDetails(std::boxed::Box<crate::model::GenericPlatformDetails>),
        /// Physical machines platform details.
        PhysicalDetails(std::boxed::Box<crate::model::PhysicalPlatformDetails>),
    }
}

/// VMware specific details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VmwarePlatformDetails {
    /// vCenter version.
    pub vcenter_version: std::string::String,

    /// ESX version.
    pub esx_version: std::string::String,

    /// VMware os enum -
    /// <https://vdc-repo.vmware.com/vmwb-repository/dcr-public/da47f910-60ac-438b-8b9b-6122f4d14524/16b7274a-bf8b-4b4c-a05e-746f2aa93c8c/doc/vim.vm.GuestOsDescriptor.GuestOsIdentifier.html>.
    pub osid: std::string::String,

    /// Folder name in vCenter where asset resides.
    pub vcenter_folder: std::string::String,

    /// vCenter URI used in collection.
    pub vcenter_uri: std::string::String,

    /// vCenter VM ID.
    pub vcenter_vm_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmwarePlatformDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vcenter_version][crate::model::VmwarePlatformDetails::vcenter_version].
    pub fn set_vcenter_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vcenter_version = v.into();
        self
    }

    /// Sets the value of [esx_version][crate::model::VmwarePlatformDetails::esx_version].
    pub fn set_esx_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.esx_version = v.into();
        self
    }

    /// Sets the value of [osid][crate::model::VmwarePlatformDetails::osid].
    pub fn set_osid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.osid = v.into();
        self
    }

    /// Sets the value of [vcenter_folder][crate::model::VmwarePlatformDetails::vcenter_folder].
    pub fn set_vcenter_folder<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vcenter_folder = v.into();
        self
    }

    /// Sets the value of [vcenter_uri][crate::model::VmwarePlatformDetails::vcenter_uri].
    pub fn set_vcenter_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vcenter_uri = v.into();
        self
    }

    /// Sets the value of [vcenter_vm_id][crate::model::VmwarePlatformDetails::vcenter_vm_id].
    pub fn set_vcenter_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vcenter_vm_id = v.into();
        self
    }
}

impl wkt::message::Message for VmwarePlatformDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.VmwarePlatformDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmwarePlatformDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vcenter_version,
            __esx_version,
            __osid,
            __vcenter_folder,
            __vcenter_uri,
            __vcenter_vm_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmwarePlatformDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vcenterVersion" => Ok(__FieldTag::__vcenter_version),
                            "vcenter_version" => Ok(__FieldTag::__vcenter_version),
                            "esxVersion" => Ok(__FieldTag::__esx_version),
                            "esx_version" => Ok(__FieldTag::__esx_version),
                            "osid" => Ok(__FieldTag::__osid),
                            "vcenterFolder" => Ok(__FieldTag::__vcenter_folder),
                            "vcenter_folder" => Ok(__FieldTag::__vcenter_folder),
                            "vcenterUri" => Ok(__FieldTag::__vcenter_uri),
                            "vcenter_uri" => Ok(__FieldTag::__vcenter_uri),
                            "vcenterVmId" => Ok(__FieldTag::__vcenter_vm_id),
                            "vcenter_vm_id" => Ok(__FieldTag::__vcenter_vm_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmwarePlatformDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmwarePlatformDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vcenter_version => {
                            if !fields.insert(__FieldTag::__vcenter_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vcenter_version",
                                ));
                            }
                            result.vcenter_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__esx_version => {
                            if !fields.insert(__FieldTag::__esx_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for esx_version",
                                ));
                            }
                            result.esx_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__osid => {
                            if !fields.insert(__FieldTag::__osid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for osid",
                                ));
                            }
                            result.osid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vcenter_folder => {
                            if !fields.insert(__FieldTag::__vcenter_folder) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vcenter_folder",
                                ));
                            }
                            result.vcenter_folder = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vcenter_uri => {
                            if !fields.insert(__FieldTag::__vcenter_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vcenter_uri",
                                ));
                            }
                            result.vcenter_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vcenter_vm_id => {
                            if !fields.insert(__FieldTag::__vcenter_vm_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vcenter_vm_id",
                                ));
                            }
                            result.vcenter_vm_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmwarePlatformDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vcenter_version.is_empty() {
            state.serialize_entry("vcenterVersion", &self.vcenter_version)?;
        }
        if !self.esx_version.is_empty() {
            state.serialize_entry("esxVersion", &self.esx_version)?;
        }
        if !self.osid.is_empty() {
            state.serialize_entry("osid", &self.osid)?;
        }
        if !self.vcenter_folder.is_empty() {
            state.serialize_entry("vcenterFolder", &self.vcenter_folder)?;
        }
        if !self.vcenter_uri.is_empty() {
            state.serialize_entry("vcenterUri", &self.vcenter_uri)?;
        }
        if !self.vcenter_vm_id.is_empty() {
            state.serialize_entry("vcenterVmId", &self.vcenter_vm_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VmwarePlatformDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmwarePlatformDetails");
        debug_struct.field("vcenter_version", &self.vcenter_version);
        debug_struct.field("esx_version", &self.esx_version);
        debug_struct.field("osid", &self.osid);
        debug_struct.field("vcenter_folder", &self.vcenter_folder);
        debug_struct.field("vcenter_uri", &self.vcenter_uri);
        debug_struct.field("vcenter_vm_id", &self.vcenter_vm_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AWS EC2 specific details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsEc2PlatformDetails {
    /// AWS platform's machine type label.
    pub machine_type_label: std::string::String,

    /// The location of the machine in the AWS format.
    pub location: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsEc2PlatformDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_type_label][crate::model::AwsEc2PlatformDetails::machine_type_label].
    pub fn set_machine_type_label<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_type_label = v.into();
        self
    }

    /// Sets the value of [location][crate::model::AwsEc2PlatformDetails::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for AwsEc2PlatformDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.AwsEc2PlatformDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsEc2PlatformDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __machine_type_label,
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsEc2PlatformDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "machineTypeLabel" => Ok(__FieldTag::__machine_type_label),
                            "machine_type_label" => Ok(__FieldTag::__machine_type_label),
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsEc2PlatformDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsEc2PlatformDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__machine_type_label => {
                            if !fields.insert(__FieldTag::__machine_type_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type_label",
                                ));
                            }
                            result.machine_type_label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsEc2PlatformDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.machine_type_label.is_empty() {
            state.serialize_entry("machineTypeLabel", &self.machine_type_label)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsEc2PlatformDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsEc2PlatformDetails");
        debug_struct.field("machine_type_label", &self.machine_type_label);
        debug_struct.field("location", &self.location);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Azure VM specific details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureVmPlatformDetails {
    /// Azure platform's machine type label.
    pub machine_type_label: std::string::String,

    /// The location of the machine in the Azure format.
    pub location: std::string::String,

    /// Azure platform's provisioning state.
    pub provisioning_state: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureVmPlatformDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_type_label][crate::model::AzureVmPlatformDetails::machine_type_label].
    pub fn set_machine_type_label<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_type_label = v.into();
        self
    }

    /// Sets the value of [location][crate::model::AzureVmPlatformDetails::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [provisioning_state][crate::model::AzureVmPlatformDetails::provisioning_state].
    pub fn set_provisioning_state<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.provisioning_state = v.into();
        self
    }
}

impl wkt::message::Message for AzureVmPlatformDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.AzureVmPlatformDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureVmPlatformDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __machine_type_label,
            __location,
            __provisioning_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureVmPlatformDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "machineTypeLabel" => Ok(__FieldTag::__machine_type_label),
                            "machine_type_label" => Ok(__FieldTag::__machine_type_label),
                            "location" => Ok(__FieldTag::__location),
                            "provisioningState" => Ok(__FieldTag::__provisioning_state),
                            "provisioning_state" => Ok(__FieldTag::__provisioning_state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureVmPlatformDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureVmPlatformDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__machine_type_label => {
                            if !fields.insert(__FieldTag::__machine_type_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type_label",
                                ));
                            }
                            result.machine_type_label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__provisioning_state => {
                            if !fields.insert(__FieldTag::__provisioning_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provisioning_state",
                                ));
                            }
                            result.provisioning_state = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureVmPlatformDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.machine_type_label.is_empty() {
            state.serialize_entry("machineTypeLabel", &self.machine_type_label)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.provisioning_state.is_empty() {
            state.serialize_entry("provisioningState", &self.provisioning_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AzureVmPlatformDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AzureVmPlatformDetails");
        debug_struct.field("machine_type_label", &self.machine_type_label);
        debug_struct.field("location", &self.location);
        debug_struct.field("provisioning_state", &self.provisioning_state);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Generic platform details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenericPlatformDetails {
    /// Free text representation of the machine location.
    /// The format of this field should not be relied on. Different VMs in the same
    /// location may have different string values for this field.
    pub location: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenericPlatformDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::GenericPlatformDetails::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for GenericPlatformDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GenericPlatformDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenericPlatformDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenericPlatformDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenericPlatformDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenericPlatformDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenericPlatformDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GenericPlatformDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenericPlatformDetails");
        debug_struct.field("location", &self.location);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Platform specific details for Physical Machines.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PhysicalPlatformDetails {
    /// Free text representation of the machine location.
    /// The format of this field should not be relied on. Different machines in the
    /// same location may have different string values for this field.
    pub location: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhysicalPlatformDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::PhysicalPlatformDetails::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for PhysicalPlatformDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.PhysicalPlatformDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PhysicalPlatformDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PhysicalPlatformDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PhysicalPlatformDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PhysicalPlatformDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PhysicalPlatformDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PhysicalPlatformDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PhysicalPlatformDetails");
        debug_struct.field("location", &self.location);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Memory usage sample.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MemoryUsageSample {
    /// Percentage of system memory utilized. Must be in the interval [0, 100].
    pub utilized_percentage: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MemoryUsageSample {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [utilized_percentage][crate::model::MemoryUsageSample::utilized_percentage].
    pub fn set_utilized_percentage<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.utilized_percentage = v.into();
        self
    }
}

impl wkt::message::Message for MemoryUsageSample {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.MemoryUsageSample"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MemoryUsageSample {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __utilized_percentage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MemoryUsageSample")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "utilizedPercentage" => Ok(__FieldTag::__utilized_percentage),
                            "utilized_percentage" => Ok(__FieldTag::__utilized_percentage),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MemoryUsageSample;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MemoryUsageSample")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__utilized_percentage => {
                            if !fields.insert(__FieldTag::__utilized_percentage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for utilized_percentage",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.utilized_percentage =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MemoryUsageSample {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.utilized_percentage) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("utilizedPercentage", &__With(&self.utilized_percentage))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MemoryUsageSample {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MemoryUsageSample");
        debug_struct.field("utilized_percentage", &self.utilized_percentage);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CPU usage sample.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CpuUsageSample {
    /// Percentage of total CPU capacity utilized. Must be in the interval [0,
    /// 100]. On most systems can be calculated using 100 - idle percentage.
    pub utilized_percentage: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CpuUsageSample {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [utilized_percentage][crate::model::CpuUsageSample::utilized_percentage].
    pub fn set_utilized_percentage<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.utilized_percentage = v.into();
        self
    }
}

impl wkt::message::Message for CpuUsageSample {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.CpuUsageSample"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CpuUsageSample {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __utilized_percentage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CpuUsageSample")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "utilizedPercentage" => Ok(__FieldTag::__utilized_percentage),
                            "utilized_percentage" => Ok(__FieldTag::__utilized_percentage),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CpuUsageSample;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CpuUsageSample")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__utilized_percentage => {
                            if !fields.insert(__FieldTag::__utilized_percentage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for utilized_percentage",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.utilized_percentage =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CpuUsageSample {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.utilized_percentage) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("utilizedPercentage", &__With(&self.utilized_percentage))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CpuUsageSample {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CpuUsageSample");
        debug_struct.field("utilized_percentage", &self.utilized_percentage);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Network usage sample. Values are across all network interfaces.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkUsageSample {
    /// Average network ingress in B/s sampled over a short window.
    /// Must be non-negative.
    pub average_ingress_bps: f32,

    /// Average network egress in B/s sampled over a short window.
    /// Must be non-negative.
    pub average_egress_bps: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkUsageSample {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [average_ingress_bps][crate::model::NetworkUsageSample::average_ingress_bps].
    pub fn set_average_ingress_bps<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.average_ingress_bps = v.into();
        self
    }

    /// Sets the value of [average_egress_bps][crate::model::NetworkUsageSample::average_egress_bps].
    pub fn set_average_egress_bps<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.average_egress_bps = v.into();
        self
    }
}

impl wkt::message::Message for NetworkUsageSample {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.NetworkUsageSample"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkUsageSample {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __average_ingress_bps,
            __average_egress_bps,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkUsageSample")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "averageIngressBps" => Ok(__FieldTag::__average_ingress_bps),
                            "average_ingress_bps" => Ok(__FieldTag::__average_ingress_bps),
                            "averageEgressBps" => Ok(__FieldTag::__average_egress_bps),
                            "average_egress_bps" => Ok(__FieldTag::__average_egress_bps),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkUsageSample;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkUsageSample")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__average_ingress_bps => {
                            if !fields.insert(__FieldTag::__average_ingress_bps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for average_ingress_bps",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.average_ingress_bps =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__average_egress_bps => {
                            if !fields.insert(__FieldTag::__average_egress_bps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for average_egress_bps",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.average_egress_bps =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkUsageSample {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.average_ingress_bps) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("averageIngressBps", &__With(&self.average_ingress_bps))?;
        }
        if !wkt::internal::is_default(&self.average_egress_bps) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("averageEgressBps", &__With(&self.average_egress_bps))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NetworkUsageSample {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkUsageSample");
        debug_struct.field("average_ingress_bps", &self.average_ingress_bps);
        debug_struct.field("average_egress_bps", &self.average_egress_bps);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Disk usage sample. Values are across all disks.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DiskUsageSample {
    /// Average IOPS sampled over a short window. Must be non-negative.
    pub average_iops: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiskUsageSample {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [average_iops][crate::model::DiskUsageSample::average_iops].
    pub fn set_average_iops<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.average_iops = v.into();
        self
    }
}

impl wkt::message::Message for DiskUsageSample {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DiskUsageSample"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiskUsageSample {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __average_iops,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiskUsageSample")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "averageIops" => Ok(__FieldTag::__average_iops),
                            "average_iops" => Ok(__FieldTag::__average_iops),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiskUsageSample;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiskUsageSample")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__average_iops => {
                            if !fields.insert(__FieldTag::__average_iops) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for average_iops",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.average_iops = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiskUsageSample {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.average_iops) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("averageIops", &__With(&self.average_iops))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DiskUsageSample {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiskUsageSample");
        debug_struct.field("average_iops", &self.average_iops);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Performance data sample.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PerformanceSample {
    /// Time the sample was collected.
    /// If omitted, the frame report time will be used.
    pub sample_time: std::option::Option<wkt::Timestamp>,

    /// Memory usage sample.
    pub memory: std::option::Option<crate::model::MemoryUsageSample>,

    /// CPU usage sample.
    pub cpu: std::option::Option<crate::model::CpuUsageSample>,

    /// Network usage sample.
    pub network: std::option::Option<crate::model::NetworkUsageSample>,

    /// Disk usage sample.
    pub disk: std::option::Option<crate::model::DiskUsageSample>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PerformanceSample {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sample_time][crate::model::PerformanceSample::sample_time].
    pub fn set_sample_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.sample_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sample_time][crate::model::PerformanceSample::sample_time].
    pub fn set_or_clear_sample_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.sample_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [memory][crate::model::PerformanceSample::memory].
    pub fn set_memory<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MemoryUsageSample>,
    {
        self.memory = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [memory][crate::model::PerformanceSample::memory].
    pub fn set_or_clear_memory<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MemoryUsageSample>,
    {
        self.memory = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cpu][crate::model::PerformanceSample::cpu].
    pub fn set_cpu<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CpuUsageSample>,
    {
        self.cpu = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cpu][crate::model::PerformanceSample::cpu].
    pub fn set_or_clear_cpu<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CpuUsageSample>,
    {
        self.cpu = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network][crate::model::PerformanceSample::network].
    pub fn set_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkUsageSample>,
    {
        self.network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network][crate::model::PerformanceSample::network].
    pub fn set_or_clear_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkUsageSample>,
    {
        self.network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk][crate::model::PerformanceSample::disk].
    pub fn set_disk<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiskUsageSample>,
    {
        self.disk = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk][crate::model::PerformanceSample::disk].
    pub fn set_or_clear_disk<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiskUsageSample>,
    {
        self.disk = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PerformanceSample {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.PerformanceSample"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PerformanceSample {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sample_time,
            __memory,
            __cpu,
            __network,
            __disk,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PerformanceSample")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sampleTime" => Ok(__FieldTag::__sample_time),
                            "sample_time" => Ok(__FieldTag::__sample_time),
                            "memory" => Ok(__FieldTag::__memory),
                            "cpu" => Ok(__FieldTag::__cpu),
                            "network" => Ok(__FieldTag::__network),
                            "disk" => Ok(__FieldTag::__disk),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PerformanceSample;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PerformanceSample")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sample_time => {
                            if !fields.insert(__FieldTag::__sample_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_time",
                                ));
                            }
                            result.sample_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__memory => {
                            if !fields.insert(__FieldTag::__memory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory",
                                ));
                            }
                            result.memory = map
                                .next_value::<std::option::Option<crate::model::MemoryUsageSample>>(
                                )?;
                        }
                        __FieldTag::__cpu => {
                            if !fields.insert(__FieldTag::__cpu) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu",
                                ));
                            }
                            result.cpu = map
                                .next_value::<std::option::Option<crate::model::CpuUsageSample>>(
                                )?;
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map.next_value::<std::option::Option<crate::model::NetworkUsageSample>>()?
                                ;
                        }
                        __FieldTag::__disk => {
                            if !fields.insert(__FieldTag::__disk) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk",
                                ));
                            }
                            result.disk = map
                                .next_value::<std::option::Option<crate::model::DiskUsageSample>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PerformanceSample {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.sample_time.is_some() {
            state.serialize_entry("sampleTime", &self.sample_time)?;
        }
        if self.memory.is_some() {
            state.serialize_entry("memory", &self.memory)?;
        }
        if self.cpu.is_some() {
            state.serialize_entry("cpu", &self.cpu)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.disk.is_some() {
            state.serialize_entry("disk", &self.disk)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PerformanceSample {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PerformanceSample");
        debug_struct.field("sample_time", &self.sample_time);
        debug_struct.field("memory", &self.memory);
        debug_struct.field("cpu", &self.cpu);
        debug_struct.field("network", &self.network);
        debug_struct.field("disk", &self.disk);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Performance data for an asset.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AssetPerformanceData {
    /// Daily resource usage aggregations.
    /// Contains all of the data available for an asset, up to the last 420 days.
    /// Aggregations are sorted from oldest to most recent.
    pub daily_resource_usage_aggregations:
        std::vec::Vec<crate::model::DailyResourceUsageAggregation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssetPerformanceData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [daily_resource_usage_aggregations][crate::model::AssetPerformanceData::daily_resource_usage_aggregations].
    pub fn set_daily_resource_usage_aggregations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DailyResourceUsageAggregation>,
    {
        use std::iter::Iterator;
        self.daily_resource_usage_aggregations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AssetPerformanceData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.AssetPerformanceData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AssetPerformanceData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __daily_resource_usage_aggregations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AssetPerformanceData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dailyResourceUsageAggregations" => {
                                Ok(__FieldTag::__daily_resource_usage_aggregations)
                            }
                            "daily_resource_usage_aggregations" => {
                                Ok(__FieldTag::__daily_resource_usage_aggregations)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AssetPerformanceData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AssetPerformanceData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__daily_resource_usage_aggregations => {
                            if !fields.insert(__FieldTag::__daily_resource_usage_aggregations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for daily_resource_usage_aggregations",
                                ));
                            }
                            result.daily_resource_usage_aggregations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DailyResourceUsageAggregation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AssetPerformanceData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.daily_resource_usage_aggregations.is_empty() {
            state.serialize_entry(
                "dailyResourceUsageAggregations",
                &self.daily_resource_usage_aggregations,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AssetPerformanceData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AssetPerformanceData");
        debug_struct.field(
            "daily_resource_usage_aggregations",
            &self.daily_resource_usage_aggregations,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Usage data aggregation for a single day.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DailyResourceUsageAggregation {
    /// Aggregation date. Day boundaries are at midnight UTC.
    pub date: std::option::Option<gtype::model::Date>,

    /// CPU usage.
    pub cpu: std::option::Option<crate::model::daily_resource_usage_aggregation::Cpu>,

    /// Memory usage.
    pub memory: std::option::Option<crate::model::daily_resource_usage_aggregation::Memory>,

    /// Network usage.
    pub network: std::option::Option<crate::model::daily_resource_usage_aggregation::Network>,

    /// Disk usage.
    pub disk: std::option::Option<crate::model::daily_resource_usage_aggregation::Disk>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DailyResourceUsageAggregation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [date][crate::model::DailyResourceUsageAggregation::date].
    pub fn set_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [date][crate::model::DailyResourceUsageAggregation::date].
    pub fn set_or_clear_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.date = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cpu][crate::model::DailyResourceUsageAggregation::cpu].
    pub fn set_cpu<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::daily_resource_usage_aggregation::Cpu>,
    {
        self.cpu = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cpu][crate::model::DailyResourceUsageAggregation::cpu].
    pub fn set_or_clear_cpu<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::daily_resource_usage_aggregation::Cpu>,
    {
        self.cpu = v.map(|x| x.into());
        self
    }

    /// Sets the value of [memory][crate::model::DailyResourceUsageAggregation::memory].
    pub fn set_memory<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::daily_resource_usage_aggregation::Memory>,
    {
        self.memory = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [memory][crate::model::DailyResourceUsageAggregation::memory].
    pub fn set_or_clear_memory<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::daily_resource_usage_aggregation::Memory>,
    {
        self.memory = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network][crate::model::DailyResourceUsageAggregation::network].
    pub fn set_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::daily_resource_usage_aggregation::Network>,
    {
        self.network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network][crate::model::DailyResourceUsageAggregation::network].
    pub fn set_or_clear_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::daily_resource_usage_aggregation::Network>,
    {
        self.network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk][crate::model::DailyResourceUsageAggregation::disk].
    pub fn set_disk<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::daily_resource_usage_aggregation::Disk>,
    {
        self.disk = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk][crate::model::DailyResourceUsageAggregation::disk].
    pub fn set_or_clear_disk<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::daily_resource_usage_aggregation::Disk>,
    {
        self.disk = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DailyResourceUsageAggregation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DailyResourceUsageAggregation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DailyResourceUsageAggregation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __date,
            __cpu,
            __memory,
            __network,
            __disk,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DailyResourceUsageAggregation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "date" => Ok(__FieldTag::__date),
                            "cpu" => Ok(__FieldTag::__cpu),
                            "memory" => Ok(__FieldTag::__memory),
                            "network" => Ok(__FieldTag::__network),
                            "disk" => Ok(__FieldTag::__disk),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DailyResourceUsageAggregation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DailyResourceUsageAggregation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__date => {
                            if !fields.insert(__FieldTag::__date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for date",
                                ));
                            }
                            result.date =
                                map.next_value::<std::option::Option<gtype::model::Date>>()?;
                        }
                        __FieldTag::__cpu => {
                            if !fields.insert(__FieldTag::__cpu) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu",
                                ));
                            }
                            result.cpu = map.next_value::<std::option::Option<
                                crate::model::daily_resource_usage_aggregation::Cpu,
                            >>()?;
                        }
                        __FieldTag::__memory => {
                            if !fields.insert(__FieldTag::__memory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory",
                                ));
                            }
                            result.memory = map.next_value::<std::option::Option<
                                crate::model::daily_resource_usage_aggregation::Memory,
                            >>()?;
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map.next_value::<std::option::Option<
                                crate::model::daily_resource_usage_aggregation::Network,
                            >>()?;
                        }
                        __FieldTag::__disk => {
                            if !fields.insert(__FieldTag::__disk) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk",
                                ));
                            }
                            result.disk = map.next_value::<std::option::Option<
                                crate::model::daily_resource_usage_aggregation::Disk,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DailyResourceUsageAggregation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.date.is_some() {
            state.serialize_entry("date", &self.date)?;
        }
        if self.cpu.is_some() {
            state.serialize_entry("cpu", &self.cpu)?;
        }
        if self.memory.is_some() {
            state.serialize_entry("memory", &self.memory)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.disk.is_some() {
            state.serialize_entry("disk", &self.disk)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DailyResourceUsageAggregation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DailyResourceUsageAggregation");
        debug_struct.field("date", &self.date);
        debug_struct.field("cpu", &self.cpu);
        debug_struct.field("memory", &self.memory);
        debug_struct.field("network", &self.network);
        debug_struct.field("disk", &self.disk);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DailyResourceUsageAggregation].
pub mod daily_resource_usage_aggregation {
    #[allow(unused_imports)]
    use super::*;

    /// Statistical aggregation of samples for a single resource usage.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Stats {
        /// Average usage value.
        pub average: f32,

        /// Median usage value.
        pub median: f32,

        /// 95th percentile usage value.
        pub nintey_fifth_percentile: f32,

        /// Peak usage value.
        pub peak: f32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Stats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [average][crate::model::daily_resource_usage_aggregation::Stats::average].
        pub fn set_average<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.average = v.into();
            self
        }

        /// Sets the value of [median][crate::model::daily_resource_usage_aggregation::Stats::median].
        pub fn set_median<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.median = v.into();
            self
        }

        /// Sets the value of [nintey_fifth_percentile][crate::model::daily_resource_usage_aggregation::Stats::nintey_fifth_percentile].
        pub fn set_nintey_fifth_percentile<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.nintey_fifth_percentile = v.into();
            self
        }

        /// Sets the value of [peak][crate::model::daily_resource_usage_aggregation::Stats::peak].
        pub fn set_peak<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.peak = v.into();
            self
        }
    }

    impl wkt::message::Message for Stats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.DailyResourceUsageAggregation.Stats"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Stats {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __average,
                __median,
                __nintey_fifth_percentile,
                __peak,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Stats")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "average" => Ok(__FieldTag::__average),
                                "median" => Ok(__FieldTag::__median),
                                "ninteyFifthPercentile" => {
                                    Ok(__FieldTag::__nintey_fifth_percentile)
                                }
                                "nintey_fifth_percentile" => {
                                    Ok(__FieldTag::__nintey_fifth_percentile)
                                }
                                "peak" => Ok(__FieldTag::__peak),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Stats;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Stats")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__average => {
                                if !fields.insert(__FieldTag::__average) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for average",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.average = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__median => {
                                if !fields.insert(__FieldTag::__median) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for median",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.median = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__nintey_fifth_percentile => {
                                if !fields.insert(__FieldTag::__nintey_fifth_percentile) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for nintey_fifth_percentile",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.nintey_fifth_percentile =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__peak => {
                                if !fields.insert(__FieldTag::__peak) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for peak",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.peak = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Stats {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.average) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("average", &__With(&self.average))?;
            }
            if !wkt::internal::is_default(&self.median) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("median", &__With(&self.median))?;
            }
            if !wkt::internal::is_default(&self.nintey_fifth_percentile) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "ninteyFifthPercentile",
                    &__With(&self.nintey_fifth_percentile),
                )?;
            }
            if !wkt::internal::is_default(&self.peak) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("peak", &__With(&self.peak))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Stats {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Stats");
            debug_struct.field("average", &self.average);
            debug_struct.field("median", &self.median);
            debug_struct.field("nintey_fifth_percentile", &self.nintey_fifth_percentile);
            debug_struct.field("peak", &self.peak);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Statistical aggregation of CPU usage.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Cpu {
        /// CPU utilization percentage.
        pub utilization_percentage:
            std::option::Option<crate::model::daily_resource_usage_aggregation::Stats>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Cpu {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [utilization_percentage][crate::model::daily_resource_usage_aggregation::Cpu::utilization_percentage].
        pub fn set_utilization_percentage<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::daily_resource_usage_aggregation::Stats>,
        {
            self.utilization_percentage = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [utilization_percentage][crate::model::daily_resource_usage_aggregation::Cpu::utilization_percentage].
        pub fn set_or_clear_utilization_percentage<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::daily_resource_usage_aggregation::Stats>,
        {
            self.utilization_percentage = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Cpu {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.DailyResourceUsageAggregation.CPU"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Cpu {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __utilization_percentage,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Cpu")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "utilizationPercentage" => Ok(__FieldTag::__utilization_percentage),
                                "utilization_percentage" => {
                                    Ok(__FieldTag::__utilization_percentage)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Cpu;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Cpu")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__utilization_percentage => {
                                if !fields.insert(__FieldTag::__utilization_percentage) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for utilization_percentage",
                                    ));
                                }
                                result.utilization_percentage = map
                                    .next_value::<std::option::Option<
                                        crate::model::daily_resource_usage_aggregation::Stats,
                                    >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Cpu {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.utilization_percentage.is_some() {
                state.serialize_entry("utilizationPercentage", &self.utilization_percentage)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Cpu {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Cpu");
            debug_struct.field("utilization_percentage", &self.utilization_percentage);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Statistical aggregation of memory usage.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Memory {
        /// Memory utilization percentage.
        pub utilization_percentage:
            std::option::Option<crate::model::daily_resource_usage_aggregation::Stats>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Memory {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [utilization_percentage][crate::model::daily_resource_usage_aggregation::Memory::utilization_percentage].
        pub fn set_utilization_percentage<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::daily_resource_usage_aggregation::Stats>,
        {
            self.utilization_percentage = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [utilization_percentage][crate::model::daily_resource_usage_aggregation::Memory::utilization_percentage].
        pub fn set_or_clear_utilization_percentage<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::daily_resource_usage_aggregation::Stats>,
        {
            self.utilization_percentage = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Memory {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.DailyResourceUsageAggregation.Memory"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Memory {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __utilization_percentage,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Memory")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "utilizationPercentage" => Ok(__FieldTag::__utilization_percentage),
                                "utilization_percentage" => {
                                    Ok(__FieldTag::__utilization_percentage)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Memory;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Memory")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__utilization_percentage => {
                                if !fields.insert(__FieldTag::__utilization_percentage) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for utilization_percentage",
                                    ));
                                }
                                result.utilization_percentage = map
                                    .next_value::<std::option::Option<
                                        crate::model::daily_resource_usage_aggregation::Stats,
                                    >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Memory {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.utilization_percentage.is_some() {
                state.serialize_entry("utilizationPercentage", &self.utilization_percentage)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Memory {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Memory");
            debug_struct.field("utilization_percentage", &self.utilization_percentage);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Statistical aggregation of network usage.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Network {
        /// Network ingress in B/s.
        pub ingress_bps: std::option::Option<crate::model::daily_resource_usage_aggregation::Stats>,

        /// Network egress in B/s.
        pub egress_bps: std::option::Option<crate::model::daily_resource_usage_aggregation::Stats>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Network {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ingress_bps][crate::model::daily_resource_usage_aggregation::Network::ingress_bps].
        pub fn set_ingress_bps<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::daily_resource_usage_aggregation::Stats>,
        {
            self.ingress_bps = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [ingress_bps][crate::model::daily_resource_usage_aggregation::Network::ingress_bps].
        pub fn set_or_clear_ingress_bps<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::daily_resource_usage_aggregation::Stats>,
        {
            self.ingress_bps = v.map(|x| x.into());
            self
        }

        /// Sets the value of [egress_bps][crate::model::daily_resource_usage_aggregation::Network::egress_bps].
        pub fn set_egress_bps<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::daily_resource_usage_aggregation::Stats>,
        {
            self.egress_bps = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [egress_bps][crate::model::daily_resource_usage_aggregation::Network::egress_bps].
        pub fn set_or_clear_egress_bps<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::daily_resource_usage_aggregation::Stats>,
        {
            self.egress_bps = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Network {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.DailyResourceUsageAggregation.Network"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Network {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __ingress_bps,
                __egress_bps,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Network")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "ingressBps" => Ok(__FieldTag::__ingress_bps),
                                "ingress_bps" => Ok(__FieldTag::__ingress_bps),
                                "egressBps" => Ok(__FieldTag::__egress_bps),
                                "egress_bps" => Ok(__FieldTag::__egress_bps),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Network;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Network")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__ingress_bps => {
                                if !fields.insert(__FieldTag::__ingress_bps) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ingress_bps",
                                    ));
                                }
                                result.ingress_bps = map.next_value::<std::option::Option<
                                    crate::model::daily_resource_usage_aggregation::Stats,
                                >>()?;
                            }
                            __FieldTag::__egress_bps => {
                                if !fields.insert(__FieldTag::__egress_bps) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for egress_bps",
                                    ));
                                }
                                result.egress_bps = map.next_value::<std::option::Option<
                                    crate::model::daily_resource_usage_aggregation::Stats,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Network {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.ingress_bps.is_some() {
                state.serialize_entry("ingressBps", &self.ingress_bps)?;
            }
            if self.egress_bps.is_some() {
                state.serialize_entry("egressBps", &self.egress_bps)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Network {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Network");
            debug_struct.field("ingress_bps", &self.ingress_bps);
            debug_struct.field("egress_bps", &self.egress_bps);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Statistical aggregation of disk usage.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Disk {
        /// Disk I/O operations per second.
        pub iops: std::option::Option<crate::model::daily_resource_usage_aggregation::Stats>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Disk {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [iops][crate::model::daily_resource_usage_aggregation::Disk::iops].
        pub fn set_iops<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::daily_resource_usage_aggregation::Stats>,
        {
            self.iops = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [iops][crate::model::daily_resource_usage_aggregation::Disk::iops].
        pub fn set_or_clear_iops<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::daily_resource_usage_aggregation::Stats>,
        {
            self.iops = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Disk {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.DailyResourceUsageAggregation.Disk"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Disk {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __iops,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Disk")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "iops" => Ok(__FieldTag::__iops),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Disk;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Disk")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__iops => {
                                if !fields.insert(__FieldTag::__iops) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for iops",
                                    ));
                                }
                                result.iops = map.next_value::<std::option::Option<
                                    crate::model::daily_resource_usage_aggregation::Stats,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Disk {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.iops.is_some() {
                state.serialize_entry("iops", &self.iops)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Disk {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Disk");
            debug_struct.field("iops", &self.iops);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Message containing insights list.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InsightList {
    /// Output only. Insights of the list.
    pub insights: std::vec::Vec<crate::model::Insight>,

    /// Output only. Update timestamp.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InsightList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [insights][crate::model::InsightList::insights].
    pub fn set_insights<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Insight>,
    {
        use std::iter::Iterator;
        self.insights = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [update_time][crate::model::InsightList::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::InsightList::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InsightList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.InsightList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InsightList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __insights,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InsightList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "insights" => Ok(__FieldTag::__insights),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InsightList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InsightList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__insights => {
                            if !fields.insert(__FieldTag::__insights) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insights",
                                ));
                            }
                            result.insights = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Insight>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InsightList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.insights.is_empty() {
            state.serialize_entry("insights", &self.insights)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for InsightList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InsightList");
        debug_struct.field("insights", &self.insights);
        debug_struct.field("update_time", &self.update_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An insight about an asset.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Insight {
    pub insight: std::option::Option<crate::model::insight::Insight>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Insight {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [insight][crate::model::Insight::insight].
    ///
    /// Note that all the setters affecting `insight` are mutually
    /// exclusive.
    pub fn set_insight<
        T: std::convert::Into<std::option::Option<crate::model::insight::Insight>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.insight = v.into();
        self
    }

    /// The value of [insight][crate::model::Insight::insight]
    /// if it holds a `MigrationInsight`, `None` if the field is not set or
    /// holds a different branch.
    pub fn migration_insight(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MigrationInsight>> {
        #[allow(unreachable_patterns)]
        self.insight.as_ref().and_then(|v| match v {
            crate::model::insight::Insight::MigrationInsight(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [insight][crate::model::Insight::insight]
    /// to hold a `MigrationInsight`.
    ///
    /// Note that all the setters affecting `insight` are
    /// mutually exclusive.
    pub fn set_migration_insight<
        T: std::convert::Into<std::boxed::Box<crate::model::MigrationInsight>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.insight =
            std::option::Option::Some(crate::model::insight::Insight::MigrationInsight(v.into()));
        self
    }

    /// The value of [insight][crate::model::Insight::insight]
    /// if it holds a `GenericInsight`, `None` if the field is not set or
    /// holds a different branch.
    pub fn generic_insight(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GenericInsight>> {
        #[allow(unreachable_patterns)]
        self.insight.as_ref().and_then(|v| match v {
            crate::model::insight::Insight::GenericInsight(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [insight][crate::model::Insight::insight]
    /// to hold a `GenericInsight`.
    ///
    /// Note that all the setters affecting `insight` are
    /// mutually exclusive.
    pub fn set_generic_insight<
        T: std::convert::Into<std::boxed::Box<crate::model::GenericInsight>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.insight =
            std::option::Option::Some(crate::model::insight::Insight::GenericInsight(v.into()));
        self
    }
}

impl wkt::message::Message for Insight {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.Insight"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Insight {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __migration_insight,
            __generic_insight,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Insight")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "migrationInsight" => Ok(__FieldTag::__migration_insight),
                            "migration_insight" => Ok(__FieldTag::__migration_insight),
                            "genericInsight" => Ok(__FieldTag::__generic_insight),
                            "generic_insight" => Ok(__FieldTag::__generic_insight),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Insight;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Insight")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__migration_insight => {
                            if !fields.insert(__FieldTag::__migration_insight) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_insight",
                                ));
                            }
                            if result.insight.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `insight`, a oneof with full ID .google.cloud.migrationcenter.v1.Insight.migration_insight, latest field was migrationInsight",
                                ));
                            }
                            result.insight = std::option::Option::Some(
                                crate::model::insight::Insight::MigrationInsight(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MigrationInsight>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__generic_insight => {
                            if !fields.insert(__FieldTag::__generic_insight) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generic_insight",
                                ));
                            }
                            if result.insight.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `insight`, a oneof with full ID .google.cloud.migrationcenter.v1.Insight.generic_insight, latest field was genericInsight",
                                ));
                            }
                            result.insight = std::option::Option::Some(
                                crate::model::insight::Insight::GenericInsight(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GenericInsight>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Insight {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.migration_insight() {
            state.serialize_entry("migrationInsight", value)?;
        }
        if let Some(value) = self.generic_insight() {
            state.serialize_entry("genericInsight", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Insight {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Insight");
        debug_struct.field("insight", &self.insight);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Insight].
pub mod insight {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Insight {
        /// Output only. An insight about potential migrations for an asset.
        MigrationInsight(std::boxed::Box<crate::model::MigrationInsight>),
        /// Output only. A generic insight about an asset
        GenericInsight(std::boxed::Box<crate::model::GenericInsight>),
    }
}

/// A generic insight about an asset.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenericInsight {
    /// Output only. Represents a globally unique message id for
    /// this insight, can be used for localization purposes, in case message_code
    /// is not yet known by the client use default_message instead.
    pub message_id: i64,

    /// Output only. In case message_code is not yet known by the client
    /// default_message will be the message to be used instead.
    pub default_message: std::string::String,

    /// Output only. Additional information about the insight, each entry can be a
    /// logical entry and must make sense if it is displayed with line breaks
    /// between each entry. Text can contain md style links.
    pub additional_information: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenericInsight {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message_id][crate::model::GenericInsight::message_id].
    pub fn set_message_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.message_id = v.into();
        self
    }

    /// Sets the value of [default_message][crate::model::GenericInsight::default_message].
    pub fn set_default_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_message = v.into();
        self
    }

    /// Sets the value of [additional_information][crate::model::GenericInsight::additional_information].
    pub fn set_additional_information<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.additional_information = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GenericInsight {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GenericInsight"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenericInsight {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message_id,
            __default_message,
            __additional_information,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenericInsight")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "messageId" => Ok(__FieldTag::__message_id),
                            "message_id" => Ok(__FieldTag::__message_id),
                            "defaultMessage" => Ok(__FieldTag::__default_message),
                            "default_message" => Ok(__FieldTag::__default_message),
                            "additionalInformation" => Ok(__FieldTag::__additional_information),
                            "additional_information" => Ok(__FieldTag::__additional_information),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenericInsight;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenericInsight")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message_id => {
                            if !fields.insert(__FieldTag::__message_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.message_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__default_message => {
                            if !fields.insert(__FieldTag::__default_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_message",
                                ));
                            }
                            result.default_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_information => {
                            if !fields.insert(__FieldTag::__additional_information) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_information",
                                ));
                            }
                            result.additional_information = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenericInsight {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.message_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("messageId", &__With(&self.message_id))?;
        }
        if !self.default_message.is_empty() {
            state.serialize_entry("defaultMessage", &self.default_message)?;
        }
        if !self.additional_information.is_empty() {
            state.serialize_entry("additionalInformation", &self.additional_information)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GenericInsight {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenericInsight");
        debug_struct.field("message_id", &self.message_id);
        debug_struct.field("default_message", &self.default_message);
        debug_struct.field("additional_information", &self.additional_information);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An insight about potential migrations for an asset.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MigrationInsight {
    /// Output only. Description of how well the asset this insight is associated
    /// with fits the proposed migration.
    pub fit: std::option::Option<crate::model::FitDescriptor>,

    /// A target for the migration.
    pub migration_target: std::option::Option<crate::model::migration_insight::MigrationTarget>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationInsight {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fit][crate::model::MigrationInsight::fit].
    pub fn set_fit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FitDescriptor>,
    {
        self.fit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fit][crate::model::MigrationInsight::fit].
    pub fn set_or_clear_fit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FitDescriptor>,
    {
        self.fit = v.map(|x| x.into());
        self
    }

    /// Sets the value of [migration_target][crate::model::MigrationInsight::migration_target].
    ///
    /// Note that all the setters affecting `migration_target` are mutually
    /// exclusive.
    pub fn set_migration_target<
        T: std::convert::Into<std::option::Option<crate::model::migration_insight::MigrationTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.migration_target = v.into();
        self
    }

    /// The value of [migration_target][crate::model::MigrationInsight::migration_target]
    /// if it holds a `ComputeEngineTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_engine_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeEngineMigrationTarget>> {
        #[allow(unreachable_patterns)]
        self.migration_target.as_ref().and_then(|v| match v {
            crate::model::migration_insight::MigrationTarget::ComputeEngineTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [migration_target][crate::model::MigrationInsight::migration_target]
    /// to hold a `ComputeEngineTarget`.
    ///
    /// Note that all the setters affecting `migration_target` are
    /// mutually exclusive.
    pub fn set_compute_engine_target<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeEngineMigrationTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.migration_target = std::option::Option::Some(
            crate::model::migration_insight::MigrationTarget::ComputeEngineTarget(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MigrationInsight {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.MigrationInsight"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MigrationInsight {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fit,
            __compute_engine_target,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MigrationInsight")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fit" => Ok(__FieldTag::__fit),
                            "computeEngineTarget" => Ok(__FieldTag::__compute_engine_target),
                            "compute_engine_target" => Ok(__FieldTag::__compute_engine_target),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MigrationInsight;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MigrationInsight")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fit => {
                            if !fields.insert(__FieldTag::__fit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fit",
                                ));
                            }
                            result.fit = map
                                .next_value::<std::option::Option<crate::model::FitDescriptor>>()?;
                        }
                        __FieldTag::__compute_engine_target => {
                            if !fields.insert(__FieldTag::__compute_engine_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_engine_target",
                                ));
                            }
                            if result.migration_target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `migration_target`, a oneof with full ID .google.cloud.migrationcenter.v1.MigrationInsight.compute_engine_target, latest field was computeEngineTarget",
                                ));
                            }
                            result.migration_target = std::option::Option::Some(
                                crate::model::migration_insight::MigrationTarget::ComputeEngineTarget(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ComputeEngineMigrationTarget>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MigrationInsight {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.fit.is_some() {
            state.serialize_entry("fit", &self.fit)?;
        }
        if let Some(value) = self.compute_engine_target() {
            state.serialize_entry("computeEngineTarget", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MigrationInsight {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MigrationInsight");
        debug_struct.field("fit", &self.fit);
        debug_struct.field("migration_target", &self.migration_target);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MigrationInsight].
pub mod migration_insight {
    #[allow(unused_imports)]
    use super::*;

    /// A target for the migration.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MigrationTarget {
        /// Output only. A Google Compute Engine target.
        ComputeEngineTarget(std::boxed::Box<crate::model::ComputeEngineMigrationTarget>),
    }
}

/// Compute engine migration target.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeEngineMigrationTarget {
    /// Description of the suggested shape for the migration target.
    pub shape: std::option::Option<crate::model::ComputeEngineShapeDescriptor>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeEngineMigrationTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [shape][crate::model::ComputeEngineMigrationTarget::shape].
    pub fn set_shape<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ComputeEngineShapeDescriptor>,
    {
        self.shape = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shape][crate::model::ComputeEngineMigrationTarget::shape].
    pub fn set_or_clear_shape<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ComputeEngineShapeDescriptor>,
    {
        self.shape = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ComputeEngineMigrationTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ComputeEngineMigrationTarget"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeEngineMigrationTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __shape,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeEngineMigrationTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "shape" => Ok(__FieldTag::__shape),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeEngineMigrationTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeEngineMigrationTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__shape => {
                            if !fields.insert(__FieldTag::__shape) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shape",
                                ));
                            }
                            result.shape = map.next_value::<std::option::Option<crate::model::ComputeEngineShapeDescriptor>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeEngineMigrationTarget {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.shape.is_some() {
            state.serialize_entry("shape", &self.shape)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ComputeEngineMigrationTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComputeEngineMigrationTarget");
        debug_struct.field("shape", &self.shape);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Compute Engine target shape descriptor.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeEngineShapeDescriptor {
    /// Memory in mebibytes.
    pub memory_mb: i32,

    /// Number of physical cores.
    pub physical_core_count: i32,

    /// Number of logical cores.
    pub logical_core_count: i32,

    /// Compute Engine machine series.
    pub series: std::string::String,

    /// Compute Engine machine type.
    pub machine_type: std::string::String,

    /// Compute Engine storage. Never empty.
    pub storage: std::vec::Vec<crate::model::ComputeStorageDescriptor>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeEngineShapeDescriptor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [memory_mb][crate::model::ComputeEngineShapeDescriptor::memory_mb].
    pub fn set_memory_mb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_mb = v.into();
        self
    }

    /// Sets the value of [physical_core_count][crate::model::ComputeEngineShapeDescriptor::physical_core_count].
    pub fn set_physical_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.physical_core_count = v.into();
        self
    }

    /// Sets the value of [logical_core_count][crate::model::ComputeEngineShapeDescriptor::logical_core_count].
    pub fn set_logical_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.logical_core_count = v.into();
        self
    }

    /// Sets the value of [series][crate::model::ComputeEngineShapeDescriptor::series].
    pub fn set_series<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.series = v.into();
        self
    }

    /// Sets the value of [machine_type][crate::model::ComputeEngineShapeDescriptor::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [storage][crate::model::ComputeEngineShapeDescriptor::storage].
    pub fn set_storage<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ComputeStorageDescriptor>,
    {
        use std::iter::Iterator;
        self.storage = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ComputeEngineShapeDescriptor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ComputeEngineShapeDescriptor"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeEngineShapeDescriptor {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __memory_mb,
            __physical_core_count,
            __logical_core_count,
            __series,
            __machine_type,
            __storage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeEngineShapeDescriptor")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "memoryMb" => Ok(__FieldTag::__memory_mb),
                            "memory_mb" => Ok(__FieldTag::__memory_mb),
                            "physicalCoreCount" => Ok(__FieldTag::__physical_core_count),
                            "physical_core_count" => Ok(__FieldTag::__physical_core_count),
                            "logicalCoreCount" => Ok(__FieldTag::__logical_core_count),
                            "logical_core_count" => Ok(__FieldTag::__logical_core_count),
                            "series" => Ok(__FieldTag::__series),
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "storage" => Ok(__FieldTag::__storage),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeEngineShapeDescriptor;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeEngineShapeDescriptor")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__memory_mb => {
                            if !fields.insert(__FieldTag::__memory_mb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_mb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_mb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__physical_core_count => {
                            if !fields.insert(__FieldTag::__physical_core_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for physical_core_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.physical_core_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__logical_core_count => {
                            if !fields.insert(__FieldTag::__logical_core_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logical_core_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.logical_core_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__series => {
                            if !fields.insert(__FieldTag::__series) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for series",
                                ));
                            }
                            result.series = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage => {
                            if !fields.insert(__FieldTag::__storage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage",
                                ));
                            }
                            result.storage = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ComputeStorageDescriptor>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeEngineShapeDescriptor {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.memory_mb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("memoryMb", &__With(&self.memory_mb))?;
        }
        if !wkt::internal::is_default(&self.physical_core_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("physicalCoreCount", &__With(&self.physical_core_count))?;
        }
        if !wkt::internal::is_default(&self.logical_core_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("logicalCoreCount", &__With(&self.logical_core_count))?;
        }
        if !self.series.is_empty() {
            state.serialize_entry("series", &self.series)?;
        }
        if !self.machine_type.is_empty() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !self.storage.is_empty() {
            state.serialize_entry("storage", &self.storage)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ComputeEngineShapeDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComputeEngineShapeDescriptor");
        debug_struct.field("memory_mb", &self.memory_mb);
        debug_struct.field("physical_core_count", &self.physical_core_count);
        debug_struct.field("logical_core_count", &self.logical_core_count);
        debug_struct.field("series", &self.series);
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("storage", &self.storage);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Compute Engine storage option descriptor.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeStorageDescriptor {
    /// Disk type backing the storage.
    pub r#type: crate::model::PersistentDiskType,

    /// Disk size in GiB.
    pub size_gb: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeStorageDescriptor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::ComputeStorageDescriptor::type].
    pub fn set_type<T: std::convert::Into<crate::model::PersistentDiskType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [size_gb][crate::model::ComputeStorageDescriptor::size_gb].
    pub fn set_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.size_gb = v.into();
        self
    }
}

impl wkt::message::Message for ComputeStorageDescriptor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ComputeStorageDescriptor"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeStorageDescriptor {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __size_gb,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeStorageDescriptor")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "sizeGb" => Ok(__FieldTag::__size_gb),
                            "size_gb" => Ok(__FieldTag::__size_gb),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeStorageDescriptor;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeStorageDescriptor")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::PersistentDiskType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__size_gb => {
                            if !fields.insert(__FieldTag::__size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeStorageDescriptor {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sizeGb", &__With(&self.size_gb))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ComputeStorageDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComputeStorageDescriptor");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("size_gb", &self.size_gb);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Describes the fit level of an asset for migration to a specific target.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FitDescriptor {
    /// Fit level.
    pub fit_level: crate::model::fit_descriptor::FitLevel,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FitDescriptor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fit_level][crate::model::FitDescriptor::fit_level].
    pub fn set_fit_level<T: std::convert::Into<crate::model::fit_descriptor::FitLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.fit_level = v.into();
        self
    }
}

impl wkt::message::Message for FitDescriptor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.FitDescriptor"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FitDescriptor {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fit_level,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FitDescriptor")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fitLevel" => Ok(__FieldTag::__fit_level),
                            "fit_level" => Ok(__FieldTag::__fit_level),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FitDescriptor;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FitDescriptor")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fit_level => {
                            if !fields.insert(__FieldTag::__fit_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fit_level",
                                ));
                            }
                            result.fit_level = map.next_value::<std::option::Option<crate::model::fit_descriptor::FitLevel>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FitDescriptor {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.fit_level) {
            state.serialize_entry("fitLevel", &self.fit_level)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FitDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FitDescriptor");
        debug_struct.field("fit_level", &self.fit_level);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [FitDescriptor].
pub mod fit_descriptor {
    #[allow(unused_imports)]
    use super::*;

    /// Fit level.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FitLevel {
        /// Not enough information.
        Unspecified,
        /// Fit.
        Fit,
        /// No Fit.
        NoFit,
        /// Fit with effort.
        RequiresEffort,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FitLevel::value] or
        /// [FitLevel::name].
        UnknownValue(fit_level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod fit_level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FitLevel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Fit => std::option::Option::Some(1),
                Self::NoFit => std::option::Option::Some(2),
                Self::RequiresEffort => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FIT_LEVEL_UNSPECIFIED"),
                Self::Fit => std::option::Option::Some("FIT"),
                Self::NoFit => std::option::Option::Some("NO_FIT"),
                Self::RequiresEffort => std::option::Option::Some("REQUIRES_EFFORT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FitLevel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FitLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FitLevel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Fit,
                2 => Self::NoFit,
                3 => Self::RequiresEffort,
                _ => Self::UnknownValue(fit_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FitLevel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FIT_LEVEL_UNSPECIFIED" => Self::Unspecified,
                "FIT" => Self::Fit,
                "NO_FIT" => Self::NoFit,
                "REQUIRES_EFFORT" => Self::RequiresEffort,
                _ => Self::UnknownValue(fit_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FitLevel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Fit => serializer.serialize_i32(1),
                Self::NoFit => serializer.serialize_i32(2),
                Self::RequiresEffort => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FitLevel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FitLevel>::new(
                ".google.cloud.migrationcenter.v1.FitDescriptor.FitLevel",
            ))
        }
    }
}

/// Message describing an aggregation. The message includes the aggregation type,
/// parameters, and the field on which to perform the aggregation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Aggregation {
    /// The name of the field on which to aggregate.
    pub field: std::string::String,

    pub aggregation_function: std::option::Option<crate::model::aggregation::AggregationFunction>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Aggregation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::Aggregation::field].
    pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field = v.into();
        self
    }

    /// Sets the value of [aggregation_function][crate::model::Aggregation::aggregation_function].
    ///
    /// Note that all the setters affecting `aggregation_function` are mutually
    /// exclusive.
    pub fn set_aggregation_function<
        T: std::convert::Into<std::option::Option<crate::model::aggregation::AggregationFunction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aggregation_function = v.into();
        self
    }

    /// The value of [aggregation_function][crate::model::Aggregation::aggregation_function]
    /// if it holds a `Count`, `None` if the field is not set or
    /// holds a different branch.
    pub fn count(&self) -> std::option::Option<&std::boxed::Box<crate::model::aggregation::Count>> {
        #[allow(unreachable_patterns)]
        self.aggregation_function.as_ref().and_then(|v| match v {
            crate::model::aggregation::AggregationFunction::Count(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [aggregation_function][crate::model::Aggregation::aggregation_function]
    /// to hold a `Count`.
    ///
    /// Note that all the setters affecting `aggregation_function` are
    /// mutually exclusive.
    pub fn set_count<T: std::convert::Into<std::boxed::Box<crate::model::aggregation::Count>>>(
        mut self,
        v: T,
    ) -> Self {
        self.aggregation_function = std::option::Option::Some(
            crate::model::aggregation::AggregationFunction::Count(v.into()),
        );
        self
    }

    /// The value of [aggregation_function][crate::model::Aggregation::aggregation_function]
    /// if it holds a `Sum`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sum(&self) -> std::option::Option<&std::boxed::Box<crate::model::aggregation::Sum>> {
        #[allow(unreachable_patterns)]
        self.aggregation_function.as_ref().and_then(|v| match v {
            crate::model::aggregation::AggregationFunction::Sum(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [aggregation_function][crate::model::Aggregation::aggregation_function]
    /// to hold a `Sum`.
    ///
    /// Note that all the setters affecting `aggregation_function` are
    /// mutually exclusive.
    pub fn set_sum<T: std::convert::Into<std::boxed::Box<crate::model::aggregation::Sum>>>(
        mut self,
        v: T,
    ) -> Self {
        self.aggregation_function = std::option::Option::Some(
            crate::model::aggregation::AggregationFunction::Sum(v.into()),
        );
        self
    }

    /// The value of [aggregation_function][crate::model::Aggregation::aggregation_function]
    /// if it holds a `Histogram`, `None` if the field is not set or
    /// holds a different branch.
    pub fn histogram(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::aggregation::Histogram>> {
        #[allow(unreachable_patterns)]
        self.aggregation_function.as_ref().and_then(|v| match v {
            crate::model::aggregation::AggregationFunction::Histogram(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [aggregation_function][crate::model::Aggregation::aggregation_function]
    /// to hold a `Histogram`.
    ///
    /// Note that all the setters affecting `aggregation_function` are
    /// mutually exclusive.
    pub fn set_histogram<
        T: std::convert::Into<std::boxed::Box<crate::model::aggregation::Histogram>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aggregation_function = std::option::Option::Some(
            crate::model::aggregation::AggregationFunction::Histogram(v.into()),
        );
        self
    }

    /// The value of [aggregation_function][crate::model::Aggregation::aggregation_function]
    /// if it holds a `Frequency`, `None` if the field is not set or
    /// holds a different branch.
    pub fn frequency(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::aggregation::Frequency>> {
        #[allow(unreachable_patterns)]
        self.aggregation_function.as_ref().and_then(|v| match v {
            crate::model::aggregation::AggregationFunction::Frequency(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [aggregation_function][crate::model::Aggregation::aggregation_function]
    /// to hold a `Frequency`.
    ///
    /// Note that all the setters affecting `aggregation_function` are
    /// mutually exclusive.
    pub fn set_frequency<
        T: std::convert::Into<std::boxed::Box<crate::model::aggregation::Frequency>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aggregation_function = std::option::Option::Some(
            crate::model::aggregation::AggregationFunction::Frequency(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Aggregation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.Aggregation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Aggregation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field,
            __count,
            __sum,
            __histogram,
            __frequency,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Aggregation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "field" => Ok(__FieldTag::__field),
                            "count" => Ok(__FieldTag::__count),
                            "sum" => Ok(__FieldTag::__sum),
                            "histogram" => Ok(__FieldTag::__histogram),
                            "frequency" => Ok(__FieldTag::__frequency),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Aggregation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Aggregation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__count => {
                            if !fields.insert(__FieldTag::__count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for count",
                                ));
                            }
                            if result.aggregation_function.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `aggregation_function`, a oneof with full ID .google.cloud.migrationcenter.v1.Aggregation.count, latest field was count",
                                ));
                            }
                            result.aggregation_function = std::option::Option::Some(
                                crate::model::aggregation::AggregationFunction::Count(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::aggregation::Count>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__sum => {
                            if !fields.insert(__FieldTag::__sum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sum",
                                ));
                            }
                            if result.aggregation_function.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `aggregation_function`, a oneof with full ID .google.cloud.migrationcenter.v1.Aggregation.sum, latest field was sum",
                                ));
                            }
                            result.aggregation_function = std::option::Option::Some(
                                crate::model::aggregation::AggregationFunction::Sum(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::aggregation::Sum>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__histogram => {
                            if !fields.insert(__FieldTag::__histogram) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for histogram",
                                ));
                            }
                            if result.aggregation_function.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `aggregation_function`, a oneof with full ID .google.cloud.migrationcenter.v1.Aggregation.histogram, latest field was histogram",
                                ));
                            }
                            result.aggregation_function = std::option::Option::Some(
                                crate::model::aggregation::AggregationFunction::Histogram(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::aggregation::Histogram>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__frequency => {
                            if !fields.insert(__FieldTag::__frequency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frequency",
                                ));
                            }
                            if result.aggregation_function.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `aggregation_function`, a oneof with full ID .google.cloud.migrationcenter.v1.Aggregation.frequency, latest field was frequency",
                                ));
                            }
                            result.aggregation_function = std::option::Option::Some(
                                crate::model::aggregation::AggregationFunction::Frequency(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::aggregation::Frequency>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Aggregation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.field.is_empty() {
            state.serialize_entry("field", &self.field)?;
        }
        if let Some(value) = self.count() {
            state.serialize_entry("count", value)?;
        }
        if let Some(value) = self.sum() {
            state.serialize_entry("sum", value)?;
        }
        if let Some(value) = self.histogram() {
            state.serialize_entry("histogram", value)?;
        }
        if let Some(value) = self.frequency() {
            state.serialize_entry("frequency", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Aggregation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Aggregation");
        debug_struct.field("field", &self.field);
        debug_struct.field("aggregation_function", &self.aggregation_function);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Aggregation].
pub mod aggregation {
    #[allow(unused_imports)]
    use super::*;

    /// Object count.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Count {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Count {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Count {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.Aggregation.Count"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Count {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Count")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Count;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Count")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Count {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Count {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Count");

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Sum of field values.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Sum {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Sum {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Sum {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.Aggregation.Sum"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Sum {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Sum")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Sum;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Sum")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Sum {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Sum {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Sum");

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Histogram of bucketed assets counts by field value.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Histogram {
        /// Lower bounds of buckets.
        /// The response will contain `n+1` buckets for `n` bounds.
        /// The first bucket will count all assets for which the field value is
        /// smaller than the first bound.
        /// Subsequent buckets will count assets for which the field value is
        /// greater or equal to a lower bound and smaller than the next one.
        /// The last bucket will count assets for which the field value is greater or
        /// equal to the final lower bound.
        /// You can define up to 20 lower bounds.
        pub lower_bounds: std::vec::Vec<f64>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Histogram {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [lower_bounds][crate::model::aggregation::Histogram::lower_bounds].
        pub fn set_lower_bounds<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<f64>,
        {
            use std::iter::Iterator;
            self.lower_bounds = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Histogram {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.Aggregation.Histogram"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Histogram {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __lower_bounds,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Histogram")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "lowerBounds" => Ok(__FieldTag::__lower_bounds),
                                "lower_bounds" => Ok(__FieldTag::__lower_bounds),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Histogram;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Histogram")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__lower_bounds => {
                                if !fields.insert(__FieldTag::__lower_bounds) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for lower_bounds",
                                    ));
                                }
                                struct __With(std::option::Option<std::vec::Vec<f64>>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<std::vec::Vec<wkt::internal::F64>>,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.lower_bounds =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Histogram {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.lower_bounds.is_empty() {
                struct __With<'a>(&'a std::vec::Vec<f64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::vec::Vec<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("lowerBounds", &__With(&self.lower_bounds))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Histogram {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Histogram");
            debug_struct.field("lower_bounds", &self.lower_bounds);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Frequency distribution of all field values.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Frequency {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Frequency {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Frequency {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.Aggregation.Frequency"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Frequency {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Frequency")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Frequency;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Frequency")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Frequency {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Frequency {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Frequency");

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AggregationFunction {
        /// Count the number of matching objects.
        Count(std::boxed::Box<crate::model::aggregation::Count>),
        /// Sum over a numeric field.
        Sum(std::boxed::Box<crate::model::aggregation::Sum>),
        /// Creates a bucketed histogram of field values.
        Histogram(std::boxed::Box<crate::model::aggregation::Histogram>),
        /// Creates a frequency distribution of all field values.
        Frequency(std::boxed::Box<crate::model::aggregation::Frequency>),
    }
}

/// Message describing a result of an aggregation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AggregationResult {
    pub field: std::string::String,

    pub result: std::option::Option<crate::model::aggregation_result::Result>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AggregationResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::AggregationResult::field].
    pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field = v.into();
        self
    }

    /// Sets the value of [result][crate::model::AggregationResult::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::aggregation_result::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::AggregationResult::result]
    /// if it holds a `Count`, `None` if the field is not set or
    /// holds a different branch.
    pub fn count(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::aggregation_result::Count>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::aggregation_result::Result::Count(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::AggregationResult::result]
    /// to hold a `Count`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_count<
        T: std::convert::Into<std::boxed::Box<crate::model::aggregation_result::Count>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::aggregation_result::Result::Count(v.into()));
        self
    }

    /// The value of [result][crate::model::AggregationResult::result]
    /// if it holds a `Sum`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sum(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::aggregation_result::Sum>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::aggregation_result::Result::Sum(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::AggregationResult::result]
    /// to hold a `Sum`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_sum<
        T: std::convert::Into<std::boxed::Box<crate::model::aggregation_result::Sum>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::aggregation_result::Result::Sum(v.into()));
        self
    }

    /// The value of [result][crate::model::AggregationResult::result]
    /// if it holds a `Histogram`, `None` if the field is not set or
    /// holds a different branch.
    pub fn histogram(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::aggregation_result::Histogram>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::aggregation_result::Result::Histogram(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::AggregationResult::result]
    /// to hold a `Histogram`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_histogram<
        T: std::convert::Into<std::boxed::Box<crate::model::aggregation_result::Histogram>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::aggregation_result::Result::Histogram(v.into()),
        );
        self
    }

    /// The value of [result][crate::model::AggregationResult::result]
    /// if it holds a `Frequency`, `None` if the field is not set or
    /// holds a different branch.
    pub fn frequency(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::aggregation_result::Frequency>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::aggregation_result::Result::Frequency(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::AggregationResult::result]
    /// to hold a `Frequency`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_frequency<
        T: std::convert::Into<std::boxed::Box<crate::model::aggregation_result::Frequency>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::aggregation_result::Result::Frequency(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AggregationResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.AggregationResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AggregationResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field,
            __count,
            __sum,
            __histogram,
            __frequency,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AggregationResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "field" => Ok(__FieldTag::__field),
                            "count" => Ok(__FieldTag::__count),
                            "sum" => Ok(__FieldTag::__sum),
                            "histogram" => Ok(__FieldTag::__histogram),
                            "frequency" => Ok(__FieldTag::__frequency),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AggregationResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AggregationResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__count => {
                            if !fields.insert(__FieldTag::__count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for count",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.migrationcenter.v1.AggregationResult.count, latest field was count",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::aggregation_result::Result::Count(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::aggregation_result::Count>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__sum => {
                            if !fields.insert(__FieldTag::__sum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sum",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.migrationcenter.v1.AggregationResult.sum, latest field was sum",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::aggregation_result::Result::Sum(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::aggregation_result::Sum>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__histogram => {
                            if !fields.insert(__FieldTag::__histogram) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for histogram",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.migrationcenter.v1.AggregationResult.histogram, latest field was histogram",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::aggregation_result::Result::Histogram(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::aggregation_result::Histogram,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__frequency => {
                            if !fields.insert(__FieldTag::__frequency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frequency",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.migrationcenter.v1.AggregationResult.frequency, latest field was frequency",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::aggregation_result::Result::Frequency(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::aggregation_result::Frequency,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AggregationResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.field.is_empty() {
            state.serialize_entry("field", &self.field)?;
        }
        if let Some(value) = self.count() {
            state.serialize_entry("count", value)?;
        }
        if let Some(value) = self.sum() {
            state.serialize_entry("sum", value)?;
        }
        if let Some(value) = self.histogram() {
            state.serialize_entry("histogram", value)?;
        }
        if let Some(value) = self.frequency() {
            state.serialize_entry("frequency", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AggregationResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AggregationResult");
        debug_struct.field("field", &self.field);
        debug_struct.field("result", &self.result);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AggregationResult].
pub mod aggregation_result {
    #[allow(unused_imports)]
    use super::*;

    /// The result of a count aggregation.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Count {
        pub value: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Count {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::aggregation_result::Count::value].
        pub fn set_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for Count {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.AggregationResult.Count"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Count {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Count")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "value" => Ok(__FieldTag::__value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Count;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Count")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.value = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Count {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.value) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("value", &__With(&self.value))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Count {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Count");
            debug_struct.field("value", &self.value);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The result of a sum aggregation.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Sum {
        pub value: f64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Sum {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::aggregation_result::Sum::value].
        pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for Sum {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.AggregationResult.Sum"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Sum {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Sum")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "value" => Ok(__FieldTag::__value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Sum;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Sum")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.value = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Sum {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.value) {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("value", &__With(&self.value))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Sum {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Sum");
            debug_struct.field("value", &self.value);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The result of a bucketed histogram aggregation.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Histogram {
        /// Buckets in the histogram.
        /// There will be `n+1` buckets matching `n` lower bounds in the request.
        /// The first bucket will be from -infinity to the first bound.
        /// Subsequent buckets will be between one bound and the next.
        /// The final bucket will be from the final bound to infinity.
        pub buckets: std::vec::Vec<crate::model::aggregation_result::histogram::Bucket>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Histogram {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [buckets][crate::model::aggregation_result::Histogram::buckets].
        pub fn set_buckets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::aggregation_result::histogram::Bucket>,
        {
            use std::iter::Iterator;
            self.buckets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Histogram {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.AggregationResult.Histogram"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Histogram {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __buckets,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Histogram")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "buckets" => Ok(__FieldTag::__buckets),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Histogram;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Histogram")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__buckets => {
                                if !fields.insert(__FieldTag::__buckets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for buckets",
                                    ));
                                }
                                result.buckets = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::aggregation_result::histogram::Bucket,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Histogram {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.buckets.is_empty() {
                state.serialize_entry("buckets", &self.buckets)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Histogram {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Histogram");
            debug_struct.field("buckets", &self.buckets);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Histogram].
    pub mod histogram {
        #[allow(unused_imports)]
        use super::*;

        /// A histogram bucket with a lower and upper bound, and a count of items
        /// with a field value between those bounds.
        /// The lower bound is inclusive and the upper bound is exclusive.
        /// Lower bound may be -infinity and upper bound may be infinity.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Bucket {
            /// Lower bound - inclusive.
            pub lower_bound: f64,

            /// Upper bound - exclusive.
            pub upper_bound: f64,

            /// Count of items in the bucket.
            pub count: i64,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Bucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [lower_bound][crate::model::aggregation_result::histogram::Bucket::lower_bound].
            pub fn set_lower_bound<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.lower_bound = v.into();
                self
            }

            /// Sets the value of [upper_bound][crate::model::aggregation_result::histogram::Bucket::upper_bound].
            pub fn set_upper_bound<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.upper_bound = v.into();
                self
            }

            /// Sets the value of [count][crate::model::aggregation_result::histogram::Bucket::count].
            pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.count = v.into();
                self
            }
        }

        impl wkt::message::Message for Bucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.migrationcenter.v1.AggregationResult.Histogram.Bucket"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Bucket {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __lower_bound,
                    __upper_bound,
                    __count,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Bucket")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "lowerBound" => Ok(__FieldTag::__lower_bound),
                                    "lower_bound" => Ok(__FieldTag::__lower_bound),
                                    "upperBound" => Ok(__FieldTag::__upper_bound),
                                    "upper_bound" => Ok(__FieldTag::__upper_bound),
                                    "count" => Ok(__FieldTag::__count),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Bucket;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Bucket")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__lower_bound => {
                                    if !fields.insert(__FieldTag::__lower_bound) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for lower_bound",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.lower_bound =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__upper_bound => {
                                    if !fields.insert(__FieldTag::__upper_bound) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for upper_bound",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.upper_bound =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__count => {
                                    if !fields.insert(__FieldTag::__count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for count"),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.count =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Bucket {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.lower_bound) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("lowerBound", &__With(&self.lower_bound))?;
                }
                if !wkt::internal::is_default(&self.upper_bound) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("upperBound", &__With(&self.upper_bound))?;
                }
                if !wkt::internal::is_default(&self.count) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("count", &__With(&self.count))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Bucket {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Bucket");
                debug_struct.field("lower_bound", &self.lower_bound);
                debug_struct.field("upper_bound", &self.upper_bound);
                debug_struct.field("count", &self.count);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// The result of a frequency distribution aggregation.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Frequency {
        pub values: std::collections::HashMap<std::string::String, i64>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Frequency {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [values][crate::model::aggregation_result::Frequency::values].
        pub fn set_values<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<i64>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for Frequency {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.AggregationResult.Frequency"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Frequency {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __values,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Frequency")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "values" => Ok(__FieldTag::__values),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Frequency;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Frequency")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__values => {
                                if !fields.insert(__FieldTag::__values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for values",
                                    ));
                                }
                                struct __With(
                                    std::option::Option<
                                        std::collections::HashMap<std::string::String, i64>,
                                    >,
                                );
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<
                                                std::collections::HashMap<
                                                    serde_with::Same,
                                                    wkt::internal::I64,
                                                >,
                                            >,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.values = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Frequency {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.values.is_empty() {
                struct __With<'a>(&'a std::collections::HashMap<std::string::String, i64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<
                            std::collections::HashMap<serde_with::Same, wkt::internal::I64>,
                        >::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("values", &__With(&self.values))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Frequency {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Frequency");
            debug_struct.field("values", &self.values);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        Count(std::boxed::Box<crate::model::aggregation_result::Count>),
        Sum(std::boxed::Box<crate::model::aggregation_result::Sum>),
        Histogram(std::boxed::Box<crate::model::aggregation_result::Histogram>),
        Frequency(std::boxed::Box<crate::model::aggregation_result::Frequency>),
    }
}

/// A resource that aggregates the validation errors found in an import job file.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FileValidationReport {
    /// The name of the file.
    pub file_name: std::string::String,

    /// Partial list of rows that encountered validation error.
    pub row_errors: std::vec::Vec<crate::model::ImportRowError>,

    /// Flag indicating that processing was aborted due to maximum number of
    /// errors.
    pub partial_report: bool,

    /// List of file level errors.
    pub file_errors: std::vec::Vec<crate::model::ImportError>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileValidationReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_name][crate::model::FileValidationReport::file_name].
    pub fn set_file_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_name = v.into();
        self
    }

    /// Sets the value of [row_errors][crate::model::FileValidationReport::row_errors].
    pub fn set_row_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportRowError>,
    {
        use std::iter::Iterator;
        self.row_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [partial_report][crate::model::FileValidationReport::partial_report].
    pub fn set_partial_report<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.partial_report = v.into();
        self
    }

    /// Sets the value of [file_errors][crate::model::FileValidationReport::file_errors].
    pub fn set_file_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportError>,
    {
        use std::iter::Iterator;
        self.file_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FileValidationReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.FileValidationReport"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FileValidationReport {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_name,
            __row_errors,
            __partial_report,
            __file_errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileValidationReport")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fileName" => Ok(__FieldTag::__file_name),
                            "file_name" => Ok(__FieldTag::__file_name),
                            "rowErrors" => Ok(__FieldTag::__row_errors),
                            "row_errors" => Ok(__FieldTag::__row_errors),
                            "partialReport" => Ok(__FieldTag::__partial_report),
                            "partial_report" => Ok(__FieldTag::__partial_report),
                            "fileErrors" => Ok(__FieldTag::__file_errors),
                            "file_errors" => Ok(__FieldTag::__file_errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FileValidationReport;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileValidationReport")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_name => {
                            if !fields.insert(__FieldTag::__file_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_name",
                                ));
                            }
                            result.file_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__row_errors => {
                            if !fields.insert(__FieldTag::__row_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_errors",
                                ));
                            }
                            result.row_errors =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ImportRowError>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__partial_report => {
                            if !fields.insert(__FieldTag::__partial_report) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partial_report",
                                ));
                            }
                            result.partial_report = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_errors => {
                            if !fields.insert(__FieldTag::__file_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_errors",
                                ));
                            }
                            result.file_errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ImportError>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FileValidationReport {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.file_name.is_empty() {
            state.serialize_entry("fileName", &self.file_name)?;
        }
        if !self.row_errors.is_empty() {
            state.serialize_entry("rowErrors", &self.row_errors)?;
        }
        if !wkt::internal::is_default(&self.partial_report) {
            state.serialize_entry("partialReport", &self.partial_report)?;
        }
        if !self.file_errors.is_empty() {
            state.serialize_entry("fileErrors", &self.file_errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FileValidationReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FileValidationReport");
        debug_struct.field("file_name", &self.file_name);
        debug_struct.field("row_errors", &self.row_errors);
        debug_struct.field("partial_report", &self.partial_report);
        debug_struct.field("file_errors", &self.file_errors);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A resource that aggregates errors across import job files.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidationReport {
    /// List of errors found in files.
    pub file_validations: std::vec::Vec<crate::model::FileValidationReport>,

    /// List of job level errors.
    pub job_errors: std::vec::Vec<crate::model::ImportError>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidationReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_validations][crate::model::ValidationReport::file_validations].
    pub fn set_file_validations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileValidationReport>,
    {
        use std::iter::Iterator;
        self.file_validations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [job_errors][crate::model::ValidationReport::job_errors].
    pub fn set_job_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportError>,
    {
        use std::iter::Iterator;
        self.job_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ValidationReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ValidationReport"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValidationReport {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_validations,
            __job_errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValidationReport")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fileValidations" => Ok(__FieldTag::__file_validations),
                            "file_validations" => Ok(__FieldTag::__file_validations),
                            "jobErrors" => Ok(__FieldTag::__job_errors),
                            "job_errors" => Ok(__FieldTag::__job_errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValidationReport;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidationReport")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_validations => {
                            if !fields.insert(__FieldTag::__file_validations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_validations",
                                ));
                            }
                            result.file_validations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FileValidationReport>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_errors => {
                            if !fields.insert(__FieldTag::__job_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_errors",
                                ));
                            }
                            result.job_errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ImportError>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ValidationReport {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.file_validations.is_empty() {
            state.serialize_entry("fileValidations", &self.file_validations)?;
        }
        if !self.job_errors.is_empty() {
            state.serialize_entry("jobErrors", &self.job_errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ValidationReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValidationReport");
        debug_struct.field("file_validations", &self.file_validations);
        debug_struct.field("job_errors", &self.job_errors);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A resource that reports result of the import job execution.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecutionReport {
    /// Total number of asset frames reported for the import job.
    pub frames_reported: i32,

    /// Validation errors encountered during the execution of the import job.
    pub execution_errors: std::option::Option<crate::model::ValidationReport>,

    /// Output only. Total number of rows in the import job.
    pub total_rows_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecutionReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [frames_reported][crate::model::ExecutionReport::frames_reported].
    pub fn set_frames_reported<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.frames_reported = v.into();
        self
    }

    /// Sets the value of [execution_errors][crate::model::ExecutionReport::execution_errors].
    pub fn set_execution_errors<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ValidationReport>,
    {
        self.execution_errors = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [execution_errors][crate::model::ExecutionReport::execution_errors].
    pub fn set_or_clear_execution_errors<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ValidationReport>,
    {
        self.execution_errors = v.map(|x| x.into());
        self
    }

    /// Sets the value of [total_rows_count][crate::model::ExecutionReport::total_rows_count].
    pub fn set_total_rows_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_rows_count = v.into();
        self
    }
}

impl wkt::message::Message for ExecutionReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ExecutionReport"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExecutionReport {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __frames_reported,
            __execution_errors,
            __total_rows_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecutionReport")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "framesReported" => Ok(__FieldTag::__frames_reported),
                            "frames_reported" => Ok(__FieldTag::__frames_reported),
                            "executionErrors" => Ok(__FieldTag::__execution_errors),
                            "execution_errors" => Ok(__FieldTag::__execution_errors),
                            "totalRowsCount" => Ok(__FieldTag::__total_rows_count),
                            "total_rows_count" => Ok(__FieldTag::__total_rows_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExecutionReport;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecutionReport")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__frames_reported => {
                            if !fields.insert(__FieldTag::__frames_reported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frames_reported",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.frames_reported =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__execution_errors => {
                            if !fields.insert(__FieldTag::__execution_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_errors",
                                ));
                            }
                            result.execution_errors = map
                                .next_value::<std::option::Option<crate::model::ValidationReport>>(
                                )?;
                        }
                        __FieldTag::__total_rows_count => {
                            if !fields.insert(__FieldTag::__total_rows_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_rows_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_rows_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExecutionReport {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.frames_reported) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("framesReported", &__With(&self.frames_reported))?;
        }
        if self.execution_errors.is_some() {
            state.serialize_entry("executionErrors", &self.execution_errors)?;
        }
        if !wkt::internal::is_default(&self.total_rows_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalRowsCount", &__With(&self.total_rows_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExecutionReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExecutionReport");
        debug_struct.field("frames_reported", &self.frames_reported);
        debug_struct.field("execution_errors", &self.execution_errors);
        debug_struct.field("total_rows_count", &self.total_rows_count);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A resource that reports the errors encountered while processing an
/// import job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportError {
    /// The error information.
    pub error_details: std::string::String,

    /// The severity of the error.
    pub severity: crate::model::import_error::Severity,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_details][crate::model::ImportError::error_details].
    pub fn set_error_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_details = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::ImportError::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::import_error::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }
}

impl wkt::message::Message for ImportError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ImportError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error_details,
            __severity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "errorDetails" => Ok(__FieldTag::__error_details),
                            "error_details" => Ok(__FieldTag::__error_details),
                            "severity" => Ok(__FieldTag::__severity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error_details => {
                            if !fields.insert(__FieldTag::__error_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_details",
                                ));
                            }
                            result.error_details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map.next_value::<std::option::Option<crate::model::import_error::Severity>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.error_details.is_empty() {
            state.serialize_entry("errorDetails", &self.error_details)?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportError");
        debug_struct.field("error_details", &self.error_details);
        debug_struct.field("severity", &self.severity);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ImportError].
pub mod import_error {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerate possible error severity.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Severity {
        Unspecified,
        Error,
        Warning,
        Info,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Severity::value] or
        /// [Severity::name].
        UnknownValue(severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Severity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Error => std::option::Option::Some(1),
                Self::Warning => std::option::Option::Some(2),
                Self::Info => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Info => std::option::Option::Some("INFO"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Severity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Severity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Error,
                2 => Self::Warning,
                3 => Self::Info,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Severity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "ERROR" => Self::Error,
                "WARNING" => Self::Warning,
                "INFO" => Self::Info,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Severity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Error => serializer.serialize_i32(1),
                Self::Warning => serializer.serialize_i32(2),
                Self::Info => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Severity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
                ".google.cloud.migrationcenter.v1.ImportError.Severity",
            ))
        }
    }
}

/// A resource that reports the import job errors at row level.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportRowError {
    /// The row number where the error was detected.
    #[deprecated]
    pub row_number: i32,

    /// The name of the VM in the row.
    pub vm_name: std::string::String,

    /// The VM UUID.
    pub vm_uuid: std::string::String,

    /// The list of errors detected in the row.
    pub errors: std::vec::Vec<crate::model::ImportError>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportRowError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [row_number][crate::model::ImportRowError::row_number].
    #[deprecated]
    pub fn set_row_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.row_number = v.into();
        self
    }

    /// Sets the value of [vm_name][crate::model::ImportRowError::vm_name].
    pub fn set_vm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_name = v.into();
        self
    }

    /// Sets the value of [vm_uuid][crate::model::ImportRowError::vm_uuid].
    pub fn set_vm_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_uuid = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::ImportRowError::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportRowError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ImportRowError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportRowError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __row_number,
            __vm_name,
            __vm_uuid,
            __errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportRowError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rowNumber" => Ok(__FieldTag::__row_number),
                            "row_number" => Ok(__FieldTag::__row_number),
                            "vmName" => Ok(__FieldTag::__vm_name),
                            "vm_name" => Ok(__FieldTag::__vm_name),
                            "vmUuid" => Ok(__FieldTag::__vm_uuid),
                            "vm_uuid" => Ok(__FieldTag::__vm_uuid),
                            "errors" => Ok(__FieldTag::__errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportRowError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportRowError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__row_number => {
                            if !fields.insert(__FieldTag::__row_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_number",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.row_number = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__vm_name => {
                            if !fields.insert(__FieldTag::__vm_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_name",
                                ));
                            }
                            result.vm_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_uuid => {
                            if !fields.insert(__FieldTag::__vm_uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_uuid",
                                ));
                            }
                            result.vm_uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ImportError>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportRowError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.row_number) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rowNumber", &__With(&self.row_number))?;
        }
        if !self.vm_name.is_empty() {
            state.serialize_entry("vmName", &self.vm_name)?;
        }
        if !self.vm_uuid.is_empty() {
            state.serialize_entry("vmUuid", &self.vm_uuid)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportRowError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportRowError");
        debug_struct.field("row_number", &self.row_number);
        debug_struct.field("vm_name", &self.vm_name);
        debug_struct.field("vm_uuid", &self.vm_uuid);
        debug_struct.field("errors", &self.errors);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A resource that contains a URI to which a data file can be uploaded.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UploadFileInfo {
    /// Output only. Upload URI for the file.
    pub signed_uri: std::string::String,

    /// Output only. The headers that were used to sign the URI.
    pub headers: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Expiration time of the upload URI.
    pub uri_expiration_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UploadFileInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [signed_uri][crate::model::UploadFileInfo::signed_uri].
    pub fn set_signed_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.signed_uri = v.into();
        self
    }

    /// Sets the value of [headers][crate::model::UploadFileInfo::headers].
    pub fn set_headers<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [uri_expiration_time][crate::model::UploadFileInfo::uri_expiration_time].
    pub fn set_uri_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.uri_expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [uri_expiration_time][crate::model::UploadFileInfo::uri_expiration_time].
    pub fn set_or_clear_uri_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.uri_expiration_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UploadFileInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.UploadFileInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UploadFileInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __signed_uri,
            __headers,
            __uri_expiration_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UploadFileInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "signedUri" => Ok(__FieldTag::__signed_uri),
                            "signed_uri" => Ok(__FieldTag::__signed_uri),
                            "headers" => Ok(__FieldTag::__headers),
                            "uriExpirationTime" => Ok(__FieldTag::__uri_expiration_time),
                            "uri_expiration_time" => Ok(__FieldTag::__uri_expiration_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UploadFileInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UploadFileInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__signed_uri => {
                            if !fields.insert(__FieldTag::__signed_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signed_uri",
                                ));
                            }
                            result.signed_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__headers => {
                            if !fields.insert(__FieldTag::__headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for headers",
                                ));
                            }
                            result.headers = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri_expiration_time => {
                            if !fields.insert(__FieldTag::__uri_expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri_expiration_time",
                                ));
                            }
                            result.uri_expiration_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UploadFileInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.signed_uri.is_empty() {
            state.serialize_entry("signedUri", &self.signed_uri)?;
        }
        if !self.headers.is_empty() {
            state.serialize_entry("headers", &self.headers)?;
        }
        if self.uri_expiration_time.is_some() {
            state.serialize_entry("uriExpirationTime", &self.uri_expiration_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UploadFileInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UploadFileInfo");
        debug_struct.field("signed_uri", &self.signed_uri);
        debug_struct.field("headers", &self.headers);
        debug_struct.field("uri_expiration_time", &self.uri_expiration_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Lists the asset IDs of all assets.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AssetList {
    /// Required. A list of asset IDs
    pub asset_ids: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssetList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [asset_ids][crate::model::AssetList::asset_ids].
    pub fn set_asset_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.asset_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AssetList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.AssetList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AssetList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __asset_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AssetList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "assetIds" => Ok(__FieldTag::__asset_ids),
                            "asset_ids" => Ok(__FieldTag::__asset_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AssetList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AssetList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__asset_ids => {
                            if !fields.insert(__FieldTag::__asset_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_ids",
                                ));
                            }
                            result.asset_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AssetList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.asset_ids.is_empty() {
            state.serialize_entry("assetIds", &self.asset_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AssetList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AssetList");
        debug_struct.field("asset_ids", &self.asset_ids);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A resource that contains a single violation of a reported `AssetFrame`
/// resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FrameViolationEntry {
    /// The field of the original frame where the violation occurred.
    pub field: std::string::String,

    /// A message describing the violation.
    pub violation: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FrameViolationEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::FrameViolationEntry::field].
    pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field = v.into();
        self
    }

    /// Sets the value of [violation][crate::model::FrameViolationEntry::violation].
    pub fn set_violation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.violation = v.into();
        self
    }
}

impl wkt::message::Message for FrameViolationEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.FrameViolationEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FrameViolationEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field,
            __violation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FrameViolationEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "field" => Ok(__FieldTag::__field),
                            "violation" => Ok(__FieldTag::__violation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FrameViolationEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FrameViolationEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__violation => {
                            if !fields.insert(__FieldTag::__violation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for violation",
                                ));
                            }
                            result.violation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FrameViolationEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.field.is_empty() {
            state.serialize_entry("field", &self.field)?;
        }
        if !self.violation.is_empty() {
            state.serialize_entry("violation", &self.violation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FrameViolationEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FrameViolationEntry");
        debug_struct.field("field", &self.field);
        debug_struct.field("violation", &self.violation);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// VirtualMachinePreferences enables you to create sets of assumptions, for
/// example, a geographical location and pricing track, for your migrated virtual
/// machines. The set of preferences influence recommendations for migrating
/// virtual machine assets.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VirtualMachinePreferences {
    /// Target product for assets using this preference set.
    /// Specify either target product or business goal, but
    /// not both.
    pub target_product: crate::model::ComputeMigrationTargetProduct,

    /// Region preferences for assets using this preference set.
    /// If you are unsure which value to set, the migration service API region is
    /// often a good value to start with.
    pub region_preferences: std::option::Option<crate::model::RegionPreferences>,

    /// Commitment plan to consider when calculating costs for virtual machine
    /// insights and recommendations.
    /// If you are unsure which value to set, a 3 year commitment plan is often a
    /// good value to start with.
    pub commitment_plan: crate::model::CommitmentPlan,

    /// Sizing optimization strategy specifies the preferred strategy used when
    /// extrapolating usage data to calculate insights and recommendations for a
    /// virtual machine.
    /// If you are unsure which value to set, a moderate sizing optimization
    /// strategy is often a good value to start with.
    pub sizing_optimization_strategy: crate::model::SizingOptimizationStrategy,

    /// Compute Engine preferences concern insights and recommendations for Compute
    /// Engine target.
    pub compute_engine_preferences: std::option::Option<crate::model::ComputeEnginePreferences>,

    /// Preferences concerning insights and recommendations for
    /// Google Cloud VMware Engine.
    pub vmware_engine_preferences: std::option::Option<crate::model::VmwareEnginePreferences>,

    /// Preferences concerning Sole Tenant nodes and virtual machines.
    pub sole_tenancy_preferences: std::option::Option<crate::model::SoleTenancyPreferences>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VirtualMachinePreferences {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_product][crate::model::VirtualMachinePreferences::target_product].
    pub fn set_target_product<
        T: std::convert::Into<crate::model::ComputeMigrationTargetProduct>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_product = v.into();
        self
    }

    /// Sets the value of [region_preferences][crate::model::VirtualMachinePreferences::region_preferences].
    pub fn set_region_preferences<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RegionPreferences>,
    {
        self.region_preferences = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [region_preferences][crate::model::VirtualMachinePreferences::region_preferences].
    pub fn set_or_clear_region_preferences<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RegionPreferences>,
    {
        self.region_preferences = v.map(|x| x.into());
        self
    }

    /// Sets the value of [commitment_plan][crate::model::VirtualMachinePreferences::commitment_plan].
    pub fn set_commitment_plan<T: std::convert::Into<crate::model::CommitmentPlan>>(
        mut self,
        v: T,
    ) -> Self {
        self.commitment_plan = v.into();
        self
    }

    /// Sets the value of [sizing_optimization_strategy][crate::model::VirtualMachinePreferences::sizing_optimization_strategy].
    pub fn set_sizing_optimization_strategy<
        T: std::convert::Into<crate::model::SizingOptimizationStrategy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sizing_optimization_strategy = v.into();
        self
    }

    /// Sets the value of [compute_engine_preferences][crate::model::VirtualMachinePreferences::compute_engine_preferences].
    pub fn set_compute_engine_preferences<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ComputeEnginePreferences>,
    {
        self.compute_engine_preferences = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compute_engine_preferences][crate::model::VirtualMachinePreferences::compute_engine_preferences].
    pub fn set_or_clear_compute_engine_preferences<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ComputeEnginePreferences>,
    {
        self.compute_engine_preferences = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vmware_engine_preferences][crate::model::VirtualMachinePreferences::vmware_engine_preferences].
    pub fn set_vmware_engine_preferences<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VmwareEnginePreferences>,
    {
        self.vmware_engine_preferences = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vmware_engine_preferences][crate::model::VirtualMachinePreferences::vmware_engine_preferences].
    pub fn set_or_clear_vmware_engine_preferences<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VmwareEnginePreferences>,
    {
        self.vmware_engine_preferences = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sole_tenancy_preferences][crate::model::VirtualMachinePreferences::sole_tenancy_preferences].
    pub fn set_sole_tenancy_preferences<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SoleTenancyPreferences>,
    {
        self.sole_tenancy_preferences = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sole_tenancy_preferences][crate::model::VirtualMachinePreferences::sole_tenancy_preferences].
    pub fn set_or_clear_sole_tenancy_preferences<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SoleTenancyPreferences>,
    {
        self.sole_tenancy_preferences = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VirtualMachinePreferences {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.VirtualMachinePreferences"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VirtualMachinePreferences {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_product,
            __region_preferences,
            __commitment_plan,
            __sizing_optimization_strategy,
            __compute_engine_preferences,
            __vmware_engine_preferences,
            __sole_tenancy_preferences,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VirtualMachinePreferences")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetProduct" => Ok(__FieldTag::__target_product),
                            "target_product" => Ok(__FieldTag::__target_product),
                            "regionPreferences" => Ok(__FieldTag::__region_preferences),
                            "region_preferences" => Ok(__FieldTag::__region_preferences),
                            "commitmentPlan" => Ok(__FieldTag::__commitment_plan),
                            "commitment_plan" => Ok(__FieldTag::__commitment_plan),
                            "sizingOptimizationStrategy" => {
                                Ok(__FieldTag::__sizing_optimization_strategy)
                            }
                            "sizing_optimization_strategy" => {
                                Ok(__FieldTag::__sizing_optimization_strategy)
                            }
                            "computeEnginePreferences" => {
                                Ok(__FieldTag::__compute_engine_preferences)
                            }
                            "compute_engine_preferences" => {
                                Ok(__FieldTag::__compute_engine_preferences)
                            }
                            "vmwareEnginePreferences" => {
                                Ok(__FieldTag::__vmware_engine_preferences)
                            }
                            "vmware_engine_preferences" => {
                                Ok(__FieldTag::__vmware_engine_preferences)
                            }
                            "soleTenancyPreferences" => Ok(__FieldTag::__sole_tenancy_preferences),
                            "sole_tenancy_preferences" => {
                                Ok(__FieldTag::__sole_tenancy_preferences)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VirtualMachinePreferences;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VirtualMachinePreferences")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_product => {
                            if !fields.insert(__FieldTag::__target_product) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_product",
                                ));
                            }
                            result.target_product =
                                map.next_value::<std::option::Option<
                                    crate::model::ComputeMigrationTargetProduct,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region_preferences => {
                            if !fields.insert(__FieldTag::__region_preferences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region_preferences",
                                ));
                            }
                            result.region_preferences = map
                                .next_value::<std::option::Option<crate::model::RegionPreferences>>(
                                )?;
                        }
                        __FieldTag::__commitment_plan => {
                            if !fields.insert(__FieldTag::__commitment_plan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commitment_plan",
                                ));
                            }
                            result.commitment_plan = map
                                .next_value::<std::option::Option<crate::model::CommitmentPlan>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sizing_optimization_strategy => {
                            if !fields.insert(__FieldTag::__sizing_optimization_strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sizing_optimization_strategy",
                                ));
                            }
                            result.sizing_optimization_strategy = map.next_value::<std::option::Option<crate::model::SizingOptimizationStrategy>>()?.unwrap_or_default();
                        }
                        __FieldTag::__compute_engine_preferences => {
                            if !fields.insert(__FieldTag::__compute_engine_preferences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_engine_preferences",
                                ));
                            }
                            result.compute_engine_preferences = map.next_value::<std::option::Option<crate::model::ComputeEnginePreferences>>()?
                                ;
                        }
                        __FieldTag::__vmware_engine_preferences => {
                            if !fields.insert(__FieldTag::__vmware_engine_preferences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vmware_engine_preferences",
                                ));
                            }
                            result.vmware_engine_preferences = map.next_value::<std::option::Option<crate::model::VmwareEnginePreferences>>()?
                                ;
                        }
                        __FieldTag::__sole_tenancy_preferences => {
                            if !fields.insert(__FieldTag::__sole_tenancy_preferences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sole_tenancy_preferences",
                                ));
                            }
                            result.sole_tenancy_preferences = map.next_value::<std::option::Option<crate::model::SoleTenancyPreferences>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VirtualMachinePreferences {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.target_product) {
            state.serialize_entry("targetProduct", &self.target_product)?;
        }
        if self.region_preferences.is_some() {
            state.serialize_entry("regionPreferences", &self.region_preferences)?;
        }
        if !wkt::internal::is_default(&self.commitment_plan) {
            state.serialize_entry("commitmentPlan", &self.commitment_plan)?;
        }
        if !wkt::internal::is_default(&self.sizing_optimization_strategy) {
            state.serialize_entry(
                "sizingOptimizationStrategy",
                &self.sizing_optimization_strategy,
            )?;
        }
        if self.compute_engine_preferences.is_some() {
            state.serialize_entry("computeEnginePreferences", &self.compute_engine_preferences)?;
        }
        if self.vmware_engine_preferences.is_some() {
            state.serialize_entry("vmwareEnginePreferences", &self.vmware_engine_preferences)?;
        }
        if self.sole_tenancy_preferences.is_some() {
            state.serialize_entry("soleTenancyPreferences", &self.sole_tenancy_preferences)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VirtualMachinePreferences {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VirtualMachinePreferences");
        debug_struct.field("target_product", &self.target_product);
        debug_struct.field("region_preferences", &self.region_preferences);
        debug_struct.field("commitment_plan", &self.commitment_plan);
        debug_struct.field(
            "sizing_optimization_strategy",
            &self.sizing_optimization_strategy,
        );
        debug_struct.field(
            "compute_engine_preferences",
            &self.compute_engine_preferences,
        );
        debug_struct.field("vmware_engine_preferences", &self.vmware_engine_preferences);
        debug_struct.field("sole_tenancy_preferences", &self.sole_tenancy_preferences);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The user preferences relating to Compute Engine target platform.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeEnginePreferences {
    /// Preferences concerning the machine types to consider on Compute Engine.
    pub machine_preferences: std::option::Option<crate::model::MachinePreferences>,

    /// License type to consider when calculating costs for virtual machine
    /// insights and recommendations. If unspecified, costs are calculated
    /// based on the default licensing plan.
    pub license_type: crate::model::LicenseType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeEnginePreferences {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_preferences][crate::model::ComputeEnginePreferences::machine_preferences].
    pub fn set_machine_preferences<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MachinePreferences>,
    {
        self.machine_preferences = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [machine_preferences][crate::model::ComputeEnginePreferences::machine_preferences].
    pub fn set_or_clear_machine_preferences<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MachinePreferences>,
    {
        self.machine_preferences = v.map(|x| x.into());
        self
    }

    /// Sets the value of [license_type][crate::model::ComputeEnginePreferences::license_type].
    pub fn set_license_type<T: std::convert::Into<crate::model::LicenseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.license_type = v.into();
        self
    }
}

impl wkt::message::Message for ComputeEnginePreferences {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ComputeEnginePreferences"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeEnginePreferences {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __machine_preferences,
            __license_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeEnginePreferences")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "machinePreferences" => Ok(__FieldTag::__machine_preferences),
                            "machine_preferences" => Ok(__FieldTag::__machine_preferences),
                            "licenseType" => Ok(__FieldTag::__license_type),
                            "license_type" => Ok(__FieldTag::__license_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeEnginePreferences;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeEnginePreferences")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__machine_preferences => {
                            if !fields.insert(__FieldTag::__machine_preferences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_preferences",
                                ));
                            }
                            result.machine_preferences = map.next_value::<std::option::Option<crate::model::MachinePreferences>>()?
                                ;
                        }
                        __FieldTag::__license_type => {
                            if !fields.insert(__FieldTag::__license_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for license_type",
                                ));
                            }
                            result.license_type = map
                                .next_value::<std::option::Option<crate::model::LicenseType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeEnginePreferences {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.machine_preferences.is_some() {
            state.serialize_entry("machinePreferences", &self.machine_preferences)?;
        }
        if !wkt::internal::is_default(&self.license_type) {
            state.serialize_entry("licenseType", &self.license_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ComputeEnginePreferences {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComputeEnginePreferences");
        debug_struct.field("machine_preferences", &self.machine_preferences);
        debug_struct.field("license_type", &self.license_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The type of machines to consider when calculating virtual machine migration
/// insights and recommendations.
/// Not all machine types are available in all zones and regions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MachinePreferences {
    /// Compute Engine machine series to consider for insights and recommendations.
    /// If empty, no restriction is applied on the machine series.
    pub allowed_machine_series: std::vec::Vec<crate::model::MachineSeries>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MachinePreferences {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowed_machine_series][crate::model::MachinePreferences::allowed_machine_series].
    pub fn set_allowed_machine_series<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MachineSeries>,
    {
        use std::iter::Iterator;
        self.allowed_machine_series = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MachinePreferences {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.MachinePreferences"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MachinePreferences {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allowed_machine_series,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MachinePreferences")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowedMachineSeries" => Ok(__FieldTag::__allowed_machine_series),
                            "allowed_machine_series" => Ok(__FieldTag::__allowed_machine_series),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MachinePreferences;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MachinePreferences")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allowed_machine_series => {
                            if !fields.insert(__FieldTag::__allowed_machine_series) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_machine_series",
                                ));
                            }
                            result.allowed_machine_series = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MachineSeries>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MachinePreferences {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.allowed_machine_series.is_empty() {
            state.serialize_entry("allowedMachineSeries", &self.allowed_machine_series)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MachinePreferences {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MachinePreferences");
        debug_struct.field("allowed_machine_series", &self.allowed_machine_series);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A Compute Engine machine series.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MachineSeries {
    /// Code to identify a Compute Engine machine series. Consult
    /// <https://cloud.google.com/compute/docs/machine-resource#machine_type_comparison>
    /// for more details on the available series.
    pub code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MachineSeries {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::MachineSeries::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }
}

impl wkt::message::Message for MachineSeries {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.MachineSeries"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MachineSeries {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MachineSeries")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MachineSeries;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MachineSeries")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MachineSeries {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.code.is_empty() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MachineSeries {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MachineSeries");
        debug_struct.field("code", &self.code);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The user preferences relating to Google Cloud VMware Engine target platform.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VmwareEnginePreferences {
    /// CPU overcommit ratio.
    /// Acceptable values are between 1.0 and 8.0, with 0.1 increment.
    pub cpu_overcommit_ratio: f64,

    /// Memory overcommit ratio.
    /// Acceptable values are 1.0, 1.25, 1.5, 1.75 and 2.0.
    pub memory_overcommit_ratio: f64,

    /// The Deduplication and Compression ratio is based on the logical (Used
    /// Before) space required to store data before applying deduplication and
    /// compression, in relation to the physical (Used After) space required after
    /// applying deduplication and compression. Specifically, the ratio is the Used
    /// Before space divided by the Used After space. For example, if the Used
    /// Before space is 3 GB, but the physical Used After space is 1 GB, the
    /// deduplication and compression ratio is 3x. Acceptable values are
    /// between 1.0 and 4.0.
    pub storage_deduplication_compression_ratio: f64,

    /// Commitment plan to consider when calculating costs for virtual machine
    /// insights and recommendations.
    /// If you are unsure which value to set, a 3 year commitment plan is often a
    /// good value to start with.
    pub commitment_plan: crate::model::vmware_engine_preferences::CommitmentPlan,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmwareEnginePreferences {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpu_overcommit_ratio][crate::model::VmwareEnginePreferences::cpu_overcommit_ratio].
    pub fn set_cpu_overcommit_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.cpu_overcommit_ratio = v.into();
        self
    }

    /// Sets the value of [memory_overcommit_ratio][crate::model::VmwareEnginePreferences::memory_overcommit_ratio].
    pub fn set_memory_overcommit_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.memory_overcommit_ratio = v.into();
        self
    }

    /// Sets the value of [storage_deduplication_compression_ratio][crate::model::VmwareEnginePreferences::storage_deduplication_compression_ratio].
    pub fn set_storage_deduplication_compression_ratio<T: std::convert::Into<f64>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_deduplication_compression_ratio = v.into();
        self
    }

    /// Sets the value of [commitment_plan][crate::model::VmwareEnginePreferences::commitment_plan].
    pub fn set_commitment_plan<
        T: std::convert::Into<crate::model::vmware_engine_preferences::CommitmentPlan>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.commitment_plan = v.into();
        self
    }
}

impl wkt::message::Message for VmwareEnginePreferences {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.VmwareEnginePreferences"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmwareEnginePreferences {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cpu_overcommit_ratio,
            __memory_overcommit_ratio,
            __storage_deduplication_compression_ratio,
            __commitment_plan,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmwareEnginePreferences")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cpuOvercommitRatio" => Ok(__FieldTag::__cpu_overcommit_ratio),
                            "cpu_overcommit_ratio" => Ok(__FieldTag::__cpu_overcommit_ratio),
                            "memoryOvercommitRatio" => Ok(__FieldTag::__memory_overcommit_ratio),
                            "memory_overcommit_ratio" => Ok(__FieldTag::__memory_overcommit_ratio),
                            "storageDeduplicationCompressionRatio" => {
                                Ok(__FieldTag::__storage_deduplication_compression_ratio)
                            }
                            "storage_deduplication_compression_ratio" => {
                                Ok(__FieldTag::__storage_deduplication_compression_ratio)
                            }
                            "commitmentPlan" => Ok(__FieldTag::__commitment_plan),
                            "commitment_plan" => Ok(__FieldTag::__commitment_plan),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmwareEnginePreferences;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmwareEnginePreferences")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cpu_overcommit_ratio => {
                            if !fields.insert(__FieldTag::__cpu_overcommit_ratio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_overcommit_ratio",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_overcommit_ratio =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_overcommit_ratio => {
                            if !fields.insert(__FieldTag::__memory_overcommit_ratio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_overcommit_ratio",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_overcommit_ratio =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__storage_deduplication_compression_ratio => {
                            if !fields.insert(__FieldTag::__storage_deduplication_compression_ratio)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_deduplication_compression_ratio",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.storage_deduplication_compression_ratio =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__commitment_plan => {
                            if !fields.insert(__FieldTag::__commitment_plan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commitment_plan",
                                ));
                            }
                            result.commitment_plan = map
                                .next_value::<std::option::Option<
                                    crate::model::vmware_engine_preferences::CommitmentPlan,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmwareEnginePreferences {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.cpu_overcommit_ratio) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cpuOvercommitRatio", &__With(&self.cpu_overcommit_ratio))?;
        }
        if !wkt::internal::is_default(&self.memory_overcommit_ratio) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "memoryOvercommitRatio",
                &__With(&self.memory_overcommit_ratio),
            )?;
        }
        if !wkt::internal::is_default(&self.storage_deduplication_compression_ratio) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "storageDeduplicationCompressionRatio",
                &__With(&self.storage_deduplication_compression_ratio),
            )?;
        }
        if !wkt::internal::is_default(&self.commitment_plan) {
            state.serialize_entry("commitmentPlan", &self.commitment_plan)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VmwareEnginePreferences {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmwareEnginePreferences");
        debug_struct.field("cpu_overcommit_ratio", &self.cpu_overcommit_ratio);
        debug_struct.field("memory_overcommit_ratio", &self.memory_overcommit_ratio);
        debug_struct.field(
            "storage_deduplication_compression_ratio",
            &self.storage_deduplication_compression_ratio,
        );
        debug_struct.field("commitment_plan", &self.commitment_plan);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [VmwareEnginePreferences].
pub mod vmware_engine_preferences {
    #[allow(unused_imports)]
    use super::*;

    /// Type of committed use discount.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CommitmentPlan {
        /// Unspecified commitment plan.
        Unspecified,
        /// No commitment plan (on-demand usage).
        OnDemand,
        /// 1 year commitment (monthly payments).
        Commitment1YearMonthlyPayments,
        /// 3 year commitment (monthly payments).
        Commitment3YearMonthlyPayments,
        /// 1 year commitment (upfront payment).
        Commitment1YearUpfrontPayment,
        /// 3 years commitment (upfront payment).
        Commitment3YearUpfrontPayment,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CommitmentPlan::value] or
        /// [CommitmentPlan::name].
        UnknownValue(commitment_plan::UnknownValue),
    }

    #[doc(hidden)]
    pub mod commitment_plan {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CommitmentPlan {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::OnDemand => std::option::Option::Some(1),
                Self::Commitment1YearMonthlyPayments => std::option::Option::Some(2),
                Self::Commitment3YearMonthlyPayments => std::option::Option::Some(3),
                Self::Commitment1YearUpfrontPayment => std::option::Option::Some(4),
                Self::Commitment3YearUpfrontPayment => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMMITMENT_PLAN_UNSPECIFIED"),
                Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
                Self::Commitment1YearMonthlyPayments => {
                    std::option::Option::Some("COMMITMENT_1_YEAR_MONTHLY_PAYMENTS")
                }
                Self::Commitment3YearMonthlyPayments => {
                    std::option::Option::Some("COMMITMENT_3_YEAR_MONTHLY_PAYMENTS")
                }
                Self::Commitment1YearUpfrontPayment => {
                    std::option::Option::Some("COMMITMENT_1_YEAR_UPFRONT_PAYMENT")
                }
                Self::Commitment3YearUpfrontPayment => {
                    std::option::Option::Some("COMMITMENT_3_YEAR_UPFRONT_PAYMENT")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CommitmentPlan {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CommitmentPlan {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CommitmentPlan {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::OnDemand,
                2 => Self::Commitment1YearMonthlyPayments,
                3 => Self::Commitment3YearMonthlyPayments,
                4 => Self::Commitment1YearUpfrontPayment,
                5 => Self::Commitment3YearUpfrontPayment,
                _ => Self::UnknownValue(commitment_plan::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CommitmentPlan {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMMITMENT_PLAN_UNSPECIFIED" => Self::Unspecified,
                "ON_DEMAND" => Self::OnDemand,
                "COMMITMENT_1_YEAR_MONTHLY_PAYMENTS" => Self::Commitment1YearMonthlyPayments,
                "COMMITMENT_3_YEAR_MONTHLY_PAYMENTS" => Self::Commitment3YearMonthlyPayments,
                "COMMITMENT_1_YEAR_UPFRONT_PAYMENT" => Self::Commitment1YearUpfrontPayment,
                "COMMITMENT_3_YEAR_UPFRONT_PAYMENT" => Self::Commitment3YearUpfrontPayment,
                _ => Self::UnknownValue(commitment_plan::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CommitmentPlan {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::OnDemand => serializer.serialize_i32(1),
                Self::Commitment1YearMonthlyPayments => serializer.serialize_i32(2),
                Self::Commitment3YearMonthlyPayments => serializer.serialize_i32(3),
                Self::Commitment1YearUpfrontPayment => serializer.serialize_i32(4),
                Self::Commitment3YearUpfrontPayment => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CommitmentPlan {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CommitmentPlan>::new(
                ".google.cloud.migrationcenter.v1.VmwareEnginePreferences.CommitmentPlan",
            ))
        }
    }
}

/// Preferences concerning Sole Tenancy nodes and VMs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SoleTenancyPreferences {
    /// CPU overcommit ratio.
    /// Acceptable values are between 1.0 and 2.0 inclusive.
    pub cpu_overcommit_ratio: f64,

    /// Sole Tenancy nodes maintenance policy.
    pub host_maintenance_policy: crate::model::sole_tenancy_preferences::HostMaintenancePolicy,

    /// Commitment plan to consider when calculating costs for virtual machine
    /// insights and recommendations.
    /// If you are unsure which value to set, a 3 year commitment plan is often a
    /// good value to start with.
    pub commitment_plan: crate::model::sole_tenancy_preferences::CommitmentPlan,

    /// A list of sole tenant node types.
    /// An empty list means that all possible node types will be considered.
    pub node_types: std::vec::Vec<crate::model::SoleTenantNodeType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SoleTenancyPreferences {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpu_overcommit_ratio][crate::model::SoleTenancyPreferences::cpu_overcommit_ratio].
    pub fn set_cpu_overcommit_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.cpu_overcommit_ratio = v.into();
        self
    }

    /// Sets the value of [host_maintenance_policy][crate::model::SoleTenancyPreferences::host_maintenance_policy].
    pub fn set_host_maintenance_policy<
        T: std::convert::Into<crate::model::sole_tenancy_preferences::HostMaintenancePolicy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.host_maintenance_policy = v.into();
        self
    }

    /// Sets the value of [commitment_plan][crate::model::SoleTenancyPreferences::commitment_plan].
    pub fn set_commitment_plan<
        T: std::convert::Into<crate::model::sole_tenancy_preferences::CommitmentPlan>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.commitment_plan = v.into();
        self
    }

    /// Sets the value of [node_types][crate::model::SoleTenancyPreferences::node_types].
    pub fn set_node_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SoleTenantNodeType>,
    {
        use std::iter::Iterator;
        self.node_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SoleTenancyPreferences {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.SoleTenancyPreferences"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SoleTenancyPreferences {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cpu_overcommit_ratio,
            __host_maintenance_policy,
            __commitment_plan,
            __node_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SoleTenancyPreferences")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cpuOvercommitRatio" => Ok(__FieldTag::__cpu_overcommit_ratio),
                            "cpu_overcommit_ratio" => Ok(__FieldTag::__cpu_overcommit_ratio),
                            "hostMaintenancePolicy" => Ok(__FieldTag::__host_maintenance_policy),
                            "host_maintenance_policy" => Ok(__FieldTag::__host_maintenance_policy),
                            "commitmentPlan" => Ok(__FieldTag::__commitment_plan),
                            "commitment_plan" => Ok(__FieldTag::__commitment_plan),
                            "nodeTypes" => Ok(__FieldTag::__node_types),
                            "node_types" => Ok(__FieldTag::__node_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SoleTenancyPreferences;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SoleTenancyPreferences")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cpu_overcommit_ratio => {
                            if !fields.insert(__FieldTag::__cpu_overcommit_ratio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_overcommit_ratio",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_overcommit_ratio =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__host_maintenance_policy => {
                            if !fields.insert(__FieldTag::__host_maintenance_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host_maintenance_policy",
                                ));
                            }
                            result.host_maintenance_policy = map
                                .next_value::<std::option::Option<
                                    crate::model::sole_tenancy_preferences::HostMaintenancePolicy,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__commitment_plan => {
                            if !fields.insert(__FieldTag::__commitment_plan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commitment_plan",
                                ));
                            }
                            result.commitment_plan = map
                                .next_value::<std::option::Option<
                                    crate::model::sole_tenancy_preferences::CommitmentPlan,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_types => {
                            if !fields.insert(__FieldTag::__node_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_types",
                                ));
                            }
                            result.node_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SoleTenantNodeType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SoleTenancyPreferences {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.cpu_overcommit_ratio) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cpuOvercommitRatio", &__With(&self.cpu_overcommit_ratio))?;
        }
        if !wkt::internal::is_default(&self.host_maintenance_policy) {
            state.serialize_entry("hostMaintenancePolicy", &self.host_maintenance_policy)?;
        }
        if !wkt::internal::is_default(&self.commitment_plan) {
            state.serialize_entry("commitmentPlan", &self.commitment_plan)?;
        }
        if !self.node_types.is_empty() {
            state.serialize_entry("nodeTypes", &self.node_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SoleTenancyPreferences {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SoleTenancyPreferences");
        debug_struct.field("cpu_overcommit_ratio", &self.cpu_overcommit_ratio);
        debug_struct.field("host_maintenance_policy", &self.host_maintenance_policy);
        debug_struct.field("commitment_plan", &self.commitment_plan);
        debug_struct.field("node_types", &self.node_types);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SoleTenancyPreferences].
pub mod sole_tenancy_preferences {
    #[allow(unused_imports)]
    use super::*;

    /// Sole Tenancy nodes maintenance policy.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HostMaintenancePolicy {
        /// Unspecified host maintenance policy.
        Unspecified,
        /// Default host maintenance policy.
        Default,
        /// Restart in place host maintenance policy.
        RestartInPlace,
        /// Migrate within node group host maintenance policy.
        MigrateWithinNodeGroup,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HostMaintenancePolicy::value] or
        /// [HostMaintenancePolicy::name].
        UnknownValue(host_maintenance_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod host_maintenance_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl HostMaintenancePolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Default => std::option::Option::Some(1),
                Self::RestartInPlace => std::option::Option::Some(2),
                Self::MigrateWithinNodeGroup => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("HOST_MAINTENANCE_POLICY_UNSPECIFIED")
                }
                Self::Default => std::option::Option::Some("HOST_MAINTENANCE_POLICY_DEFAULT"),
                Self::RestartInPlace => {
                    std::option::Option::Some("HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE")
                }
                Self::MigrateWithinNodeGroup => {
                    std::option::Option::Some("HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for HostMaintenancePolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for HostMaintenancePolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for HostMaintenancePolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Default,
                2 => Self::RestartInPlace,
                3 => Self::MigrateWithinNodeGroup,
                _ => Self::UnknownValue(host_maintenance_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for HostMaintenancePolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HOST_MAINTENANCE_POLICY_UNSPECIFIED" => Self::Unspecified,
                "HOST_MAINTENANCE_POLICY_DEFAULT" => Self::Default,
                "HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE" => Self::RestartInPlace,
                "HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP" => Self::MigrateWithinNodeGroup,
                _ => Self::UnknownValue(host_maintenance_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for HostMaintenancePolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Default => serializer.serialize_i32(1),
                Self::RestartInPlace => serializer.serialize_i32(2),
                Self::MigrateWithinNodeGroup => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for HostMaintenancePolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HostMaintenancePolicy>::new(
                ".google.cloud.migrationcenter.v1.SoleTenancyPreferences.HostMaintenancePolicy",
            ))
        }
    }

    /// Type of committed use discount.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CommitmentPlan {
        /// Unspecified commitment plan.
        Unspecified,
        /// No commitment plan (on-demand usage).
        OnDemand,
        /// 1 year commitment.
        Commitment1Year,
        /// 3 years commitment.
        Commitment3Year,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CommitmentPlan::value] or
        /// [CommitmentPlan::name].
        UnknownValue(commitment_plan::UnknownValue),
    }

    #[doc(hidden)]
    pub mod commitment_plan {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CommitmentPlan {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::OnDemand => std::option::Option::Some(1),
                Self::Commitment1Year => std::option::Option::Some(2),
                Self::Commitment3Year => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMMITMENT_PLAN_UNSPECIFIED"),
                Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
                Self::Commitment1Year => std::option::Option::Some("COMMITMENT_1_YEAR"),
                Self::Commitment3Year => std::option::Option::Some("COMMITMENT_3_YEAR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CommitmentPlan {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CommitmentPlan {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CommitmentPlan {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::OnDemand,
                2 => Self::Commitment1Year,
                3 => Self::Commitment3Year,
                _ => Self::UnknownValue(commitment_plan::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CommitmentPlan {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMMITMENT_PLAN_UNSPECIFIED" => Self::Unspecified,
                "ON_DEMAND" => Self::OnDemand,
                "COMMITMENT_1_YEAR" => Self::Commitment1Year,
                "COMMITMENT_3_YEAR" => Self::Commitment3Year,
                _ => Self::UnknownValue(commitment_plan::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CommitmentPlan {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::OnDemand => serializer.serialize_i32(1),
                Self::Commitment1Year => serializer.serialize_i32(2),
                Self::Commitment3Year => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CommitmentPlan {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CommitmentPlan>::new(
                ".google.cloud.migrationcenter.v1.SoleTenancyPreferences.CommitmentPlan",
            ))
        }
    }
}

/// A Sole Tenant node type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SoleTenantNodeType {
    /// Name of the Sole Tenant node. Consult
    /// <https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes>
    pub node_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SoleTenantNodeType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_name][crate::model::SoleTenantNodeType::node_name].
    pub fn set_node_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_name = v.into();
        self
    }
}

impl wkt::message::Message for SoleTenantNodeType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.SoleTenantNodeType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SoleTenantNodeType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __node_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SoleTenantNodeType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nodeName" => Ok(__FieldTag::__node_name),
                            "node_name" => Ok(__FieldTag::__node_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SoleTenantNodeType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SoleTenantNodeType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__node_name => {
                            if !fields.insert(__FieldTag::__node_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_name",
                                ));
                            }
                            result.node_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SoleTenantNodeType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.node_name.is_empty() {
            state.serialize_entry("nodeName", &self.node_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SoleTenantNodeType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SoleTenantNodeType");
        debug_struct.field("node_name", &self.node_name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The user preferences relating to target regions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionPreferences {
    /// A list of preferred regions,
    /// ordered by the most preferred region first.
    /// Set only valid Google Cloud region names.
    /// See <https://cloud.google.com/compute/docs/regions-zones>
    /// for available regions.
    pub preferred_regions: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RegionPreferences {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [preferred_regions][crate::model::RegionPreferences::preferred_regions].
    pub fn set_preferred_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.preferred_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RegionPreferences {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.RegionPreferences"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RegionPreferences {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __preferred_regions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RegionPreferences")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "preferredRegions" => Ok(__FieldTag::__preferred_regions),
                            "preferred_regions" => Ok(__FieldTag::__preferred_regions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RegionPreferences;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RegionPreferences")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__preferred_regions => {
                            if !fields.insert(__FieldTag::__preferred_regions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preferred_regions",
                                ));
                            }
                            result.preferred_regions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RegionPreferences {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.preferred_regions.is_empty() {
            state.serialize_entry("preferredRegions", &self.preferred_regions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RegionPreferences {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RegionPreferences");
        debug_struct.field("preferred_regions", &self.preferred_regions);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Describes the Migration Center settings related to the project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Settings {
    /// Output only. The name of the resource.
    pub name: std::string::String,

    /// The preference set used by default for a project.
    pub preference_set: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Settings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Settings::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [preference_set][crate::model::Settings::preference_set].
    pub fn set_preference_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.preference_set = v.into();
        self
    }
}

impl wkt::message::Message for Settings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.Settings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Settings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __preference_set,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Settings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "preferenceSet" => Ok(__FieldTag::__preference_set),
                            "preference_set" => Ok(__FieldTag::__preference_set),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Settings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Settings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__preference_set => {
                            if !fields.insert(__FieldTag::__preference_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preference_set",
                                ));
                            }
                            result.preference_set = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Settings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.preference_set.is_empty() {
            state.serialize_entry("preferenceSet", &self.preference_set)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Settings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Settings");
        debug_struct.field("name", &self.name);
        debug_struct.field("preference_set", &self.preference_set);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Describes the Summary view of a Report, which contains aggregated values
/// for all the groups and preference sets included in this Report.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReportSummary {
    /// Aggregate statistics for all the assets across all the groups.
    pub all_assets_stats: std::option::Option<crate::model::report_summary::AssetAggregateStats>,

    /// Findings for each Group included in this report.
    pub group_findings: std::vec::Vec<crate::model::report_summary::GroupFinding>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReportSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [all_assets_stats][crate::model::ReportSummary::all_assets_stats].
    pub fn set_all_assets_stats<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::report_summary::AssetAggregateStats>,
    {
        self.all_assets_stats = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [all_assets_stats][crate::model::ReportSummary::all_assets_stats].
    pub fn set_or_clear_all_assets_stats<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::report_summary::AssetAggregateStats>,
    {
        self.all_assets_stats = v.map(|x| x.into());
        self
    }

    /// Sets the value of [group_findings][crate::model::ReportSummary::group_findings].
    pub fn set_group_findings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::report_summary::GroupFinding>,
    {
        use std::iter::Iterator;
        self.group_findings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReportSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReportSummary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __all_assets_stats,
            __group_findings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReportSummary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allAssetsStats" => Ok(__FieldTag::__all_assets_stats),
                            "all_assets_stats" => Ok(__FieldTag::__all_assets_stats),
                            "groupFindings" => Ok(__FieldTag::__group_findings),
                            "group_findings" => Ok(__FieldTag::__group_findings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReportSummary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReportSummary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__all_assets_stats => {
                            if !fields.insert(__FieldTag::__all_assets_stats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for all_assets_stats",
                                ));
                            }
                            result.all_assets_stats = map.next_value::<std::option::Option<
                                crate::model::report_summary::AssetAggregateStats,
                            >>()?;
                        }
                        __FieldTag::__group_findings => {
                            if !fields.insert(__FieldTag::__group_findings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_findings",
                                ));
                            }
                            result.group_findings = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::report_summary::GroupFinding>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReportSummary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.all_assets_stats.is_some() {
            state.serialize_entry("allAssetsStats", &self.all_assets_stats)?;
        }
        if !self.group_findings.is_empty() {
            state.serialize_entry("groupFindings", &self.group_findings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReportSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReportSummary");
        debug_struct.field("all_assets_stats", &self.all_assets_stats);
        debug_struct.field("group_findings", &self.group_findings);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ReportSummary].
pub mod report_summary {
    #[allow(unused_imports)]
    use super::*;

    /// Describes a collection of data points rendered as a Chart.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ChartData {
        /// Each data point in the chart is represented as a name-value pair
        /// with the name being the x-axis label, and the value being the y-axis
        /// value.
        pub data_points: std::vec::Vec<crate::model::report_summary::chart_data::DataPoint>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ChartData {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [data_points][crate::model::report_summary::ChartData::data_points].
        pub fn set_data_points<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::report_summary::chart_data::DataPoint>,
        {
            use std::iter::Iterator;
            self.data_points = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ChartData {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.ChartData"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ChartData {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __data_points,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ChartData")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "dataPoints" => Ok(__FieldTag::__data_points),
                                "data_points" => Ok(__FieldTag::__data_points),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ChartData;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ChartData")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__data_points => {
                                if !fields.insert(__FieldTag::__data_points) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for data_points",
                                    ));
                                }
                                result.data_points = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::report_summary::chart_data::DataPoint,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ChartData {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.data_points.is_empty() {
                state.serialize_entry("dataPoints", &self.data_points)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ChartData {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ChartData");
            debug_struct.field("data_points", &self.data_points);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [ChartData].
    pub mod chart_data {
        #[allow(unused_imports)]
        use super::*;

        /// Describes a single data point in the Chart.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct DataPoint {
            /// The X-axis label for this data point.
            pub label: std::string::String,

            /// The Y-axis value for this data point.
            pub value: f64,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl DataPoint {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [label][crate::model::report_summary::chart_data::DataPoint::label].
            pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.label = v.into();
                self
            }

            /// Sets the value of [value][crate::model::report_summary::chart_data::DataPoint::value].
            pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.value = v.into();
                self
            }
        }

        impl wkt::message::Message for DataPoint {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.ChartData.DataPoint"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for DataPoint {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __label,
                    __value,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for DataPoint")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "label" => Ok(__FieldTag::__label),
                                    "value" => Ok(__FieldTag::__value),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = DataPoint;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct DataPoint")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__label => {
                                    if !fields.insert(__FieldTag::__label) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for label"),
                                        );
                                    }
                                    result.label = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__value => {
                                    if !fields.insert(__FieldTag::__value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for value"),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.value =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for DataPoint {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.label.is_empty() {
                    state.serialize_entry("label", &self.label)?;
                }
                if !wkt::internal::is_default(&self.value) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("value", &__With(&self.value))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for DataPoint {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("DataPoint");
                debug_struct.field("label", &self.label);
                debug_struct.field("value", &self.value);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// Utilization Chart is a specific type of visualization which displays
    /// a metric classified into "Used" and "Free" buckets.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UtilizationChartData {
        /// Aggregate value which falls into the "Used" bucket.
        pub used: i64,

        /// Aggregate value which falls into the "Free" bucket.
        pub free: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UtilizationChartData {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [used][crate::model::report_summary::UtilizationChartData::used].
        pub fn set_used<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.used = v.into();
            self
        }

        /// Sets the value of [free][crate::model::report_summary::UtilizationChartData::free].
        pub fn set_free<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.free = v.into();
            self
        }
    }

    impl wkt::message::Message for UtilizationChartData {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.UtilizationChartData"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for UtilizationChartData {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __used,
                __free,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for UtilizationChartData")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "used" => Ok(__FieldTag::__used),
                                "free" => Ok(__FieldTag::__free),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = UtilizationChartData;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct UtilizationChartData")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__used => {
                                if !fields.insert(__FieldTag::__used) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for used",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.used = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__free => {
                                if !fields.insert(__FieldTag::__free) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for free",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.free = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for UtilizationChartData {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.used) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("used", &__With(&self.used))?;
            }
            if !wkt::internal::is_default(&self.free) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("free", &__With(&self.free))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for UtilizationChartData {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("UtilizationChartData");
            debug_struct.field("used", &self.used);
            debug_struct.field("free", &self.free);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// A Histogram Chart shows a distribution of values into buckets, showing
    /// a count of values which fall into a bucket.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct HistogramChartData {
        /// Buckets in the histogram.
        /// There will be `n+1` buckets matching `n` lower bounds in the request.
        /// The first bucket will be from -infinity to the first bound.
        /// Subsequent buckets will be between one bound and the next.
        /// The final bucket will be from the final bound to infinity.
        pub buckets: std::vec::Vec<crate::model::report_summary::histogram_chart_data::Bucket>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl HistogramChartData {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [buckets][crate::model::report_summary::HistogramChartData::buckets].
        pub fn set_buckets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::report_summary::histogram_chart_data::Bucket>,
        {
            use std::iter::Iterator;
            self.buckets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for HistogramChartData {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.HistogramChartData"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for HistogramChartData {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __buckets,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for HistogramChartData")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "buckets" => Ok(__FieldTag::__buckets),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = HistogramChartData;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct HistogramChartData")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__buckets => {
                                if !fields.insert(__FieldTag::__buckets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for buckets",
                                    ));
                                }
                                result.buckets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::report_summary::histogram_chart_data::Bucket>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for HistogramChartData {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.buckets.is_empty() {
                state.serialize_entry("buckets", &self.buckets)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for HistogramChartData {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("HistogramChartData");
            debug_struct.field("buckets", &self.buckets);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [HistogramChartData].
    pub mod histogram_chart_data {
        #[allow(unused_imports)]
        use super::*;

        /// A histogram bucket with a lower and upper bound, and a count of items
        /// with a field value between those bounds.
        /// The lower bound is inclusive and the upper bound is exclusive.
        /// Lower bound may be -infinity and upper bound may be infinity.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Bucket {
            /// Lower bound - inclusive.
            pub lower_bound: i64,

            /// Upper bound - exclusive.
            pub upper_bound: i64,

            /// Count of items in the bucket.
            pub count: i64,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Bucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [lower_bound][crate::model::report_summary::histogram_chart_data::Bucket::lower_bound].
            pub fn set_lower_bound<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.lower_bound = v.into();
                self
            }

            /// Sets the value of [upper_bound][crate::model::report_summary::histogram_chart_data::Bucket::upper_bound].
            pub fn set_upper_bound<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.upper_bound = v.into();
                self
            }

            /// Sets the value of [count][crate::model::report_summary::histogram_chart_data::Bucket::count].
            pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.count = v.into();
                self
            }
        }

        impl wkt::message::Message for Bucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.HistogramChartData.Bucket"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Bucket {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __lower_bound,
                    __upper_bound,
                    __count,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Bucket")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "lowerBound" => Ok(__FieldTag::__lower_bound),
                                    "lower_bound" => Ok(__FieldTag::__lower_bound),
                                    "upperBound" => Ok(__FieldTag::__upper_bound),
                                    "upper_bound" => Ok(__FieldTag::__upper_bound),
                                    "count" => Ok(__FieldTag::__count),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Bucket;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Bucket")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__lower_bound => {
                                    if !fields.insert(__FieldTag::__lower_bound) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for lower_bound",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.lower_bound =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__upper_bound => {
                                    if !fields.insert(__FieldTag::__upper_bound) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for upper_bound",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.upper_bound =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__count => {
                                    if !fields.insert(__FieldTag::__count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for count"),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.count =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Bucket {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.lower_bound) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("lowerBound", &__With(&self.lower_bound))?;
                }
                if !wkt::internal::is_default(&self.upper_bound) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("upperBound", &__With(&self.upper_bound))?;
                }
                if !wkt::internal::is_default(&self.count) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("count", &__With(&self.count))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Bucket {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Bucket");
                debug_struct.field("lower_bound", &self.lower_bound);
                debug_struct.field("upper_bound", &self.upper_bound);
                debug_struct.field("count", &self.count);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// Aggregate statistics for a collection of assets.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AssetAggregateStats {
        /// Sum of the memory in bytes of all the assets in this collection.
        pub total_memory_bytes: i64,

        /// Sum of persistent storage in bytes of all the assets in this collection.
        pub total_storage_bytes: i64,

        /// Sum of the CPU core count of all the assets in this collection.
        pub total_cores: i64,

        /// Count of the number of unique assets in this collection.
        pub total_assets: i64,

        /// Total memory split into Used/Free buckets.
        pub memory_utilization_chart:
            std::option::Option<crate::model::report_summary::UtilizationChartData>,

        /// Total memory split into Used/Free buckets.
        pub storage_utilization_chart:
            std::option::Option<crate::model::report_summary::UtilizationChartData>,

        /// Count of assets grouped by Operating System families.
        pub operating_system: std::option::Option<crate::model::report_summary::ChartData>,

        /// Histogram showing a distribution of CPU core counts.
        pub core_count_histogram:
            std::option::Option<crate::model::report_summary::HistogramChartData>,

        /// Histogram showing a distribution of memory sizes.
        pub memory_bytes_histogram:
            std::option::Option<crate::model::report_summary::HistogramChartData>,

        /// Histogram showing a distribution of memory sizes.
        pub storage_bytes_histogram:
            std::option::Option<crate::model::report_summary::HistogramChartData>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AssetAggregateStats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [total_memory_bytes][crate::model::report_summary::AssetAggregateStats::total_memory_bytes].
        pub fn set_total_memory_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.total_memory_bytes = v.into();
            self
        }

        /// Sets the value of [total_storage_bytes][crate::model::report_summary::AssetAggregateStats::total_storage_bytes].
        pub fn set_total_storage_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.total_storage_bytes = v.into();
            self
        }

        /// Sets the value of [total_cores][crate::model::report_summary::AssetAggregateStats::total_cores].
        pub fn set_total_cores<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.total_cores = v.into();
            self
        }

        /// Sets the value of [total_assets][crate::model::report_summary::AssetAggregateStats::total_assets].
        pub fn set_total_assets<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.total_assets = v.into();
            self
        }

        /// Sets the value of [memory_utilization_chart][crate::model::report_summary::AssetAggregateStats::memory_utilization_chart].
        pub fn set_memory_utilization_chart<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::UtilizationChartData>,
        {
            self.memory_utilization_chart = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [memory_utilization_chart][crate::model::report_summary::AssetAggregateStats::memory_utilization_chart].
        pub fn set_or_clear_memory_utilization_chart<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::UtilizationChartData>,
        {
            self.memory_utilization_chart = v.map(|x| x.into());
            self
        }

        /// Sets the value of [storage_utilization_chart][crate::model::report_summary::AssetAggregateStats::storage_utilization_chart].
        pub fn set_storage_utilization_chart<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::UtilizationChartData>,
        {
            self.storage_utilization_chart = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [storage_utilization_chart][crate::model::report_summary::AssetAggregateStats::storage_utilization_chart].
        pub fn set_or_clear_storage_utilization_chart<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::UtilizationChartData>,
        {
            self.storage_utilization_chart = v.map(|x| x.into());
            self
        }

        /// Sets the value of [operating_system][crate::model::report_summary::AssetAggregateStats::operating_system].
        pub fn set_operating_system<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::ChartData>,
        {
            self.operating_system = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [operating_system][crate::model::report_summary::AssetAggregateStats::operating_system].
        pub fn set_or_clear_operating_system<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::ChartData>,
        {
            self.operating_system = v.map(|x| x.into());
            self
        }

        /// Sets the value of [core_count_histogram][crate::model::report_summary::AssetAggregateStats::core_count_histogram].
        pub fn set_core_count_histogram<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::HistogramChartData>,
        {
            self.core_count_histogram = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [core_count_histogram][crate::model::report_summary::AssetAggregateStats::core_count_histogram].
        pub fn set_or_clear_core_count_histogram<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::HistogramChartData>,
        {
            self.core_count_histogram = v.map(|x| x.into());
            self
        }

        /// Sets the value of [memory_bytes_histogram][crate::model::report_summary::AssetAggregateStats::memory_bytes_histogram].
        pub fn set_memory_bytes_histogram<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::HistogramChartData>,
        {
            self.memory_bytes_histogram = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [memory_bytes_histogram][crate::model::report_summary::AssetAggregateStats::memory_bytes_histogram].
        pub fn set_or_clear_memory_bytes_histogram<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::HistogramChartData>,
        {
            self.memory_bytes_histogram = v.map(|x| x.into());
            self
        }

        /// Sets the value of [storage_bytes_histogram][crate::model::report_summary::AssetAggregateStats::storage_bytes_histogram].
        pub fn set_storage_bytes_histogram<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::HistogramChartData>,
        {
            self.storage_bytes_histogram = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [storage_bytes_histogram][crate::model::report_summary::AssetAggregateStats::storage_bytes_histogram].
        pub fn set_or_clear_storage_bytes_histogram<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::HistogramChartData>,
        {
            self.storage_bytes_histogram = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for AssetAggregateStats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.AssetAggregateStats"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AssetAggregateStats {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __total_memory_bytes,
                __total_storage_bytes,
                __total_cores,
                __total_assets,
                __memory_utilization_chart,
                __storage_utilization_chart,
                __operating_system,
                __core_count_histogram,
                __memory_bytes_histogram,
                __storage_bytes_histogram,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AssetAggregateStats")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "totalMemoryBytes" => Ok(__FieldTag::__total_memory_bytes),
                                "total_memory_bytes" => Ok(__FieldTag::__total_memory_bytes),
                                "totalStorageBytes" => Ok(__FieldTag::__total_storage_bytes),
                                "total_storage_bytes" => Ok(__FieldTag::__total_storage_bytes),
                                "totalCores" => Ok(__FieldTag::__total_cores),
                                "total_cores" => Ok(__FieldTag::__total_cores),
                                "totalAssets" => Ok(__FieldTag::__total_assets),
                                "total_assets" => Ok(__FieldTag::__total_assets),
                                "memoryUtilizationChart" => {
                                    Ok(__FieldTag::__memory_utilization_chart)
                                }
                                "memory_utilization_chart" => {
                                    Ok(__FieldTag::__memory_utilization_chart)
                                }
                                "storageUtilizationChart" => {
                                    Ok(__FieldTag::__storage_utilization_chart)
                                }
                                "storage_utilization_chart" => {
                                    Ok(__FieldTag::__storage_utilization_chart)
                                }
                                "operatingSystem" => Ok(__FieldTag::__operating_system),
                                "operating_system" => Ok(__FieldTag::__operating_system),
                                "coreCountHistogram" => Ok(__FieldTag::__core_count_histogram),
                                "core_count_histogram" => Ok(__FieldTag::__core_count_histogram),
                                "memoryBytesHistogram" => Ok(__FieldTag::__memory_bytes_histogram),
                                "memory_bytes_histogram" => {
                                    Ok(__FieldTag::__memory_bytes_histogram)
                                }
                                "storageBytesHistogram" => {
                                    Ok(__FieldTag::__storage_bytes_histogram)
                                }
                                "storage_bytes_histogram" => {
                                    Ok(__FieldTag::__storage_bytes_histogram)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AssetAggregateStats;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AssetAggregateStats")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__total_memory_bytes => {
                                if !fields.insert(__FieldTag::__total_memory_bytes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for total_memory_bytes",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.total_memory_bytes =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__total_storage_bytes => {
                                if !fields.insert(__FieldTag::__total_storage_bytes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for total_storage_bytes",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.total_storage_bytes =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__total_cores => {
                                if !fields.insert(__FieldTag::__total_cores) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for total_cores",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.total_cores =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__total_assets => {
                                if !fields.insert(__FieldTag::__total_assets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for total_assets",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.total_assets =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__memory_utilization_chart => {
                                if !fields.insert(__FieldTag::__memory_utilization_chart) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for memory_utilization_chart",
                                    ));
                                }
                                result.memory_utilization_chart = map
                                    .next_value::<std::option::Option<
                                        crate::model::report_summary::UtilizationChartData,
                                    >>()?;
                            }
                            __FieldTag::__storage_utilization_chart => {
                                if !fields.insert(__FieldTag::__storage_utilization_chart) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for storage_utilization_chart",
                                    ));
                                }
                                result.storage_utilization_chart = map
                                    .next_value::<std::option::Option<
                                        crate::model::report_summary::UtilizationChartData,
                                    >>()?;
                            }
                            __FieldTag::__operating_system => {
                                if !fields.insert(__FieldTag::__operating_system) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for operating_system",
                                    ));
                                }
                                result.operating_system =
                                    map.next_value::<std::option::Option<
                                        crate::model::report_summary::ChartData,
                                    >>()?;
                            }
                            __FieldTag::__core_count_histogram => {
                                if !fields.insert(__FieldTag::__core_count_histogram) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for core_count_histogram",
                                    ));
                                }
                                result.core_count_histogram = map
                                    .next_value::<std::option::Option<
                                        crate::model::report_summary::HistogramChartData,
                                    >>()?;
                            }
                            __FieldTag::__memory_bytes_histogram => {
                                if !fields.insert(__FieldTag::__memory_bytes_histogram) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for memory_bytes_histogram",
                                    ));
                                }
                                result.memory_bytes_histogram = map
                                    .next_value::<std::option::Option<
                                        crate::model::report_summary::HistogramChartData,
                                    >>()?;
                            }
                            __FieldTag::__storage_bytes_histogram => {
                                if !fields.insert(__FieldTag::__storage_bytes_histogram) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for storage_bytes_histogram",
                                    ));
                                }
                                result.storage_bytes_histogram = map
                                    .next_value::<std::option::Option<
                                        crate::model::report_summary::HistogramChartData,
                                    >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AssetAggregateStats {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.total_memory_bytes) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("totalMemoryBytes", &__With(&self.total_memory_bytes))?;
            }
            if !wkt::internal::is_default(&self.total_storage_bytes) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("totalStorageBytes", &__With(&self.total_storage_bytes))?;
            }
            if !wkt::internal::is_default(&self.total_cores) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("totalCores", &__With(&self.total_cores))?;
            }
            if !wkt::internal::is_default(&self.total_assets) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("totalAssets", &__With(&self.total_assets))?;
            }
            if self.memory_utilization_chart.is_some() {
                state.serialize_entry("memoryUtilizationChart", &self.memory_utilization_chart)?;
            }
            if self.storage_utilization_chart.is_some() {
                state
                    .serialize_entry("storageUtilizationChart", &self.storage_utilization_chart)?;
            }
            if self.operating_system.is_some() {
                state.serialize_entry("operatingSystem", &self.operating_system)?;
            }
            if self.core_count_histogram.is_some() {
                state.serialize_entry("coreCountHistogram", &self.core_count_histogram)?;
            }
            if self.memory_bytes_histogram.is_some() {
                state.serialize_entry("memoryBytesHistogram", &self.memory_bytes_histogram)?;
            }
            if self.storage_bytes_histogram.is_some() {
                state.serialize_entry("storageBytesHistogram", &self.storage_bytes_histogram)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AssetAggregateStats {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AssetAggregateStats");
            debug_struct.field("total_memory_bytes", &self.total_memory_bytes);
            debug_struct.field("total_storage_bytes", &self.total_storage_bytes);
            debug_struct.field("total_cores", &self.total_cores);
            debug_struct.field("total_assets", &self.total_assets);
            debug_struct.field("memory_utilization_chart", &self.memory_utilization_chart);
            debug_struct.field("storage_utilization_chart", &self.storage_utilization_chart);
            debug_struct.field("operating_system", &self.operating_system);
            debug_struct.field("core_count_histogram", &self.core_count_histogram);
            debug_struct.field("memory_bytes_histogram", &self.memory_bytes_histogram);
            debug_struct.field("storage_bytes_histogram", &self.storage_bytes_histogram);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Represents a data point tracking the count of assets allocated for a
    /// specific Machine Series.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MachineSeriesAllocation {
        /// The Machine Series (e.g. "E2", "N2")
        pub machine_series: std::option::Option<crate::model::MachineSeries>,

        /// Count of assets allocated to this machine series.
        pub allocated_asset_count: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MachineSeriesAllocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [machine_series][crate::model::report_summary::MachineSeriesAllocation::machine_series].
        pub fn set_machine_series<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::MachineSeries>,
        {
            self.machine_series = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [machine_series][crate::model::report_summary::MachineSeriesAllocation::machine_series].
        pub fn set_or_clear_machine_series<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::MachineSeries>,
        {
            self.machine_series = v.map(|x| x.into());
            self
        }

        /// Sets the value of [allocated_asset_count][crate::model::report_summary::MachineSeriesAllocation::allocated_asset_count].
        pub fn set_allocated_asset_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.allocated_asset_count = v.into();
            self
        }
    }

    impl wkt::message::Message for MachineSeriesAllocation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.MachineSeriesAllocation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MachineSeriesAllocation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __machine_series,
                __allocated_asset_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MachineSeriesAllocation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "machineSeries" => Ok(__FieldTag::__machine_series),
                                "machine_series" => Ok(__FieldTag::__machine_series),
                                "allocatedAssetCount" => Ok(__FieldTag::__allocated_asset_count),
                                "allocated_asset_count" => Ok(__FieldTag::__allocated_asset_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MachineSeriesAllocation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MachineSeriesAllocation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__machine_series => {
                                if !fields.insert(__FieldTag::__machine_series) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for machine_series",
                                    ));
                                }
                                result.machine_series = map
                                    .next_value::<std::option::Option<crate::model::MachineSeries>>(
                                    )?;
                            }
                            __FieldTag::__allocated_asset_count => {
                                if !fields.insert(__FieldTag::__allocated_asset_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allocated_asset_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.allocated_asset_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MachineSeriesAllocation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.machine_series.is_some() {
                state.serialize_entry("machineSeries", &self.machine_series)?;
            }
            if !wkt::internal::is_default(&self.allocated_asset_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state
                    .serialize_entry("allocatedAssetCount", &__With(&self.allocated_asset_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for MachineSeriesAllocation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("MachineSeriesAllocation");
            debug_struct.field("machine_series", &self.machine_series);
            debug_struct.field("allocated_asset_count", &self.allocated_asset_count);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// A set of findings that applies to assets destined for Compute Engine.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ComputeEngineFinding {
        /// Set of regions in which the assets were allocated.
        pub allocated_regions: std::vec::Vec<std::string::String>,

        /// Count of assets which were allocated.
        pub allocated_asset_count: i64,

        /// Distribution of assets based on the Machine Series.
        pub machine_series_allocations:
            std::vec::Vec<crate::model::report_summary::MachineSeriesAllocation>,

        /// Set of disk types allocated to assets.
        pub allocated_disk_types: std::vec::Vec<crate::model::PersistentDiskType>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ComputeEngineFinding {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [allocated_regions][crate::model::report_summary::ComputeEngineFinding::allocated_regions].
        pub fn set_allocated_regions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allocated_regions = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [allocated_asset_count][crate::model::report_summary::ComputeEngineFinding::allocated_asset_count].
        pub fn set_allocated_asset_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.allocated_asset_count = v.into();
            self
        }

        /// Sets the value of [machine_series_allocations][crate::model::report_summary::ComputeEngineFinding::machine_series_allocations].
        pub fn set_machine_series_allocations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::report_summary::MachineSeriesAllocation>,
        {
            use std::iter::Iterator;
            self.machine_series_allocations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [allocated_disk_types][crate::model::report_summary::ComputeEngineFinding::allocated_disk_types].
        pub fn set_allocated_disk_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::PersistentDiskType>,
        {
            use std::iter::Iterator;
            self.allocated_disk_types = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ComputeEngineFinding {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.ComputeEngineFinding"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ComputeEngineFinding {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __allocated_regions,
                __allocated_asset_count,
                __machine_series_allocations,
                __allocated_disk_types,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ComputeEngineFinding")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "allocatedRegions" => Ok(__FieldTag::__allocated_regions),
                                "allocated_regions" => Ok(__FieldTag::__allocated_regions),
                                "allocatedAssetCount" => Ok(__FieldTag::__allocated_asset_count),
                                "allocated_asset_count" => Ok(__FieldTag::__allocated_asset_count),
                                "machineSeriesAllocations" => {
                                    Ok(__FieldTag::__machine_series_allocations)
                                }
                                "machine_series_allocations" => {
                                    Ok(__FieldTag::__machine_series_allocations)
                                }
                                "allocatedDiskTypes" => Ok(__FieldTag::__allocated_disk_types),
                                "allocated_disk_types" => Ok(__FieldTag::__allocated_disk_types),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ComputeEngineFinding;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ComputeEngineFinding")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__allocated_regions => {
                                if !fields.insert(__FieldTag::__allocated_regions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allocated_regions",
                                    ));
                                }
                                result.allocated_regions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__allocated_asset_count => {
                                if !fields.insert(__FieldTag::__allocated_asset_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allocated_asset_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.allocated_asset_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__machine_series_allocations => {
                                if !fields.insert(__FieldTag::__machine_series_allocations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for machine_series_allocations",
                                    ));
                                }
                                result.machine_series_allocations = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::report_summary::MachineSeriesAllocation,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__allocated_disk_types => {
                                if !fields.insert(__FieldTag::__allocated_disk_types) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allocated_disk_types",
                                    ));
                                }
                                result.allocated_disk_types = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::PersistentDiskType>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ComputeEngineFinding {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.allocated_regions.is_empty() {
                state.serialize_entry("allocatedRegions", &self.allocated_regions)?;
            }
            if !wkt::internal::is_default(&self.allocated_asset_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state
                    .serialize_entry("allocatedAssetCount", &__With(&self.allocated_asset_count))?;
            }
            if !self.machine_series_allocations.is_empty() {
                state.serialize_entry(
                    "machineSeriesAllocations",
                    &self.machine_series_allocations,
                )?;
            }
            if !self.allocated_disk_types.is_empty() {
                state.serialize_entry("allocatedDiskTypes", &self.allocated_disk_types)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ComputeEngineFinding {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ComputeEngineFinding");
            debug_struct.field("allocated_regions", &self.allocated_regions);
            debug_struct.field("allocated_asset_count", &self.allocated_asset_count);
            debug_struct.field(
                "machine_series_allocations",
                &self.machine_series_allocations,
            );
            debug_struct.field("allocated_disk_types", &self.allocated_disk_types);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// A set of findings that applies to assets destined for VMWare Engine.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VmwareEngineFinding {
        /// Set of regions in which the assets were allocated
        pub allocated_regions: std::vec::Vec<std::string::String>,

        /// Count of assets which are allocated
        pub allocated_asset_count: i64,

        /// Set of per-nodetype allocation records
        pub node_allocations: std::vec::Vec<crate::model::report_summary::VmwareNodeAllocation>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VmwareEngineFinding {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [allocated_regions][crate::model::report_summary::VmwareEngineFinding::allocated_regions].
        pub fn set_allocated_regions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allocated_regions = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [allocated_asset_count][crate::model::report_summary::VmwareEngineFinding::allocated_asset_count].
        pub fn set_allocated_asset_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.allocated_asset_count = v.into();
            self
        }

        /// Sets the value of [node_allocations][crate::model::report_summary::VmwareEngineFinding::node_allocations].
        pub fn set_node_allocations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::report_summary::VmwareNodeAllocation>,
        {
            use std::iter::Iterator;
            self.node_allocations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for VmwareEngineFinding {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.VmwareEngineFinding"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for VmwareEngineFinding {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __allocated_regions,
                __allocated_asset_count,
                __node_allocations,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for VmwareEngineFinding")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "allocatedRegions" => Ok(__FieldTag::__allocated_regions),
                                "allocated_regions" => Ok(__FieldTag::__allocated_regions),
                                "allocatedAssetCount" => Ok(__FieldTag::__allocated_asset_count),
                                "allocated_asset_count" => Ok(__FieldTag::__allocated_asset_count),
                                "nodeAllocations" => Ok(__FieldTag::__node_allocations),
                                "node_allocations" => Ok(__FieldTag::__node_allocations),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = VmwareEngineFinding;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct VmwareEngineFinding")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__allocated_regions => {
                                if !fields.insert(__FieldTag::__allocated_regions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allocated_regions",
                                    ));
                                }
                                result.allocated_regions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__allocated_asset_count => {
                                if !fields.insert(__FieldTag::__allocated_asset_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allocated_asset_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.allocated_asset_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__node_allocations => {
                                if !fields.insert(__FieldTag::__node_allocations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for node_allocations",
                                    ));
                                }
                                result.node_allocations = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::report_summary::VmwareNodeAllocation,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for VmwareEngineFinding {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.allocated_regions.is_empty() {
                state.serialize_entry("allocatedRegions", &self.allocated_regions)?;
            }
            if !wkt::internal::is_default(&self.allocated_asset_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state
                    .serialize_entry("allocatedAssetCount", &__With(&self.allocated_asset_count))?;
            }
            if !self.node_allocations.is_empty() {
                state.serialize_entry("nodeAllocations", &self.node_allocations)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for VmwareEngineFinding {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("VmwareEngineFinding");
            debug_struct.field("allocated_regions", &self.allocated_regions);
            debug_struct.field("allocated_asset_count", &self.allocated_asset_count);
            debug_struct.field("node_allocations", &self.node_allocations);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Represents assets allocated to a specific VMWare Node type.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VmwareNodeAllocation {
        /// VMWare node type, e.g. "ve1-standard-72"
        pub vmware_node: std::option::Option<crate::model::report_summary::VmwareNode>,

        /// Count of this node type to be provisioned
        pub node_count: i64,

        /// Count of assets allocated to these nodes
        pub allocated_asset_count: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VmwareNodeAllocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [vmware_node][crate::model::report_summary::VmwareNodeAllocation::vmware_node].
        pub fn set_vmware_node<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::VmwareNode>,
        {
            self.vmware_node = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [vmware_node][crate::model::report_summary::VmwareNodeAllocation::vmware_node].
        pub fn set_or_clear_vmware_node<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::VmwareNode>,
        {
            self.vmware_node = v.map(|x| x.into());
            self
        }

        /// Sets the value of [node_count][crate::model::report_summary::VmwareNodeAllocation::node_count].
        pub fn set_node_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.node_count = v.into();
            self
        }

        /// Sets the value of [allocated_asset_count][crate::model::report_summary::VmwareNodeAllocation::allocated_asset_count].
        pub fn set_allocated_asset_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.allocated_asset_count = v.into();
            self
        }
    }

    impl wkt::message::Message for VmwareNodeAllocation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.VmwareNodeAllocation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for VmwareNodeAllocation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __vmware_node,
                __node_count,
                __allocated_asset_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for VmwareNodeAllocation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "vmwareNode" => Ok(__FieldTag::__vmware_node),
                                "vmware_node" => Ok(__FieldTag::__vmware_node),
                                "nodeCount" => Ok(__FieldTag::__node_count),
                                "node_count" => Ok(__FieldTag::__node_count),
                                "allocatedAssetCount" => Ok(__FieldTag::__allocated_asset_count),
                                "allocated_asset_count" => Ok(__FieldTag::__allocated_asset_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = VmwareNodeAllocation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct VmwareNodeAllocation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__vmware_node => {
                                if !fields.insert(__FieldTag::__vmware_node) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for vmware_node",
                                    ));
                                }
                                result.vmware_node =
                                    map.next_value::<std::option::Option<
                                        crate::model::report_summary::VmwareNode,
                                    >>()?;
                            }
                            __FieldTag::__node_count => {
                                if !fields.insert(__FieldTag::__node_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for node_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.node_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__allocated_asset_count => {
                                if !fields.insert(__FieldTag::__allocated_asset_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allocated_asset_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.allocated_asset_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for VmwareNodeAllocation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.vmware_node.is_some() {
                state.serialize_entry("vmwareNode", &self.vmware_node)?;
            }
            if !wkt::internal::is_default(&self.node_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("nodeCount", &__With(&self.node_count))?;
            }
            if !wkt::internal::is_default(&self.allocated_asset_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state
                    .serialize_entry("allocatedAssetCount", &__With(&self.allocated_asset_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for VmwareNodeAllocation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("VmwareNodeAllocation");
            debug_struct.field("vmware_node", &self.vmware_node);
            debug_struct.field("node_count", &self.node_count);
            debug_struct.field("allocated_asset_count", &self.allocated_asset_count);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// A VMWare Engine Node
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VmwareNode {
        /// Code to identify VMware Engine node series, e.g. "ve1-standard-72". Based
        /// on the displayName of
        /// cloud.google.com/vmware-engine/docs/reference/rest/v1/projects.locations.nodeTypes
        pub code: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VmwareNode {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::report_summary::VmwareNode::code].
        pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.code = v.into();
            self
        }
    }

    impl wkt::message::Message for VmwareNode {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.VmwareNode"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for VmwareNode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __code,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for VmwareNode")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "code" => Ok(__FieldTag::__code),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = VmwareNode;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct VmwareNode")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__code => {
                                if !fields.insert(__FieldTag::__code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for code",
                                    ));
                                }
                                result.code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for VmwareNode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.code.is_empty() {
                state.serialize_entry("code", &self.code)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for VmwareNode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("VmwareNode");
            debug_struct.field("code", &self.code);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// A set of findings that applies to assets destined for Sole-Tenant nodes.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SoleTenantFinding {
        /// Set of regions in which the assets are allocated
        pub allocated_regions: std::vec::Vec<std::string::String>,

        /// Count of assets which are allocated
        pub allocated_asset_count: i64,

        /// Set of per-nodetype allocation records
        pub node_allocations: std::vec::Vec<crate::model::report_summary::SoleTenantNodeAllocation>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SoleTenantFinding {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [allocated_regions][crate::model::report_summary::SoleTenantFinding::allocated_regions].
        pub fn set_allocated_regions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allocated_regions = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [allocated_asset_count][crate::model::report_summary::SoleTenantFinding::allocated_asset_count].
        pub fn set_allocated_asset_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.allocated_asset_count = v.into();
            self
        }

        /// Sets the value of [node_allocations][crate::model::report_summary::SoleTenantFinding::node_allocations].
        pub fn set_node_allocations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::report_summary::SoleTenantNodeAllocation>,
        {
            use std::iter::Iterator;
            self.node_allocations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SoleTenantFinding {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.SoleTenantFinding"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SoleTenantFinding {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __allocated_regions,
                __allocated_asset_count,
                __node_allocations,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SoleTenantFinding")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "allocatedRegions" => Ok(__FieldTag::__allocated_regions),
                                "allocated_regions" => Ok(__FieldTag::__allocated_regions),
                                "allocatedAssetCount" => Ok(__FieldTag::__allocated_asset_count),
                                "allocated_asset_count" => Ok(__FieldTag::__allocated_asset_count),
                                "nodeAllocations" => Ok(__FieldTag::__node_allocations),
                                "node_allocations" => Ok(__FieldTag::__node_allocations),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SoleTenantFinding;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SoleTenantFinding")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__allocated_regions => {
                                if !fields.insert(__FieldTag::__allocated_regions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allocated_regions",
                                    ));
                                }
                                result.allocated_regions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__allocated_asset_count => {
                                if !fields.insert(__FieldTag::__allocated_asset_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allocated_asset_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.allocated_asset_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__node_allocations => {
                                if !fields.insert(__FieldTag::__node_allocations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for node_allocations",
                                    ));
                                }
                                result.node_allocations = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::report_summary::SoleTenantNodeAllocation,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SoleTenantFinding {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.allocated_regions.is_empty() {
                state.serialize_entry("allocatedRegions", &self.allocated_regions)?;
            }
            if !wkt::internal::is_default(&self.allocated_asset_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state
                    .serialize_entry("allocatedAssetCount", &__With(&self.allocated_asset_count))?;
            }
            if !self.node_allocations.is_empty() {
                state.serialize_entry("nodeAllocations", &self.node_allocations)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SoleTenantFinding {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SoleTenantFinding");
            debug_struct.field("allocated_regions", &self.allocated_regions);
            debug_struct.field("allocated_asset_count", &self.allocated_asset_count);
            debug_struct.field("node_allocations", &self.node_allocations);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Represents the assets allocated to a specific Sole-Tenant node type.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SoleTenantNodeAllocation {
        /// Sole Tenant node type, e.g. "m3-node-128-3904"
        pub node: std::option::Option<crate::model::SoleTenantNodeType>,

        /// Count of this node type to be provisioned
        pub node_count: i64,

        /// Count of assets allocated to these nodes
        pub allocated_asset_count: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SoleTenantNodeAllocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [node][crate::model::report_summary::SoleTenantNodeAllocation::node].
        pub fn set_node<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::SoleTenantNodeType>,
        {
            self.node = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [node][crate::model::report_summary::SoleTenantNodeAllocation::node].
        pub fn set_or_clear_node<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::SoleTenantNodeType>,
        {
            self.node = v.map(|x| x.into());
            self
        }

        /// Sets the value of [node_count][crate::model::report_summary::SoleTenantNodeAllocation::node_count].
        pub fn set_node_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.node_count = v.into();
            self
        }

        /// Sets the value of [allocated_asset_count][crate::model::report_summary::SoleTenantNodeAllocation::allocated_asset_count].
        pub fn set_allocated_asset_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.allocated_asset_count = v.into();
            self
        }
    }

    impl wkt::message::Message for SoleTenantNodeAllocation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.SoleTenantNodeAllocation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SoleTenantNodeAllocation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __node,
                __node_count,
                __allocated_asset_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SoleTenantNodeAllocation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "node" => Ok(__FieldTag::__node),
                                "nodeCount" => Ok(__FieldTag::__node_count),
                                "node_count" => Ok(__FieldTag::__node_count),
                                "allocatedAssetCount" => Ok(__FieldTag::__allocated_asset_count),
                                "allocated_asset_count" => Ok(__FieldTag::__allocated_asset_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SoleTenantNodeAllocation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SoleTenantNodeAllocation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__node => {
                                if !fields.insert(__FieldTag::__node) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for node",
                                    ));
                                }
                                result.node = map.next_value::<std::option::Option<crate::model::SoleTenantNodeType>>()?
                                    ;
                            }
                            __FieldTag::__node_count => {
                                if !fields.insert(__FieldTag::__node_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for node_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.node_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__allocated_asset_count => {
                                if !fields.insert(__FieldTag::__allocated_asset_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allocated_asset_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.allocated_asset_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SoleTenantNodeAllocation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.node.is_some() {
                state.serialize_entry("node", &self.node)?;
            }
            if !wkt::internal::is_default(&self.node_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("nodeCount", &__With(&self.node_count))?;
            }
            if !wkt::internal::is_default(&self.allocated_asset_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state
                    .serialize_entry("allocatedAssetCount", &__With(&self.allocated_asset_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SoleTenantNodeAllocation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SoleTenantNodeAllocation");
            debug_struct.field("node", &self.node);
            debug_struct.field("node_count", &self.node_count);
            debug_struct.field("allocated_asset_count", &self.allocated_asset_count);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Summary Findings for a specific Group/PreferenceSet combination.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GroupPreferenceSetFinding {
        /// Display Name of the Preference Set
        pub display_name: std::string::String,

        /// Description for the Preference Set.
        pub description: std::string::String,

        /// A set of preferences that applies to all machines in the context.
        pub machine_preferences: std::option::Option<crate::model::VirtualMachinePreferences>,

        /// Total monthly cost for this preference set.
        pub monthly_cost_total: std::option::Option<gtype::model::Money>,

        /// Compute monthly cost for this preference set.
        pub monthly_cost_compute: std::option::Option<gtype::model::Money>,

        /// Licensing monthly cost for this preference set.
        pub monthly_cost_os_license: std::option::Option<gtype::model::Money>,

        /// Network Egress monthly cost for this preference set.
        pub monthly_cost_network_egress: std::option::Option<gtype::model::Money>,

        /// Storage monthly cost for this preference set.
        pub monthly_cost_storage: std::option::Option<gtype::model::Money>,

        /// Miscellaneous monthly cost for this preference set.
        pub monthly_cost_other: std::option::Option<gtype::model::Money>,

        /// A set of findings that applies to Compute Engine machines in the input.
        pub compute_engine_finding:
            std::option::Option<crate::model::report_summary::ComputeEngineFinding>,

        /// A set of findings that applies to VMWare machines in the input.
        pub vmware_engine_finding:
            std::option::Option<crate::model::report_summary::VmwareEngineFinding>,

        /// A set of findings that applies to Sole-Tenant machines in the input.
        pub sole_tenant_finding:
            std::option::Option<crate::model::report_summary::SoleTenantFinding>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GroupPreferenceSetFinding {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::report_summary::GroupPreferenceSetFinding::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [description][crate::model::report_summary::GroupPreferenceSetFinding::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [machine_preferences][crate::model::report_summary::GroupPreferenceSetFinding::machine_preferences].
        pub fn set_machine_preferences<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::VirtualMachinePreferences>,
        {
            self.machine_preferences = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [machine_preferences][crate::model::report_summary::GroupPreferenceSetFinding::machine_preferences].
        pub fn set_or_clear_machine_preferences<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::VirtualMachinePreferences>,
        {
            self.machine_preferences = v.map(|x| x.into());
            self
        }

        /// Sets the value of [monthly_cost_total][crate::model::report_summary::GroupPreferenceSetFinding::monthly_cost_total].
        pub fn set_monthly_cost_total<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::Money>,
        {
            self.monthly_cost_total = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [monthly_cost_total][crate::model::report_summary::GroupPreferenceSetFinding::monthly_cost_total].
        pub fn set_or_clear_monthly_cost_total<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::Money>,
        {
            self.monthly_cost_total = v.map(|x| x.into());
            self
        }

        /// Sets the value of [monthly_cost_compute][crate::model::report_summary::GroupPreferenceSetFinding::monthly_cost_compute].
        pub fn set_monthly_cost_compute<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::Money>,
        {
            self.monthly_cost_compute = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [monthly_cost_compute][crate::model::report_summary::GroupPreferenceSetFinding::monthly_cost_compute].
        pub fn set_or_clear_monthly_cost_compute<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::Money>,
        {
            self.monthly_cost_compute = v.map(|x| x.into());
            self
        }

        /// Sets the value of [monthly_cost_os_license][crate::model::report_summary::GroupPreferenceSetFinding::monthly_cost_os_license].
        pub fn set_monthly_cost_os_license<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::Money>,
        {
            self.monthly_cost_os_license = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [monthly_cost_os_license][crate::model::report_summary::GroupPreferenceSetFinding::monthly_cost_os_license].
        pub fn set_or_clear_monthly_cost_os_license<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::Money>,
        {
            self.monthly_cost_os_license = v.map(|x| x.into());
            self
        }

        /// Sets the value of [monthly_cost_network_egress][crate::model::report_summary::GroupPreferenceSetFinding::monthly_cost_network_egress].
        pub fn set_monthly_cost_network_egress<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::Money>,
        {
            self.monthly_cost_network_egress = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [monthly_cost_network_egress][crate::model::report_summary::GroupPreferenceSetFinding::monthly_cost_network_egress].
        pub fn set_or_clear_monthly_cost_network_egress<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<gtype::model::Money>,
        {
            self.monthly_cost_network_egress = v.map(|x| x.into());
            self
        }

        /// Sets the value of [monthly_cost_storage][crate::model::report_summary::GroupPreferenceSetFinding::monthly_cost_storage].
        pub fn set_monthly_cost_storage<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::Money>,
        {
            self.monthly_cost_storage = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [monthly_cost_storage][crate::model::report_summary::GroupPreferenceSetFinding::monthly_cost_storage].
        pub fn set_or_clear_monthly_cost_storage<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::Money>,
        {
            self.monthly_cost_storage = v.map(|x| x.into());
            self
        }

        /// Sets the value of [monthly_cost_other][crate::model::report_summary::GroupPreferenceSetFinding::monthly_cost_other].
        pub fn set_monthly_cost_other<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::Money>,
        {
            self.monthly_cost_other = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [monthly_cost_other][crate::model::report_summary::GroupPreferenceSetFinding::monthly_cost_other].
        pub fn set_or_clear_monthly_cost_other<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::Money>,
        {
            self.monthly_cost_other = v.map(|x| x.into());
            self
        }

        /// Sets the value of [compute_engine_finding][crate::model::report_summary::GroupPreferenceSetFinding::compute_engine_finding].
        pub fn set_compute_engine_finding<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::ComputeEngineFinding>,
        {
            self.compute_engine_finding = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [compute_engine_finding][crate::model::report_summary::GroupPreferenceSetFinding::compute_engine_finding].
        pub fn set_or_clear_compute_engine_finding<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::ComputeEngineFinding>,
        {
            self.compute_engine_finding = v.map(|x| x.into());
            self
        }

        /// Sets the value of [vmware_engine_finding][crate::model::report_summary::GroupPreferenceSetFinding::vmware_engine_finding].
        pub fn set_vmware_engine_finding<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::VmwareEngineFinding>,
        {
            self.vmware_engine_finding = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [vmware_engine_finding][crate::model::report_summary::GroupPreferenceSetFinding::vmware_engine_finding].
        pub fn set_or_clear_vmware_engine_finding<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::VmwareEngineFinding>,
        {
            self.vmware_engine_finding = v.map(|x| x.into());
            self
        }

        /// Sets the value of [sole_tenant_finding][crate::model::report_summary::GroupPreferenceSetFinding::sole_tenant_finding].
        pub fn set_sole_tenant_finding<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::SoleTenantFinding>,
        {
            self.sole_tenant_finding = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [sole_tenant_finding][crate::model::report_summary::GroupPreferenceSetFinding::sole_tenant_finding].
        pub fn set_or_clear_sole_tenant_finding<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::SoleTenantFinding>,
        {
            self.sole_tenant_finding = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for GroupPreferenceSetFinding {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.GroupPreferenceSetFinding"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GroupPreferenceSetFinding {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __display_name,
                __description,
                __machine_preferences,
                __monthly_cost_total,
                __monthly_cost_compute,
                __monthly_cost_os_license,
                __monthly_cost_network_egress,
                __monthly_cost_storage,
                __monthly_cost_other,
                __compute_engine_finding,
                __vmware_engine_finding,
                __sole_tenant_finding,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GroupPreferenceSetFinding")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                "description" => Ok(__FieldTag::__description),
                                "machinePreferences" => Ok(__FieldTag::__machine_preferences),
                                "machine_preferences" => Ok(__FieldTag::__machine_preferences),
                                "monthlyCostTotal" => Ok(__FieldTag::__monthly_cost_total),
                                "monthly_cost_total" => Ok(__FieldTag::__monthly_cost_total),
                                "monthlyCostCompute" => Ok(__FieldTag::__monthly_cost_compute),
                                "monthly_cost_compute" => Ok(__FieldTag::__monthly_cost_compute),
                                "monthlyCostOsLicense" => Ok(__FieldTag::__monthly_cost_os_license),
                                "monthly_cost_os_license" => {
                                    Ok(__FieldTag::__monthly_cost_os_license)
                                }
                                "monthlyCostNetworkEgress" => {
                                    Ok(__FieldTag::__monthly_cost_network_egress)
                                }
                                "monthly_cost_network_egress" => {
                                    Ok(__FieldTag::__monthly_cost_network_egress)
                                }
                                "monthlyCostStorage" => Ok(__FieldTag::__monthly_cost_storage),
                                "monthly_cost_storage" => Ok(__FieldTag::__monthly_cost_storage),
                                "monthlyCostOther" => Ok(__FieldTag::__monthly_cost_other),
                                "monthly_cost_other" => Ok(__FieldTag::__monthly_cost_other),
                                "computeEngineFinding" => Ok(__FieldTag::__compute_engine_finding),
                                "compute_engine_finding" => {
                                    Ok(__FieldTag::__compute_engine_finding)
                                }
                                "vmwareEngineFinding" => Ok(__FieldTag::__vmware_engine_finding),
                                "vmware_engine_finding" => Ok(__FieldTag::__vmware_engine_finding),
                                "soleTenantFinding" => Ok(__FieldTag::__sole_tenant_finding),
                                "sole_tenant_finding" => Ok(__FieldTag::__sole_tenant_finding),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GroupPreferenceSetFinding;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GroupPreferenceSetFinding")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__machine_preferences => {
                                if !fields.insert(__FieldTag::__machine_preferences) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for machine_preferences",
                                    ));
                                }
                                result.machine_preferences =
                                    map.next_value::<std::option::Option<
                                        crate::model::VirtualMachinePreferences,
                                    >>()?;
                            }
                            __FieldTag::__monthly_cost_total => {
                                if !fields.insert(__FieldTag::__monthly_cost_total) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for monthly_cost_total",
                                    ));
                                }
                                result.monthly_cost_total =
                                    map.next_value::<std::option::Option<gtype::model::Money>>()?;
                            }
                            __FieldTag::__monthly_cost_compute => {
                                if !fields.insert(__FieldTag::__monthly_cost_compute) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for monthly_cost_compute",
                                    ));
                                }
                                result.monthly_cost_compute =
                                    map.next_value::<std::option::Option<gtype::model::Money>>()?;
                            }
                            __FieldTag::__monthly_cost_os_license => {
                                if !fields.insert(__FieldTag::__monthly_cost_os_license) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for monthly_cost_os_license",
                                    ));
                                }
                                result.monthly_cost_os_license =
                                    map.next_value::<std::option::Option<gtype::model::Money>>()?;
                            }
                            __FieldTag::__monthly_cost_network_egress => {
                                if !fields.insert(__FieldTag::__monthly_cost_network_egress) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for monthly_cost_network_egress",
                                    ));
                                }
                                result.monthly_cost_network_egress =
                                    map.next_value::<std::option::Option<gtype::model::Money>>()?;
                            }
                            __FieldTag::__monthly_cost_storage => {
                                if !fields.insert(__FieldTag::__monthly_cost_storage) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for monthly_cost_storage",
                                    ));
                                }
                                result.monthly_cost_storage =
                                    map.next_value::<std::option::Option<gtype::model::Money>>()?;
                            }
                            __FieldTag::__monthly_cost_other => {
                                if !fields.insert(__FieldTag::__monthly_cost_other) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for monthly_cost_other",
                                    ));
                                }
                                result.monthly_cost_other =
                                    map.next_value::<std::option::Option<gtype::model::Money>>()?;
                            }
                            __FieldTag::__compute_engine_finding => {
                                if !fields.insert(__FieldTag::__compute_engine_finding) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for compute_engine_finding",
                                    ));
                                }
                                result.compute_engine_finding = map
                                    .next_value::<std::option::Option<
                                        crate::model::report_summary::ComputeEngineFinding,
                                    >>()?;
                            }
                            __FieldTag::__vmware_engine_finding => {
                                if !fields.insert(__FieldTag::__vmware_engine_finding) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for vmware_engine_finding",
                                    ));
                                }
                                result.vmware_engine_finding = map
                                    .next_value::<std::option::Option<
                                        crate::model::report_summary::VmwareEngineFinding,
                                    >>()?;
                            }
                            __FieldTag::__sole_tenant_finding => {
                                if !fields.insert(__FieldTag::__sole_tenant_finding) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sole_tenant_finding",
                                    ));
                                }
                                result.sole_tenant_finding = map
                                    .next_value::<std::option::Option<
                                        crate::model::report_summary::SoleTenantFinding,
                                    >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GroupPreferenceSetFinding {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if self.machine_preferences.is_some() {
                state.serialize_entry("machinePreferences", &self.machine_preferences)?;
            }
            if self.monthly_cost_total.is_some() {
                state.serialize_entry("monthlyCostTotal", &self.monthly_cost_total)?;
            }
            if self.monthly_cost_compute.is_some() {
                state.serialize_entry("monthlyCostCompute", &self.monthly_cost_compute)?;
            }
            if self.monthly_cost_os_license.is_some() {
                state.serialize_entry("monthlyCostOsLicense", &self.monthly_cost_os_license)?;
            }
            if self.monthly_cost_network_egress.is_some() {
                state.serialize_entry(
                    "monthlyCostNetworkEgress",
                    &self.monthly_cost_network_egress,
                )?;
            }
            if self.monthly_cost_storage.is_some() {
                state.serialize_entry("monthlyCostStorage", &self.monthly_cost_storage)?;
            }
            if self.monthly_cost_other.is_some() {
                state.serialize_entry("monthlyCostOther", &self.monthly_cost_other)?;
            }
            if self.compute_engine_finding.is_some() {
                state.serialize_entry("computeEngineFinding", &self.compute_engine_finding)?;
            }
            if self.vmware_engine_finding.is_some() {
                state.serialize_entry("vmwareEngineFinding", &self.vmware_engine_finding)?;
            }
            if self.sole_tenant_finding.is_some() {
                state.serialize_entry("soleTenantFinding", &self.sole_tenant_finding)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GroupPreferenceSetFinding {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GroupPreferenceSetFinding");
            debug_struct.field("display_name", &self.display_name);
            debug_struct.field("description", &self.description);
            debug_struct.field("machine_preferences", &self.machine_preferences);
            debug_struct.field("monthly_cost_total", &self.monthly_cost_total);
            debug_struct.field("monthly_cost_compute", &self.monthly_cost_compute);
            debug_struct.field("monthly_cost_os_license", &self.monthly_cost_os_license);
            debug_struct.field(
                "monthly_cost_network_egress",
                &self.monthly_cost_network_egress,
            );
            debug_struct.field("monthly_cost_storage", &self.monthly_cost_storage);
            debug_struct.field("monthly_cost_other", &self.monthly_cost_other);
            debug_struct.field("compute_engine_finding", &self.compute_engine_finding);
            debug_struct.field("vmware_engine_finding", &self.vmware_engine_finding);
            debug_struct.field("sole_tenant_finding", &self.sole_tenant_finding);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Summary Findings for a specific Group.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GroupFinding {
        /// Display Name for the Group.
        pub display_name: std::string::String,

        /// Description for the Group.
        pub description: std::string::String,

        /// Summary statistics for all the assets in this group.
        pub asset_aggregate_stats:
            std::option::Option<crate::model::report_summary::AssetAggregateStats>,

        /// This field is deprecated, do not rely on it having a value.
        #[deprecated]
        pub overlapping_asset_count: i64,

        /// Findings for each of the PreferenceSets for this group.
        pub preference_set_findings:
            std::vec::Vec<crate::model::report_summary::GroupPreferenceSetFinding>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GroupFinding {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::report_summary::GroupFinding::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [description][crate::model::report_summary::GroupFinding::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [asset_aggregate_stats][crate::model::report_summary::GroupFinding::asset_aggregate_stats].
        pub fn set_asset_aggregate_stats<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::AssetAggregateStats>,
        {
            self.asset_aggregate_stats = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [asset_aggregate_stats][crate::model::report_summary::GroupFinding::asset_aggregate_stats].
        pub fn set_or_clear_asset_aggregate_stats<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::report_summary::AssetAggregateStats>,
        {
            self.asset_aggregate_stats = v.map(|x| x.into());
            self
        }

        /// Sets the value of [overlapping_asset_count][crate::model::report_summary::GroupFinding::overlapping_asset_count].
        #[deprecated]
        pub fn set_overlapping_asset_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.overlapping_asset_count = v.into();
            self
        }

        /// Sets the value of [preference_set_findings][crate::model::report_summary::GroupFinding::preference_set_findings].
        pub fn set_preference_set_findings<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::report_summary::GroupPreferenceSetFinding>,
        {
            use std::iter::Iterator;
            self.preference_set_findings = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for GroupFinding {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.GroupFinding"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GroupFinding {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __display_name,
                __description,
                __asset_aggregate_stats,
                __overlapping_asset_count,
                __preference_set_findings,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GroupFinding")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                "description" => Ok(__FieldTag::__description),
                                "assetAggregateStats" => Ok(__FieldTag::__asset_aggregate_stats),
                                "asset_aggregate_stats" => Ok(__FieldTag::__asset_aggregate_stats),
                                "overlappingAssetCount" => {
                                    Ok(__FieldTag::__overlapping_asset_count)
                                }
                                "overlapping_asset_count" => {
                                    Ok(__FieldTag::__overlapping_asset_count)
                                }
                                "preferenceSetFindings" => {
                                    Ok(__FieldTag::__preference_set_findings)
                                }
                                "preference_set_findings" => {
                                    Ok(__FieldTag::__preference_set_findings)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GroupFinding;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GroupFinding")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__asset_aggregate_stats => {
                                if !fields.insert(__FieldTag::__asset_aggregate_stats) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for asset_aggregate_stats",
                                    ));
                                }
                                result.asset_aggregate_stats = map
                                    .next_value::<std::option::Option<
                                        crate::model::report_summary::AssetAggregateStats,
                                    >>()?;
                            }
                            __FieldTag::__overlapping_asset_count => {
                                if !fields.insert(__FieldTag::__overlapping_asset_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for overlapping_asset_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.overlapping_asset_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__preference_set_findings => {
                                if !fields.insert(__FieldTag::__preference_set_findings) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for preference_set_findings",
                                    ));
                                }
                                result.preference_set_findings = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::report_summary::GroupPreferenceSetFinding,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GroupFinding {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if self.asset_aggregate_stats.is_some() {
                state.serialize_entry("assetAggregateStats", &self.asset_aggregate_stats)?;
            }
            if !wkt::internal::is_default(&self.overlapping_asset_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "overlappingAssetCount",
                    &__With(&self.overlapping_asset_count),
                )?;
            }
            if !self.preference_set_findings.is_empty() {
                state.serialize_entry("preferenceSetFindings", &self.preference_set_findings)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GroupFinding {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GroupFinding");
            debug_struct.field("display_name", &self.display_name);
            debug_struct.field("description", &self.description);
            debug_struct.field("asset_aggregate_stats", &self.asset_aggregate_stats);
            debug_struct.field("overlapping_asset_count", &self.overlapping_asset_count);
            debug_struct.field("preference_set_findings", &self.preference_set_findings);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Specifies the types of asset views that provide complete or partial details
/// of an asset.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AssetView {
    /// The asset view is not specified. The API displays the basic view by
    /// default.
    Unspecified,
    /// The asset view includes only basic metadata of the asset.
    Basic,
    /// The asset view includes all the metadata of an asset and performance data.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AssetView::value] or
    /// [AssetView::name].
    UnknownValue(asset_view::UnknownValue),
}

#[doc(hidden)]
pub mod asset_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl AssetView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ASSET_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("ASSET_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("ASSET_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for AssetView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for AssetView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for AssetView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(asset_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for AssetView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ASSET_VIEW_UNSPECIFIED" => Self::Unspecified,
            "ASSET_VIEW_BASIC" => Self::Basic,
            "ASSET_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(asset_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for AssetView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for AssetView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AssetView>::new(
            ".google.cloud.migrationcenter.v1.AssetView",
        ))
    }
}

/// Known categories of operating systems.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum OperatingSystemFamily {
    OsFamilyUnknown,
    /// Microsoft Windows Server and Desktop.
    OsFamilyWindows,
    /// Various Linux flavors.
    OsFamilyLinux,
    /// Non-Linux Unix flavors.
    OsFamilyUnix,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [OperatingSystemFamily::value] or
    /// [OperatingSystemFamily::name].
    UnknownValue(operating_system_family::UnknownValue),
}

#[doc(hidden)]
pub mod operating_system_family {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl OperatingSystemFamily {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::OsFamilyUnknown => std::option::Option::Some(0),
            Self::OsFamilyWindows => std::option::Option::Some(1),
            Self::OsFamilyLinux => std::option::Option::Some(2),
            Self::OsFamilyUnix => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::OsFamilyUnknown => std::option::Option::Some("OS_FAMILY_UNKNOWN"),
            Self::OsFamilyWindows => std::option::Option::Some("OS_FAMILY_WINDOWS"),
            Self::OsFamilyLinux => std::option::Option::Some("OS_FAMILY_LINUX"),
            Self::OsFamilyUnix => std::option::Option::Some("OS_FAMILY_UNIX"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for OperatingSystemFamily {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for OperatingSystemFamily {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for OperatingSystemFamily {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::OsFamilyUnknown,
            1 => Self::OsFamilyWindows,
            2 => Self::OsFamilyLinux,
            3 => Self::OsFamilyUnix,
            _ => Self::UnknownValue(operating_system_family::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for OperatingSystemFamily {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "OS_FAMILY_UNKNOWN" => Self::OsFamilyUnknown,
            "OS_FAMILY_WINDOWS" => Self::OsFamilyWindows,
            "OS_FAMILY_LINUX" => Self::OsFamilyLinux,
            "OS_FAMILY_UNIX" => Self::OsFamilyUnix,
            _ => Self::UnknownValue(operating_system_family::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for OperatingSystemFamily {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::OsFamilyUnknown => serializer.serialize_i32(0),
            Self::OsFamilyWindows => serializer.serialize_i32(1),
            Self::OsFamilyLinux => serializer.serialize_i32(2),
            Self::OsFamilyUnix => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for OperatingSystemFamily {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<OperatingSystemFamily>::new(
            ".google.cloud.migrationcenter.v1.OperatingSystemFamily",
        ))
    }
}

/// Specifies the data formats supported by Migration Center.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ImportJobFormat {
    /// Default value.
    Unspecified,
    /// RVTools format (XLSX).
    RvtoolsXlsx,
    /// RVTools format (CSV).
    RvtoolsCsv,
    /// CSV format exported from AWS using the
    /// [AWS collection
    /// script][<https://github.com/GoogleCloudPlatform/aws-to-stratozone-export>].
    ExportedAwsCsv,
    /// CSV format exported from Azure using the
    /// [Azure collection
    /// script][<https://github.com/GoogleCloudPlatform/azure-to-stratozone-export>].
    ExportedAzureCsv,
    /// CSV format created manually and following the StratoZone format. For more
    /// information, see [Manually create and upload data
    /// tables][<https://cloud.google.com/migrate/stratozone/docs/import-data-portal>].
    StratozoneCsv,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ImportJobFormat::value] or
    /// [ImportJobFormat::name].
    UnknownValue(import_job_format::UnknownValue),
}

#[doc(hidden)]
pub mod import_job_format {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ImportJobFormat {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::RvtoolsXlsx => std::option::Option::Some(1),
            Self::RvtoolsCsv => std::option::Option::Some(2),
            Self::ExportedAwsCsv => std::option::Option::Some(4),
            Self::ExportedAzureCsv => std::option::Option::Some(5),
            Self::StratozoneCsv => std::option::Option::Some(6),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("IMPORT_JOB_FORMAT_UNSPECIFIED"),
            Self::RvtoolsXlsx => std::option::Option::Some("IMPORT_JOB_FORMAT_RVTOOLS_XLSX"),
            Self::RvtoolsCsv => std::option::Option::Some("IMPORT_JOB_FORMAT_RVTOOLS_CSV"),
            Self::ExportedAwsCsv => std::option::Option::Some("IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV"),
            Self::ExportedAzureCsv => {
                std::option::Option::Some("IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV")
            }
            Self::StratozoneCsv => std::option::Option::Some("IMPORT_JOB_FORMAT_STRATOZONE_CSV"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ImportJobFormat {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ImportJobFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ImportJobFormat {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::RvtoolsXlsx,
            2 => Self::RvtoolsCsv,
            4 => Self::ExportedAwsCsv,
            5 => Self::ExportedAzureCsv,
            6 => Self::StratozoneCsv,
            _ => Self::UnknownValue(import_job_format::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ImportJobFormat {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "IMPORT_JOB_FORMAT_UNSPECIFIED" => Self::Unspecified,
            "IMPORT_JOB_FORMAT_RVTOOLS_XLSX" => Self::RvtoolsXlsx,
            "IMPORT_JOB_FORMAT_RVTOOLS_CSV" => Self::RvtoolsCsv,
            "IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV" => Self::ExportedAwsCsv,
            "IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV" => Self::ExportedAzureCsv,
            "IMPORT_JOB_FORMAT_STRATOZONE_CSV" => Self::StratozoneCsv,
            _ => Self::UnknownValue(import_job_format::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ImportJobFormat {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::RvtoolsXlsx => serializer.serialize_i32(1),
            Self::RvtoolsCsv => serializer.serialize_i32(2),
            Self::ExportedAwsCsv => serializer.serialize_i32(4),
            Self::ExportedAzureCsv => serializer.serialize_i32(5),
            Self::StratozoneCsv => serializer.serialize_i32(6),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ImportJobFormat {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ImportJobFormat>::new(
            ".google.cloud.migrationcenter.v1.ImportJobFormat",
        ))
    }
}

/// Specifies the types of import job views that provide complete or partial
/// details of an import job.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ImportJobView {
    /// The import job view is not specified. The API displays the basic view by
    /// default.
    Unspecified,
    /// The import job view includes basic metadata of an import job.
    /// This view does not include payload information.
    Basic,
    /// The import job view includes all metadata of an import job.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ImportJobView::value] or
    /// [ImportJobView::name].
    UnknownValue(import_job_view::UnknownValue),
}

#[doc(hidden)]
pub mod import_job_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ImportJobView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("IMPORT_JOB_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("IMPORT_JOB_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("IMPORT_JOB_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ImportJobView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ImportJobView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ImportJobView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(import_job_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ImportJobView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "IMPORT_JOB_VIEW_UNSPECIFIED" => Self::Unspecified,
            "IMPORT_JOB_VIEW_BASIC" => Self::Basic,
            "IMPORT_JOB_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(import_job_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ImportJobView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ImportJobView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ImportJobView>::new(
            ".google.cloud.migrationcenter.v1.ImportJobView",
        ))
    }
}

/// ErrorFrameView can be specified in ErrorFrames List and Get requests to
/// control the level of details that is returned for the original frame.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ErrorFrameView {
    /// Value is unset. The system will fallback to the default value.
    Unspecified,
    /// Include basic frame data, but not the full contents.
    Basic,
    /// Include everything.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ErrorFrameView::value] or
    /// [ErrorFrameView::name].
    UnknownValue(error_frame_view::UnknownValue),
}

#[doc(hidden)]
pub mod error_frame_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ErrorFrameView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ERROR_FRAME_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("ERROR_FRAME_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("ERROR_FRAME_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ErrorFrameView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ErrorFrameView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ErrorFrameView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(error_frame_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ErrorFrameView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ERROR_FRAME_VIEW_UNSPECIFIED" => Self::Unspecified,
            "ERROR_FRAME_VIEW_BASIC" => Self::Basic,
            "ERROR_FRAME_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(error_frame_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ErrorFrameView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ErrorFrameView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ErrorFrameView>::new(
            ".google.cloud.migrationcenter.v1.ErrorFrameView",
        ))
    }
}

/// The persistent disk (PD) types of Compute Engine virtual machines.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum PersistentDiskType {
    /// Unspecified (default value).
    /// Selecting this value allows the system to use any disk type according
    /// to reported usage. This a good value to start with.
    Unspecified,
    /// Standard HDD Persistent Disk.
    Standard,
    /// Balanced Persistent Disk.
    Balanced,
    /// SSD Persistent Disk.
    Ssd,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [PersistentDiskType::value] or
    /// [PersistentDiskType::name].
    UnknownValue(persistent_disk_type::UnknownValue),
}

#[doc(hidden)]
pub mod persistent_disk_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl PersistentDiskType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Standard => std::option::Option::Some(1),
            Self::Balanced => std::option::Option::Some(2),
            Self::Ssd => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("PERSISTENT_DISK_TYPE_UNSPECIFIED"),
            Self::Standard => std::option::Option::Some("PERSISTENT_DISK_TYPE_STANDARD"),
            Self::Balanced => std::option::Option::Some("PERSISTENT_DISK_TYPE_BALANCED"),
            Self::Ssd => std::option::Option::Some("PERSISTENT_DISK_TYPE_SSD"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for PersistentDiskType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for PersistentDiskType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for PersistentDiskType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Standard,
            2 => Self::Balanced,
            3 => Self::Ssd,
            _ => Self::UnknownValue(persistent_disk_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for PersistentDiskType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "PERSISTENT_DISK_TYPE_UNSPECIFIED" => Self::Unspecified,
            "PERSISTENT_DISK_TYPE_STANDARD" => Self::Standard,
            "PERSISTENT_DISK_TYPE_BALANCED" => Self::Balanced,
            "PERSISTENT_DISK_TYPE_SSD" => Self::Ssd,
            _ => Self::UnknownValue(persistent_disk_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for PersistentDiskType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Standard => serializer.serialize_i32(1),
            Self::Balanced => serializer.serialize_i32(2),
            Self::Ssd => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for PersistentDiskType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<PersistentDiskType>::new(
            ".google.cloud.migrationcenter.v1.PersistentDiskType",
        ))
    }
}

/// The License type for premium images (RHEL, RHEL for SAP, SLES, SLES for SAP,
/// Windows Server).
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum LicenseType {
    /// Unspecified (default value).
    Unspecified,
    /// Default Google Cloud licensing plan. Licensing is charged per usage.
    /// This a good value to start with.
    Default,
    /// Bring-your-own-license (BYOL) plan. User provides the OS license.
    BringYourOwnLicense,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [LicenseType::value] or
    /// [LicenseType::name].
    UnknownValue(license_type::UnknownValue),
}

#[doc(hidden)]
pub mod license_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl LicenseType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Default => std::option::Option::Some(1),
            Self::BringYourOwnLicense => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("LICENSE_TYPE_UNSPECIFIED"),
            Self::Default => std::option::Option::Some("LICENSE_TYPE_DEFAULT"),
            Self::BringYourOwnLicense => {
                std::option::Option::Some("LICENSE_TYPE_BRING_YOUR_OWN_LICENSE")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for LicenseType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for LicenseType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for LicenseType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Default,
            2 => Self::BringYourOwnLicense,
            _ => Self::UnknownValue(license_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for LicenseType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "LICENSE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "LICENSE_TYPE_DEFAULT" => Self::Default,
            "LICENSE_TYPE_BRING_YOUR_OWN_LICENSE" => Self::BringYourOwnLicense,
            _ => Self::UnknownValue(license_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for LicenseType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Default => serializer.serialize_i32(1),
            Self::BringYourOwnLicense => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for LicenseType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<LicenseType>::new(
            ".google.cloud.migrationcenter.v1.LicenseType",
        ))
    }
}

/// The sizing optimization strategy preferences of a virtual machine. This
/// strategy, in addition to actual usage data of the virtual machine, can help
/// determine the recommended shape on the target platform.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SizingOptimizationStrategy {
    /// Unspecified (default value).
    Unspecified,
    /// No optimization applied. Virtual machine sizing matches as closely as
    /// possible the machine shape on the source site, not considering any actual
    /// performance data.
    SameAsSource,
    /// Virtual machine sizing will match the reported usage and shape, with some
    /// slack. This a good value to start with.
    Moderate,
    /// Virtual machine sizing will match the reported usage, with little slack.
    /// Using this option can help reduce costs.
    Aggressive,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SizingOptimizationStrategy::value] or
    /// [SizingOptimizationStrategy::name].
    UnknownValue(sizing_optimization_strategy::UnknownValue),
}

#[doc(hidden)]
pub mod sizing_optimization_strategy {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SizingOptimizationStrategy {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::SameAsSource => std::option::Option::Some(1),
            Self::Moderate => std::option::Option::Some(2),
            Self::Aggressive => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED")
            }
            Self::SameAsSource => {
                std::option::Option::Some("SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE")
            }
            Self::Moderate => std::option::Option::Some("SIZING_OPTIMIZATION_STRATEGY_MODERATE"),
            Self::Aggressive => {
                std::option::Option::Some("SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SizingOptimizationStrategy {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SizingOptimizationStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SizingOptimizationStrategy {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::SameAsSource,
            2 => Self::Moderate,
            3 => Self::Aggressive,
            _ => Self::UnknownValue(sizing_optimization_strategy::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SizingOptimizationStrategy {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED" => Self::Unspecified,
            "SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE" => Self::SameAsSource,
            "SIZING_OPTIMIZATION_STRATEGY_MODERATE" => Self::Moderate,
            "SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE" => Self::Aggressive,
            _ => Self::UnknownValue(sizing_optimization_strategy::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SizingOptimizationStrategy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::SameAsSource => serializer.serialize_i32(1),
            Self::Moderate => serializer.serialize_i32(2),
            Self::Aggressive => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SizingOptimizationStrategy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<SizingOptimizationStrategy>::new(
                ".google.cloud.migrationcenter.v1.SizingOptimizationStrategy",
            ),
        )
    }
}

/// The plan of commitments for VM resource-based committed use discount (CUD).
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CommitmentPlan {
    /// Unspecified commitment plan.
    Unspecified,
    /// No commitment plan.
    None,
    /// 1 year commitment.
    OneYear,
    /// 3 years commitment.
    ThreeYears,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CommitmentPlan::value] or
    /// [CommitmentPlan::name].
    UnknownValue(commitment_plan::UnknownValue),
}

#[doc(hidden)]
pub mod commitment_plan {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CommitmentPlan {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::None => std::option::Option::Some(1),
            Self::OneYear => std::option::Option::Some(2),
            Self::ThreeYears => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("COMMITMENT_PLAN_UNSPECIFIED"),
            Self::None => std::option::Option::Some("COMMITMENT_PLAN_NONE"),
            Self::OneYear => std::option::Option::Some("COMMITMENT_PLAN_ONE_YEAR"),
            Self::ThreeYears => std::option::Option::Some("COMMITMENT_PLAN_THREE_YEARS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CommitmentPlan {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CommitmentPlan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CommitmentPlan {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::None,
            2 => Self::OneYear,
            3 => Self::ThreeYears,
            _ => Self::UnknownValue(commitment_plan::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for CommitmentPlan {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMMITMENT_PLAN_UNSPECIFIED" => Self::Unspecified,
            "COMMITMENT_PLAN_NONE" => Self::None,
            "COMMITMENT_PLAN_ONE_YEAR" => Self::OneYear,
            "COMMITMENT_PLAN_THREE_YEARS" => Self::ThreeYears,
            _ => Self::UnknownValue(commitment_plan::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for CommitmentPlan {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::None => serializer.serialize_i32(1),
            Self::OneYear => serializer.serialize_i32(2),
            Self::ThreeYears => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CommitmentPlan {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CommitmentPlan>::new(
            ".google.cloud.migrationcenter.v1.CommitmentPlan",
        ))
    }
}

/// The preference for a specific Google Cloud product platform.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ComputeMigrationTargetProduct {
    /// Unspecified (default value).
    Unspecified,
    /// Prefer to migrate to Google Cloud Compute Engine.
    ComputeEngine,
    /// Prefer to migrate to Google Cloud VMware Engine.
    VmwareEngine,
    /// Prefer to migrate to Google Cloud Sole Tenant Nodes.
    SoleTenancy,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ComputeMigrationTargetProduct::value] or
    /// [ComputeMigrationTargetProduct::name].
    UnknownValue(compute_migration_target_product::UnknownValue),
}

#[doc(hidden)]
pub mod compute_migration_target_product {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ComputeMigrationTargetProduct {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::ComputeEngine => std::option::Option::Some(1),
            Self::VmwareEngine => std::option::Option::Some(2),
            Self::SoleTenancy => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED")
            }
            Self::ComputeEngine => {
                std::option::Option::Some("COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE")
            }
            Self::VmwareEngine => {
                std::option::Option::Some("COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE")
            }
            Self::SoleTenancy => {
                std::option::Option::Some("COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ComputeMigrationTargetProduct {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ComputeMigrationTargetProduct {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ComputeMigrationTargetProduct {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::ComputeEngine,
            2 => Self::VmwareEngine,
            3 => Self::SoleTenancy,
            _ => Self::UnknownValue(compute_migration_target_product::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ComputeMigrationTargetProduct {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED" => Self::Unspecified,
            "COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE" => Self::ComputeEngine,
            "COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE" => Self::VmwareEngine,
            "COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY" => Self::SoleTenancy,
            _ => Self::UnknownValue(compute_migration_target_product::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ComputeMigrationTargetProduct {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::ComputeEngine => serializer.serialize_i32(1),
            Self::VmwareEngine => serializer.serialize_i32(2),
            Self::SoleTenancy => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ComputeMigrationTargetProduct {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<ComputeMigrationTargetProduct>::new(
                ".google.cloud.migrationcenter.v1.ComputeMigrationTargetProduct",
            ),
        )
    }
}

/// Specifies the types of views that provide complete or partial details
/// of a Report.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ReportView {
    /// The report view is not specified. The API displays the basic view by
    /// default.
    Unspecified,
    /// The report view includes only basic metadata of the Report. Useful for
    /// list views.
    Basic,
    /// The report view includes all the metadata of the Report. Useful for
    /// preview.
    Full,
    /// The report view includes the standard metadata of an report. Useful for
    /// detail view.
    Standard,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ReportView::value] or
    /// [ReportView::name].
    UnknownValue(report_view::UnknownValue),
}

#[doc(hidden)]
pub mod report_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ReportView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::Standard => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("REPORT_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("REPORT_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("REPORT_VIEW_FULL"),
            Self::Standard => std::option::Option::Some("REPORT_VIEW_STANDARD"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ReportView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ReportView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ReportView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            3 => Self::Standard,
            _ => Self::UnknownValue(report_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ReportView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "REPORT_VIEW_UNSPECIFIED" => Self::Unspecified,
            "REPORT_VIEW_BASIC" => Self::Basic,
            "REPORT_VIEW_FULL" => Self::Full,
            "REPORT_VIEW_STANDARD" => Self::Standard,
            _ => Self::UnknownValue(report_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ReportView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::Standard => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ReportView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ReportView>::new(
            ".google.cloud.migrationcenter.v1.ReportView",
        ))
    }
}
