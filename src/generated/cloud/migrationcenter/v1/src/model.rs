// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// An asset represents a resource in your environment. Asset types include
/// virtual machines and databases.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Asset {
    /// Output only. The full name of the asset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The timestamp when the asset was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the asset was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels as key value pairs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Generic asset attributes.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub attributes: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The list of insights associated with the asset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub insight_list: std::option::Option<crate::model::InsightList>,

    /// Output only. Performance data for the asset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub performance_data: std::option::Option<crate::model::AssetPerformanceData>,

    /// Output only. The list of sources contributing to the asset.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub sources: std::vec::Vec<std::string::String>,

    /// Output only. The list of groups that the asset is assigned to.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub assigned_groups: std::vec::Vec<std::string::String>,

    /// The internal information of an asset. Only one field can be specified
    /// with different attributes based on the type of the asset.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub asset_details: std::option::Option<crate::model::asset::AssetDetails>,
}

impl Asset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Asset::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Asset::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Asset::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [insight_list][crate::model::Asset::insight_list].
    pub fn set_insight_list<
        T: std::convert::Into<std::option::Option<crate::model::InsightList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.insight_list = v.into();
        self
    }

    /// Sets the value of [performance_data][crate::model::Asset::performance_data].
    pub fn set_performance_data<
        T: std::convert::Into<std::option::Option<crate::model::AssetPerformanceData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.performance_data = v.into();
        self
    }

    /// Sets the value of [sources][crate::model::Asset::sources].
    pub fn set_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.sources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [assigned_groups][crate::model::Asset::assigned_groups].
    pub fn set_assigned_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.assigned_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Asset::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [attributes][crate::model::Asset::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `asset_details`.
    pub fn set_asset_details<
        T: std::convert::Into<std::option::Option<crate::model::asset::AssetDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.asset_details = v.into();
        self
    }

    /// The value of [asset_details][crate::model::Asset::asset_details]
    /// if it holds a `MachineDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_machine_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MachineDetails>> {
        #[allow(unreachable_patterns)]
        self.asset_details.as_ref().and_then(|v| match v {
            crate::model::asset::AssetDetails::MachineDetails(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [asset_details][crate::model::Asset::asset_details]
    /// to hold a `MachineDetails`.
    ///
    /// Note that all the setters affecting `asset_details` are
    /// mutually exclusive.
    pub fn set_machine_details<
        T: std::convert::Into<std::boxed::Box<crate::model::MachineDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.asset_details =
            std::option::Option::Some(crate::model::asset::AssetDetails::MachineDetails(v.into()));
        self
    }
}

impl wkt::message::Message for Asset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.Asset"
    }
}

/// Defines additional types related to Asset
pub mod asset {
    #[allow(unused_imports)]
    use super::*;

    /// The internal information of an asset. Only one field can be specified
    /// with different attributes based on the type of the asset.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AssetDetails {
        /// Output only. Asset information specific for virtual and physical
        /// machines.
        MachineDetails(std::boxed::Box<crate::model::MachineDetails>),
    }
}

/// The preferences that apply to all assets in a given context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PreferenceSet {
    /// Output only. Name of the preference set.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The timestamp when the preference set was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the preference set was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// User-friendly display name. Maximum length is 63 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// A description of the preference set.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// A set of preferences that applies to all virtual machines in the context.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub virtual_machine_preferences: std::option::Option<crate::model::VirtualMachinePreferences>,
}

impl PreferenceSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PreferenceSet::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PreferenceSet::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PreferenceSet::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PreferenceSet::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::PreferenceSet::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [virtual_machine_preferences][crate::model::PreferenceSet::virtual_machine_preferences].
    pub fn set_virtual_machine_preferences<
        T: std::convert::Into<std::option::Option<crate::model::VirtualMachinePreferences>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.virtual_machine_preferences = v.into();
        self
    }
}

impl wkt::message::Message for PreferenceSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.PreferenceSet"
    }
}

/// A resource that represents the background job that imports asset frames.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportJob {
    /// Output only. The full name of the import job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// User-friendly display name. Maximum length is 63 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The timestamp when the import job was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the import job was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the import job was completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub complete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The state of the import job.
    pub state: crate::model::import_job::ImportJobState,

    /// Labels as key value pairs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Reference to a source.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub asset_source: std::string::String,

    /// Holds the various report types of an import job.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub report: std::option::Option<crate::model::import_job::Report>,
}

impl ImportJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ImportJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ImportJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ImportJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ImportJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [complete_time][crate::model::ImportJob::complete_time].
    pub fn set_complete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.complete_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::ImportJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::import_job::ImportJobState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [asset_source][crate::model::ImportJob::asset_source].
    pub fn set_asset_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_source = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ImportJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `report`.
    pub fn set_report<
        T: std::convert::Into<std::option::Option<crate::model::import_job::Report>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.report = v.into();
        self
    }

    /// The value of [report][crate::model::ImportJob::report]
    /// if it holds a `ValidationReport`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_validation_report(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ValidationReport>> {
        #[allow(unreachable_patterns)]
        self.report.as_ref().and_then(|v| match v {
            crate::model::import_job::Report::ValidationReport(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [report][crate::model::ImportJob::report]
    /// if it holds a `ExecutionReport`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_execution_report(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExecutionReport>> {
        #[allow(unreachable_patterns)]
        self.report.as_ref().and_then(|v| match v {
            crate::model::import_job::Report::ExecutionReport(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [report][crate::model::ImportJob::report]
    /// to hold a `ValidationReport`.
    ///
    /// Note that all the setters affecting `report` are
    /// mutually exclusive.
    pub fn set_validation_report<
        T: std::convert::Into<std::boxed::Box<crate::model::ValidationReport>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.report =
            std::option::Option::Some(crate::model::import_job::Report::ValidationReport(v.into()));
        self
    }

    /// Sets the value of [report][crate::model::ImportJob::report]
    /// to hold a `ExecutionReport`.
    ///
    /// Note that all the setters affecting `report` are
    /// mutually exclusive.
    pub fn set_execution_report<
        T: std::convert::Into<std::boxed::Box<crate::model::ExecutionReport>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.report =
            std::option::Option::Some(crate::model::import_job::Report::ExecutionReport(v.into()));
        self
    }
}

impl wkt::message::Message for ImportJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ImportJob"
    }
}

/// Defines additional types related to ImportJob
pub mod import_job {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerates possible states of an import job.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ImportJobState(i32);

    impl ImportJobState {
        /// Default value.
        pub const IMPORT_JOB_STATE_UNSPECIFIED: ImportJobState = ImportJobState::new(0);

        /// The import job is pending.
        pub const IMPORT_JOB_STATE_PENDING: ImportJobState = ImportJobState::new(1);

        /// The processing of the import job is ongoing.
        pub const IMPORT_JOB_STATE_RUNNING: ImportJobState = ImportJobState::new(2);

        /// The import job processing has completed.
        pub const IMPORT_JOB_STATE_COMPLETED: ImportJobState = ImportJobState::new(3);

        /// The import job failed to be processed.
        pub const IMPORT_JOB_STATE_FAILED: ImportJobState = ImportJobState::new(4);

        /// The import job is being validated.
        pub const IMPORT_JOB_STATE_VALIDATING: ImportJobState = ImportJobState::new(5);

        /// The import job contains blocking errors.
        pub const IMPORT_JOB_STATE_FAILED_VALIDATION: ImportJobState = ImportJobState::new(6);

        /// The validation of the job completed with no blocking errors.
        pub const IMPORT_JOB_STATE_READY: ImportJobState = ImportJobState::new(7);

        /// Creates a new ImportJobState instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("IMPORT_JOB_STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("IMPORT_JOB_STATE_PENDING"),
                2 => std::borrow::Cow::Borrowed("IMPORT_JOB_STATE_RUNNING"),
                3 => std::borrow::Cow::Borrowed("IMPORT_JOB_STATE_COMPLETED"),
                4 => std::borrow::Cow::Borrowed("IMPORT_JOB_STATE_FAILED"),
                5 => std::borrow::Cow::Borrowed("IMPORT_JOB_STATE_VALIDATING"),
                6 => std::borrow::Cow::Borrowed("IMPORT_JOB_STATE_FAILED_VALIDATION"),
                7 => std::borrow::Cow::Borrowed("IMPORT_JOB_STATE_READY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "IMPORT_JOB_STATE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::IMPORT_JOB_STATE_UNSPECIFIED)
                }
                "IMPORT_JOB_STATE_PENDING" => {
                    std::option::Option::Some(Self::IMPORT_JOB_STATE_PENDING)
                }
                "IMPORT_JOB_STATE_RUNNING" => {
                    std::option::Option::Some(Self::IMPORT_JOB_STATE_RUNNING)
                }
                "IMPORT_JOB_STATE_COMPLETED" => {
                    std::option::Option::Some(Self::IMPORT_JOB_STATE_COMPLETED)
                }
                "IMPORT_JOB_STATE_FAILED" => {
                    std::option::Option::Some(Self::IMPORT_JOB_STATE_FAILED)
                }
                "IMPORT_JOB_STATE_VALIDATING" => {
                    std::option::Option::Some(Self::IMPORT_JOB_STATE_VALIDATING)
                }
                "IMPORT_JOB_STATE_FAILED_VALIDATION" => {
                    std::option::Option::Some(Self::IMPORT_JOB_STATE_FAILED_VALIDATION)
                }
                "IMPORT_JOB_STATE_READY" => std::option::Option::Some(Self::IMPORT_JOB_STATE_READY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ImportJobState {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ImportJobState {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Holds the various report types of an import job.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Report {
        /// Output only. The report with the validation results of the import job.
        ValidationReport(std::boxed::Box<crate::model::ValidationReport>),
        /// Output only. The report with the results of running the import job.
        ExecutionReport(std::boxed::Box<crate::model::ExecutionReport>),
    }
}

/// A resource that represents a payload file in an import job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportDataFile {
    /// Output only. The name of the file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// User-friendly display name. Maximum length is 63 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. The payload format.
    pub format: crate::model::ImportJobFormat,

    /// Output only. The timestamp when the file was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The state of the import data file.
    pub state: crate::model::import_data_file::State,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub file_info: std::option::Option<crate::model::import_data_file::FileInfo>,
}

impl ImportDataFile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ImportDataFile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ImportDataFile::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [format][crate::model::ImportDataFile::format].
    pub fn set_format<T: std::convert::Into<crate::model::ImportJobFormat>>(
        mut self,
        v: T,
    ) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ImportDataFile::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::ImportDataFile::state].
    pub fn set_state<T: std::convert::Into<crate::model::import_data_file::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of `file_info`.
    pub fn set_file_info<
        T: std::convert::Into<std::option::Option<crate::model::import_data_file::FileInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_info = v.into();
        self
    }

    /// The value of [file_info][crate::model::ImportDataFile::file_info]
    /// if it holds a `UploadFileInfo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_upload_file_info(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UploadFileInfo>> {
        #[allow(unreachable_patterns)]
        self.file_info.as_ref().and_then(|v| match v {
            crate::model::import_data_file::FileInfo::UploadFileInfo(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [file_info][crate::model::ImportDataFile::file_info]
    /// to hold a `UploadFileInfo`.
    ///
    /// Note that all the setters affecting `file_info` are
    /// mutually exclusive.
    pub fn set_upload_file_info<
        T: std::convert::Into<std::boxed::Box<crate::model::UploadFileInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_info = std::option::Option::Some(
            crate::model::import_data_file::FileInfo::UploadFileInfo(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportDataFile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ImportDataFile"
    }
}

/// Defines additional types related to ImportDataFile
pub mod import_data_file {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerates possible states of an import data file.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Default value.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The data file is being created.
        pub const CREATING: State = State::new(1);

        /// The data file completed initialization.
        pub const ACTIVE: State = State::new(2);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("ACTIVE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum FileInfo {
        /// Information about a file that is uploaded to a storage service.
        UploadFileInfo(std::boxed::Box<crate::model::UploadFileInfo>),
    }
}

/// A resource that represents an asset group.
/// The purpose of an asset group is to bundle a set of assets that have
/// something in common, while allowing users to add annotations to the group.
/// An asset can belong to multiple groups.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Group {
    /// Output only. The name of the group.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The timestamp when the group was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the group was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels as key value pairs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// User-friendly display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,
}

impl Group {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Group::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Group::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Group::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Group::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Group::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Group::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Group {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.Group"
    }
}

/// Message representing a frame which failed to be processed due to an error.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ErrorFrame {
    /// Output only. The identifier of the ErrorFrame.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. All the violations that were detected for the frame.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub violations: std::vec::Vec<crate::model::FrameViolationEntry>,

    /// Output only. The frame that was originally reported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub original_frame: std::option::Option<crate::model::AssetFrame>,

    /// Output only. Frame ingestion time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ingestion_time: std::option::Option<wkt::Timestamp>,
}

impl ErrorFrame {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ErrorFrame::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [original_frame][crate::model::ErrorFrame::original_frame].
    pub fn set_original_frame<
        T: std::convert::Into<std::option::Option<crate::model::AssetFrame>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.original_frame = v.into();
        self
    }

    /// Sets the value of [ingestion_time][crate::model::ErrorFrame::ingestion_time].
    pub fn set_ingestion_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ingestion_time = v.into();
        self
    }

    /// Sets the value of [violations][crate::model::ErrorFrame::violations].
    pub fn set_violations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FrameViolationEntry>,
    {
        use std::iter::Iterator;
        self.violations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ErrorFrame {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ErrorFrame"
    }
}

/// Source represents an object from which asset information is
/// streamed to Migration Center.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Source {
    /// Output only. The full name of the source.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The timestamp when the source was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the source was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// User-friendly display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Free-text description.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Data source type.
    #[serde(rename = "type")]
    pub r#type: crate::model::source::SourceType,

    /// The information confidence of the source.
    /// The higher the value, the higher the confidence.
    pub priority: i32,

    /// If `true`, the source is managed by other service(s).
    pub managed: bool,

    /// Output only. Number of frames that are still being processed.
    pub pending_frame_count: i32,

    /// Output only. The number of frames that were reported by the source and
    /// contained errors.
    pub error_frame_count: i32,

    /// Output only. The state of the source.
    pub state: crate::model::source::State,
}

impl Source {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Source::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Source::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Source::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Source::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Source::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Source::type].
    pub fn set_type<T: std::convert::Into<crate::model::source::SourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [priority][crate::model::Source::priority].
    pub fn set_priority<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.priority = v.into();
        self
    }

    /// Sets the value of [managed][crate::model::Source::managed].
    pub fn set_managed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.managed = v.into();
        self
    }

    /// Sets the value of [pending_frame_count][crate::model::Source::pending_frame_count].
    pub fn set_pending_frame_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.pending_frame_count = v.into();
        self
    }

    /// Sets the value of [error_frame_count][crate::model::Source::error_frame_count].
    pub fn set_error_frame_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.error_frame_count = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Source::state].
    pub fn set_state<T: std::convert::Into<crate::model::source::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for Source {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.Source"
    }
}

/// Defines additional types related to Source
pub mod source {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SourceType(i32);

    impl SourceType {
        /// Unspecified
        pub const SOURCE_TYPE_UNKNOWN: SourceType = SourceType::new(0);

        /// Manually uploaded file (e.g. CSV)
        pub const SOURCE_TYPE_UPLOAD: SourceType = SourceType::new(1);

        /// Guest-level info
        pub const SOURCE_TYPE_GUEST_OS_SCAN: SourceType = SourceType::new(2);

        /// Inventory-level scan
        pub const SOURCE_TYPE_INVENTORY_SCAN: SourceType = SourceType::new(3);

        /// Third-party owned sources.
        pub const SOURCE_TYPE_CUSTOM: SourceType = SourceType::new(4);

        /// Creates a new SourceType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SOURCE_TYPE_UNKNOWN"),
                1 => std::borrow::Cow::Borrowed("SOURCE_TYPE_UPLOAD"),
                2 => std::borrow::Cow::Borrowed("SOURCE_TYPE_GUEST_OS_SCAN"),
                3 => std::borrow::Cow::Borrowed("SOURCE_TYPE_INVENTORY_SCAN"),
                4 => std::borrow::Cow::Borrowed("SOURCE_TYPE_CUSTOM"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SOURCE_TYPE_UNKNOWN" => std::option::Option::Some(Self::SOURCE_TYPE_UNKNOWN),
                "SOURCE_TYPE_UPLOAD" => std::option::Option::Some(Self::SOURCE_TYPE_UPLOAD),
                "SOURCE_TYPE_GUEST_OS_SCAN" => {
                    std::option::Option::Some(Self::SOURCE_TYPE_GUEST_OS_SCAN)
                }
                "SOURCE_TYPE_INVENTORY_SCAN" => {
                    std::option::Option::Some(Self::SOURCE_TYPE_INVENTORY_SCAN)
                }
                "SOURCE_TYPE_CUSTOM" => std::option::Option::Some(Self::SOURCE_TYPE_CUSTOM),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for SourceType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for SourceType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Enumerates possible states of a source.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Unspecified.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The source is active and ready to be used.
        pub const ACTIVE: State = State::new(1);

        /// In the process of being deleted.
        pub const DELETING: State = State::new(2);

        /// Source is in an invalid state. Asset frames reported to it will be
        /// ignored.
        pub const INVALID: State = State::new(3);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ACTIVE"),
                2 => std::borrow::Cow::Borrowed("DELETING"),
                3 => std::borrow::Cow::Borrowed("INVALID"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                "INVALID" => std::option::Option::Some(Self::INVALID),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// The groups and associated preference sets on which
/// we can generate reports.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReportConfig {
    /// Output only. Name of resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The timestamp when the resource was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the resource was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// User-friendly display name. Maximum length is 63 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Free-text description.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Required. Collection of combinations of groups and preference sets.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub group_preferenceset_assignments:
        std::vec::Vec<crate::model::report_config::GroupPreferenceSetAssignment>,
}

impl ReportConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReportConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ReportConfig::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ReportConfig::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ReportConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ReportConfig::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [group_preferenceset_assignments][crate::model::ReportConfig::group_preferenceset_assignments].
    pub fn set_group_preferenceset_assignments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::report_config::GroupPreferenceSetAssignment>,
    {
        use std::iter::Iterator;
        self.group_preferenceset_assignments = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReportConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ReportConfig"
    }
}

/// Defines additional types related to ReportConfig
pub mod report_config {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a combination of a group with a preference set.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GroupPreferenceSetAssignment {
        /// Required. Name of the group.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub group: std::string::String,

        /// Required. Name of the Preference Set.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub preference_set: std::string::String,
    }

    impl GroupPreferenceSetAssignment {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [group][crate::model::report_config::GroupPreferenceSetAssignment::group].
        pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.group = v.into();
            self
        }

        /// Sets the value of [preference_set][crate::model::report_config::GroupPreferenceSetAssignment::preference_set].
        pub fn set_preference_set<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.preference_set = v.into();
            self
        }
    }

    impl wkt::message::Message for GroupPreferenceSetAssignment {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportConfig.GroupPreferenceSetAssignment"
        }
    }
}

/// Report represents a point-in-time rendering of the ReportConfig results.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Report {
    /// Output only. Name of resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Creation timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Last update timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// User-friendly display name. Maximum length is 63 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Free-text description.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Report type.
    #[serde(rename = "type")]
    pub r#type: crate::model::report::Type,

    /// Report creation state.
    pub state: crate::model::report::State,

    /// Output only. Summary view of the Report.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub summary: std::option::Option<crate::model::ReportSummary>,
}

impl Report {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Report::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Report::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Report::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Report::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Report::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Report::type].
    pub fn set_type<T: std::convert::Into<crate::model::report::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Report::state].
    pub fn set_state<T: std::convert::Into<crate::model::report::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [summary][crate::model::Report::summary].
    pub fn set_summary<T: std::convert::Into<std::option::Option<crate::model::ReportSummary>>>(
        mut self,
        v: T,
    ) -> Self {
        self.summary = v.into();
        self
    }
}

impl wkt::message::Message for Report {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.Report"
    }
}

/// Defines additional types related to Report
pub mod report {
    #[allow(unused_imports)]
    use super::*;

    /// Report type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(i32);

    impl Type {
        /// Default Report type.
        pub const TYPE_UNSPECIFIED: Type = Type::new(0);

        /// Total cost of ownership Report type.
        pub const TOTAL_COST_OF_OWNERSHIP: Type = Type::new(1);

        /// Creates a new Type instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("TOTAL_COST_OF_OWNERSHIP"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TYPE_UNSPECIFIED),
                "TOTAL_COST_OF_OWNERSHIP" => {
                    std::option::Option::Some(Self::TOTAL_COST_OF_OWNERSHIP)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Report creation state.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Default Report creation state.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// Creating Report.
        pub const PENDING: State = State::new(1);

        /// Successfully created Report.
        pub const SUCCEEDED: State = State::new(2);

        /// Failed to create Report.
        pub const FAILED: State = State::new(3);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PENDING"),
                2 => std::borrow::Cow::Borrowed("SUCCEEDED"),
                3 => std::borrow::Cow::Borrowed("FAILED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "PENDING" => std::option::Option::Some(Self::PENDING),
                "SUCCEEDED" => std::option::Option::Some(Self::SUCCEEDED),
                "FAILED" => std::option::Option::Some(Self::FAILED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.OperationMetadata"
    }
}

/// Message for requesting a list of assets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAssetsRequest {
    /// Required. Parent value for `ListAssetsRequest`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// View of the assets. Defaults to BASIC.
    pub view: crate::model::AssetView,
}

impl ListAssetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAssetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAssetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAssetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAssetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAssetsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListAssetsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::AssetView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListAssetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListAssetsRequest"
    }
}

/// Response message for listing assets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAssetsResponse {
    /// A list of assets.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub assets: std::vec::Vec<crate::model::Asset>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListAssetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAssetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [assets][crate::model::ListAssetsResponse::assets].
    pub fn set_assets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Asset>,
    {
        use std::iter::Iterator;
        self.assets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListAssetsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAssetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListAssetsResponse"
    }
}

impl gax::paginator::PageableResponse for ListAssetsResponse {
    type PageItem = crate::model::Asset;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.assets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a Asset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAssetRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// View of the assets. Defaults to BASIC.
    pub view: crate::model::AssetView,
}

impl GetAssetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAssetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetAssetRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::AssetView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetAssetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetAssetRequest"
    }
}

/// A request to update an asset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAssetRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `Asset` resource by the update.
    /// The values specified in the `update_mask` field are relative to the
    /// resource, not the full request.
    /// A field will be overwritten if it is in the mask.
    /// A single * value in the mask lets you to overwrite all fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub asset: std::option::Option<crate::model::Asset>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdateAssetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateAssetRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [asset][crate::model::UpdateAssetRequest::asset].
    pub fn set_asset<T: std::convert::Into<std::option::Option<crate::model::Asset>>>(
        mut self,
        v: T,
    ) -> Self {
        self.asset = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateAssetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAssetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.UpdateAssetRequest"
    }
}

/// A request to update a list of assets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchUpdateAssetsRequest {
    /// Required. Parent value for batch asset update.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The request message specifying the resources to update.
    /// A maximum of 1000 assets can be modified in a batch.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub requests: std::vec::Vec<crate::model::UpdateAssetRequest>,
}

impl BatchUpdateAssetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchUpdateAssetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::BatchUpdateAssetsRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UpdateAssetRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchUpdateAssetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.BatchUpdateAssetsRequest"
    }
}

/// Response for updating a list of assets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchUpdateAssetsResponse {
    /// Update asset content.
    /// The content only includes values after field mask being applied.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub assets: std::vec::Vec<crate::model::Asset>,
}

impl BatchUpdateAssetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [assets][crate::model::BatchUpdateAssetsResponse::assets].
    pub fn set_assets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Asset>,
    {
        use std::iter::Iterator;
        self.assets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchUpdateAssetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.BatchUpdateAssetsResponse"
    }
}

/// A request to delete an asset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAssetRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteAssetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAssetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteAssetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAssetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DeleteAssetRequest"
    }
}

/// A request to delete a list of  asset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchDeleteAssetsRequest {
    /// Required. Parent value for batch asset delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The IDs of the assets to delete.
    /// A maximum of 1000 assets can be deleted in a batch.
    /// Format: projects/{project}/locations/{location}/assets/{name}.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub names: std::vec::Vec<std::string::String>,

    /// Optional. When this value is set to `true` the request is a no-op for
    /// non-existing assets. See <https://google.aip.dev/135#delete-if-existing> for
    /// additional details. Default value is `false`.
    pub allow_missing: bool,
}

impl BatchDeleteAssetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchDeleteAssetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::BatchDeleteAssetsRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [names][crate::model::BatchDeleteAssetsRequest::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchDeleteAssetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.BatchDeleteAssetsRequest"
    }
}

/// A request to report a set of asset frames.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReportAssetFramesRequest {
    /// Required. Parent of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Collection of frames data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub frames: std::option::Option<crate::model::Frames>,

    /// Required. Reference to a source.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source: std::string::String,
}

impl ReportAssetFramesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ReportAssetFramesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [frames][crate::model::ReportAssetFramesRequest::frames].
    pub fn set_frames<T: std::convert::Into<std::option::Option<crate::model::Frames>>>(
        mut self,
        v: T,
    ) -> Self {
        self.frames = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ReportAssetFramesRequest::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }
}

impl wkt::message::Message for ReportAssetFramesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ReportAssetFramesRequest"
    }
}

/// A response to a call to `ReportAssetFrame`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReportAssetFramesResponse {}

impl ReportAssetFramesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ReportAssetFramesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ReportAssetFramesResponse"
    }
}

/// A request to aggregate one or more values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AggregateAssetsValuesRequest {
    /// Required. Parent value for `AggregateAssetsValuesRequest`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Array of aggregations to perform.
    /// Up to 25 aggregations can be defined.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub aggregations: std::vec::Vec<crate::model::Aggregation>,

    /// The aggregation will be performed on assets that match the provided filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl AggregateAssetsValuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::AggregateAssetsValuesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::AggregateAssetsValuesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [aggregations][crate::model::AggregateAssetsValuesRequest::aggregations].
    pub fn set_aggregations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Aggregation>,
    {
        use std::iter::Iterator;
        self.aggregations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AggregateAssetsValuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.AggregateAssetsValuesRequest"
    }
}

/// A response to a request to aggregated assets values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AggregateAssetsValuesResponse {
    /// The aggregation results.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub results: std::vec::Vec<crate::model::AggregationResult>,
}

impl AggregateAssetsValuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [results][crate::model::AggregateAssetsValuesResponse::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AggregationResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AggregateAssetsValuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.AggregateAssetsValuesResponse"
    }
}

/// A request to create an import job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateImportJobRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. ID of the import job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub import_job_id: std::string::String,

    /// Required. The resource being created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub import_job: std::option::Option<crate::model::ImportJob>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateImportJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateImportJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [import_job_id][crate::model::CreateImportJobRequest::import_job_id].
    pub fn set_import_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.import_job_id = v.into();
        self
    }

    /// Sets the value of [import_job][crate::model::CreateImportJobRequest::import_job].
    pub fn set_import_job<T: std::convert::Into<std::option::Option<crate::model::ImportJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.import_job = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateImportJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateImportJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.CreateImportJobRequest"
    }
}

/// A request to list import jobs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListImportJobsRequest {
    /// Required. Parent value for `ListImportJobsRequest`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. The level of details of each import job.
    /// Default value is BASIC.
    pub view: crate::model::ImportJobView,
}

impl ListImportJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListImportJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListImportJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListImportJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListImportJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListImportJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListImportJobsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ImportJobView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListImportJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListImportJobsRequest"
    }
}

/// A response for listing import jobs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListImportJobsResponse {
    /// The list of import jobs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub import_jobs: std::vec::Vec<crate::model::ImportJob>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListImportJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListImportJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [import_jobs][crate::model::ListImportJobsResponse::import_jobs].
    pub fn set_import_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportJob>,
    {
        use std::iter::Iterator;
        self.import_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListImportJobsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListImportJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListImportJobsResponse"
    }
}

impl gax::paginator::PageableResponse for ListImportJobsResponse {
    type PageItem = crate::model::ImportJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.import_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A request to get an import job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetImportJobRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The level of details of the import job.
    /// Default value is FULL.
    pub view: crate::model::ImportJobView,
}

impl GetImportJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetImportJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetImportJobRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ImportJobView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetImportJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetImportJobRequest"
    }
}

/// A request to delete an import job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteImportJobRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set to `true`, any `ImportDataFiles` of this job will also be
    /// deleted If set to `false`, the request only works if the job has no data
    /// files.
    pub force: bool,
}

impl DeleteImportJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteImportJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteImportJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteImportJobRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteImportJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DeleteImportJobRequest"
    }
}

/// A request to update an import job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateImportJobRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `Asset` resource by the update.
    /// The values specified in the `update_mask` field are relative to the
    /// resource, not the full request.
    /// A field will be overwritten if it is in the mask.
    /// A single * value in the mask lets you to overwrite all fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub import_job: std::option::Option<crate::model::ImportJob>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdateImportJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateImportJobRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [import_job][crate::model::UpdateImportJobRequest::import_job].
    pub fn set_import_job<T: std::convert::Into<std::option::Option<crate::model::ImportJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.import_job = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateImportJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateImportJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.UpdateImportJobRequest"
    }
}

/// A request to validate an import job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ValidateImportJobRequest {
    /// Required. The name of the import job to validate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl ValidateImportJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ValidateImportJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::ValidateImportJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for ValidateImportJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ValidateImportJobRequest"
    }
}

/// A request to run an import job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RunImportJobRequest {
    /// Required. The name of the import job to run.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl RunImportJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RunImportJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::RunImportJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for RunImportJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.RunImportJobRequest"
    }
}

/// A request to get an import data file.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetImportDataFileRequest {
    /// Required. Name of the ImportDataFile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetImportDataFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetImportDataFileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetImportDataFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetImportDataFileRequest"
    }
}

/// A request to list import data files of an import job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListImportDataFilesRequest {
    /// Required. Name of the parent of the `ImportDataFiles` resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of data files to return. The service may return
    /// fewer than this value. If unspecified, at most 500 data files will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// A page token, received from a previous `ListImportDataFiles` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListImportDataFiles`
    /// must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListImportDataFilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListImportDataFilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListImportDataFilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListImportDataFilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListImportDataFilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListImportDataFilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListImportDataFilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListImportDataFilesRequest"
    }
}

/// Response for listing payload files of an import job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListImportDataFilesResponse {
    /// The list of import data files.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub import_data_files: std::vec::Vec<crate::model::ImportDataFile>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListImportDataFilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListImportDataFilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [import_data_files][crate::model::ListImportDataFilesResponse::import_data_files].
    pub fn set_import_data_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportDataFile>,
    {
        use std::iter::Iterator;
        self.import_data_files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListImportDataFilesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListImportDataFilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListImportDataFilesResponse"
    }
}

impl gax::paginator::PageableResponse for ListImportDataFilesResponse {
    type PageItem = crate::model::ImportDataFile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.import_data_files
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A request to create an `ImportDataFile` resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateImportDataFileRequest {
    /// Required. Name of the parent of the ImportDataFile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID of the new data file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub import_data_file_id: std::string::String,

    /// Required. The resource being created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub import_data_file: std::option::Option<crate::model::ImportDataFile>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateImportDataFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateImportDataFileRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [import_data_file_id][crate::model::CreateImportDataFileRequest::import_data_file_id].
    pub fn set_import_data_file_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.import_data_file_id = v.into();
        self
    }

    /// Sets the value of [import_data_file][crate::model::CreateImportDataFileRequest::import_data_file].
    pub fn set_import_data_file<
        T: std::convert::Into<std::option::Option<crate::model::ImportDataFile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_data_file = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateImportDataFileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateImportDataFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.CreateImportDataFileRequest"
    }
}

/// A request to delete an `ImportDataFile` resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteImportDataFileRequest {
    /// Required. Name of the ImportDataFile to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteImportDataFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteImportDataFileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteImportDataFileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteImportDataFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DeleteImportDataFileRequest"
    }
}

/// A request to list groups.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGroupsRequest {
    /// Required. Parent value for `ListGroupsRequest`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGroupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListGroupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListGroupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListGroupsRequest"
    }
}

/// A response for listing groups.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGroupsResponse {
    /// The list of Group
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub groups: std::vec::Vec<crate::model::Group>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [groups][crate::model::ListGroupsResponse::groups].
    pub fn set_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Group>,
    {
        use std::iter::Iterator;
        self.groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListGroupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListGroupsResponse"
    }
}

impl gax::paginator::PageableResponse for ListGroupsResponse {
    type PageItem = crate::model::Group;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.groups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A request to get a group.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetGroupRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetGroupRequest"
    }
}

/// A request to create a group.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateGroupRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. User specified ID for the group. It will become the last
    /// component of the group name. The ID must be unique within the project, must
    /// conform with RFC-1034, is restricted to lower-cased letters, and has a
    /// maximum length of 63 characters. The ID must match the regular expression:
    /// `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub group_id: std::string::String,

    /// Required. The group resource being created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub group: std::option::Option<crate::model::Group>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateGroupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [group_id][crate::model::CreateGroupRequest::group_id].
    pub fn set_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group_id = v.into();
        self
    }

    /// Sets the value of [group][crate::model::CreateGroupRequest::group].
    pub fn set_group<T: std::convert::Into<std::option::Option<crate::model::Group>>>(
        mut self,
        v: T,
    ) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.CreateGroupRequest"
    }
}

/// A request to update a group.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateGroupRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `Group` resource by the update.
    /// The values specified in the `update_mask` are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    /// A single * value in the mask lets you to overwrite all fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The group resource being updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub group: std::option::Option<crate::model::Group>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdateGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateGroupRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [group][crate::model::UpdateGroupRequest::group].
    pub fn set_group<T: std::convert::Into<std::option::Option<crate::model::Group>>>(
        mut self,
        v: T,
    ) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.UpdateGroupRequest"
    }
}

/// A request to delete a group.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteGroupRequest {
    /// Required. Name of the group resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DeleteGroupRequest"
    }
}

/// A request to add assets to a group.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddAssetsToGroupRequest {
    /// Required. Group reference.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub group: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Required. List of assets to be added.
    /// The maximum number of assets that can be added in a single request is
    /// 1000.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub assets: std::option::Option<crate::model::AssetList>,

    /// Optional. When this value is set to `false` and one of the given assets is
    /// already an existing member of the group, the operation fails with an
    /// `Already Exists` error. When set to `true` this situation is silently
    /// ignored by the server.
    ///
    /// Default value is `false`.
    pub allow_existing: bool,
}

impl AddAssetsToGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::AddAssetsToGroupRequest::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::AddAssetsToGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [assets][crate::model::AddAssetsToGroupRequest::assets].
    pub fn set_assets<T: std::convert::Into<std::option::Option<crate::model::AssetList>>>(
        mut self,
        v: T,
    ) -> Self {
        self.assets = v.into();
        self
    }

    /// Sets the value of [allow_existing][crate::model::AddAssetsToGroupRequest::allow_existing].
    pub fn set_allow_existing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_existing = v.into();
        self
    }
}

impl wkt::message::Message for AddAssetsToGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.AddAssetsToGroupRequest"
    }
}

/// A request to remove assets from a group.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoveAssetsFromGroupRequest {
    /// Required. Group reference.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub group: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Required. List of assets to be removed.
    /// The maximum number of assets that can be removed in a single request is
    /// 1000.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub assets: std::option::Option<crate::model::AssetList>,

    /// Optional. When this value is set to `false` and one of the given assets is
    /// not an existing member of the group, the operation fails with a `Not Found`
    /// error. When set to `true` this situation is silently ignored by the server.
    ///
    /// Default value is `false`.
    pub allow_missing: bool,
}

impl RemoveAssetsFromGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::RemoveAssetsFromGroupRequest::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::RemoveAssetsFromGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [assets][crate::model::RemoveAssetsFromGroupRequest::assets].
    pub fn set_assets<T: std::convert::Into<std::option::Option<crate::model::AssetList>>>(
        mut self,
        v: T,
    ) -> Self {
        self.assets = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::RemoveAssetsFromGroupRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for RemoveAssetsFromGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.RemoveAssetsFromGroupRequest"
    }
}

/// A request to list error frames for a source.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListErrorFramesRequest {
    /// Required. Parent value (the source) for `ListErrorFramesRequest`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. An optional view mode to control the level of details of each
    /// error frame. The default is a BASIC frame view.
    pub view: crate::model::ErrorFrameView,
}

impl ListErrorFramesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListErrorFramesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListErrorFramesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListErrorFramesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListErrorFramesRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ErrorFrameView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListErrorFramesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListErrorFramesRequest"
    }
}

/// A response for listing error frames.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListErrorFramesResponse {
    /// The list of error frames.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub error_frames: std::vec::Vec<crate::model::ErrorFrame>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListErrorFramesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListErrorFramesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [error_frames][crate::model::ListErrorFramesResponse::error_frames].
    pub fn set_error_frames<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ErrorFrame>,
    {
        use std::iter::Iterator;
        self.error_frames = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListErrorFramesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListErrorFramesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListErrorFramesResponse"
    }
}

impl gax::paginator::PageableResponse for ListErrorFramesResponse {
    type PageItem = crate::model::ErrorFrame;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.error_frames
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetErrorFrameRequest {
    /// Required. The name of the frame to retrieve.
    /// Format:
    /// projects/{project}/locations/{location}/sources/{source}/errorFrames/{error_frame}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional view mode to control the level of details for the
    /// frame. The default is a basic frame view.
    pub view: crate::model::ErrorFrameView,
}

impl GetErrorFrameRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetErrorFrameRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetErrorFrameRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ErrorFrameView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetErrorFrameRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetErrorFrameRequest"
    }
}

/// A request for a list of sources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSourcesRequest {
    /// Required. Parent value for `ListSourcesRequest`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. The server may return fewer items than requested.
    /// If unspecified, the server will pick an appropriate default value.
    pub page_size: i32,

    /// A token identifying a page of results that the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListSourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSourcesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSourcesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSourcesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSourcesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListSourcesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListSourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListSourcesRequest"
    }
}

/// Response message for listing sources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSourcesResponse {
    /// The list of sources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub sources: std::vec::Vec<crate::model::Source>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListSourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListSourcesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [sources][crate::model::ListSourcesResponse::sources].
    pub fn set_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Source>,
    {
        use std::iter::Iterator;
        self.sources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListSourcesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListSourcesResponse"
    }
}

impl gax::paginator::PageableResponse for ListSourcesResponse {
    type PageItem = crate::model::Source;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.sources
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A request to get a source.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSourceRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetSourceRequest"
    }
}

/// A request to create a source.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSourceRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. User specified ID for the source. It will become the last
    /// component of the source name. The ID must be unique within the project,
    /// must conform with RFC-1034, is restricted to lower-cased letters, and has a
    /// maximum length of 63 characters. The ID must match the regular expression:
    /// `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_id: std::string::String,

    /// Required. The resource being created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::Source>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSourceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source_id][crate::model::CreateSourceRequest::source_id].
    pub fn set_source_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_id = v.into();
        self
    }

    /// Sets the value of [source][crate::model::CreateSourceRequest::source].
    pub fn set_source<T: std::convert::Into<std::option::Option<crate::model::Source>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateSourceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.CreateSourceRequest"
    }
}

/// A request to update a source.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSourceRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `Source` resource by the update.
    /// The values specified in the `update_mask` field are relative to the
    /// resource, not the full request.
    /// A field will be overwritten if it is in the mask.
    /// A single * value in the mask lets you to overwrite all fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::Source>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdateSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateSourceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [source][crate::model::UpdateSourceRequest::source].
    pub fn set_source<T: std::convert::Into<std::option::Option<crate::model::Source>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateSourceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.UpdateSourceRequest"
    }
}

/// A request to delete a source.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSourceRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteSourceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DeleteSourceRequest"
    }
}

/// Request for listing preference sets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPreferenceSetsRequest {
    /// Required. Parent value for `ListPreferenceSetsRequest`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, at most 500 preference sets will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListPreferenceSetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPreferenceSetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPreferenceSetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPreferenceSetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListPreferenceSetsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListPreferenceSetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListPreferenceSetsRequest"
    }
}

/// Response message for listing preference sets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPreferenceSetsResponse {
    /// The list of PreferenceSets
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub preference_sets: std::vec::Vec<crate::model::PreferenceSet>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListPreferenceSetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListPreferenceSetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [preference_sets][crate::model::ListPreferenceSetsResponse::preference_sets].
    pub fn set_preference_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PreferenceSet>,
    {
        use std::iter::Iterator;
        self.preference_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListPreferenceSetsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPreferenceSetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListPreferenceSetsResponse"
    }
}

impl gax::paginator::PageableResponse for ListPreferenceSetsResponse {
    type PageItem = crate::model::PreferenceSet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.preference_sets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A request to get a preference set.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPreferenceSetRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetPreferenceSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPreferenceSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPreferenceSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetPreferenceSetRequest"
    }
}

/// A request to create a preference set.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePreferenceSetRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. User specified ID for the preference set. It will become the last
    /// component of the preference set name. The ID must be unique within the
    /// project, must conform with RFC-1034, is restricted to lower-cased letters,
    /// and has a maximum length of 63 characters. The ID must match the regular
    /// expression
    /// `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub preference_set_id: std::string::String,

    /// Required. The preference set resource being created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub preference_set: std::option::Option<crate::model::PreferenceSet>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreatePreferenceSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePreferenceSetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [preference_set_id][crate::model::CreatePreferenceSetRequest::preference_set_id].
    pub fn set_preference_set_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.preference_set_id = v.into();
        self
    }

    /// Sets the value of [preference_set][crate::model::CreatePreferenceSetRequest::preference_set].
    pub fn set_preference_set<
        T: std::convert::Into<std::option::Option<crate::model::PreferenceSet>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.preference_set = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreatePreferenceSetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreatePreferenceSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.CreatePreferenceSetRequest"
    }
}

/// A request to update a preference set.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdatePreferenceSetRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `PreferenceSet` resource by the update.
    /// The values specified in the `update_mask` field are relative to the
    /// resource, not the full request.
    /// A field will be overwritten if it is in the mask.
    /// A single * value in the mask lets you to overwrite all fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The preference set resource being updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub preference_set: std::option::Option<crate::model::PreferenceSet>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdatePreferenceSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdatePreferenceSetRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [preference_set][crate::model::UpdatePreferenceSetRequest::preference_set].
    pub fn set_preference_set<
        T: std::convert::Into<std::option::Option<crate::model::PreferenceSet>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.preference_set = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdatePreferenceSetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePreferenceSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.UpdatePreferenceSetRequest"
    }
}

/// A request to delete a preference set.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePreferenceSetRequest {
    /// Required. Name of the group resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeletePreferenceSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePreferenceSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeletePreferenceSetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeletePreferenceSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DeletePreferenceSetRequest"
    }
}

/// A request to get the settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSettingsRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetSettingsRequest"
    }
}

/// A request to update the settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSettingsRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `Settings` resource by the update.
    /// The values specified in the `update_mask` field are relative to the
    /// resource, not the full request.
    /// A field will be overwritten if it is in the mask.
    /// A single * value in the mask lets you to overwrite all fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The project settings resource being updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub settings: std::option::Option<crate::model::Settings>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdateSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateSettingsRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [settings][crate::model::UpdateSettingsRequest::settings].
    pub fn set_settings<T: std::convert::Into<std::option::Option<crate::model::Settings>>>(
        mut self,
        v: T,
    ) -> Self {
        self.settings = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateSettingsRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.UpdateSettingsRequest"
    }
}

/// A request to create a `ReportConfig` resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateReportConfigRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. User specified ID for the report config. It will become the last
    /// component of the report config name. The ID must be unique within the
    /// project, must conform with RFC-1034, is restricted to lower-cased letters,
    /// and has a maximum length of 63 characters. The ID must match the regular
    /// expression: [a-z]([a-z0-9-]{0,61}[a-z0-9])?.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub report_config_id: std::string::String,

    /// Required. The report config set resource being created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub report_config: std::option::Option<crate::model::ReportConfig>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateReportConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateReportConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [report_config_id][crate::model::CreateReportConfigRequest::report_config_id].
    pub fn set_report_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.report_config_id = v.into();
        self
    }

    /// Sets the value of [report_config][crate::model::CreateReportConfigRequest::report_config].
    pub fn set_report_config<
        T: std::convert::Into<std::option::Option<crate::model::ReportConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.report_config = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateReportConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateReportConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.CreateReportConfigRequest"
    }
}

/// A request to delete a ReportConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteReportConfigRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set to `true`, any child `Reports` of this entity will also be
    /// deleted. If set to `false`, the request only works if the resource has no
    /// children.
    pub force: bool,
}

impl DeleteReportConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteReportConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteReportConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteReportConfigRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteReportConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DeleteReportConfigRequest"
    }
}

/// A request to get a Report.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetReportRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Determines what information to retrieve for the Report.
    pub view: crate::model::ReportView,
}

impl GetReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetReportRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ReportView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetReportRequest"
    }
}

/// A request for a list of Reports.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListReportsRequest {
    /// Required. Parent value for `ListReportsRequest`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. The server may return fewer items than requested.
    /// If unspecified, the server will pick an appropriate default value.
    pub page_size: i32,

    /// A token identifying a page of results that the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Determines what information to retrieve for each Report.
    pub view: crate::model::ReportView,
}

impl ListReportsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReportsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReportsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReportsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListReportsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListReportsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListReportsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ReportView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListReportsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListReportsRequest"
    }
}

/// Response message for listing Reports.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListReportsResponse {
    /// The list of Reports.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reports: std::vec::Vec<crate::model::Report>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListReportsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListReportsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [reports][crate::model::ListReportsResponse::reports].
    pub fn set_reports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Report>,
    {
        use std::iter::Iterator;
        self.reports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListReportsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListReportsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListReportsResponse"
    }
}

impl gax::paginator::PageableResponse for ListReportsResponse {
    type PageItem = crate::model::Report;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.reports
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A request to delete a Report.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteReportRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteReportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteReportRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DeleteReportRequest"
    }
}

/// A request to get a `ReportConfig` resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetReportConfigRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetReportConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReportConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetReportConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GetReportConfigRequest"
    }
}

/// A request to get a list of `ReportConfig` resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListReportConfigsRequest {
    /// Required. Parent value for `ListReportConfigsRequest`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListReportConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReportConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReportConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReportConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListReportConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListReportConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListReportConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListReportConfigsRequest"
    }
}

/// Response message for listing report configs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListReportConfigsResponse {
    /// A list of report configs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub report_configs: std::vec::Vec<crate::model::ReportConfig>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListReportConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListReportConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [report_configs][crate::model::ListReportConfigsResponse::report_configs].
    pub fn set_report_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReportConfig>,
    {
        use std::iter::Iterator;
        self.report_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListReportConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListReportConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ListReportConfigsResponse"
    }
}

impl gax::paginator::PageableResponse for ListReportConfigsResponse {
    type PageItem = crate::model::ReportConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.report_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for creating a Report.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateReportRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. User specified id for the report. It will become the last
    /// component of the report name. The id must be unique within the project,
    /// must conform with RFC-1034, is restricted to lower-cased letters, and has a
    /// maximum length of 63 characters. The id must match the regular expression:
    /// [a-z]([a-z0-9-]{0,61}[a-z0-9])?.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub report_id: std::string::String,

    /// Required. The report resource being created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub report: std::option::Option<crate::model::Report>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateReportRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [report_id][crate::model::CreateReportRequest::report_id].
    pub fn set_report_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.report_id = v.into();
        self
    }

    /// Sets the value of [report][crate::model::CreateReportRequest::report].
    pub fn set_report<T: std::convert::Into<std::option::Option<crate::model::Report>>>(
        mut self,
        v: T,
    ) -> Self {
        self.report = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateReportRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.CreateReportRequest"
    }
}

/// Collection of frame data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Frames {
    /// A repeated field of asset data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub frames_data: std::vec::Vec<crate::model::AssetFrame>,
}

impl Frames {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [frames_data][crate::model::Frames::frames_data].
    pub fn set_frames_data<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AssetFrame>,
    {
        use std::iter::Iterator;
        self.frames_data = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Frames {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.Frames"
    }
}

/// Contains data reported from an inventory source on an asset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AssetFrame {
    /// The time the data was reported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub report_time: std::option::Option<wkt::Timestamp>,

    /// Labels as key value pairs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Generic asset attributes.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub attributes: std::collections::HashMap<std::string::String, std::string::String>,

    /// Asset performance data samples.
    /// Samples that are from more than 40 days ago or after tomorrow are ignored.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub performance_samples: std::vec::Vec<crate::model::PerformanceSample>,

    /// Optional. Trace token is optionally provided to assist with debugging and
    /// traceability.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trace_token: std::string::String,

    /// The internal data of the frame is a oneof field depending on the type
    /// of asset information in the frame.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub frame_data: std::option::Option<crate::model::asset_frame::FrameData>,
}

impl AssetFrame {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [report_time][crate::model::AssetFrame::report_time].
    pub fn set_report_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.report_time = v.into();
        self
    }

    /// Sets the value of [trace_token][crate::model::AssetFrame::trace_token].
    pub fn set_trace_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trace_token = v.into();
        self
    }

    /// Sets the value of [performance_samples][crate::model::AssetFrame::performance_samples].
    pub fn set_performance_samples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PerformanceSample>,
    {
        use std::iter::Iterator;
        self.performance_samples = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::AssetFrame::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [attributes][crate::model::AssetFrame::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `frame_data`.
    pub fn set_frame_data<
        T: std::convert::Into<std::option::Option<crate::model::asset_frame::FrameData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.frame_data = v.into();
        self
    }

    /// The value of [frame_data][crate::model::AssetFrame::frame_data]
    /// if it holds a `MachineDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_machine_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MachineDetails>> {
        #[allow(unreachable_patterns)]
        self.frame_data.as_ref().and_then(|v| match v {
            crate::model::asset_frame::FrameData::MachineDetails(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [frame_data][crate::model::AssetFrame::frame_data]
    /// to hold a `MachineDetails`.
    ///
    /// Note that all the setters affecting `frame_data` are
    /// mutually exclusive.
    pub fn set_machine_details<
        T: std::convert::Into<std::boxed::Box<crate::model::MachineDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.frame_data = std::option::Option::Some(
            crate::model::asset_frame::FrameData::MachineDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AssetFrame {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.AssetFrame"
    }
}

/// Defines additional types related to AssetFrame
pub mod asset_frame {
    #[allow(unused_imports)]
    use super::*;

    /// The internal data of the frame is a oneof field depending on the type
    /// of asset information in the frame.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum FrameData {
        /// Asset information specific for virtual machines.
        MachineDetails(std::boxed::Box<crate::model::MachineDetails>),
    }
}

/// Details of a machine.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MachineDetails {
    /// Machine unique identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uuid: std::string::String,

    /// Machine name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_name: std::string::String,

    /// Machine creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Number of CPU cores in the machine. Must be non-negative.
    pub core_count: i32,

    /// The amount of memory in the machine. Must be non-negative.
    pub memory_mb: i32,

    /// Power state of the machine.
    pub power_state: crate::model::machine_details::PowerState,

    /// Architecture details (vendor, CPU architecture).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub architecture: std::option::Option<crate::model::MachineArchitectureDetails>,

    /// Guest OS information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub guest_os: std::option::Option<crate::model::GuestOsDetails>,

    /// Network details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network: std::option::Option<crate::model::MachineNetworkDetails>,

    /// Disk details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disks: std::option::Option<crate::model::MachineDiskDetails>,

    /// Platform specific information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub platform: std::option::Option<crate::model::PlatformDetails>,
}

impl MachineDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uuid][crate::model::MachineDetails::uuid].
    pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uuid = v.into();
        self
    }

    /// Sets the value of [machine_name][crate::model::MachineDetails::machine_name].
    pub fn set_machine_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MachineDetails::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [core_count][crate::model::MachineDetails::core_count].
    pub fn set_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.core_count = v.into();
        self
    }

    /// Sets the value of [memory_mb][crate::model::MachineDetails::memory_mb].
    pub fn set_memory_mb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_mb = v.into();
        self
    }

    /// Sets the value of [power_state][crate::model::MachineDetails::power_state].
    pub fn set_power_state<T: std::convert::Into<crate::model::machine_details::PowerState>>(
        mut self,
        v: T,
    ) -> Self {
        self.power_state = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::MachineDetails::architecture].
    pub fn set_architecture<
        T: std::convert::Into<std::option::Option<crate::model::MachineArchitectureDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.architecture = v.into();
        self
    }

    /// Sets the value of [guest_os][crate::model::MachineDetails::guest_os].
    pub fn set_guest_os<
        T: std::convert::Into<std::option::Option<crate::model::GuestOsDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.guest_os = v.into();
        self
    }

    /// Sets the value of [network][crate::model::MachineDetails::network].
    pub fn set_network<
        T: std::convert::Into<std::option::Option<crate::model::MachineNetworkDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [disks][crate::model::MachineDetails::disks].
    pub fn set_disks<
        T: std::convert::Into<std::option::Option<crate::model::MachineDiskDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.disks = v.into();
        self
    }

    /// Sets the value of [platform][crate::model::MachineDetails::platform].
    pub fn set_platform<
        T: std::convert::Into<std::option::Option<crate::model::PlatformDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform = v.into();
        self
    }
}

impl wkt::message::Message for MachineDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.MachineDetails"
    }
}

/// Defines additional types related to MachineDetails
pub mod machine_details {
    #[allow(unused_imports)]
    use super::*;

    /// Machine power state.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct PowerState(i32);

    impl PowerState {
        /// Power state is unknown.
        pub const POWER_STATE_UNSPECIFIED: PowerState = PowerState::new(0);

        /// The machine is preparing to enter the ACTIVE state. An instance may enter
        /// the PENDING state when it launches for the first time, or when it is
        /// started after being in the SUSPENDED state.
        pub const PENDING: PowerState = PowerState::new(1);

        /// The machine is active.
        pub const ACTIVE: PowerState = PowerState::new(2);

        /// The machine is being turned off.
        pub const SUSPENDING: PowerState = PowerState::new(3);

        /// The machine is off.
        pub const SUSPENDED: PowerState = PowerState::new(4);

        /// The machine is being deleted from the hosting platform.
        pub const DELETING: PowerState = PowerState::new(5);

        /// The machine is deleted from the hosting platform.
        pub const DELETED: PowerState = PowerState::new(6);

        /// Creates a new PowerState instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("POWER_STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PENDING"),
                2 => std::borrow::Cow::Borrowed("ACTIVE"),
                3 => std::borrow::Cow::Borrowed("SUSPENDING"),
                4 => std::borrow::Cow::Borrowed("SUSPENDED"),
                5 => std::borrow::Cow::Borrowed("DELETING"),
                6 => std::borrow::Cow::Borrowed("DELETED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "POWER_STATE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::POWER_STATE_UNSPECIFIED)
                }
                "PENDING" => std::option::Option::Some(Self::PENDING),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                "SUSPENDING" => std::option::Option::Some(Self::SUSPENDING),
                "SUSPENDED" => std::option::Option::Some(Self::SUSPENDED),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                "DELETED" => std::option::Option::Some(Self::DELETED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for PowerState {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for PowerState {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Details of the machine architecture.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MachineArchitectureDetails {
    /// CPU architecture, e.g., "x64-based PC", "x86_64", "i686" etc.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cpu_architecture: std::string::String,

    /// CPU name, e.g., "Intel Xeon E5-2690", "AMD EPYC 7571" etc.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cpu_name: std::string::String,

    /// Hardware vendor.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vendor: std::string::String,

    /// Number of CPU threads allocated to the machine.
    pub cpu_thread_count: i32,

    /// Number of processor sockets allocated to the machine.
    pub cpu_socket_count: i32,

    /// BIOS Details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bios: std::option::Option<crate::model::BiosDetails>,

    /// Firmware type.
    pub firmware_type: crate::model::machine_architecture_details::FirmwareType,

    /// CPU hyper-threading support.
    pub hyperthreading: crate::model::machine_architecture_details::CpuHyperThreading,
}

impl MachineArchitectureDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpu_architecture][crate::model::MachineArchitectureDetails::cpu_architecture].
    pub fn set_cpu_architecture<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cpu_architecture = v.into();
        self
    }

    /// Sets the value of [cpu_name][crate::model::MachineArchitectureDetails::cpu_name].
    pub fn set_cpu_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpu_name = v.into();
        self
    }

    /// Sets the value of [vendor][crate::model::MachineArchitectureDetails::vendor].
    pub fn set_vendor<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vendor = v.into();
        self
    }

    /// Sets the value of [cpu_thread_count][crate::model::MachineArchitectureDetails::cpu_thread_count].
    pub fn set_cpu_thread_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_thread_count = v.into();
        self
    }

    /// Sets the value of [cpu_socket_count][crate::model::MachineArchitectureDetails::cpu_socket_count].
    pub fn set_cpu_socket_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_socket_count = v.into();
        self
    }

    /// Sets the value of [bios][crate::model::MachineArchitectureDetails::bios].
    pub fn set_bios<T: std::convert::Into<std::option::Option<crate::model::BiosDetails>>>(
        mut self,
        v: T,
    ) -> Self {
        self.bios = v.into();
        self
    }

    /// Sets the value of [firmware_type][crate::model::MachineArchitectureDetails::firmware_type].
    pub fn set_firmware_type<
        T: std::convert::Into<crate::model::machine_architecture_details::FirmwareType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firmware_type = v.into();
        self
    }

    /// Sets the value of [hyperthreading][crate::model::MachineArchitectureDetails::hyperthreading].
    pub fn set_hyperthreading<
        T: std::convert::Into<crate::model::machine_architecture_details::CpuHyperThreading>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hyperthreading = v.into();
        self
    }
}

impl wkt::message::Message for MachineArchitectureDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.MachineArchitectureDetails"
    }
}

/// Defines additional types related to MachineArchitectureDetails
pub mod machine_architecture_details {
    #[allow(unused_imports)]
    use super::*;

    /// Firmware type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct FirmwareType(i32);

    impl FirmwareType {
        /// Unspecified or unknown.
        pub const FIRMWARE_TYPE_UNSPECIFIED: FirmwareType = FirmwareType::new(0);

        /// BIOS firmware.
        pub const BIOS: FirmwareType = FirmwareType::new(1);

        /// EFI firmware.
        pub const EFI: FirmwareType = FirmwareType::new(2);

        /// Creates a new FirmwareType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("FIRMWARE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("BIOS"),
                2 => std::borrow::Cow::Borrowed("EFI"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "FIRMWARE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::FIRMWARE_TYPE_UNSPECIFIED)
                }
                "BIOS" => std::option::Option::Some(Self::BIOS),
                "EFI" => std::option::Option::Some(Self::EFI),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for FirmwareType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for FirmwareType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// CPU hyper-threading support.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct CpuHyperThreading(i32);

    impl CpuHyperThreading {
        /// Unspecified or unknown.
        pub const CPU_HYPER_THREADING_UNSPECIFIED: CpuHyperThreading = CpuHyperThreading::new(0);

        /// Hyper-threading is disabled.
        pub const DISABLED: CpuHyperThreading = CpuHyperThreading::new(1);

        /// Hyper-threading is enabled.
        pub const ENABLED: CpuHyperThreading = CpuHyperThreading::new(2);

        /// Creates a new CpuHyperThreading instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CPU_HYPER_THREADING_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DISABLED"),
                2 => std::borrow::Cow::Borrowed("ENABLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CPU_HYPER_THREADING_UNSPECIFIED" => {
                    std::option::Option::Some(Self::CPU_HYPER_THREADING_UNSPECIFIED)
                }
                "DISABLED" => std::option::Option::Some(Self::DISABLED),
                "ENABLED" => std::option::Option::Some(Self::ENABLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for CpuHyperThreading {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for CpuHyperThreading {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Details about the BIOS.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BiosDetails {
    /// BIOS name.
    /// This fields is deprecated. Please use the `id` field instead.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bios_name: std::string::String,

    /// BIOS ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// BIOS manufacturer.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub manufacturer: std::string::String,

    /// BIOS version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// BIOS release date.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub release_date: std::option::Option<gtype::model::Date>,

    /// SMBIOS UUID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub smbios_uuid: std::string::String,
}

impl BiosDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bios_name][crate::model::BiosDetails::bios_name].
    pub fn set_bios_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bios_name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::BiosDetails::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [manufacturer][crate::model::BiosDetails::manufacturer].
    pub fn set_manufacturer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.manufacturer = v.into();
        self
    }

    /// Sets the value of [version][crate::model::BiosDetails::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [release_date][crate::model::BiosDetails::release_date].
    pub fn set_release_date<T: std::convert::Into<std::option::Option<gtype::model::Date>>>(
        mut self,
        v: T,
    ) -> Self {
        self.release_date = v.into();
        self
    }

    /// Sets the value of [smbios_uuid][crate::model::BiosDetails::smbios_uuid].
    pub fn set_smbios_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.smbios_uuid = v.into();
        self
    }
}

impl wkt::message::Message for BiosDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.BiosDetails"
    }
}

/// Details of network adapters and settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MachineNetworkDetails {
    /// The primary IP address of the machine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub primary_ip_address: std::string::String,

    /// The public IP address of the machine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_ip_address: std::string::String,

    /// MAC address of the machine.
    /// This property is used to uniqly identify the machine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub primary_mac_address: std::string::String,

    /// List of network adapters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub adapters: std::option::Option<crate::model::NetworkAdapterList>,
}

impl MachineNetworkDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [primary_ip_address][crate::model::MachineNetworkDetails::primary_ip_address].
    pub fn set_primary_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.primary_ip_address = v.into();
        self
    }

    /// Sets the value of [public_ip_address][crate::model::MachineNetworkDetails::public_ip_address].
    pub fn set_public_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.public_ip_address = v.into();
        self
    }

    /// Sets the value of [primary_mac_address][crate::model::MachineNetworkDetails::primary_mac_address].
    pub fn set_primary_mac_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.primary_mac_address = v.into();
        self
    }

    /// Sets the value of [adapters][crate::model::MachineNetworkDetails::adapters].
    pub fn set_adapters<
        T: std::convert::Into<std::option::Option<crate::model::NetworkAdapterList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.adapters = v.into();
        self
    }
}

impl wkt::message::Message for MachineNetworkDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.MachineNetworkDetails"
    }
}

/// List of network adapters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkAdapterList {
    /// Network adapter entries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entries: std::vec::Vec<crate::model::NetworkAdapterDetails>,
}

impl NetworkAdapterList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::NetworkAdapterList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkAdapterDetails>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NetworkAdapterList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.NetworkAdapterList"
    }
}

/// Details of network adapter.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkAdapterDetails {
    /// Network adapter type (e.g. VMXNET3).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub adapter_type: std::string::String,

    /// MAC address.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mac_address: std::string::String,

    /// NetworkAddressList
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub addresses: std::option::Option<crate::model::NetworkAddressList>,
}

impl NetworkAdapterDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [adapter_type][crate::model::NetworkAdapterDetails::adapter_type].
    pub fn set_adapter_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.adapter_type = v.into();
        self
    }

    /// Sets the value of [mac_address][crate::model::NetworkAdapterDetails::mac_address].
    pub fn set_mac_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mac_address = v.into();
        self
    }

    /// Sets the value of [addresses][crate::model::NetworkAdapterDetails::addresses].
    pub fn set_addresses<
        T: std::convert::Into<std::option::Option<crate::model::NetworkAddressList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.addresses = v.into();
        self
    }
}

impl wkt::message::Message for NetworkAdapterDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.NetworkAdapterDetails"
    }
}

/// List of allocated/assigned network addresses.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkAddressList {
    /// Network address entries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entries: std::vec::Vec<crate::model::NetworkAddress>,
}

impl NetworkAddressList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::NetworkAddressList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkAddress>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NetworkAddressList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.NetworkAddressList"
    }
}

/// Details of network address.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkAddress {
    /// Assigned or configured IP Address.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_address: std::string::String,

    /// Subnet mask.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnet_mask: std::string::String,

    /// Broadcast address.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bcast: std::string::String,

    /// Fully qualified domain name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub fqdn: std::string::String,

    /// Whether DHCP is used to assign addresses.
    pub assignment: crate::model::network_address::AddressAssignment,
}

impl NetworkAddress {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip_address][crate::model::NetworkAddress::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [subnet_mask][crate::model::NetworkAddress::subnet_mask].
    pub fn set_subnet_mask<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet_mask = v.into();
        self
    }

    /// Sets the value of [bcast][crate::model::NetworkAddress::bcast].
    pub fn set_bcast<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bcast = v.into();
        self
    }

    /// Sets the value of [fqdn][crate::model::NetworkAddress::fqdn].
    pub fn set_fqdn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fqdn = v.into();
        self
    }

    /// Sets the value of [assignment][crate::model::NetworkAddress::assignment].
    pub fn set_assignment<
        T: std::convert::Into<crate::model::network_address::AddressAssignment>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.assignment = v.into();
        self
    }
}

impl wkt::message::Message for NetworkAddress {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.NetworkAddress"
    }
}

/// Defines additional types related to NetworkAddress
pub mod network_address {
    #[allow(unused_imports)]
    use super::*;

    /// Network address assignment.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AddressAssignment(i32);

    impl AddressAssignment {
        /// Unknown (default value).
        pub const ADDRESS_ASSIGNMENT_UNSPECIFIED: AddressAssignment = AddressAssignment::new(0);

        /// Staticly assigned IP.
        pub const ADDRESS_ASSIGNMENT_STATIC: AddressAssignment = AddressAssignment::new(1);

        /// Dynamically assigned IP (DHCP).
        pub const ADDRESS_ASSIGNMENT_DHCP: AddressAssignment = AddressAssignment::new(2);

        /// Creates a new AddressAssignment instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ADDRESS_ASSIGNMENT_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ADDRESS_ASSIGNMENT_STATIC"),
                2 => std::borrow::Cow::Borrowed("ADDRESS_ASSIGNMENT_DHCP"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ADDRESS_ASSIGNMENT_UNSPECIFIED" => {
                    std::option::Option::Some(Self::ADDRESS_ASSIGNMENT_UNSPECIFIED)
                }
                "ADDRESS_ASSIGNMENT_STATIC" => {
                    std::option::Option::Some(Self::ADDRESS_ASSIGNMENT_STATIC)
                }
                "ADDRESS_ASSIGNMENT_DHCP" => {
                    std::option::Option::Some(Self::ADDRESS_ASSIGNMENT_DHCP)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for AddressAssignment {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for AddressAssignment {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Details of machine disks.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MachineDiskDetails {
    /// Disk total Capacity.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_capacity_bytes: i64,

    /// Total disk free space.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_free_bytes: i64,

    /// List of disks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disks: std::option::Option<crate::model::DiskEntryList>,
}

impl MachineDiskDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_capacity_bytes][crate::model::MachineDiskDetails::total_capacity_bytes].
    pub fn set_total_capacity_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_capacity_bytes = v.into();
        self
    }

    /// Sets the value of [total_free_bytes][crate::model::MachineDiskDetails::total_free_bytes].
    pub fn set_total_free_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_free_bytes = v.into();
        self
    }

    /// Sets the value of [disks][crate::model::MachineDiskDetails::disks].
    pub fn set_disks<T: std::convert::Into<std::option::Option<crate::model::DiskEntryList>>>(
        mut self,
        v: T,
    ) -> Self {
        self.disks = v.into();
        self
    }
}

impl wkt::message::Message for MachineDiskDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.MachineDiskDetails"
    }
}

/// VM disks.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiskEntryList {
    /// Disk entries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entries: std::vec::Vec<crate::model::DiskEntry>,
}

impl DiskEntryList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::DiskEntryList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiskEntry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DiskEntryList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DiskEntryList"
    }
}

/// Single disk entry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiskEntry {
    /// Disk capacity.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub capacity_bytes: i64,

    /// Disk free space.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub free_bytes: i64,

    /// Disk label.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub disk_label: std::string::String,

    /// Disk label type (e.g. BIOS/GPT)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub disk_label_type: std::string::String,

    /// Disks interface type.
    pub interface_type: crate::model::disk_entry::InterfaceType,

    /// Partition layout.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub partitions: std::option::Option<crate::model::DiskPartitionList>,

    /// Disk hardware address (e.g. 0:1 for SCSI).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hw_address: std::string::String,

    /// Additional details for specific platforms.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub platform_specific: std::option::Option<crate::model::disk_entry::PlatformSpecific>,
}

impl DiskEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [capacity_bytes][crate::model::DiskEntry::capacity_bytes].
    pub fn set_capacity_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.capacity_bytes = v.into();
        self
    }

    /// Sets the value of [free_bytes][crate::model::DiskEntry::free_bytes].
    pub fn set_free_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.free_bytes = v.into();
        self
    }

    /// Sets the value of [disk_label][crate::model::DiskEntry::disk_label].
    pub fn set_disk_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_label = v.into();
        self
    }

    /// Sets the value of [disk_label_type][crate::model::DiskEntry::disk_label_type].
    pub fn set_disk_label_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_label_type = v.into();
        self
    }

    /// Sets the value of [interface_type][crate::model::DiskEntry::interface_type].
    pub fn set_interface_type<T: std::convert::Into<crate::model::disk_entry::InterfaceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.interface_type = v.into();
        self
    }

    /// Sets the value of [partitions][crate::model::DiskEntry::partitions].
    pub fn set_partitions<
        T: std::convert::Into<std::option::Option<crate::model::DiskPartitionList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.partitions = v.into();
        self
    }

    /// Sets the value of [hw_address][crate::model::DiskEntry::hw_address].
    pub fn set_hw_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hw_address = v.into();
        self
    }

    /// Sets the value of `platform_specific`.
    pub fn set_platform_specific<
        T: std::convert::Into<std::option::Option<crate::model::disk_entry::PlatformSpecific>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_specific = v.into();
        self
    }

    /// The value of [platform_specific][crate::model::DiskEntry::platform_specific]
    /// if it holds a `Vmware`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vmware(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmwareDiskConfig>> {
        #[allow(unreachable_patterns)]
        self.platform_specific.as_ref().and_then(|v| match v {
            crate::model::disk_entry::PlatformSpecific::Vmware(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [platform_specific][crate::model::DiskEntry::platform_specific]
    /// to hold a `Vmware`.
    ///
    /// Note that all the setters affecting `platform_specific` are
    /// mutually exclusive.
    pub fn set_vmware<T: std::convert::Into<std::boxed::Box<crate::model::VmwareDiskConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.platform_specific =
            std::option::Option::Some(crate::model::disk_entry::PlatformSpecific::Vmware(v.into()));
        self
    }
}

impl wkt::message::Message for DiskEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DiskEntry"
    }
}

/// Defines additional types related to DiskEntry
pub mod disk_entry {
    #[allow(unused_imports)]
    use super::*;

    /// Disks interface type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct InterfaceType(i32);

    impl InterfaceType {
        /// Interface type unknown or unspecified.
        pub const INTERFACE_TYPE_UNSPECIFIED: InterfaceType = InterfaceType::new(0);

        /// IDE interface type.
        pub const IDE: InterfaceType = InterfaceType::new(1);

        /// SATA interface type.
        pub const SATA: InterfaceType = InterfaceType::new(2);

        /// SAS interface type.
        pub const SAS: InterfaceType = InterfaceType::new(3);

        /// SCSI interface type.
        pub const SCSI: InterfaceType = InterfaceType::new(4);

        /// NVME interface type.
        pub const NVME: InterfaceType = InterfaceType::new(5);

        /// FC interface type.
        pub const FC: InterfaceType = InterfaceType::new(6);

        /// iSCSI interface type.
        pub const ISCSI: InterfaceType = InterfaceType::new(7);

        /// Creates a new InterfaceType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("INTERFACE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("IDE"),
                2 => std::borrow::Cow::Borrowed("SATA"),
                3 => std::borrow::Cow::Borrowed("SAS"),
                4 => std::borrow::Cow::Borrowed("SCSI"),
                5 => std::borrow::Cow::Borrowed("NVME"),
                6 => std::borrow::Cow::Borrowed("FC"),
                7 => std::borrow::Cow::Borrowed("ISCSI"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "INTERFACE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::INTERFACE_TYPE_UNSPECIFIED)
                }
                "IDE" => std::option::Option::Some(Self::IDE),
                "SATA" => std::option::Option::Some(Self::SATA),
                "SAS" => std::option::Option::Some(Self::SAS),
                "SCSI" => std::option::Option::Some(Self::SCSI),
                "NVME" => std::option::Option::Some(Self::NVME),
                "FC" => std::option::Option::Some(Self::FC),
                "ISCSI" => std::option::Option::Some(Self::ISCSI),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for InterfaceType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for InterfaceType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Additional details for specific platforms.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum PlatformSpecific {
        /// VMware disk details.
        Vmware(std::boxed::Box<crate::model::VmwareDiskConfig>),
    }
}

/// Disk partition list.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiskPartitionList {
    /// Partition entries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entries: std::vec::Vec<crate::model::DiskPartition>,
}

impl DiskPartitionList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::DiskPartitionList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiskPartition>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DiskPartitionList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DiskPartitionList"
    }
}

/// Disk Partition details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiskPartition {
    /// Partition type.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Partition file system.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_system: std::string::String,

    /// Mount pount (Linux/Windows) or drive letter (Windows).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mount_point: std::string::String,

    /// Partition capacity.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub capacity_bytes: i64,

    /// Partition free space.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub free_bytes: i64,

    /// Partition UUID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uuid: std::string::String,

    /// Sub-partitions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sub_partitions: std::option::Option<std::boxed::Box<crate::model::DiskPartitionList>>,
}

impl DiskPartition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::DiskPartition::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [file_system][crate::model::DiskPartition::file_system].
    pub fn set_file_system<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_system = v.into();
        self
    }

    /// Sets the value of [mount_point][crate::model::DiskPartition::mount_point].
    pub fn set_mount_point<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mount_point = v.into();
        self
    }

    /// Sets the value of [capacity_bytes][crate::model::DiskPartition::capacity_bytes].
    pub fn set_capacity_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.capacity_bytes = v.into();
        self
    }

    /// Sets the value of [free_bytes][crate::model::DiskPartition::free_bytes].
    pub fn set_free_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.free_bytes = v.into();
        self
    }

    /// Sets the value of [uuid][crate::model::DiskPartition::uuid].
    pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uuid = v.into();
        self
    }

    /// Sets the value of [sub_partitions][crate::model::DiskPartition::sub_partitions].
    pub fn set_sub_partitions<
        T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::DiskPartitionList>>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sub_partitions = v.into();
        self
    }
}

impl wkt::message::Message for DiskPartition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DiskPartition"
    }
}

/// VMware disk config details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VmwareDiskConfig {
    /// VMDK backing type.
    pub backing_type: crate::model::vmware_disk_config::BackingType,

    /// Is VMDK shared with other VMs.
    pub shared: bool,

    /// VMDK disk mode.
    pub vmdk_mode: crate::model::vmware_disk_config::VmdkMode,

    /// RDM compatibility mode.
    pub rdm_compatibility: crate::model::vmware_disk_config::RdmCompatibility,
}

impl VmwareDiskConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backing_type][crate::model::VmwareDiskConfig::backing_type].
    pub fn set_backing_type<
        T: std::convert::Into<crate::model::vmware_disk_config::BackingType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backing_type = v.into();
        self
    }

    /// Sets the value of [shared][crate::model::VmwareDiskConfig::shared].
    pub fn set_shared<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.shared = v.into();
        self
    }

    /// Sets the value of [vmdk_mode][crate::model::VmwareDiskConfig::vmdk_mode].
    pub fn set_vmdk_mode<T: std::convert::Into<crate::model::vmware_disk_config::VmdkMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.vmdk_mode = v.into();
        self
    }

    /// Sets the value of [rdm_compatibility][crate::model::VmwareDiskConfig::rdm_compatibility].
    pub fn set_rdm_compatibility<
        T: std::convert::Into<crate::model::vmware_disk_config::RdmCompatibility>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rdm_compatibility = v.into();
        self
    }
}

impl wkt::message::Message for VmwareDiskConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.VmwareDiskConfig"
    }
}

/// Defines additional types related to VmwareDiskConfig
pub mod vmware_disk_config {
    #[allow(unused_imports)]
    use super::*;

    /// VMDK backing type possible values.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct BackingType(i32);

    impl BackingType {
        /// Default value.
        pub const BACKING_TYPE_UNSPECIFIED: BackingType = BackingType::new(0);

        /// Flat v1.
        pub const BACKING_TYPE_FLAT_V1: BackingType = BackingType::new(1);

        /// Flat v2.
        pub const BACKING_TYPE_FLAT_V2: BackingType = BackingType::new(2);

        /// Persistent memory, also known as Non-Volatile Memory (NVM).
        pub const BACKING_TYPE_PMEM: BackingType = BackingType::new(3);

        /// Raw Disk Memory v1.
        pub const BACKING_TYPE_RDM_V1: BackingType = BackingType::new(4);

        /// Raw Disk Memory v2.
        pub const BACKING_TYPE_RDM_V2: BackingType = BackingType::new(5);

        /// SEsparse is a snapshot format introduced in vSphere 5.5 for large disks.
        pub const BACKING_TYPE_SESPARSE: BackingType = BackingType::new(6);

        /// SEsparse v1.
        pub const BACKING_TYPE_SESPARSE_V1: BackingType = BackingType::new(7);

        /// SEsparse v1.
        pub const BACKING_TYPE_SESPARSE_V2: BackingType = BackingType::new(8);

        /// Creates a new BackingType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("BACKING_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("BACKING_TYPE_FLAT_V1"),
                2 => std::borrow::Cow::Borrowed("BACKING_TYPE_FLAT_V2"),
                3 => std::borrow::Cow::Borrowed("BACKING_TYPE_PMEM"),
                4 => std::borrow::Cow::Borrowed("BACKING_TYPE_RDM_V1"),
                5 => std::borrow::Cow::Borrowed("BACKING_TYPE_RDM_V2"),
                6 => std::borrow::Cow::Borrowed("BACKING_TYPE_SESPARSE"),
                7 => std::borrow::Cow::Borrowed("BACKING_TYPE_SESPARSE_V1"),
                8 => std::borrow::Cow::Borrowed("BACKING_TYPE_SESPARSE_V2"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "BACKING_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::BACKING_TYPE_UNSPECIFIED)
                }
                "BACKING_TYPE_FLAT_V1" => std::option::Option::Some(Self::BACKING_TYPE_FLAT_V1),
                "BACKING_TYPE_FLAT_V2" => std::option::Option::Some(Self::BACKING_TYPE_FLAT_V2),
                "BACKING_TYPE_PMEM" => std::option::Option::Some(Self::BACKING_TYPE_PMEM),
                "BACKING_TYPE_RDM_V1" => std::option::Option::Some(Self::BACKING_TYPE_RDM_V1),
                "BACKING_TYPE_RDM_V2" => std::option::Option::Some(Self::BACKING_TYPE_RDM_V2),
                "BACKING_TYPE_SESPARSE" => std::option::Option::Some(Self::BACKING_TYPE_SESPARSE),
                "BACKING_TYPE_SESPARSE_V1" => {
                    std::option::Option::Some(Self::BACKING_TYPE_SESPARSE_V1)
                }
                "BACKING_TYPE_SESPARSE_V2" => {
                    std::option::Option::Some(Self::BACKING_TYPE_SESPARSE_V2)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for BackingType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for BackingType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// VMDK disk mode.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct VmdkMode(i32);

    impl VmdkMode {
        /// VMDK disk mode unspecified or unknown.
        pub const VMDK_MODE_UNSPECIFIED: VmdkMode = VmdkMode::new(0);

        /// Dependent disk mode.
        pub const DEPENDENT: VmdkMode = VmdkMode::new(1);

        /// Independent - Persistent disk mode.
        pub const INDEPENDENT_PERSISTENT: VmdkMode = VmdkMode::new(2);

        /// Independent - Nonpersistent disk mode.
        pub const INDEPENDENT_NONPERSISTENT: VmdkMode = VmdkMode::new(3);

        /// Creates a new VmdkMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("VMDK_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DEPENDENT"),
                2 => std::borrow::Cow::Borrowed("INDEPENDENT_PERSISTENT"),
                3 => std::borrow::Cow::Borrowed("INDEPENDENT_NONPERSISTENT"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "VMDK_MODE_UNSPECIFIED" => std::option::Option::Some(Self::VMDK_MODE_UNSPECIFIED),
                "DEPENDENT" => std::option::Option::Some(Self::DEPENDENT),
                "INDEPENDENT_PERSISTENT" => std::option::Option::Some(Self::INDEPENDENT_PERSISTENT),
                "INDEPENDENT_NONPERSISTENT" => {
                    std::option::Option::Some(Self::INDEPENDENT_NONPERSISTENT)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for VmdkMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for VmdkMode {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// RDM compatibility mode.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RdmCompatibility(i32);

    impl RdmCompatibility {
        /// Compatibility mode unspecified or unknown.
        pub const RDM_COMPATIBILITY_UNSPECIFIED: RdmCompatibility = RdmCompatibility::new(0);

        /// Physical compatibility mode.
        pub const PHYSICAL_COMPATIBILITY: RdmCompatibility = RdmCompatibility::new(1);

        /// Virtual compatibility mode.
        pub const VIRTUAL_COMPATIBILITY: RdmCompatibility = RdmCompatibility::new(2);

        /// Creates a new RdmCompatibility instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("RDM_COMPATIBILITY_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PHYSICAL_COMPATIBILITY"),
                2 => std::borrow::Cow::Borrowed("VIRTUAL_COMPATIBILITY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "RDM_COMPATIBILITY_UNSPECIFIED" => {
                    std::option::Option::Some(Self::RDM_COMPATIBILITY_UNSPECIFIED)
                }
                "PHYSICAL_COMPATIBILITY" => std::option::Option::Some(Self::PHYSICAL_COMPATIBILITY),
                "VIRTUAL_COMPATIBILITY" => std::option::Option::Some(Self::VIRTUAL_COMPATIBILITY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for RdmCompatibility {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for RdmCompatibility {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Information from Guest-level collections.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GuestOsDetails {
    /// The name of the operating system.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub os_name: std::string::String,

    /// What family the OS belong to, if known.
    pub family: crate::model::OperatingSystemFamily,

    /// The version of the operating system.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// OS and app configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::GuestConfigDetails>,

    /// Runtime information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub runtime: std::option::Option<crate::model::GuestRuntimeDetails>,
}

impl GuestOsDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [os_name][crate::model::GuestOsDetails::os_name].
    pub fn set_os_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.os_name = v.into();
        self
    }

    /// Sets the value of [family][crate::model::GuestOsDetails::family].
    pub fn set_family<T: std::convert::Into<crate::model::OperatingSystemFamily>>(
        mut self,
        v: T,
    ) -> Self {
        self.family = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GuestOsDetails::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [config][crate::model::GuestOsDetails::config].
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::GuestConfigDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [runtime][crate::model::GuestOsDetails::runtime].
    pub fn set_runtime<
        T: std::convert::Into<std::option::Option<crate::model::GuestRuntimeDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime = v.into();
        self
    }
}

impl wkt::message::Message for GuestOsDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GuestOsDetails"
    }
}

/// Guest OS config information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GuestConfigDetails {
    /// OS issue (typically /etc/issue in Linux).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub issue: std::string::String,

    /// Mount list (Linux fstab).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub fstab: std::option::Option<crate::model::FstabEntryList>,

    /// Hosts file (/etc/hosts).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hosts: std::option::Option<crate::model::HostsEntryList>,

    /// NFS exports.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nfs_exports: std::option::Option<crate::model::NfsExportList>,

    /// Security-Enhanced Linux (SELinux) mode.
    pub selinux_mode: crate::model::guest_config_details::SeLinuxMode,
}

impl GuestConfigDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue][crate::model::GuestConfigDetails::issue].
    pub fn set_issue<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issue = v.into();
        self
    }

    /// Sets the value of [fstab][crate::model::GuestConfigDetails::fstab].
    pub fn set_fstab<T: std::convert::Into<std::option::Option<crate::model::FstabEntryList>>>(
        mut self,
        v: T,
    ) -> Self {
        self.fstab = v.into();
        self
    }

    /// Sets the value of [hosts][crate::model::GuestConfigDetails::hosts].
    pub fn set_hosts<T: std::convert::Into<std::option::Option<crate::model::HostsEntryList>>>(
        mut self,
        v: T,
    ) -> Self {
        self.hosts = v.into();
        self
    }

    /// Sets the value of [nfs_exports][crate::model::GuestConfigDetails::nfs_exports].
    pub fn set_nfs_exports<
        T: std::convert::Into<std::option::Option<crate::model::NfsExportList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nfs_exports = v.into();
        self
    }

    /// Sets the value of [selinux_mode][crate::model::GuestConfigDetails::selinux_mode].
    pub fn set_selinux_mode<
        T: std::convert::Into<crate::model::guest_config_details::SeLinuxMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.selinux_mode = v.into();
        self
    }
}

impl wkt::message::Message for GuestConfigDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GuestConfigDetails"
    }
}

/// Defines additional types related to GuestConfigDetails
pub mod guest_config_details {
    #[allow(unused_imports)]
    use super::*;

    /// Security-Enhanced Linux (SELinux) mode.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SeLinuxMode(i32);

    impl SeLinuxMode {
        /// SELinux mode unknown or unspecified.
        pub const SE_LINUX_MODE_UNSPECIFIED: SeLinuxMode = SeLinuxMode::new(0);

        /// SELinux is disabled.
        pub const SE_LINUX_MODE_DISABLED: SeLinuxMode = SeLinuxMode::new(1);

        /// SELinux permissive mode.
        pub const SE_LINUX_MODE_PERMISSIVE: SeLinuxMode = SeLinuxMode::new(2);

        /// SELinux enforcing mode.
        pub const SE_LINUX_MODE_ENFORCING: SeLinuxMode = SeLinuxMode::new(3);

        /// Creates a new SeLinuxMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SE_LINUX_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("SE_LINUX_MODE_DISABLED"),
                2 => std::borrow::Cow::Borrowed("SE_LINUX_MODE_PERMISSIVE"),
                3 => std::borrow::Cow::Borrowed("SE_LINUX_MODE_ENFORCING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SE_LINUX_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::SE_LINUX_MODE_UNSPECIFIED)
                }
                "SE_LINUX_MODE_DISABLED" => std::option::Option::Some(Self::SE_LINUX_MODE_DISABLED),
                "SE_LINUX_MODE_PERMISSIVE" => {
                    std::option::Option::Some(Self::SE_LINUX_MODE_PERMISSIVE)
                }
                "SE_LINUX_MODE_ENFORCING" => {
                    std::option::Option::Some(Self::SE_LINUX_MODE_ENFORCING)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for SeLinuxMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for SeLinuxMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Fstab content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FstabEntryList {
    /// Fstab entries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entries: std::vec::Vec<crate::model::FstabEntry>,
}

impl FstabEntryList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::FstabEntryList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FstabEntry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FstabEntryList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.FstabEntryList"
    }
}

/// Single fstab entry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FstabEntry {
    /// The block special device or remote filesystem to be mounted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub spec: std::string::String,

    /// The mount point for the filesystem.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file: std::string::String,

    /// The type of the filesystem.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vfstype: std::string::String,

    /// Mount options associated with the filesystem.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mntops: std::string::String,

    /// Used by dump to determine which filesystems need to be dumped.
    pub freq: i32,

    /// Used by the fsck(8) program to determine the order in which filesystem
    /// checks are done at reboot time.
    pub passno: i32,
}

impl FstabEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [spec][crate::model::FstabEntry::spec].
    pub fn set_spec<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.spec = v.into();
        self
    }

    /// Sets the value of [file][crate::model::FstabEntry::file].
    pub fn set_file<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file = v.into();
        self
    }

    /// Sets the value of [vfstype][crate::model::FstabEntry::vfstype].
    pub fn set_vfstype<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vfstype = v.into();
        self
    }

    /// Sets the value of [mntops][crate::model::FstabEntry::mntops].
    pub fn set_mntops<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mntops = v.into();
        self
    }

    /// Sets the value of [freq][crate::model::FstabEntry::freq].
    pub fn set_freq<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.freq = v.into();
        self
    }

    /// Sets the value of [passno][crate::model::FstabEntry::passno].
    pub fn set_passno<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.passno = v.into();
        self
    }
}

impl wkt::message::Message for FstabEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.FstabEntry"
    }
}

/// Hosts content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HostsEntryList {
    /// Hosts entries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entries: std::vec::Vec<crate::model::HostsEntry>,
}

impl HostsEntryList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::HostsEntryList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::HostsEntry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for HostsEntryList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.HostsEntryList"
    }
}

/// Single /etc/hosts entry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HostsEntry {
    /// IP (raw, IPv4/6 agnostic).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip: std::string::String,

    /// List of host names / aliases.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub host_names: std::vec::Vec<std::string::String>,
}

impl HostsEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip][crate::model::HostsEntry::ip].
    pub fn set_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip = v.into();
        self
    }

    /// Sets the value of [host_names][crate::model::HostsEntry::host_names].
    pub fn set_host_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.host_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for HostsEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.HostsEntry"
    }
}

/// NFS exports.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NfsExportList {
    /// NFS export entries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entries: std::vec::Vec<crate::model::NfsExport>,
}

impl NfsExportList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::NfsExportList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NfsExport>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NfsExportList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.NfsExportList"
    }
}

/// NFS export.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NfsExport {
    /// The directory being exported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub export_directory: std::string::String,

    /// The hosts or networks to which the export is being shared.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub hosts: std::vec::Vec<std::string::String>,
}

impl NfsExport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [export_directory][crate::model::NfsExport::export_directory].
    pub fn set_export_directory<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.export_directory = v.into();
        self
    }

    /// Sets the value of [hosts][crate::model::NfsExport::hosts].
    pub fn set_hosts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.hosts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NfsExport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.NfsExport"
    }
}

/// Guest OS runtime information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GuestRuntimeDetails {
    /// Running background services.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub services: std::option::Option<crate::model::RunningServiceList>,

    /// Running processes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub processes: std::option::Option<crate::model::RunningProcessList>,

    /// Runtime network information (connections, ports).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network: std::option::Option<crate::model::RuntimeNetworkInfo>,

    /// Last time the OS was booted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_boot_time: std::option::Option<wkt::Timestamp>,

    /// Domain, e.g. c.stratozone-development.internal.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub domain: std::string::String,

    /// Machine name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_name: std::string::String,

    /// Installed applications information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub installed_apps: std::option::Option<crate::model::GuestInstalledApplicationList>,

    /// Open files information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub open_file_list: std::option::Option<crate::model::OpenFileList>,
}

impl GuestRuntimeDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [services][crate::model::GuestRuntimeDetails::services].
    pub fn set_services<
        T: std::convert::Into<std::option::Option<crate::model::RunningServiceList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.services = v.into();
        self
    }

    /// Sets the value of [processes][crate::model::GuestRuntimeDetails::processes].
    pub fn set_processes<
        T: std::convert::Into<std::option::Option<crate::model::RunningProcessList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.processes = v.into();
        self
    }

    /// Sets the value of [network][crate::model::GuestRuntimeDetails::network].
    pub fn set_network<
        T: std::convert::Into<std::option::Option<crate::model::RuntimeNetworkInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [last_boot_time][crate::model::GuestRuntimeDetails::last_boot_time].
    pub fn set_last_boot_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_boot_time = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::GuestRuntimeDetails::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [machine_name][crate::model::GuestRuntimeDetails::machine_name].
    pub fn set_machine_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_name = v.into();
        self
    }

    /// Sets the value of [installed_apps][crate::model::GuestRuntimeDetails::installed_apps].
    pub fn set_installed_apps<
        T: std::convert::Into<std::option::Option<crate::model::GuestInstalledApplicationList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.installed_apps = v.into();
        self
    }

    /// Sets the value of [open_file_list][crate::model::GuestRuntimeDetails::open_file_list].
    pub fn set_open_file_list<
        T: std::convert::Into<std::option::Option<crate::model::OpenFileList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.open_file_list = v.into();
        self
    }
}

impl wkt::message::Message for GuestRuntimeDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GuestRuntimeDetails"
    }
}

/// List of running guest OS services.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RunningServiceList {
    /// Running service entries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entries: std::vec::Vec<crate::model::RunningService>,
}

impl RunningServiceList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::RunningServiceList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RunningService>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RunningServiceList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.RunningServiceList"
    }
}

/// Guest OS running service details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RunningService {
    /// Service name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_name: std::string::String,

    /// Service state (OS-agnostic).
    pub state: crate::model::running_service::State,

    /// Service start mode (OS-agnostic).
    pub start_mode: crate::model::running_service::StartMode,

    /// Service binary path.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub exe_path: std::string::String,

    /// Service command line.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cmdline: std::string::String,

    /// Service pid.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub pid: i64,
}

impl RunningService {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::RunningService::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::RunningService::state].
    pub fn set_state<T: std::convert::Into<crate::model::running_service::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [start_mode][crate::model::RunningService::start_mode].
    pub fn set_start_mode<T: std::convert::Into<crate::model::running_service::StartMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_mode = v.into();
        self
    }

    /// Sets the value of [exe_path][crate::model::RunningService::exe_path].
    pub fn set_exe_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.exe_path = v.into();
        self
    }

    /// Sets the value of [cmdline][crate::model::RunningService::cmdline].
    pub fn set_cmdline<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cmdline = v.into();
        self
    }

    /// Sets the value of [pid][crate::model::RunningService::pid].
    pub fn set_pid<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.pid = v.into();
        self
    }
}

impl wkt::message::Message for RunningService {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.RunningService"
    }
}

/// Defines additional types related to RunningService
pub mod running_service {
    #[allow(unused_imports)]
    use super::*;

    /// Service state (OS-agnostic).
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Service state unspecified.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// Service is active.
        pub const ACTIVE: State = State::new(1);

        /// Service is paused.
        pub const PAUSED: State = State::new(2);

        /// Service is stopped.
        pub const STOPPED: State = State::new(3);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ACTIVE"),
                2 => std::borrow::Cow::Borrowed("PAUSED"),
                3 => std::borrow::Cow::Borrowed("STOPPED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                "PAUSED" => std::option::Option::Some(Self::PAUSED),
                "STOPPED" => std::option::Option::Some(Self::STOPPED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Service start mode (OS-agnostic).
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct StartMode(i32);

    impl StartMode {
        /// Start mode unspecified.
        pub const START_MODE_UNSPECIFIED: StartMode = StartMode::new(0);

        /// The service is a device driver started by the system loader.
        pub const BOOT: StartMode = StartMode::new(1);

        /// The service is a device driver started by the IOInitSystem function.
        pub const SYSTEM: StartMode = StartMode::new(2);

        /// The service is started by the operating system, at system start-up
        pub const AUTO: StartMode = StartMode::new(3);

        /// The service is started only manually, by a user.
        pub const MANUAL: StartMode = StartMode::new(4);

        /// The service is disabled.
        pub const DISABLED: StartMode = StartMode::new(5);

        /// Creates a new StartMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("START_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("BOOT"),
                2 => std::borrow::Cow::Borrowed("SYSTEM"),
                3 => std::borrow::Cow::Borrowed("AUTO"),
                4 => std::borrow::Cow::Borrowed("MANUAL"),
                5 => std::borrow::Cow::Borrowed("DISABLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "START_MODE_UNSPECIFIED" => std::option::Option::Some(Self::START_MODE_UNSPECIFIED),
                "BOOT" => std::option::Option::Some(Self::BOOT),
                "SYSTEM" => std::option::Option::Some(Self::SYSTEM),
                "AUTO" => std::option::Option::Some(Self::AUTO),
                "MANUAL" => std::option::Option::Some(Self::MANUAL),
                "DISABLED" => std::option::Option::Some(Self::DISABLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for StartMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for StartMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// List of running guest OS processes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RunningProcessList {
    /// Running process entries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entries: std::vec::Vec<crate::model::RunningProcess>,
}

impl RunningProcessList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::RunningProcessList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RunningProcess>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RunningProcessList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.RunningProcessList"
    }
}

/// Guest OS running process details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RunningProcess {
    /// Process ID.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub pid: i64,

    /// Process binary path.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub exe_path: std::string::String,

    /// Process full command line.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cmdline: std::string::String,

    /// User running the process.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user: std::string::String,

    /// Process extended attributes.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub attributes: std::collections::HashMap<std::string::String, std::string::String>,
}

impl RunningProcess {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pid][crate::model::RunningProcess::pid].
    pub fn set_pid<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.pid = v.into();
        self
    }

    /// Sets the value of [exe_path][crate::model::RunningProcess::exe_path].
    pub fn set_exe_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.exe_path = v.into();
        self
    }

    /// Sets the value of [cmdline][crate::model::RunningProcess::cmdline].
    pub fn set_cmdline<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cmdline = v.into();
        self
    }

    /// Sets the value of [user][crate::model::RunningProcess::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [attributes][crate::model::RunningProcess::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for RunningProcess {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.RunningProcess"
    }
}

/// Runtime networking information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RuntimeNetworkInfo {
    /// Time of the last network scan.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scan_time: std::option::Option<wkt::Timestamp>,

    /// Network connections.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connections: std::option::Option<crate::model::NetworkConnectionList>,
}

impl RuntimeNetworkInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scan_time][crate::model::RuntimeNetworkInfo::scan_time].
    pub fn set_scan_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scan_time = v.into();
        self
    }

    /// Sets the value of [connections][crate::model::RuntimeNetworkInfo::connections].
    pub fn set_connections<
        T: std::convert::Into<std::option::Option<crate::model::NetworkConnectionList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connections = v.into();
        self
    }
}

impl wkt::message::Message for RuntimeNetworkInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.RuntimeNetworkInfo"
    }
}

/// Network connection list.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkConnectionList {
    /// Network connection entries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entries: std::vec::Vec<crate::model::NetworkConnection>,
}

impl NetworkConnectionList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::NetworkConnectionList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkConnection>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NetworkConnectionList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.NetworkConnectionList"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkConnection {
    /// Connection protocol (e.g. TCP/UDP).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub protocol: std::string::String,

    /// Local IP address.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub local_ip_address: std::string::String,

    /// Local port.
    pub local_port: i32,

    /// Remote IP address.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub remote_ip_address: std::string::String,

    /// Remote port.
    pub remote_port: i32,

    /// Network connection state.
    pub state: crate::model::network_connection::State,

    /// Process ID.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub pid: i64,

    /// Process or service name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub process_name: std::string::String,
}

impl NetworkConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [protocol][crate::model::NetworkConnection::protocol].
    pub fn set_protocol<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [local_ip_address][crate::model::NetworkConnection::local_ip_address].
    pub fn set_local_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.local_ip_address = v.into();
        self
    }

    /// Sets the value of [local_port][crate::model::NetworkConnection::local_port].
    pub fn set_local_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.local_port = v.into();
        self
    }

    /// Sets the value of [remote_ip_address][crate::model::NetworkConnection::remote_ip_address].
    pub fn set_remote_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.remote_ip_address = v.into();
        self
    }

    /// Sets the value of [remote_port][crate::model::NetworkConnection::remote_port].
    pub fn set_remote_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.remote_port = v.into();
        self
    }

    /// Sets the value of [state][crate::model::NetworkConnection::state].
    pub fn set_state<T: std::convert::Into<crate::model::network_connection::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [pid][crate::model::NetworkConnection::pid].
    pub fn set_pid<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.pid = v.into();
        self
    }

    /// Sets the value of [process_name][crate::model::NetworkConnection::process_name].
    pub fn set_process_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.process_name = v.into();
        self
    }
}

impl wkt::message::Message for NetworkConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.NetworkConnection"
    }
}

/// Defines additional types related to NetworkConnection
pub mod network_connection {
    #[allow(unused_imports)]
    use super::*;

    /// Network connection state.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Connection state is unknown or unspecified.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The connection is being opened.
        pub const OPENING: State = State::new(1);

        /// The connection is open.
        pub const OPEN: State = State::new(2);

        /// Listening for incoming connections.
        pub const LISTEN: State = State::new(3);

        /// The connection is being closed.
        pub const CLOSING: State = State::new(4);

        /// The connection is closed.
        pub const CLOSED: State = State::new(5);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("OPENING"),
                2 => std::borrow::Cow::Borrowed("OPEN"),
                3 => std::borrow::Cow::Borrowed("LISTEN"),
                4 => std::borrow::Cow::Borrowed("CLOSING"),
                5 => std::borrow::Cow::Borrowed("CLOSED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "OPENING" => std::option::Option::Some(Self::OPENING),
                "OPEN" => std::option::Option::Some(Self::OPEN),
                "LISTEN" => std::option::Option::Some(Self::LISTEN),
                "CLOSING" => std::option::Option::Some(Self::CLOSING),
                "CLOSED" => std::option::Option::Some(Self::CLOSED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Guest installed application list.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GuestInstalledApplicationList {
    /// Application entries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entries: std::vec::Vec<crate::model::GuestInstalledApplication>,
}

impl GuestInstalledApplicationList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::GuestInstalledApplicationList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GuestInstalledApplication>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GuestInstalledApplicationList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GuestInstalledApplicationList"
    }
}

/// Guest installed application information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GuestInstalledApplication {
    /// Installed application name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub application_name: std::string::String,

    /// Installed application vendor.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vendor: std::string::String,

    /// The time when the application was installed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub install_time: std::option::Option<wkt::Timestamp>,

    /// Source path.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Installed application version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,
}

impl GuestInstalledApplication {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [application_name][crate::model::GuestInstalledApplication::application_name].
    pub fn set_application_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.application_name = v.into();
        self
    }

    /// Sets the value of [vendor][crate::model::GuestInstalledApplication::vendor].
    pub fn set_vendor<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vendor = v.into();
        self
    }

    /// Sets the value of [install_time][crate::model::GuestInstalledApplication::install_time].
    pub fn set_install_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.install_time = v.into();
        self
    }

    /// Sets the value of [path][crate::model::GuestInstalledApplication::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GuestInstalledApplication::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for GuestInstalledApplication {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GuestInstalledApplication"
    }
}

/// Open file list.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OpenFileList {
    /// Open file details entries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entries: std::vec::Vec<crate::model::OpenFileDetails>,
}

impl OpenFileList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::OpenFileList::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OpenFileDetails>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OpenFileList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.OpenFileList"
    }
}

/// Open file Information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OpenFileDetails {
    /// Opened file command.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub command: std::string::String,

    /// Opened file user.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user: std::string::String,

    /// Opened file file type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_type: std::string::String,

    /// Opened file file path.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_path: std::string::String,
}

impl OpenFileDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [command][crate::model::OpenFileDetails::command].
    pub fn set_command<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.command = v.into();
        self
    }

    /// Sets the value of [user][crate::model::OpenFileDetails::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [file_type][crate::model::OpenFileDetails::file_type].
    pub fn set_file_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_type = v.into();
        self
    }

    /// Sets the value of [file_path][crate::model::OpenFileDetails::file_path].
    pub fn set_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_path = v.into();
        self
    }
}

impl wkt::message::Message for OpenFileDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.OpenFileDetails"
    }
}

/// Information about the platform.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PlatformDetails {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub vendor_details: std::option::Option<crate::model::platform_details::VendorDetails>,
}

impl PlatformDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `vendor_details`.
    pub fn set_vendor_details<
        T: std::convert::Into<std::option::Option<crate::model::platform_details::VendorDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vendor_details = v.into();
        self
    }

    /// The value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// if it holds a `VmwareDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vmware_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmwarePlatformDetails>> {
        #[allow(unreachable_patterns)]
        self.vendor_details.as_ref().and_then(|v| match v {
            crate::model::platform_details::VendorDetails::VmwareDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// if it holds a `AwsEc2Details`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_aws_ec2_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AwsEc2PlatformDetails>> {
        #[allow(unreachable_patterns)]
        self.vendor_details.as_ref().and_then(|v| match v {
            crate::model::platform_details::VendorDetails::AwsEc2Details(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// if it holds a `AzureVmDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_azure_vm_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AzureVmPlatformDetails>> {
        #[allow(unreachable_patterns)]
        self.vendor_details.as_ref().and_then(|v| match v {
            crate::model::platform_details::VendorDetails::AzureVmDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// if it holds a `GenericDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_generic_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GenericPlatformDetails>> {
        #[allow(unreachable_patterns)]
        self.vendor_details.as_ref().and_then(|v| match v {
            crate::model::platform_details::VendorDetails::GenericDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// if it holds a `PhysicalDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_physical_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PhysicalPlatformDetails>> {
        #[allow(unreachable_patterns)]
        self.vendor_details.as_ref().and_then(|v| match v {
            crate::model::platform_details::VendorDetails::PhysicalDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// to hold a `VmwareDetails`.
    ///
    /// Note that all the setters affecting `vendor_details` are
    /// mutually exclusive.
    pub fn set_vmware_details<
        T: std::convert::Into<std::boxed::Box<crate::model::VmwarePlatformDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vendor_details = std::option::Option::Some(
            crate::model::platform_details::VendorDetails::VmwareDetails(v.into()),
        );
        self
    }

    /// Sets the value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// to hold a `AwsEc2Details`.
    ///
    /// Note that all the setters affecting `vendor_details` are
    /// mutually exclusive.
    pub fn set_aws_ec2_details<
        T: std::convert::Into<std::boxed::Box<crate::model::AwsEc2PlatformDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vendor_details = std::option::Option::Some(
            crate::model::platform_details::VendorDetails::AwsEc2Details(v.into()),
        );
        self
    }

    /// Sets the value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// to hold a `AzureVmDetails`.
    ///
    /// Note that all the setters affecting `vendor_details` are
    /// mutually exclusive.
    pub fn set_azure_vm_details<
        T: std::convert::Into<std::boxed::Box<crate::model::AzureVmPlatformDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vendor_details = std::option::Option::Some(
            crate::model::platform_details::VendorDetails::AzureVmDetails(v.into()),
        );
        self
    }

    /// Sets the value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// to hold a `GenericDetails`.
    ///
    /// Note that all the setters affecting `vendor_details` are
    /// mutually exclusive.
    pub fn set_generic_details<
        T: std::convert::Into<std::boxed::Box<crate::model::GenericPlatformDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vendor_details = std::option::Option::Some(
            crate::model::platform_details::VendorDetails::GenericDetails(v.into()),
        );
        self
    }

    /// Sets the value of [vendor_details][crate::model::PlatformDetails::vendor_details]
    /// to hold a `PhysicalDetails`.
    ///
    /// Note that all the setters affecting `vendor_details` are
    /// mutually exclusive.
    pub fn set_physical_details<
        T: std::convert::Into<std::boxed::Box<crate::model::PhysicalPlatformDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vendor_details = std::option::Option::Some(
            crate::model::platform_details::VendorDetails::PhysicalDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PlatformDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.PlatformDetails"
    }
}

/// Defines additional types related to PlatformDetails
pub mod platform_details {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum VendorDetails {
        /// VMware specific details.
        VmwareDetails(std::boxed::Box<crate::model::VmwarePlatformDetails>),
        /// AWS EC2 specific details.
        AwsEc2Details(std::boxed::Box<crate::model::AwsEc2PlatformDetails>),
        /// Azure VM specific details.
        AzureVmDetails(std::boxed::Box<crate::model::AzureVmPlatformDetails>),
        /// Generic platform details.
        GenericDetails(std::boxed::Box<crate::model::GenericPlatformDetails>),
        /// Physical machines platform details.
        PhysicalDetails(std::boxed::Box<crate::model::PhysicalPlatformDetails>),
    }
}

/// VMware specific details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VmwarePlatformDetails {
    /// vCenter version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vcenter_version: std::string::String,

    /// ESX version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub esx_version: std::string::String,

    /// VMware os enum -
    /// <https://vdc-repo.vmware.com/vmwb-repository/dcr-public/da47f910-60ac-438b-8b9b-6122f4d14524/16b7274a-bf8b-4b4c-a05e-746f2aa93c8c/doc/vim.vm.GuestOsDescriptor.GuestOsIdentifier.html>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub osid: std::string::String,

    /// Folder name in vCenter where asset resides.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vcenter_folder: std::string::String,

    /// vCenter URI used in collection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vcenter_uri: std::string::String,

    /// vCenter VM ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vcenter_vm_id: std::string::String,
}

impl VmwarePlatformDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vcenter_version][crate::model::VmwarePlatformDetails::vcenter_version].
    pub fn set_vcenter_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vcenter_version = v.into();
        self
    }

    /// Sets the value of [esx_version][crate::model::VmwarePlatformDetails::esx_version].
    pub fn set_esx_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.esx_version = v.into();
        self
    }

    /// Sets the value of [osid][crate::model::VmwarePlatformDetails::osid].
    pub fn set_osid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.osid = v.into();
        self
    }

    /// Sets the value of [vcenter_folder][crate::model::VmwarePlatformDetails::vcenter_folder].
    pub fn set_vcenter_folder<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vcenter_folder = v.into();
        self
    }

    /// Sets the value of [vcenter_uri][crate::model::VmwarePlatformDetails::vcenter_uri].
    pub fn set_vcenter_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vcenter_uri = v.into();
        self
    }

    /// Sets the value of [vcenter_vm_id][crate::model::VmwarePlatformDetails::vcenter_vm_id].
    pub fn set_vcenter_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vcenter_vm_id = v.into();
        self
    }
}

impl wkt::message::Message for VmwarePlatformDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.VmwarePlatformDetails"
    }
}

/// AWS EC2 specific details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsEc2PlatformDetails {
    /// AWS platform's machine type label.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_type_label: std::string::String,

    /// The location of the machine in the AWS format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,
}

impl AwsEc2PlatformDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_type_label][crate::model::AwsEc2PlatformDetails::machine_type_label].
    pub fn set_machine_type_label<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_type_label = v.into();
        self
    }

    /// Sets the value of [location][crate::model::AwsEc2PlatformDetails::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for AwsEc2PlatformDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.AwsEc2PlatformDetails"
    }
}

/// Azure VM specific details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureVmPlatformDetails {
    /// Azure platform's machine type label.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_type_label: std::string::String,

    /// The location of the machine in the Azure format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Azure platform's provisioning state.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub provisioning_state: std::string::String,
}

impl AzureVmPlatformDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_type_label][crate::model::AzureVmPlatformDetails::machine_type_label].
    pub fn set_machine_type_label<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_type_label = v.into();
        self
    }

    /// Sets the value of [location][crate::model::AzureVmPlatformDetails::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [provisioning_state][crate::model::AzureVmPlatformDetails::provisioning_state].
    pub fn set_provisioning_state<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.provisioning_state = v.into();
        self
    }
}

impl wkt::message::Message for AzureVmPlatformDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.AzureVmPlatformDetails"
    }
}

/// Generic platform details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenericPlatformDetails {
    /// Free text representation of the machine location.
    /// The format of this field should not be relied on. Different VMs in the same
    /// location may have different string values for this field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,
}

impl GenericPlatformDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::GenericPlatformDetails::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for GenericPlatformDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GenericPlatformDetails"
    }
}

/// Platform specific details for Physical Machines.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PhysicalPlatformDetails {
    /// Free text representation of the machine location.
    /// The format of this field should not be relied on. Different machines in the
    /// same location may have different string values for this field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,
}

impl PhysicalPlatformDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::PhysicalPlatformDetails::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for PhysicalPlatformDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.PhysicalPlatformDetails"
    }
}

/// Memory usage sample.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MemoryUsageSample {
    /// Percentage of system memory utilized. Must be in the interval [0, 100].
    pub utilized_percentage: f32,
}

impl MemoryUsageSample {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [utilized_percentage][crate::model::MemoryUsageSample::utilized_percentage].
    pub fn set_utilized_percentage<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.utilized_percentage = v.into();
        self
    }
}

impl wkt::message::Message for MemoryUsageSample {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.MemoryUsageSample"
    }
}

/// CPU usage sample.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CpuUsageSample {
    /// Percentage of total CPU capacity utilized. Must be in the interval [0,
    /// 100]. On most systems can be calculated using 100 - idle percentage.
    pub utilized_percentage: f32,
}

impl CpuUsageSample {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [utilized_percentage][crate::model::CpuUsageSample::utilized_percentage].
    pub fn set_utilized_percentage<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.utilized_percentage = v.into();
        self
    }
}

impl wkt::message::Message for CpuUsageSample {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.CpuUsageSample"
    }
}

/// Network usage sample. Values are across all network interfaces.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkUsageSample {
    /// Average network ingress in B/s sampled over a short window.
    /// Must be non-negative.
    pub average_ingress_bps: f32,

    /// Average network egress in B/s sampled over a short window.
    /// Must be non-negative.
    pub average_egress_bps: f32,
}

impl NetworkUsageSample {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [average_ingress_bps][crate::model::NetworkUsageSample::average_ingress_bps].
    pub fn set_average_ingress_bps<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.average_ingress_bps = v.into();
        self
    }

    /// Sets the value of [average_egress_bps][crate::model::NetworkUsageSample::average_egress_bps].
    pub fn set_average_egress_bps<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.average_egress_bps = v.into();
        self
    }
}

impl wkt::message::Message for NetworkUsageSample {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.NetworkUsageSample"
    }
}

/// Disk usage sample. Values are across all disks.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiskUsageSample {
    /// Average IOPS sampled over a short window. Must be non-negative.
    pub average_iops: f32,
}

impl DiskUsageSample {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [average_iops][crate::model::DiskUsageSample::average_iops].
    pub fn set_average_iops<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.average_iops = v.into();
        self
    }
}

impl wkt::message::Message for DiskUsageSample {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DiskUsageSample"
    }
}

/// Performance data sample.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PerformanceSample {
    /// Time the sample was collected.
    /// If omitted, the frame report time will be used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sample_time: std::option::Option<wkt::Timestamp>,

    /// Memory usage sample.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub memory: std::option::Option<crate::model::MemoryUsageSample>,

    /// CPU usage sample.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cpu: std::option::Option<crate::model::CpuUsageSample>,

    /// Network usage sample.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network: std::option::Option<crate::model::NetworkUsageSample>,

    /// Disk usage sample.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk: std::option::Option<crate::model::DiskUsageSample>,
}

impl PerformanceSample {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sample_time][crate::model::PerformanceSample::sample_time].
    pub fn set_sample_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.sample_time = v.into();
        self
    }

    /// Sets the value of [memory][crate::model::PerformanceSample::memory].
    pub fn set_memory<
        T: std::convert::Into<std::option::Option<crate::model::MemoryUsageSample>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.memory = v.into();
        self
    }

    /// Sets the value of [cpu][crate::model::PerformanceSample::cpu].
    pub fn set_cpu<T: std::convert::Into<std::option::Option<crate::model::CpuUsageSample>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cpu = v.into();
        self
    }

    /// Sets the value of [network][crate::model::PerformanceSample::network].
    pub fn set_network<
        T: std::convert::Into<std::option::Option<crate::model::NetworkUsageSample>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [disk][crate::model::PerformanceSample::disk].
    pub fn set_disk<T: std::convert::Into<std::option::Option<crate::model::DiskUsageSample>>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk = v.into();
        self
    }
}

impl wkt::message::Message for PerformanceSample {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.PerformanceSample"
    }
}

/// Performance data for an asset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AssetPerformanceData {
    /// Daily resource usage aggregations.
    /// Contains all of the data available for an asset, up to the last 420 days.
    /// Aggregations are sorted from oldest to most recent.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub daily_resource_usage_aggregations:
        std::vec::Vec<crate::model::DailyResourceUsageAggregation>,
}

impl AssetPerformanceData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [daily_resource_usage_aggregations][crate::model::AssetPerformanceData::daily_resource_usage_aggregations].
    pub fn set_daily_resource_usage_aggregations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DailyResourceUsageAggregation>,
    {
        use std::iter::Iterator;
        self.daily_resource_usage_aggregations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AssetPerformanceData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.AssetPerformanceData"
    }
}

/// Usage data aggregation for a single day.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DailyResourceUsageAggregation {
    /// Aggregation date. Day boundaries are at midnight UTC.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub date: std::option::Option<gtype::model::Date>,

    /// CPU usage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cpu: std::option::Option<crate::model::daily_resource_usage_aggregation::Cpu>,

    /// Memory usage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub memory: std::option::Option<crate::model::daily_resource_usage_aggregation::Memory>,

    /// Network usage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network: std::option::Option<crate::model::daily_resource_usage_aggregation::Network>,

    /// Disk usage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk: std::option::Option<crate::model::daily_resource_usage_aggregation::Disk>,
}

impl DailyResourceUsageAggregation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [date][crate::model::DailyResourceUsageAggregation::date].
    pub fn set_date<T: std::convert::Into<std::option::Option<gtype::model::Date>>>(
        mut self,
        v: T,
    ) -> Self {
        self.date = v.into();
        self
    }

    /// Sets the value of [cpu][crate::model::DailyResourceUsageAggregation::cpu].
    pub fn set_cpu<
        T: std::convert::Into<
            std::option::Option<crate::model::daily_resource_usage_aggregation::Cpu>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cpu = v.into();
        self
    }

    /// Sets the value of [memory][crate::model::DailyResourceUsageAggregation::memory].
    pub fn set_memory<
        T: std::convert::Into<
            std::option::Option<crate::model::daily_resource_usage_aggregation::Memory>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.memory = v.into();
        self
    }

    /// Sets the value of [network][crate::model::DailyResourceUsageAggregation::network].
    pub fn set_network<
        T: std::convert::Into<
            std::option::Option<crate::model::daily_resource_usage_aggregation::Network>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [disk][crate::model::DailyResourceUsageAggregation::disk].
    pub fn set_disk<
        T: std::convert::Into<
            std::option::Option<crate::model::daily_resource_usage_aggregation::Disk>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.disk = v.into();
        self
    }
}

impl wkt::message::Message for DailyResourceUsageAggregation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.DailyResourceUsageAggregation"
    }
}

/// Defines additional types related to DailyResourceUsageAggregation
pub mod daily_resource_usage_aggregation {
    #[allow(unused_imports)]
    use super::*;

    /// Statistical aggregation of samples for a single resource usage.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Stats {
        /// Average usage value.
        pub average: f32,

        /// Median usage value.
        pub median: f32,

        /// 95th percentile usage value.
        pub nintey_fifth_percentile: f32,

        /// Peak usage value.
        pub peak: f32,
    }

    impl Stats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [average][crate::model::daily_resource_usage_aggregation::Stats::average].
        pub fn set_average<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.average = v.into();
            self
        }

        /// Sets the value of [median][crate::model::daily_resource_usage_aggregation::Stats::median].
        pub fn set_median<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.median = v.into();
            self
        }

        /// Sets the value of [nintey_fifth_percentile][crate::model::daily_resource_usage_aggregation::Stats::nintey_fifth_percentile].
        pub fn set_nintey_fifth_percentile<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.nintey_fifth_percentile = v.into();
            self
        }

        /// Sets the value of [peak][crate::model::daily_resource_usage_aggregation::Stats::peak].
        pub fn set_peak<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.peak = v.into();
            self
        }
    }

    impl wkt::message::Message for Stats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.DailyResourceUsageAggregation.Stats"
        }
    }

    /// Statistical aggregation of CPU usage.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Cpu {
        /// CPU utilization percentage.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub utilization_percentage:
            std::option::Option<crate::model::daily_resource_usage_aggregation::Stats>,
    }

    impl Cpu {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [utilization_percentage][crate::model::daily_resource_usage_aggregation::Cpu::utilization_percentage].
        pub fn set_utilization_percentage<
            T: std::convert::Into<
                std::option::Option<crate::model::daily_resource_usage_aggregation::Stats>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.utilization_percentage = v.into();
            self
        }
    }

    impl wkt::message::Message for Cpu {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.DailyResourceUsageAggregation.CPU"
        }
    }

    /// Statistical aggregation of memory usage.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Memory {
        /// Memory utilization percentage.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub utilization_percentage:
            std::option::Option<crate::model::daily_resource_usage_aggregation::Stats>,
    }

    impl Memory {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [utilization_percentage][crate::model::daily_resource_usage_aggregation::Memory::utilization_percentage].
        pub fn set_utilization_percentage<
            T: std::convert::Into<
                std::option::Option<crate::model::daily_resource_usage_aggregation::Stats>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.utilization_percentage = v.into();
            self
        }
    }

    impl wkt::message::Message for Memory {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.DailyResourceUsageAggregation.Memory"
        }
    }

    /// Statistical aggregation of network usage.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Network {
        /// Network ingress in B/s.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub ingress_bps: std::option::Option<crate::model::daily_resource_usage_aggregation::Stats>,

        /// Network egress in B/s.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub egress_bps: std::option::Option<crate::model::daily_resource_usage_aggregation::Stats>,
    }

    impl Network {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ingress_bps][crate::model::daily_resource_usage_aggregation::Network::ingress_bps].
        pub fn set_ingress_bps<
            T: std::convert::Into<
                std::option::Option<crate::model::daily_resource_usage_aggregation::Stats>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.ingress_bps = v.into();
            self
        }

        /// Sets the value of [egress_bps][crate::model::daily_resource_usage_aggregation::Network::egress_bps].
        pub fn set_egress_bps<
            T: std::convert::Into<
                std::option::Option<crate::model::daily_resource_usage_aggregation::Stats>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.egress_bps = v.into();
            self
        }
    }

    impl wkt::message::Message for Network {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.DailyResourceUsageAggregation.Network"
        }
    }

    /// Statistical aggregation of disk usage.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Disk {
        /// Disk I/O operations per second.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub iops: std::option::Option<crate::model::daily_resource_usage_aggregation::Stats>,
    }

    impl Disk {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [iops][crate::model::daily_resource_usage_aggregation::Disk::iops].
        pub fn set_iops<
            T: std::convert::Into<
                std::option::Option<crate::model::daily_resource_usage_aggregation::Stats>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.iops = v.into();
            self
        }
    }

    impl wkt::message::Message for Disk {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.DailyResourceUsageAggregation.Disk"
        }
    }
}

/// Message containing insights list.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InsightList {
    /// Output only. Insights of the list.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub insights: std::vec::Vec<crate::model::Insight>,

    /// Output only. Update timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,
}

impl InsightList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_time][crate::model::InsightList::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [insights][crate::model::InsightList::insights].
    pub fn set_insights<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Insight>,
    {
        use std::iter::Iterator;
        self.insights = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InsightList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.InsightList"
    }
}

/// An insight about an asset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Insight {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub insight: std::option::Option<crate::model::insight::Insight>,
}

impl Insight {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `insight`.
    pub fn set_insight<
        T: std::convert::Into<std::option::Option<crate::model::insight::Insight>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.insight = v.into();
        self
    }

    /// The value of [insight][crate::model::Insight::insight]
    /// if it holds a `MigrationInsight`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_migration_insight(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MigrationInsight>> {
        #[allow(unreachable_patterns)]
        self.insight.as_ref().and_then(|v| match v {
            crate::model::insight::Insight::MigrationInsight(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [insight][crate::model::Insight::insight]
    /// if it holds a `GenericInsight`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_generic_insight(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GenericInsight>> {
        #[allow(unreachable_patterns)]
        self.insight.as_ref().and_then(|v| match v {
            crate::model::insight::Insight::GenericInsight(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [insight][crate::model::Insight::insight]
    /// to hold a `MigrationInsight`.
    ///
    /// Note that all the setters affecting `insight` are
    /// mutually exclusive.
    pub fn set_migration_insight<
        T: std::convert::Into<std::boxed::Box<crate::model::MigrationInsight>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.insight =
            std::option::Option::Some(crate::model::insight::Insight::MigrationInsight(v.into()));
        self
    }

    /// Sets the value of [insight][crate::model::Insight::insight]
    /// to hold a `GenericInsight`.
    ///
    /// Note that all the setters affecting `insight` are
    /// mutually exclusive.
    pub fn set_generic_insight<
        T: std::convert::Into<std::boxed::Box<crate::model::GenericInsight>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.insight =
            std::option::Option::Some(crate::model::insight::Insight::GenericInsight(v.into()));
        self
    }
}

impl wkt::message::Message for Insight {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.Insight"
    }
}

/// Defines additional types related to Insight
pub mod insight {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Insight {
        /// Output only. An insight about potential migrations for an asset.
        MigrationInsight(std::boxed::Box<crate::model::MigrationInsight>),
        /// Output only. A generic insight about an asset
        GenericInsight(std::boxed::Box<crate::model::GenericInsight>),
    }
}

/// A generic insight about an asset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenericInsight {
    /// Output only. Represents a globally unique message id for
    /// this insight, can be used for localization purposes, in case message_code
    /// is not yet known by the client use default_message instead.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub message_id: i64,

    /// Output only. In case message_code is not yet known by the client
    /// default_message will be the message to be used instead.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_message: std::string::String,

    /// Output only. Additional information about the insight, each entry can be a
    /// logical entry and must make sense if it is displayed with line breaks
    /// between each entry. Text can contain md style links.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub additional_information: std::vec::Vec<std::string::String>,
}

impl GenericInsight {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message_id][crate::model::GenericInsight::message_id].
    pub fn set_message_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.message_id = v.into();
        self
    }

    /// Sets the value of [default_message][crate::model::GenericInsight::default_message].
    pub fn set_default_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_message = v.into();
        self
    }

    /// Sets the value of [additional_information][crate::model::GenericInsight::additional_information].
    pub fn set_additional_information<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.additional_information = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GenericInsight {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.GenericInsight"
    }
}

/// An insight about potential migrations for an asset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrationInsight {
    /// Output only. Description of how well the asset this insight is associated
    /// with fits the proposed migration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub fit: std::option::Option<crate::model::FitDescriptor>,

    /// A target for the migration.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub migration_target: std::option::Option<crate::model::migration_insight::MigrationTarget>,
}

impl MigrationInsight {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fit][crate::model::MigrationInsight::fit].
    pub fn set_fit<T: std::convert::Into<std::option::Option<crate::model::FitDescriptor>>>(
        mut self,
        v: T,
    ) -> Self {
        self.fit = v.into();
        self
    }

    /// Sets the value of `migration_target`.
    pub fn set_migration_target<
        T: std::convert::Into<std::option::Option<crate::model::migration_insight::MigrationTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.migration_target = v.into();
        self
    }

    /// The value of [migration_target][crate::model::MigrationInsight::migration_target]
    /// if it holds a `ComputeEngineTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_compute_engine_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeEngineMigrationTarget>> {
        #[allow(unreachable_patterns)]
        self.migration_target.as_ref().and_then(|v| match v {
            crate::model::migration_insight::MigrationTarget::ComputeEngineTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [migration_target][crate::model::MigrationInsight::migration_target]
    /// to hold a `ComputeEngineTarget`.
    ///
    /// Note that all the setters affecting `migration_target` are
    /// mutually exclusive.
    pub fn set_compute_engine_target<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeEngineMigrationTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.migration_target = std::option::Option::Some(
            crate::model::migration_insight::MigrationTarget::ComputeEngineTarget(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MigrationInsight {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.MigrationInsight"
    }
}

/// Defines additional types related to MigrationInsight
pub mod migration_insight {
    #[allow(unused_imports)]
    use super::*;

    /// A target for the migration.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum MigrationTarget {
        /// Output only. A Google Compute Engine target.
        ComputeEngineTarget(std::boxed::Box<crate::model::ComputeEngineMigrationTarget>),
    }
}

/// Compute engine migration target.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeEngineMigrationTarget {
    /// Description of the suggested shape for the migration target.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub shape: std::option::Option<crate::model::ComputeEngineShapeDescriptor>,
}

impl ComputeEngineMigrationTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [shape][crate::model::ComputeEngineMigrationTarget::shape].
    pub fn set_shape<
        T: std::convert::Into<std::option::Option<crate::model::ComputeEngineShapeDescriptor>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.shape = v.into();
        self
    }
}

impl wkt::message::Message for ComputeEngineMigrationTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ComputeEngineMigrationTarget"
    }
}

/// Compute Engine target shape descriptor.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeEngineShapeDescriptor {
    /// Memory in mebibytes.
    pub memory_mb: i32,

    /// Number of physical cores.
    pub physical_core_count: i32,

    /// Number of logical cores.
    pub logical_core_count: i32,

    /// Compute Engine machine series.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub series: std::string::String,

    /// Compute Engine machine type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_type: std::string::String,

    /// Compute Engine storage. Never empty.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub storage: std::vec::Vec<crate::model::ComputeStorageDescriptor>,
}

impl ComputeEngineShapeDescriptor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [memory_mb][crate::model::ComputeEngineShapeDescriptor::memory_mb].
    pub fn set_memory_mb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_mb = v.into();
        self
    }

    /// Sets the value of [physical_core_count][crate::model::ComputeEngineShapeDescriptor::physical_core_count].
    pub fn set_physical_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.physical_core_count = v.into();
        self
    }

    /// Sets the value of [logical_core_count][crate::model::ComputeEngineShapeDescriptor::logical_core_count].
    pub fn set_logical_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.logical_core_count = v.into();
        self
    }

    /// Sets the value of [series][crate::model::ComputeEngineShapeDescriptor::series].
    pub fn set_series<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.series = v.into();
        self
    }

    /// Sets the value of [machine_type][crate::model::ComputeEngineShapeDescriptor::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [storage][crate::model::ComputeEngineShapeDescriptor::storage].
    pub fn set_storage<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ComputeStorageDescriptor>,
    {
        use std::iter::Iterator;
        self.storage = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ComputeEngineShapeDescriptor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ComputeEngineShapeDescriptor"
    }
}

/// Compute Engine storage option descriptor.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeStorageDescriptor {
    /// Disk type backing the storage.
    #[serde(rename = "type")]
    pub r#type: crate::model::PersistentDiskType,

    /// Disk size in GiB.
    pub size_gb: i32,
}

impl ComputeStorageDescriptor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::ComputeStorageDescriptor::type].
    pub fn set_type<T: std::convert::Into<crate::model::PersistentDiskType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [size_gb][crate::model::ComputeStorageDescriptor::size_gb].
    pub fn set_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.size_gb = v.into();
        self
    }
}

impl wkt::message::Message for ComputeStorageDescriptor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ComputeStorageDescriptor"
    }
}

/// Describes the fit level of an asset for migration to a specific target.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FitDescriptor {
    /// Fit level.
    pub fit_level: crate::model::fit_descriptor::FitLevel,
}

impl FitDescriptor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fit_level][crate::model::FitDescriptor::fit_level].
    pub fn set_fit_level<T: std::convert::Into<crate::model::fit_descriptor::FitLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.fit_level = v.into();
        self
    }
}

impl wkt::message::Message for FitDescriptor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.FitDescriptor"
    }
}

/// Defines additional types related to FitDescriptor
pub mod fit_descriptor {
    #[allow(unused_imports)]
    use super::*;

    /// Fit level.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct FitLevel(i32);

    impl FitLevel {
        /// Not enough information.
        pub const FIT_LEVEL_UNSPECIFIED: FitLevel = FitLevel::new(0);

        /// Fit.
        pub const FIT: FitLevel = FitLevel::new(1);

        /// No Fit.
        pub const NO_FIT: FitLevel = FitLevel::new(2);

        /// Fit with effort.
        pub const REQUIRES_EFFORT: FitLevel = FitLevel::new(3);

        /// Creates a new FitLevel instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("FIT_LEVEL_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("FIT"),
                2 => std::borrow::Cow::Borrowed("NO_FIT"),
                3 => std::borrow::Cow::Borrowed("REQUIRES_EFFORT"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "FIT_LEVEL_UNSPECIFIED" => std::option::Option::Some(Self::FIT_LEVEL_UNSPECIFIED),
                "FIT" => std::option::Option::Some(Self::FIT),
                "NO_FIT" => std::option::Option::Some(Self::NO_FIT),
                "REQUIRES_EFFORT" => std::option::Option::Some(Self::REQUIRES_EFFORT),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for FitLevel {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for FitLevel {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Message describing an aggregation. The message includes the aggregation type,
/// parameters, and the field on which to perform the aggregation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Aggregation {
    /// The name of the field on which to aggregate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub field: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub aggregation_function: std::option::Option<crate::model::aggregation::AggregationFunction>,
}

impl Aggregation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::Aggregation::field].
    pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field = v.into();
        self
    }

    /// Sets the value of `aggregation_function`.
    pub fn set_aggregation_function<
        T: std::convert::Into<std::option::Option<crate::model::aggregation::AggregationFunction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aggregation_function = v.into();
        self
    }

    /// The value of [aggregation_function][crate::model::Aggregation::aggregation_function]
    /// if it holds a `Count`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_count(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::aggregation::Count>> {
        #[allow(unreachable_patterns)]
        self.aggregation_function.as_ref().and_then(|v| match v {
            crate::model::aggregation::AggregationFunction::Count(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [aggregation_function][crate::model::Aggregation::aggregation_function]
    /// if it holds a `Sum`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_sum(&self) -> std::option::Option<&std::boxed::Box<crate::model::aggregation::Sum>> {
        #[allow(unreachable_patterns)]
        self.aggregation_function.as_ref().and_then(|v| match v {
            crate::model::aggregation::AggregationFunction::Sum(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [aggregation_function][crate::model::Aggregation::aggregation_function]
    /// if it holds a `Histogram`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_histogram(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::aggregation::Histogram>> {
        #[allow(unreachable_patterns)]
        self.aggregation_function.as_ref().and_then(|v| match v {
            crate::model::aggregation::AggregationFunction::Histogram(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [aggregation_function][crate::model::Aggregation::aggregation_function]
    /// if it holds a `Frequency`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_frequency(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::aggregation::Frequency>> {
        #[allow(unreachable_patterns)]
        self.aggregation_function.as_ref().and_then(|v| match v {
            crate::model::aggregation::AggregationFunction::Frequency(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [aggregation_function][crate::model::Aggregation::aggregation_function]
    /// to hold a `Count`.
    ///
    /// Note that all the setters affecting `aggregation_function` are
    /// mutually exclusive.
    pub fn set_count<T: std::convert::Into<std::boxed::Box<crate::model::aggregation::Count>>>(
        mut self,
        v: T,
    ) -> Self {
        self.aggregation_function = std::option::Option::Some(
            crate::model::aggregation::AggregationFunction::Count(v.into()),
        );
        self
    }

    /// Sets the value of [aggregation_function][crate::model::Aggregation::aggregation_function]
    /// to hold a `Sum`.
    ///
    /// Note that all the setters affecting `aggregation_function` are
    /// mutually exclusive.
    pub fn set_sum<T: std::convert::Into<std::boxed::Box<crate::model::aggregation::Sum>>>(
        mut self,
        v: T,
    ) -> Self {
        self.aggregation_function = std::option::Option::Some(
            crate::model::aggregation::AggregationFunction::Sum(v.into()),
        );
        self
    }

    /// Sets the value of [aggregation_function][crate::model::Aggregation::aggregation_function]
    /// to hold a `Histogram`.
    ///
    /// Note that all the setters affecting `aggregation_function` are
    /// mutually exclusive.
    pub fn set_histogram<
        T: std::convert::Into<std::boxed::Box<crate::model::aggregation::Histogram>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aggregation_function = std::option::Option::Some(
            crate::model::aggregation::AggregationFunction::Histogram(v.into()),
        );
        self
    }

    /// Sets the value of [aggregation_function][crate::model::Aggregation::aggregation_function]
    /// to hold a `Frequency`.
    ///
    /// Note that all the setters affecting `aggregation_function` are
    /// mutually exclusive.
    pub fn set_frequency<
        T: std::convert::Into<std::boxed::Box<crate::model::aggregation::Frequency>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aggregation_function = std::option::Option::Some(
            crate::model::aggregation::AggregationFunction::Frequency(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Aggregation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.Aggregation"
    }
}

/// Defines additional types related to Aggregation
pub mod aggregation {
    #[allow(unused_imports)]
    use super::*;

    /// Object count.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Count {}

    impl Count {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Count {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.Aggregation.Count"
        }
    }

    /// Sum of field values.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Sum {}

    impl Sum {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Sum {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.Aggregation.Sum"
        }
    }

    /// Histogram of bucketed assets counts by field value.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Histogram {
        /// Lower bounds of buckets.
        /// The response will contain `n+1` buckets for `n` bounds.
        /// The first bucket will count all assets for which the field value is
        /// smaller than the first bound.
        /// Subsequent buckets will count assets for which the field value is
        /// greater or equal to a lower bound and smaller than the next one.
        /// The last bucket will count assets for which the field value is greater or
        /// equal to the final lower bound.
        /// You can define up to 20 lower bounds.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub lower_bounds: std::vec::Vec<f64>,
    }

    impl Histogram {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [lower_bounds][crate::model::aggregation::Histogram::lower_bounds].
        pub fn set_lower_bounds<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<f64>,
        {
            use std::iter::Iterator;
            self.lower_bounds = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Histogram {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.Aggregation.Histogram"
        }
    }

    /// Frequency distribution of all field values.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Frequency {}

    impl Frequency {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Frequency {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.Aggregation.Frequency"
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AggregationFunction {
        /// Count the number of matching objects.
        Count(std::boxed::Box<crate::model::aggregation::Count>),
        /// Sum over a numeric field.
        Sum(std::boxed::Box<crate::model::aggregation::Sum>),
        /// Creates a bucketed histogram of field values.
        Histogram(std::boxed::Box<crate::model::aggregation::Histogram>),
        /// Creates a frequency distribution of all field values.
        Frequency(std::boxed::Box<crate::model::aggregation::Frequency>),
    }
}

/// Message describing a result of an aggregation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AggregationResult {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub field: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::aggregation_result::Result>,
}

impl AggregationResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::AggregationResult::field].
    pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field = v.into();
        self
    }

    /// Sets the value of `result`.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::aggregation_result::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::AggregationResult::result]
    /// if it holds a `Count`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_count(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::aggregation_result::Count>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::aggregation_result::Result::Count(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [result][crate::model::AggregationResult::result]
    /// if it holds a `Sum`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_sum(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::aggregation_result::Sum>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::aggregation_result::Result::Sum(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [result][crate::model::AggregationResult::result]
    /// if it holds a `Histogram`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_histogram(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::aggregation_result::Histogram>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::aggregation_result::Result::Histogram(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [result][crate::model::AggregationResult::result]
    /// if it holds a `Frequency`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_frequency(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::aggregation_result::Frequency>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::aggregation_result::Result::Frequency(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::AggregationResult::result]
    /// to hold a `Count`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_count<
        T: std::convert::Into<std::boxed::Box<crate::model::aggregation_result::Count>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::aggregation_result::Result::Count(v.into()));
        self
    }

    /// Sets the value of [result][crate::model::AggregationResult::result]
    /// to hold a `Sum`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_sum<
        T: std::convert::Into<std::boxed::Box<crate::model::aggregation_result::Sum>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::aggregation_result::Result::Sum(v.into()));
        self
    }

    /// Sets the value of [result][crate::model::AggregationResult::result]
    /// to hold a `Histogram`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_histogram<
        T: std::convert::Into<std::boxed::Box<crate::model::aggregation_result::Histogram>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::aggregation_result::Result::Histogram(v.into()),
        );
        self
    }

    /// Sets the value of [result][crate::model::AggregationResult::result]
    /// to hold a `Frequency`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_frequency<
        T: std::convert::Into<std::boxed::Box<crate::model::aggregation_result::Frequency>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::aggregation_result::Result::Frequency(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AggregationResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.AggregationResult"
    }
}

/// Defines additional types related to AggregationResult
pub mod aggregation_result {
    #[allow(unused_imports)]
    use super::*;

    /// The result of a count aggregation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Count {
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub value: i64,
    }

    impl Count {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::aggregation_result::Count::value].
        pub fn set_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for Count {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.AggregationResult.Count"
        }
    }

    /// The result of a sum aggregation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Sum {
        pub value: f64,
    }

    impl Sum {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::aggregation_result::Sum::value].
        pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for Sum {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.AggregationResult.Sum"
        }
    }

    /// The result of a bucketed histogram aggregation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Histogram {
        /// Buckets in the histogram.
        /// There will be `n+1` buckets matching `n` lower bounds in the request.
        /// The first bucket will be from -infinity to the first bound.
        /// Subsequent buckets will be between one bound and the next.
        /// The final bucket will be from the final bound to infinity.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub buckets: std::vec::Vec<crate::model::aggregation_result::histogram::Bucket>,
    }

    impl Histogram {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [buckets][crate::model::aggregation_result::Histogram::buckets].
        pub fn set_buckets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::aggregation_result::histogram::Bucket>,
        {
            use std::iter::Iterator;
            self.buckets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Histogram {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.AggregationResult.Histogram"
        }
    }

    /// Defines additional types related to Histogram
    pub mod histogram {
        #[allow(unused_imports)]
        use super::*;

        /// A histogram bucket with a lower and upper bound, and a count of items
        /// with a field value between those bounds.
        /// The lower bound is inclusive and the upper bound is exclusive.
        /// Lower bound may be -infinity and upper bound may be infinity.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Bucket {
            /// Lower bound - inclusive.
            pub lower_bound: f64,

            /// Upper bound - exclusive.
            pub upper_bound: f64,

            /// Count of items in the bucket.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub count: i64,
        }

        impl Bucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [lower_bound][crate::model::aggregation_result::histogram::Bucket::lower_bound].
            pub fn set_lower_bound<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.lower_bound = v.into();
                self
            }

            /// Sets the value of [upper_bound][crate::model::aggregation_result::histogram::Bucket::upper_bound].
            pub fn set_upper_bound<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.upper_bound = v.into();
                self
            }

            /// Sets the value of [count][crate::model::aggregation_result::histogram::Bucket::count].
            pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.count = v.into();
                self
            }
        }

        impl wkt::message::Message for Bucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.migrationcenter.v1.AggregationResult.Histogram.Bucket"
            }
        }
    }

    /// The result of a frequency distribution aggregation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Frequency {
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        #[serde_as(as = "std::collections::HashMap<_, serde_with::DisplayFromStr>")]
        pub values: std::collections::HashMap<std::string::String, i64>,
    }

    impl Frequency {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [values][crate::model::aggregation_result::Frequency::values].
        pub fn set_values<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<i64>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for Frequency {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.AggregationResult.Frequency"
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Result {
        Count(std::boxed::Box<crate::model::aggregation_result::Count>),
        Sum(std::boxed::Box<crate::model::aggregation_result::Sum>),
        Histogram(std::boxed::Box<crate::model::aggregation_result::Histogram>),
        Frequency(std::boxed::Box<crate::model::aggregation_result::Frequency>),
    }
}

/// A resource that aggregates the validation errors found in an import job file.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileValidationReport {
    /// The name of the file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_name: std::string::String,

    /// Partial list of rows that encountered validation error.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub row_errors: std::vec::Vec<crate::model::ImportRowError>,

    /// Flag indicating that processing was aborted due to maximum number of
    /// errors.
    pub partial_report: bool,

    /// List of file level errors.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_errors: std::vec::Vec<crate::model::ImportError>,
}

impl FileValidationReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_name][crate::model::FileValidationReport::file_name].
    pub fn set_file_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_name = v.into();
        self
    }

    /// Sets the value of [partial_report][crate::model::FileValidationReport::partial_report].
    pub fn set_partial_report<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.partial_report = v.into();
        self
    }

    /// Sets the value of [row_errors][crate::model::FileValidationReport::row_errors].
    pub fn set_row_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportRowError>,
    {
        use std::iter::Iterator;
        self.row_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_errors][crate::model::FileValidationReport::file_errors].
    pub fn set_file_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportError>,
    {
        use std::iter::Iterator;
        self.file_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FileValidationReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.FileValidationReport"
    }
}

/// A resource that aggregates errors across import job files.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ValidationReport {
    /// List of errors found in files.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_validations: std::vec::Vec<crate::model::FileValidationReport>,

    /// List of job level errors.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub job_errors: std::vec::Vec<crate::model::ImportError>,
}

impl ValidationReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_validations][crate::model::ValidationReport::file_validations].
    pub fn set_file_validations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileValidationReport>,
    {
        use std::iter::Iterator;
        self.file_validations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [job_errors][crate::model::ValidationReport::job_errors].
    pub fn set_job_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportError>,
    {
        use std::iter::Iterator;
        self.job_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ValidationReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ValidationReport"
    }
}

/// A resource that reports result of the import job execution.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExecutionReport {
    /// Total number of asset frames reported for the import job.
    pub frames_reported: i32,

    /// Validation errors encountered during the execution of the import job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execution_errors: std::option::Option<crate::model::ValidationReport>,

    /// Output only. Total number of rows in the import job.
    pub total_rows_count: i32,
}

impl ExecutionReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [frames_reported][crate::model::ExecutionReport::frames_reported].
    pub fn set_frames_reported<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.frames_reported = v.into();
        self
    }

    /// Sets the value of [execution_errors][crate::model::ExecutionReport::execution_errors].
    pub fn set_execution_errors<
        T: std::convert::Into<std::option::Option<crate::model::ValidationReport>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.execution_errors = v.into();
        self
    }

    /// Sets the value of [total_rows_count][crate::model::ExecutionReport::total_rows_count].
    pub fn set_total_rows_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_rows_count = v.into();
        self
    }
}

impl wkt::message::Message for ExecutionReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ExecutionReport"
    }
}

/// A resource that reports the errors encountered while processing an
/// import job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportError {
    /// The error information.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_details: std::string::String,

    /// The severity of the error.
    pub severity: crate::model::import_error::Severity,
}

impl ImportError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_details][crate::model::ImportError::error_details].
    pub fn set_error_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_details = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::ImportError::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::import_error::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }
}

impl wkt::message::Message for ImportError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ImportError"
    }
}

/// Defines additional types related to ImportError
pub mod import_error {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerate possible error severity.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Severity(i32);

    impl Severity {
        pub const SEVERITY_UNSPECIFIED: Severity = Severity::new(0);

        pub const ERROR: Severity = Severity::new(1);

        pub const WARNING: Severity = Severity::new(2);

        pub const INFO: Severity = Severity::new(3);

        /// Creates a new Severity instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SEVERITY_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ERROR"),
                2 => std::borrow::Cow::Borrowed("WARNING"),
                3 => std::borrow::Cow::Borrowed("INFO"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SEVERITY_UNSPECIFIED" => std::option::Option::Some(Self::SEVERITY_UNSPECIFIED),
                "ERROR" => std::option::Option::Some(Self::ERROR),
                "WARNING" => std::option::Option::Some(Self::WARNING),
                "INFO" => std::option::Option::Some(Self::INFO),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Severity {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A resource that reports the import job errors at row level.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportRowError {
    /// The row number where the error was detected.
    pub row_number: i32,

    /// The name of the VM in the row.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_name: std::string::String,

    /// The VM UUID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_uuid: std::string::String,

    /// The list of errors detected in the row.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::ImportError>,
}

impl ImportRowError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [row_number][crate::model::ImportRowError::row_number].
    pub fn set_row_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.row_number = v.into();
        self
    }

    /// Sets the value of [vm_name][crate::model::ImportRowError::vm_name].
    pub fn set_vm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_name = v.into();
        self
    }

    /// Sets the value of [vm_uuid][crate::model::ImportRowError::vm_uuid].
    pub fn set_vm_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_uuid = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::ImportRowError::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportRowError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ImportRowError"
    }
}

/// A resource that contains a URI to which a data file can be uploaded.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadFileInfo {
    /// Output only. Upload URI for the file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub signed_uri: std::string::String,

    /// Output only. The headers that were used to sign the URI.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub headers: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Expiration time of the upload URI.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub uri_expiration_time: std::option::Option<wkt::Timestamp>,
}

impl UploadFileInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [signed_uri][crate::model::UploadFileInfo::signed_uri].
    pub fn set_signed_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.signed_uri = v.into();
        self
    }

    /// Sets the value of [uri_expiration_time][crate::model::UploadFileInfo::uri_expiration_time].
    pub fn set_uri_expiration_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.uri_expiration_time = v.into();
        self
    }

    /// Sets the value of [headers][crate::model::UploadFileInfo::headers].
    pub fn set_headers<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for UploadFileInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.UploadFileInfo"
    }
}

/// Lists the asset IDs of all assets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AssetList {
    /// Required. A list of asset IDs
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub asset_ids: std::vec::Vec<std::string::String>,
}

impl AssetList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [asset_ids][crate::model::AssetList::asset_ids].
    pub fn set_asset_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.asset_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AssetList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.AssetList"
    }
}

/// A resource that contains a single violation of a reported `AssetFrame`
/// resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FrameViolationEntry {
    /// The field of the original frame where the violation occurred.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub field: std::string::String,

    /// A message describing the violation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub violation: std::string::String,
}

impl FrameViolationEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::FrameViolationEntry::field].
    pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field = v.into();
        self
    }

    /// Sets the value of [violation][crate::model::FrameViolationEntry::violation].
    pub fn set_violation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.violation = v.into();
        self
    }
}

impl wkt::message::Message for FrameViolationEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.FrameViolationEntry"
    }
}

/// VirtualMachinePreferences enables you to create sets of assumptions, for
/// example, a geographical location and pricing track, for your migrated virtual
/// machines. The set of preferences influence recommendations for migrating
/// virtual machine assets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VirtualMachinePreferences {
    /// Target product for assets using this preference set.
    /// Specify either target product or business goal, but
    /// not both.
    pub target_product: crate::model::ComputeMigrationTargetProduct,

    /// Region preferences for assets using this preference set.
    /// If you are unsure which value to set, the migration service API region is
    /// often a good value to start with.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub region_preferences: std::option::Option<crate::model::RegionPreferences>,

    /// Commitment plan to consider when calculating costs for virtual machine
    /// insights and recommendations.
    /// If you are unsure which value to set, a 3 year commitment plan is often a
    /// good value to start with.
    pub commitment_plan: crate::model::CommitmentPlan,

    /// Sizing optimization strategy specifies the preferred strategy used when
    /// extrapolating usage data to calculate insights and recommendations for a
    /// virtual machine.
    /// If you are unsure which value to set, a moderate sizing optimization
    /// strategy is often a good value to start with.
    pub sizing_optimization_strategy: crate::model::SizingOptimizationStrategy,

    /// Compute Engine preferences concern insights and recommendations for Compute
    /// Engine target.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub compute_engine_preferences: std::option::Option<crate::model::ComputeEnginePreferences>,

    /// Preferences concerning insights and recommendations for
    /// Google Cloud VMware Engine.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vmware_engine_preferences: std::option::Option<crate::model::VmwareEnginePreferences>,

    /// Preferences concerning Sole Tenant nodes and virtual machines.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sole_tenancy_preferences: std::option::Option<crate::model::SoleTenancyPreferences>,
}

impl VirtualMachinePreferences {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_product][crate::model::VirtualMachinePreferences::target_product].
    pub fn set_target_product<
        T: std::convert::Into<crate::model::ComputeMigrationTargetProduct>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_product = v.into();
        self
    }

    /// Sets the value of [region_preferences][crate::model::VirtualMachinePreferences::region_preferences].
    pub fn set_region_preferences<
        T: std::convert::Into<std::option::Option<crate::model::RegionPreferences>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.region_preferences = v.into();
        self
    }

    /// Sets the value of [commitment_plan][crate::model::VirtualMachinePreferences::commitment_plan].
    pub fn set_commitment_plan<T: std::convert::Into<crate::model::CommitmentPlan>>(
        mut self,
        v: T,
    ) -> Self {
        self.commitment_plan = v.into();
        self
    }

    /// Sets the value of [sizing_optimization_strategy][crate::model::VirtualMachinePreferences::sizing_optimization_strategy].
    pub fn set_sizing_optimization_strategy<
        T: std::convert::Into<crate::model::SizingOptimizationStrategy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sizing_optimization_strategy = v.into();
        self
    }

    /// Sets the value of [compute_engine_preferences][crate::model::VirtualMachinePreferences::compute_engine_preferences].
    pub fn set_compute_engine_preferences<
        T: std::convert::Into<std::option::Option<crate::model::ComputeEnginePreferences>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compute_engine_preferences = v.into();
        self
    }

    /// Sets the value of [vmware_engine_preferences][crate::model::VirtualMachinePreferences::vmware_engine_preferences].
    pub fn set_vmware_engine_preferences<
        T: std::convert::Into<std::option::Option<crate::model::VmwareEnginePreferences>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vmware_engine_preferences = v.into();
        self
    }

    /// Sets the value of [sole_tenancy_preferences][crate::model::VirtualMachinePreferences::sole_tenancy_preferences].
    pub fn set_sole_tenancy_preferences<
        T: std::convert::Into<std::option::Option<crate::model::SoleTenancyPreferences>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sole_tenancy_preferences = v.into();
        self
    }
}

impl wkt::message::Message for VirtualMachinePreferences {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.VirtualMachinePreferences"
    }
}

/// The user preferences relating to Compute Engine target platform.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeEnginePreferences {
    /// Preferences concerning the machine types to consider on Compute Engine.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub machine_preferences: std::option::Option<crate::model::MachinePreferences>,

    /// License type to consider when calculating costs for virtual machine
    /// insights and recommendations. If unspecified, costs are calculated
    /// based on the default licensing plan.
    pub license_type: crate::model::LicenseType,
}

impl ComputeEnginePreferences {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_preferences][crate::model::ComputeEnginePreferences::machine_preferences].
    pub fn set_machine_preferences<
        T: std::convert::Into<std::option::Option<crate::model::MachinePreferences>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.machine_preferences = v.into();
        self
    }

    /// Sets the value of [license_type][crate::model::ComputeEnginePreferences::license_type].
    pub fn set_license_type<T: std::convert::Into<crate::model::LicenseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.license_type = v.into();
        self
    }
}

impl wkt::message::Message for ComputeEnginePreferences {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ComputeEnginePreferences"
    }
}

/// The type of machines to consider when calculating virtual machine migration
/// insights and recommendations.
/// Not all machine types are available in all zones and regions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MachinePreferences {
    /// Compute Engine machine series to consider for insights and recommendations.
    /// If empty, no restriction is applied on the machine series.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub allowed_machine_series: std::vec::Vec<crate::model::MachineSeries>,
}

impl MachinePreferences {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowed_machine_series][crate::model::MachinePreferences::allowed_machine_series].
    pub fn set_allowed_machine_series<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MachineSeries>,
    {
        use std::iter::Iterator;
        self.allowed_machine_series = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MachinePreferences {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.MachinePreferences"
    }
}

/// A Compute Engine machine series.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MachineSeries {
    /// Code to identify a Compute Engine machine series. Consult
    /// <https://cloud.google.com/compute/docs/machine-resource#machine_type_comparison>
    /// for more details on the available series.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub code: std::string::String,
}

impl MachineSeries {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::MachineSeries::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }
}

impl wkt::message::Message for MachineSeries {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.MachineSeries"
    }
}

/// The user preferences relating to Google Cloud VMware Engine target platform.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VmwareEnginePreferences {
    /// CPU overcommit ratio.
    /// Acceptable values are between 1.0 and 8.0, with 0.1 increment.
    pub cpu_overcommit_ratio: f64,

    /// Memory overcommit ratio.
    /// Acceptable values are 1.0, 1.25, 1.5, 1.75 and 2.0.
    pub memory_overcommit_ratio: f64,

    /// The Deduplication and Compression ratio is based on the logical (Used
    /// Before) space required to store data before applying deduplication and
    /// compression, in relation to the physical (Used After) space required after
    /// applying deduplication and compression. Specifically, the ratio is the Used
    /// Before space divided by the Used After space. For example, if the Used
    /// Before space is 3 GB, but the physical Used After space is 1 GB, the
    /// deduplication and compression ratio is 3x. Acceptable values are
    /// between 1.0 and 4.0.
    pub storage_deduplication_compression_ratio: f64,

    /// Commitment plan to consider when calculating costs for virtual machine
    /// insights and recommendations.
    /// If you are unsure which value to set, a 3 year commitment plan is often a
    /// good value to start with.
    pub commitment_plan: crate::model::vmware_engine_preferences::CommitmentPlan,
}

impl VmwareEnginePreferences {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpu_overcommit_ratio][crate::model::VmwareEnginePreferences::cpu_overcommit_ratio].
    pub fn set_cpu_overcommit_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.cpu_overcommit_ratio = v.into();
        self
    }

    /// Sets the value of [memory_overcommit_ratio][crate::model::VmwareEnginePreferences::memory_overcommit_ratio].
    pub fn set_memory_overcommit_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.memory_overcommit_ratio = v.into();
        self
    }

    /// Sets the value of [storage_deduplication_compression_ratio][crate::model::VmwareEnginePreferences::storage_deduplication_compression_ratio].
    pub fn set_storage_deduplication_compression_ratio<T: std::convert::Into<f64>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_deduplication_compression_ratio = v.into();
        self
    }

    /// Sets the value of [commitment_plan][crate::model::VmwareEnginePreferences::commitment_plan].
    pub fn set_commitment_plan<
        T: std::convert::Into<crate::model::vmware_engine_preferences::CommitmentPlan>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.commitment_plan = v.into();
        self
    }
}

impl wkt::message::Message for VmwareEnginePreferences {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.VmwareEnginePreferences"
    }
}

/// Defines additional types related to VmwareEnginePreferences
pub mod vmware_engine_preferences {
    #[allow(unused_imports)]
    use super::*;

    /// Type of committed use discount.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct CommitmentPlan(i32);

    impl CommitmentPlan {
        /// Unspecified commitment plan.
        pub const COMMITMENT_PLAN_UNSPECIFIED: CommitmentPlan = CommitmentPlan::new(0);

        /// No commitment plan (on-demand usage).
        pub const ON_DEMAND: CommitmentPlan = CommitmentPlan::new(1);

        /// 1 year commitment (monthly payments).
        pub const COMMITMENT_1_YEAR_MONTHLY_PAYMENTS: CommitmentPlan = CommitmentPlan::new(2);

        /// 3 year commitment (monthly payments).
        pub const COMMITMENT_3_YEAR_MONTHLY_PAYMENTS: CommitmentPlan = CommitmentPlan::new(3);

        /// 1 year commitment (upfront payment).
        pub const COMMITMENT_1_YEAR_UPFRONT_PAYMENT: CommitmentPlan = CommitmentPlan::new(4);

        /// 3 years commitment (upfront payment).
        pub const COMMITMENT_3_YEAR_UPFRONT_PAYMENT: CommitmentPlan = CommitmentPlan::new(5);

        /// Creates a new CommitmentPlan instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("COMMITMENT_PLAN_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ON_DEMAND"),
                2 => std::borrow::Cow::Borrowed("COMMITMENT_1_YEAR_MONTHLY_PAYMENTS"),
                3 => std::borrow::Cow::Borrowed("COMMITMENT_3_YEAR_MONTHLY_PAYMENTS"),
                4 => std::borrow::Cow::Borrowed("COMMITMENT_1_YEAR_UPFRONT_PAYMENT"),
                5 => std::borrow::Cow::Borrowed("COMMITMENT_3_YEAR_UPFRONT_PAYMENT"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "COMMITMENT_PLAN_UNSPECIFIED" => {
                    std::option::Option::Some(Self::COMMITMENT_PLAN_UNSPECIFIED)
                }
                "ON_DEMAND" => std::option::Option::Some(Self::ON_DEMAND),
                "COMMITMENT_1_YEAR_MONTHLY_PAYMENTS" => {
                    std::option::Option::Some(Self::COMMITMENT_1_YEAR_MONTHLY_PAYMENTS)
                }
                "COMMITMENT_3_YEAR_MONTHLY_PAYMENTS" => {
                    std::option::Option::Some(Self::COMMITMENT_3_YEAR_MONTHLY_PAYMENTS)
                }
                "COMMITMENT_1_YEAR_UPFRONT_PAYMENT" => {
                    std::option::Option::Some(Self::COMMITMENT_1_YEAR_UPFRONT_PAYMENT)
                }
                "COMMITMENT_3_YEAR_UPFRONT_PAYMENT" => {
                    std::option::Option::Some(Self::COMMITMENT_3_YEAR_UPFRONT_PAYMENT)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for CommitmentPlan {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for CommitmentPlan {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Preferences concerning Sole Tenancy nodes and VMs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SoleTenancyPreferences {
    /// CPU overcommit ratio.
    /// Acceptable values are between 1.0 and 2.0 inclusive.
    pub cpu_overcommit_ratio: f64,

    /// Sole Tenancy nodes maintenance policy.
    pub host_maintenance_policy: crate::model::sole_tenancy_preferences::HostMaintenancePolicy,

    /// Commitment plan to consider when calculating costs for virtual machine
    /// insights and recommendations.
    /// If you are unsure which value to set, a 3 year commitment plan is often a
    /// good value to start with.
    pub commitment_plan: crate::model::sole_tenancy_preferences::CommitmentPlan,

    /// A list of sole tenant node types.
    /// An empty list means that all possible node types will be considered.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub node_types: std::vec::Vec<crate::model::SoleTenantNodeType>,
}

impl SoleTenancyPreferences {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpu_overcommit_ratio][crate::model::SoleTenancyPreferences::cpu_overcommit_ratio].
    pub fn set_cpu_overcommit_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.cpu_overcommit_ratio = v.into();
        self
    }

    /// Sets the value of [host_maintenance_policy][crate::model::SoleTenancyPreferences::host_maintenance_policy].
    pub fn set_host_maintenance_policy<
        T: std::convert::Into<crate::model::sole_tenancy_preferences::HostMaintenancePolicy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.host_maintenance_policy = v.into();
        self
    }

    /// Sets the value of [commitment_plan][crate::model::SoleTenancyPreferences::commitment_plan].
    pub fn set_commitment_plan<
        T: std::convert::Into<crate::model::sole_tenancy_preferences::CommitmentPlan>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.commitment_plan = v.into();
        self
    }

    /// Sets the value of [node_types][crate::model::SoleTenancyPreferences::node_types].
    pub fn set_node_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SoleTenantNodeType>,
    {
        use std::iter::Iterator;
        self.node_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SoleTenancyPreferences {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.SoleTenancyPreferences"
    }
}

/// Defines additional types related to SoleTenancyPreferences
pub mod sole_tenancy_preferences {
    #[allow(unused_imports)]
    use super::*;

    /// Sole Tenancy nodes maintenance policy.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct HostMaintenancePolicy(i32);

    impl HostMaintenancePolicy {
        /// Unspecified host maintenance policy.
        pub const HOST_MAINTENANCE_POLICY_UNSPECIFIED: HostMaintenancePolicy =
            HostMaintenancePolicy::new(0);

        /// Default host maintenance policy.
        pub const HOST_MAINTENANCE_POLICY_DEFAULT: HostMaintenancePolicy =
            HostMaintenancePolicy::new(1);

        /// Restart in place host maintenance policy.
        pub const HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE: HostMaintenancePolicy =
            HostMaintenancePolicy::new(2);

        /// Migrate within node group host maintenance policy.
        pub const HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP: HostMaintenancePolicy =
            HostMaintenancePolicy::new(3);

        /// Creates a new HostMaintenancePolicy instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("HOST_MAINTENANCE_POLICY_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("HOST_MAINTENANCE_POLICY_DEFAULT"),
                2 => std::borrow::Cow::Borrowed("HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE"),
                3 => {
                    std::borrow::Cow::Borrowed("HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP")
                }
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "HOST_MAINTENANCE_POLICY_UNSPECIFIED" => {
                    std::option::Option::Some(Self::HOST_MAINTENANCE_POLICY_UNSPECIFIED)
                }
                "HOST_MAINTENANCE_POLICY_DEFAULT" => {
                    std::option::Option::Some(Self::HOST_MAINTENANCE_POLICY_DEFAULT)
                }
                "HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE" => {
                    std::option::Option::Some(Self::HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE)
                }
                "HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP" => std::option::Option::Some(
                    Self::HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP,
                ),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for HostMaintenancePolicy {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for HostMaintenancePolicy {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Type of committed use discount.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct CommitmentPlan(i32);

    impl CommitmentPlan {
        /// Unspecified commitment plan.
        pub const COMMITMENT_PLAN_UNSPECIFIED: CommitmentPlan = CommitmentPlan::new(0);

        /// No commitment plan (on-demand usage).
        pub const ON_DEMAND: CommitmentPlan = CommitmentPlan::new(1);

        /// 1 year commitment.
        pub const COMMITMENT_1_YEAR: CommitmentPlan = CommitmentPlan::new(2);

        /// 3 years commitment.
        pub const COMMITMENT_3_YEAR: CommitmentPlan = CommitmentPlan::new(3);

        /// Creates a new CommitmentPlan instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("COMMITMENT_PLAN_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ON_DEMAND"),
                2 => std::borrow::Cow::Borrowed("COMMITMENT_1_YEAR"),
                3 => std::borrow::Cow::Borrowed("COMMITMENT_3_YEAR"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "COMMITMENT_PLAN_UNSPECIFIED" => {
                    std::option::Option::Some(Self::COMMITMENT_PLAN_UNSPECIFIED)
                }
                "ON_DEMAND" => std::option::Option::Some(Self::ON_DEMAND),
                "COMMITMENT_1_YEAR" => std::option::Option::Some(Self::COMMITMENT_1_YEAR),
                "COMMITMENT_3_YEAR" => std::option::Option::Some(Self::COMMITMENT_3_YEAR),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for CommitmentPlan {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for CommitmentPlan {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A Sole Tenant node type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SoleTenantNodeType {
    /// Name of the Sole Tenant node. Consult
    /// <https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub node_name: std::string::String,
}

impl SoleTenantNodeType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_name][crate::model::SoleTenantNodeType::node_name].
    pub fn set_node_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_name = v.into();
        self
    }
}

impl wkt::message::Message for SoleTenantNodeType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.SoleTenantNodeType"
    }
}

/// The user preferences relating to target regions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RegionPreferences {
    /// A list of preferred regions,
    /// ordered by the most preferred region first.
    /// Set only valid Google Cloud region names.
    /// See <https://cloud.google.com/compute/docs/regions-zones>
    /// for available regions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub preferred_regions: std::vec::Vec<std::string::String>,
}

impl RegionPreferences {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [preferred_regions][crate::model::RegionPreferences::preferred_regions].
    pub fn set_preferred_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.preferred_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RegionPreferences {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.RegionPreferences"
    }
}

/// Describes the Migration Center settings related to the project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Settings {
    /// Output only. The name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The preference set used by default for a project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub preference_set: std::string::String,
}

impl Settings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Settings::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [preference_set][crate::model::Settings::preference_set].
    pub fn set_preference_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.preference_set = v.into();
        self
    }
}

impl wkt::message::Message for Settings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.Settings"
    }
}

/// Describes the Summary view of a Report, which contains aggregated values
/// for all the groups and preference sets included in this Report.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReportSummary {
    /// Aggregate statistics for all the assets across all the groups.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub all_assets_stats: std::option::Option<crate::model::report_summary::AssetAggregateStats>,

    /// Findings for each Group included in this report.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub group_findings: std::vec::Vec<crate::model::report_summary::GroupFinding>,
}

impl ReportSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [all_assets_stats][crate::model::ReportSummary::all_assets_stats].
    pub fn set_all_assets_stats<
        T: std::convert::Into<std::option::Option<crate::model::report_summary::AssetAggregateStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.all_assets_stats = v.into();
        self
    }

    /// Sets the value of [group_findings][crate::model::ReportSummary::group_findings].
    pub fn set_group_findings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::report_summary::GroupFinding>,
    {
        use std::iter::Iterator;
        self.group_findings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReportSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary"
    }
}

/// Defines additional types related to ReportSummary
pub mod report_summary {
    #[allow(unused_imports)]
    use super::*;

    /// Describes a collection of data points rendered as a Chart.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ChartData {
        /// Each data point in the chart is represented as a name-value pair
        /// with the name being the x-axis label, and the value being the y-axis
        /// value.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub data_points: std::vec::Vec<crate::model::report_summary::chart_data::DataPoint>,
    }

    impl ChartData {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [data_points][crate::model::report_summary::ChartData::data_points].
        pub fn set_data_points<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::report_summary::chart_data::DataPoint>,
        {
            use std::iter::Iterator;
            self.data_points = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ChartData {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.ChartData"
        }
    }

    /// Defines additional types related to ChartData
    pub mod chart_data {
        #[allow(unused_imports)]
        use super::*;

        /// Describes a single data point in the Chart.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DataPoint {
            /// The X-axis label for this data point.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub label: std::string::String,

            /// The Y-axis value for this data point.
            pub value: f64,
        }

        impl DataPoint {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [label][crate::model::report_summary::chart_data::DataPoint::label].
            pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.label = v.into();
                self
            }

            /// Sets the value of [value][crate::model::report_summary::chart_data::DataPoint::value].
            pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.value = v.into();
                self
            }
        }

        impl wkt::message::Message for DataPoint {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.ChartData.DataPoint"
            }
        }
    }

    /// Utilization Chart is a specific type of visualization which displays
    /// a metric classified into "Used" and "Free" buckets.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UtilizationChartData {
        /// Aggregate value which falls into the "Used" bucket.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub used: i64,

        /// Aggregate value which falls into the "Free" bucket.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub free: i64,
    }

    impl UtilizationChartData {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [used][crate::model::report_summary::UtilizationChartData::used].
        pub fn set_used<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.used = v.into();
            self
        }

        /// Sets the value of [free][crate::model::report_summary::UtilizationChartData::free].
        pub fn set_free<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.free = v.into();
            self
        }
    }

    impl wkt::message::Message for UtilizationChartData {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.UtilizationChartData"
        }
    }

    /// A Histogram Chart shows a distribution of values into buckets, showing
    /// a count of values which fall into a bucket.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct HistogramChartData {
        /// Buckets in the histogram.
        /// There will be `n+1` buckets matching `n` lower bounds in the request.
        /// The first bucket will be from -infinity to the first bound.
        /// Subsequent buckets will be between one bound and the next.
        /// The final bucket will be from the final bound to infinity.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub buckets: std::vec::Vec<crate::model::report_summary::histogram_chart_data::Bucket>,
    }

    impl HistogramChartData {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [buckets][crate::model::report_summary::HistogramChartData::buckets].
        pub fn set_buckets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::report_summary::histogram_chart_data::Bucket>,
        {
            use std::iter::Iterator;
            self.buckets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for HistogramChartData {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.HistogramChartData"
        }
    }

    /// Defines additional types related to HistogramChartData
    pub mod histogram_chart_data {
        #[allow(unused_imports)]
        use super::*;

        /// A histogram bucket with a lower and upper bound, and a count of items
        /// with a field value between those bounds.
        /// The lower bound is inclusive and the upper bound is exclusive.
        /// Lower bound may be -infinity and upper bound may be infinity.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Bucket {
            /// Lower bound - inclusive.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub lower_bound: i64,

            /// Upper bound - exclusive.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub upper_bound: i64,

            /// Count of items in the bucket.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub count: i64,
        }

        impl Bucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [lower_bound][crate::model::report_summary::histogram_chart_data::Bucket::lower_bound].
            pub fn set_lower_bound<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.lower_bound = v.into();
                self
            }

            /// Sets the value of [upper_bound][crate::model::report_summary::histogram_chart_data::Bucket::upper_bound].
            pub fn set_upper_bound<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.upper_bound = v.into();
                self
            }

            /// Sets the value of [count][crate::model::report_summary::histogram_chart_data::Bucket::count].
            pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.count = v.into();
                self
            }
        }

        impl wkt::message::Message for Bucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.HistogramChartData.Bucket"
            }
        }
    }

    /// Aggregate statistics for a collection of assets.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AssetAggregateStats {
        /// Sum of the memory in bytes of all the assets in this collection.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub total_memory_bytes: i64,

        /// Sum of persistent storage in bytes of all the assets in this collection.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub total_storage_bytes: i64,

        /// Sum of the CPU core count of all the assets in this collection.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub total_cores: i64,

        /// Count of the number of unique assets in this collection.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub total_assets: i64,

        /// Total memory split into Used/Free buckets.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub memory_utilization_chart:
            std::option::Option<crate::model::report_summary::UtilizationChartData>,

        /// Total memory split into Used/Free buckets.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub storage_utilization_chart:
            std::option::Option<crate::model::report_summary::UtilizationChartData>,

        /// Count of assets grouped by Operating System families.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub operating_system: std::option::Option<crate::model::report_summary::ChartData>,

        /// Histogram showing a distribution of CPU core counts.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub core_count_histogram:
            std::option::Option<crate::model::report_summary::HistogramChartData>,

        /// Histogram showing a distribution of memory sizes.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub memory_bytes_histogram:
            std::option::Option<crate::model::report_summary::HistogramChartData>,

        /// Histogram showing a distribution of memory sizes.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub storage_bytes_histogram:
            std::option::Option<crate::model::report_summary::HistogramChartData>,
    }

    impl AssetAggregateStats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [total_memory_bytes][crate::model::report_summary::AssetAggregateStats::total_memory_bytes].
        pub fn set_total_memory_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.total_memory_bytes = v.into();
            self
        }

        /// Sets the value of [total_storage_bytes][crate::model::report_summary::AssetAggregateStats::total_storage_bytes].
        pub fn set_total_storage_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.total_storage_bytes = v.into();
            self
        }

        /// Sets the value of [total_cores][crate::model::report_summary::AssetAggregateStats::total_cores].
        pub fn set_total_cores<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.total_cores = v.into();
            self
        }

        /// Sets the value of [total_assets][crate::model::report_summary::AssetAggregateStats::total_assets].
        pub fn set_total_assets<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.total_assets = v.into();
            self
        }

        /// Sets the value of [memory_utilization_chart][crate::model::report_summary::AssetAggregateStats::memory_utilization_chart].
        pub fn set_memory_utilization_chart<
            T: std::convert::Into<
                std::option::Option<crate::model::report_summary::UtilizationChartData>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.memory_utilization_chart = v.into();
            self
        }

        /// Sets the value of [storage_utilization_chart][crate::model::report_summary::AssetAggregateStats::storage_utilization_chart].
        pub fn set_storage_utilization_chart<
            T: std::convert::Into<
                std::option::Option<crate::model::report_summary::UtilizationChartData>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.storage_utilization_chart = v.into();
            self
        }

        /// Sets the value of [operating_system][crate::model::report_summary::AssetAggregateStats::operating_system].
        pub fn set_operating_system<
            T: std::convert::Into<std::option::Option<crate::model::report_summary::ChartData>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.operating_system = v.into();
            self
        }

        /// Sets the value of [core_count_histogram][crate::model::report_summary::AssetAggregateStats::core_count_histogram].
        pub fn set_core_count_histogram<
            T: std::convert::Into<
                std::option::Option<crate::model::report_summary::HistogramChartData>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.core_count_histogram = v.into();
            self
        }

        /// Sets the value of [memory_bytes_histogram][crate::model::report_summary::AssetAggregateStats::memory_bytes_histogram].
        pub fn set_memory_bytes_histogram<
            T: std::convert::Into<
                std::option::Option<crate::model::report_summary::HistogramChartData>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.memory_bytes_histogram = v.into();
            self
        }

        /// Sets the value of [storage_bytes_histogram][crate::model::report_summary::AssetAggregateStats::storage_bytes_histogram].
        pub fn set_storage_bytes_histogram<
            T: std::convert::Into<
                std::option::Option<crate::model::report_summary::HistogramChartData>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.storage_bytes_histogram = v.into();
            self
        }
    }

    impl wkt::message::Message for AssetAggregateStats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.AssetAggregateStats"
        }
    }

    /// Represents a data point tracking the count of assets allocated for a
    /// specific Machine Series.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MachineSeriesAllocation {
        /// The Machine Series (e.g. "E2", "N2")
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub machine_series: std::option::Option<crate::model::MachineSeries>,

        /// Count of assets allocated to this machine series.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub allocated_asset_count: i64,
    }

    impl MachineSeriesAllocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [machine_series][crate::model::report_summary::MachineSeriesAllocation::machine_series].
        pub fn set_machine_series<
            T: std::convert::Into<std::option::Option<crate::model::MachineSeries>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.machine_series = v.into();
            self
        }

        /// Sets the value of [allocated_asset_count][crate::model::report_summary::MachineSeriesAllocation::allocated_asset_count].
        pub fn set_allocated_asset_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.allocated_asset_count = v.into();
            self
        }
    }

    impl wkt::message::Message for MachineSeriesAllocation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.MachineSeriesAllocation"
        }
    }

    /// A set of findings that applies to assets destined for Compute Engine.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ComputeEngineFinding {
        /// Set of regions in which the assets were allocated.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub allocated_regions: std::vec::Vec<std::string::String>,

        /// Count of assets which were allocated.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub allocated_asset_count: i64,

        /// Distribution of assets based on the Machine Series.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub machine_series_allocations:
            std::vec::Vec<crate::model::report_summary::MachineSeriesAllocation>,

        /// Set of disk types allocated to assets.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub allocated_disk_types: std::vec::Vec<crate::model::PersistentDiskType>,
    }

    impl ComputeEngineFinding {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [allocated_asset_count][crate::model::report_summary::ComputeEngineFinding::allocated_asset_count].
        pub fn set_allocated_asset_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.allocated_asset_count = v.into();
            self
        }

        /// Sets the value of [allocated_regions][crate::model::report_summary::ComputeEngineFinding::allocated_regions].
        pub fn set_allocated_regions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allocated_regions = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [machine_series_allocations][crate::model::report_summary::ComputeEngineFinding::machine_series_allocations].
        pub fn set_machine_series_allocations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::report_summary::MachineSeriesAllocation>,
        {
            use std::iter::Iterator;
            self.machine_series_allocations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [allocated_disk_types][crate::model::report_summary::ComputeEngineFinding::allocated_disk_types].
        pub fn set_allocated_disk_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::PersistentDiskType>,
        {
            use std::iter::Iterator;
            self.allocated_disk_types = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ComputeEngineFinding {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.ComputeEngineFinding"
        }
    }

    /// A set of findings that applies to assets destined for VMWare Engine.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VmwareEngineFinding {
        /// Set of regions in which the assets were allocated
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub allocated_regions: std::vec::Vec<std::string::String>,

        /// Count of assets which are allocated
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub allocated_asset_count: i64,

        /// Set of per-nodetype allocation records
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub node_allocations: std::vec::Vec<crate::model::report_summary::VmwareNodeAllocation>,
    }

    impl VmwareEngineFinding {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [allocated_asset_count][crate::model::report_summary::VmwareEngineFinding::allocated_asset_count].
        pub fn set_allocated_asset_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.allocated_asset_count = v.into();
            self
        }

        /// Sets the value of [allocated_regions][crate::model::report_summary::VmwareEngineFinding::allocated_regions].
        pub fn set_allocated_regions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allocated_regions = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [node_allocations][crate::model::report_summary::VmwareEngineFinding::node_allocations].
        pub fn set_node_allocations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::report_summary::VmwareNodeAllocation>,
        {
            use std::iter::Iterator;
            self.node_allocations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for VmwareEngineFinding {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.VmwareEngineFinding"
        }
    }

    /// Represents assets allocated to a specific VMWare Node type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VmwareNodeAllocation {
        /// VMWare node type, e.g. "ve1-standard-72"
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub vmware_node: std::option::Option<crate::model::report_summary::VmwareNode>,

        /// Count of this node type to be provisioned
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub node_count: i64,

        /// Count of assets allocated to these nodes
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub allocated_asset_count: i64,
    }

    impl VmwareNodeAllocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [vmware_node][crate::model::report_summary::VmwareNodeAllocation::vmware_node].
        pub fn set_vmware_node<
            T: std::convert::Into<std::option::Option<crate::model::report_summary::VmwareNode>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.vmware_node = v.into();
            self
        }

        /// Sets the value of [node_count][crate::model::report_summary::VmwareNodeAllocation::node_count].
        pub fn set_node_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.node_count = v.into();
            self
        }

        /// Sets the value of [allocated_asset_count][crate::model::report_summary::VmwareNodeAllocation::allocated_asset_count].
        pub fn set_allocated_asset_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.allocated_asset_count = v.into();
            self
        }
    }

    impl wkt::message::Message for VmwareNodeAllocation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.VmwareNodeAllocation"
        }
    }

    /// A VMWare Engine Node
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VmwareNode {
        /// Code to identify VMware Engine node series, e.g. "ve1-standard-72". Based
        /// on the displayName of
        /// cloud.google.com/vmware-engine/docs/reference/rest/v1/projects.locations.nodeTypes
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub code: std::string::String,
    }

    impl VmwareNode {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::report_summary::VmwareNode::code].
        pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.code = v.into();
            self
        }
    }

    impl wkt::message::Message for VmwareNode {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.VmwareNode"
        }
    }

    /// A set of findings that applies to assets destined for Sole-Tenant nodes.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SoleTenantFinding {
        /// Set of regions in which the assets are allocated
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub allocated_regions: std::vec::Vec<std::string::String>,

        /// Count of assets which are allocated
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub allocated_asset_count: i64,

        /// Set of per-nodetype allocation records
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub node_allocations: std::vec::Vec<crate::model::report_summary::SoleTenantNodeAllocation>,
    }

    impl SoleTenantFinding {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [allocated_asset_count][crate::model::report_summary::SoleTenantFinding::allocated_asset_count].
        pub fn set_allocated_asset_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.allocated_asset_count = v.into();
            self
        }

        /// Sets the value of [allocated_regions][crate::model::report_summary::SoleTenantFinding::allocated_regions].
        pub fn set_allocated_regions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allocated_regions = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [node_allocations][crate::model::report_summary::SoleTenantFinding::node_allocations].
        pub fn set_node_allocations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::report_summary::SoleTenantNodeAllocation>,
        {
            use std::iter::Iterator;
            self.node_allocations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SoleTenantFinding {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.SoleTenantFinding"
        }
    }

    /// Represents the assets allocated to a specific Sole-Tenant node type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SoleTenantNodeAllocation {
        /// Sole Tenant node type, e.g. "m3-node-128-3904"
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub node: std::option::Option<crate::model::SoleTenantNodeType>,

        /// Count of this node type to be provisioned
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub node_count: i64,

        /// Count of assets allocated to these nodes
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub allocated_asset_count: i64,
    }

    impl SoleTenantNodeAllocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [node][crate::model::report_summary::SoleTenantNodeAllocation::node].
        pub fn set_node<
            T: std::convert::Into<std::option::Option<crate::model::SoleTenantNodeType>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.node = v.into();
            self
        }

        /// Sets the value of [node_count][crate::model::report_summary::SoleTenantNodeAllocation::node_count].
        pub fn set_node_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.node_count = v.into();
            self
        }

        /// Sets the value of [allocated_asset_count][crate::model::report_summary::SoleTenantNodeAllocation::allocated_asset_count].
        pub fn set_allocated_asset_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.allocated_asset_count = v.into();
            self
        }
    }

    impl wkt::message::Message for SoleTenantNodeAllocation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.SoleTenantNodeAllocation"
        }
    }

    /// Summary Findings for a specific Group/PreferenceSet combination.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GroupPreferenceSetFinding {
        /// Display Name of the Preference Set
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub display_name: std::string::String,

        /// Description for the Preference Set.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub description: std::string::String,

        /// A set of preferences that applies to all machines in the context.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub machine_preferences: std::option::Option<crate::model::VirtualMachinePreferences>,

        /// Total monthly cost for this preference set.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub monthly_cost_total: std::option::Option<gtype::model::Money>,

        /// Compute monthly cost for this preference set.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub monthly_cost_compute: std::option::Option<gtype::model::Money>,

        /// Licensing monthly cost for this preference set.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub monthly_cost_os_license: std::option::Option<gtype::model::Money>,

        /// Network Egress monthly cost for this preference set.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub monthly_cost_network_egress: std::option::Option<gtype::model::Money>,

        /// Storage monthly cost for this preference set.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub monthly_cost_storage: std::option::Option<gtype::model::Money>,

        /// Miscellaneous monthly cost for this preference set.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub monthly_cost_other: std::option::Option<gtype::model::Money>,

        /// A set of findings that applies to Compute Engine machines in the input.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub compute_engine_finding:
            std::option::Option<crate::model::report_summary::ComputeEngineFinding>,

        /// A set of findings that applies to VMWare machines in the input.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub vmware_engine_finding:
            std::option::Option<crate::model::report_summary::VmwareEngineFinding>,

        /// A set of findings that applies to Sole-Tenant machines in the input.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub sole_tenant_finding:
            std::option::Option<crate::model::report_summary::SoleTenantFinding>,
    }

    impl GroupPreferenceSetFinding {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::report_summary::GroupPreferenceSetFinding::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [description][crate::model::report_summary::GroupPreferenceSetFinding::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [machine_preferences][crate::model::report_summary::GroupPreferenceSetFinding::machine_preferences].
        pub fn set_machine_preferences<
            T: std::convert::Into<std::option::Option<crate::model::VirtualMachinePreferences>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.machine_preferences = v.into();
            self
        }

        /// Sets the value of [monthly_cost_total][crate::model::report_summary::GroupPreferenceSetFinding::monthly_cost_total].
        pub fn set_monthly_cost_total<
            T: std::convert::Into<std::option::Option<gtype::model::Money>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.monthly_cost_total = v.into();
            self
        }

        /// Sets the value of [monthly_cost_compute][crate::model::report_summary::GroupPreferenceSetFinding::monthly_cost_compute].
        pub fn set_monthly_cost_compute<
            T: std::convert::Into<std::option::Option<gtype::model::Money>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.monthly_cost_compute = v.into();
            self
        }

        /// Sets the value of [monthly_cost_os_license][crate::model::report_summary::GroupPreferenceSetFinding::monthly_cost_os_license].
        pub fn set_monthly_cost_os_license<
            T: std::convert::Into<std::option::Option<gtype::model::Money>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.monthly_cost_os_license = v.into();
            self
        }

        /// Sets the value of [monthly_cost_network_egress][crate::model::report_summary::GroupPreferenceSetFinding::monthly_cost_network_egress].
        pub fn set_monthly_cost_network_egress<
            T: std::convert::Into<std::option::Option<gtype::model::Money>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.monthly_cost_network_egress = v.into();
            self
        }

        /// Sets the value of [monthly_cost_storage][crate::model::report_summary::GroupPreferenceSetFinding::monthly_cost_storage].
        pub fn set_monthly_cost_storage<
            T: std::convert::Into<std::option::Option<gtype::model::Money>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.monthly_cost_storage = v.into();
            self
        }

        /// Sets the value of [monthly_cost_other][crate::model::report_summary::GroupPreferenceSetFinding::monthly_cost_other].
        pub fn set_monthly_cost_other<
            T: std::convert::Into<std::option::Option<gtype::model::Money>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.monthly_cost_other = v.into();
            self
        }

        /// Sets the value of [compute_engine_finding][crate::model::report_summary::GroupPreferenceSetFinding::compute_engine_finding].
        pub fn set_compute_engine_finding<
            T: std::convert::Into<
                std::option::Option<crate::model::report_summary::ComputeEngineFinding>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.compute_engine_finding = v.into();
            self
        }

        /// Sets the value of [vmware_engine_finding][crate::model::report_summary::GroupPreferenceSetFinding::vmware_engine_finding].
        pub fn set_vmware_engine_finding<
            T: std::convert::Into<
                std::option::Option<crate::model::report_summary::VmwareEngineFinding>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.vmware_engine_finding = v.into();
            self
        }

        /// Sets the value of [sole_tenant_finding][crate::model::report_summary::GroupPreferenceSetFinding::sole_tenant_finding].
        pub fn set_sole_tenant_finding<
            T: std::convert::Into<
                std::option::Option<crate::model::report_summary::SoleTenantFinding>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.sole_tenant_finding = v.into();
            self
        }
    }

    impl wkt::message::Message for GroupPreferenceSetFinding {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.GroupPreferenceSetFinding"
        }
    }

    /// Summary Findings for a specific Group.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GroupFinding {
        /// Display Name for the Group.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub display_name: std::string::String,

        /// Description for the Group.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub description: std::string::String,

        /// Summary statistics for all the assets in this group.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub asset_aggregate_stats:
            std::option::Option<crate::model::report_summary::AssetAggregateStats>,

        /// This field is deprecated, do not rely on it having a value.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub overlapping_asset_count: i64,

        /// Findings for each of the PreferenceSets for this group.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub preference_set_findings:
            std::vec::Vec<crate::model::report_summary::GroupPreferenceSetFinding>,
    }

    impl GroupFinding {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::report_summary::GroupFinding::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [description][crate::model::report_summary::GroupFinding::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [asset_aggregate_stats][crate::model::report_summary::GroupFinding::asset_aggregate_stats].
        pub fn set_asset_aggregate_stats<
            T: std::convert::Into<
                std::option::Option<crate::model::report_summary::AssetAggregateStats>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.asset_aggregate_stats = v.into();
            self
        }

        /// Sets the value of [overlapping_asset_count][crate::model::report_summary::GroupFinding::overlapping_asset_count].
        pub fn set_overlapping_asset_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.overlapping_asset_count = v.into();
            self
        }

        /// Sets the value of [preference_set_findings][crate::model::report_summary::GroupFinding::preference_set_findings].
        pub fn set_preference_set_findings<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::report_summary::GroupPreferenceSetFinding>,
        {
            use std::iter::Iterator;
            self.preference_set_findings = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for GroupFinding {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.migrationcenter.v1.ReportSummary.GroupFinding"
        }
    }
}

/// Specifies the types of asset views that provide complete or partial details
/// of an asset.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct AssetView(i32);

impl AssetView {
    /// The asset view is not specified. The API displays the basic view by
    /// default.
    pub const ASSET_VIEW_UNSPECIFIED: AssetView = AssetView::new(0);

    /// The asset view includes only basic metadata of the asset.
    pub const ASSET_VIEW_BASIC: AssetView = AssetView::new(1);

    /// The asset view includes all the metadata of an asset and performance data.
    pub const ASSET_VIEW_FULL: AssetView = AssetView::new(2);

    /// Creates a new AssetView instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("ASSET_VIEW_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("ASSET_VIEW_BASIC"),
            2 => std::borrow::Cow::Borrowed("ASSET_VIEW_FULL"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "ASSET_VIEW_UNSPECIFIED" => std::option::Option::Some(Self::ASSET_VIEW_UNSPECIFIED),
            "ASSET_VIEW_BASIC" => std::option::Option::Some(Self::ASSET_VIEW_BASIC),
            "ASSET_VIEW_FULL" => std::option::Option::Some(Self::ASSET_VIEW_FULL),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for AssetView {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for AssetView {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Known categories of operating systems.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct OperatingSystemFamily(i32);

impl OperatingSystemFamily {
    pub const OS_FAMILY_UNKNOWN: OperatingSystemFamily = OperatingSystemFamily::new(0);

    /// Microsoft Windows Server and Desktop.
    pub const OS_FAMILY_WINDOWS: OperatingSystemFamily = OperatingSystemFamily::new(1);

    /// Various Linux flavors.
    pub const OS_FAMILY_LINUX: OperatingSystemFamily = OperatingSystemFamily::new(2);

    /// Non-Linux Unix flavors.
    pub const OS_FAMILY_UNIX: OperatingSystemFamily = OperatingSystemFamily::new(3);

    /// Creates a new OperatingSystemFamily instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("OS_FAMILY_UNKNOWN"),
            1 => std::borrow::Cow::Borrowed("OS_FAMILY_WINDOWS"),
            2 => std::borrow::Cow::Borrowed("OS_FAMILY_LINUX"),
            3 => std::borrow::Cow::Borrowed("OS_FAMILY_UNIX"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "OS_FAMILY_UNKNOWN" => std::option::Option::Some(Self::OS_FAMILY_UNKNOWN),
            "OS_FAMILY_WINDOWS" => std::option::Option::Some(Self::OS_FAMILY_WINDOWS),
            "OS_FAMILY_LINUX" => std::option::Option::Some(Self::OS_FAMILY_LINUX),
            "OS_FAMILY_UNIX" => std::option::Option::Some(Self::OS_FAMILY_UNIX),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for OperatingSystemFamily {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for OperatingSystemFamily {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Specifies the data formats supported by Migration Center.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ImportJobFormat(i32);

impl ImportJobFormat {
    /// Default value.
    pub const IMPORT_JOB_FORMAT_UNSPECIFIED: ImportJobFormat = ImportJobFormat::new(0);

    /// RVTools format (XLSX).
    pub const IMPORT_JOB_FORMAT_RVTOOLS_XLSX: ImportJobFormat = ImportJobFormat::new(1);

    /// RVTools format (CSV).
    pub const IMPORT_JOB_FORMAT_RVTOOLS_CSV: ImportJobFormat = ImportJobFormat::new(2);

    /// CSV format exported from AWS using the
    /// [AWS collection
    /// script][<https://github.com/GoogleCloudPlatform/aws-to-stratozone-export>].
    pub const IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV: ImportJobFormat = ImportJobFormat::new(4);

    /// CSV format exported from Azure using the
    /// [Azure collection
    /// script][<https://github.com/GoogleCloudPlatform/azure-to-stratozone-export>].
    pub const IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV: ImportJobFormat = ImportJobFormat::new(5);

    /// CSV format created manually and following the StratoZone format. For more
    /// information, see [Manually create and upload data
    /// tables][<https://cloud.google.com/migrate/stratozone/docs/import-data-portal>].
    pub const IMPORT_JOB_FORMAT_STRATOZONE_CSV: ImportJobFormat = ImportJobFormat::new(6);

    /// Creates a new ImportJobFormat instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("IMPORT_JOB_FORMAT_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("IMPORT_JOB_FORMAT_RVTOOLS_XLSX"),
            2 => std::borrow::Cow::Borrowed("IMPORT_JOB_FORMAT_RVTOOLS_CSV"),
            4 => std::borrow::Cow::Borrowed("IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV"),
            5 => std::borrow::Cow::Borrowed("IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV"),
            6 => std::borrow::Cow::Borrowed("IMPORT_JOB_FORMAT_STRATOZONE_CSV"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "IMPORT_JOB_FORMAT_UNSPECIFIED" => {
                std::option::Option::Some(Self::IMPORT_JOB_FORMAT_UNSPECIFIED)
            }
            "IMPORT_JOB_FORMAT_RVTOOLS_XLSX" => {
                std::option::Option::Some(Self::IMPORT_JOB_FORMAT_RVTOOLS_XLSX)
            }
            "IMPORT_JOB_FORMAT_RVTOOLS_CSV" => {
                std::option::Option::Some(Self::IMPORT_JOB_FORMAT_RVTOOLS_CSV)
            }
            "IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV" => {
                std::option::Option::Some(Self::IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV)
            }
            "IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV" => {
                std::option::Option::Some(Self::IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV)
            }
            "IMPORT_JOB_FORMAT_STRATOZONE_CSV" => {
                std::option::Option::Some(Self::IMPORT_JOB_FORMAT_STRATOZONE_CSV)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for ImportJobFormat {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for ImportJobFormat {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Specifies the types of import job views that provide complete or partial
/// details of an import job.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ImportJobView(i32);

impl ImportJobView {
    /// The import job view is not specified. The API displays the basic view by
    /// default.
    pub const IMPORT_JOB_VIEW_UNSPECIFIED: ImportJobView = ImportJobView::new(0);

    /// The import job view includes basic metadata of an import job.
    /// This view does not include payload information.
    pub const IMPORT_JOB_VIEW_BASIC: ImportJobView = ImportJobView::new(1);

    /// The import job view includes all metadata of an import job.
    pub const IMPORT_JOB_VIEW_FULL: ImportJobView = ImportJobView::new(2);

    /// Creates a new ImportJobView instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("IMPORT_JOB_VIEW_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("IMPORT_JOB_VIEW_BASIC"),
            2 => std::borrow::Cow::Borrowed("IMPORT_JOB_VIEW_FULL"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "IMPORT_JOB_VIEW_UNSPECIFIED" => {
                std::option::Option::Some(Self::IMPORT_JOB_VIEW_UNSPECIFIED)
            }
            "IMPORT_JOB_VIEW_BASIC" => std::option::Option::Some(Self::IMPORT_JOB_VIEW_BASIC),
            "IMPORT_JOB_VIEW_FULL" => std::option::Option::Some(Self::IMPORT_JOB_VIEW_FULL),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for ImportJobView {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for ImportJobView {
    fn default() -> Self {
        Self::new(0)
    }
}

/// ErrorFrameView can be specified in ErrorFrames List and Get requests to
/// control the level of details that is returned for the original frame.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ErrorFrameView(i32);

impl ErrorFrameView {
    /// Value is unset. The system will fallback to the default value.
    pub const ERROR_FRAME_VIEW_UNSPECIFIED: ErrorFrameView = ErrorFrameView::new(0);

    /// Include basic frame data, but not the full contents.
    pub const ERROR_FRAME_VIEW_BASIC: ErrorFrameView = ErrorFrameView::new(1);

    /// Include everything.
    pub const ERROR_FRAME_VIEW_FULL: ErrorFrameView = ErrorFrameView::new(2);

    /// Creates a new ErrorFrameView instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("ERROR_FRAME_VIEW_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("ERROR_FRAME_VIEW_BASIC"),
            2 => std::borrow::Cow::Borrowed("ERROR_FRAME_VIEW_FULL"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "ERROR_FRAME_VIEW_UNSPECIFIED" => {
                std::option::Option::Some(Self::ERROR_FRAME_VIEW_UNSPECIFIED)
            }
            "ERROR_FRAME_VIEW_BASIC" => std::option::Option::Some(Self::ERROR_FRAME_VIEW_BASIC),
            "ERROR_FRAME_VIEW_FULL" => std::option::Option::Some(Self::ERROR_FRAME_VIEW_FULL),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for ErrorFrameView {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for ErrorFrameView {
    fn default() -> Self {
        Self::new(0)
    }
}

/// The persistent disk (PD) types of Compute Engine virtual machines.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct PersistentDiskType(i32);

impl PersistentDiskType {
    /// Unspecified (default value).
    /// Selecting this value allows the system to use any disk type according
    /// to reported usage. This a good value to start with.
    pub const PERSISTENT_DISK_TYPE_UNSPECIFIED: PersistentDiskType = PersistentDiskType::new(0);

    /// Standard HDD Persistent Disk.
    pub const PERSISTENT_DISK_TYPE_STANDARD: PersistentDiskType = PersistentDiskType::new(1);

    /// Balanced Persistent Disk.
    pub const PERSISTENT_DISK_TYPE_BALANCED: PersistentDiskType = PersistentDiskType::new(2);

    /// SSD Persistent Disk.
    pub const PERSISTENT_DISK_TYPE_SSD: PersistentDiskType = PersistentDiskType::new(3);

    /// Creates a new PersistentDiskType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("PERSISTENT_DISK_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("PERSISTENT_DISK_TYPE_STANDARD"),
            2 => std::borrow::Cow::Borrowed("PERSISTENT_DISK_TYPE_BALANCED"),
            3 => std::borrow::Cow::Borrowed("PERSISTENT_DISK_TYPE_SSD"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "PERSISTENT_DISK_TYPE_UNSPECIFIED" => {
                std::option::Option::Some(Self::PERSISTENT_DISK_TYPE_UNSPECIFIED)
            }
            "PERSISTENT_DISK_TYPE_STANDARD" => {
                std::option::Option::Some(Self::PERSISTENT_DISK_TYPE_STANDARD)
            }
            "PERSISTENT_DISK_TYPE_BALANCED" => {
                std::option::Option::Some(Self::PERSISTENT_DISK_TYPE_BALANCED)
            }
            "PERSISTENT_DISK_TYPE_SSD" => std::option::Option::Some(Self::PERSISTENT_DISK_TYPE_SSD),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for PersistentDiskType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for PersistentDiskType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// The License type for premium images (RHEL, RHEL for SAP, SLES, SLES for SAP,
/// Windows Server).
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct LicenseType(i32);

impl LicenseType {
    /// Unspecified (default value).
    pub const LICENSE_TYPE_UNSPECIFIED: LicenseType = LicenseType::new(0);

    /// Default Google Cloud licensing plan. Licensing is charged per usage.
    /// This a good value to start with.
    pub const LICENSE_TYPE_DEFAULT: LicenseType = LicenseType::new(1);

    /// Bring-your-own-license (BYOL) plan. User provides the OS license.
    pub const LICENSE_TYPE_BRING_YOUR_OWN_LICENSE: LicenseType = LicenseType::new(2);

    /// Creates a new LicenseType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("LICENSE_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("LICENSE_TYPE_DEFAULT"),
            2 => std::borrow::Cow::Borrowed("LICENSE_TYPE_BRING_YOUR_OWN_LICENSE"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "LICENSE_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::LICENSE_TYPE_UNSPECIFIED),
            "LICENSE_TYPE_DEFAULT" => std::option::Option::Some(Self::LICENSE_TYPE_DEFAULT),
            "LICENSE_TYPE_BRING_YOUR_OWN_LICENSE" => {
                std::option::Option::Some(Self::LICENSE_TYPE_BRING_YOUR_OWN_LICENSE)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for LicenseType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for LicenseType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// The sizing optimization strategy preferences of a virtual machine. This
/// strategy, in addition to actual usage data of the virtual machine, can help
/// determine the recommended shape on the target platform.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct SizingOptimizationStrategy(i32);

impl SizingOptimizationStrategy {
    /// Unspecified (default value).
    pub const SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED: SizingOptimizationStrategy =
        SizingOptimizationStrategy::new(0);

    /// No optimization applied. Virtual machine sizing matches as closely as
    /// possible the machine shape on the source site, not considering any actual
    /// performance data.
    pub const SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE: SizingOptimizationStrategy =
        SizingOptimizationStrategy::new(1);

    /// Virtual machine sizing will match the reported usage and shape, with some
    /// slack. This a good value to start with.
    pub const SIZING_OPTIMIZATION_STRATEGY_MODERATE: SizingOptimizationStrategy =
        SizingOptimizationStrategy::new(2);

    /// Virtual machine sizing will match the reported usage, with little slack.
    /// Using this option can help reduce costs.
    pub const SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE: SizingOptimizationStrategy =
        SizingOptimizationStrategy::new(3);

    /// Creates a new SizingOptimizationStrategy instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE"),
            2 => std::borrow::Cow::Borrowed("SIZING_OPTIMIZATION_STRATEGY_MODERATE"),
            3 => std::borrow::Cow::Borrowed("SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED" => {
                std::option::Option::Some(Self::SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED)
            }
            "SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE" => {
                std::option::Option::Some(Self::SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE)
            }
            "SIZING_OPTIMIZATION_STRATEGY_MODERATE" => {
                std::option::Option::Some(Self::SIZING_OPTIMIZATION_STRATEGY_MODERATE)
            }
            "SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE" => {
                std::option::Option::Some(Self::SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for SizingOptimizationStrategy {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for SizingOptimizationStrategy {
    fn default() -> Self {
        Self::new(0)
    }
}

/// The plan of commitments for VM resource-based committed use discount (CUD).
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct CommitmentPlan(i32);

impl CommitmentPlan {
    /// Unspecified commitment plan.
    pub const COMMITMENT_PLAN_UNSPECIFIED: CommitmentPlan = CommitmentPlan::new(0);

    /// No commitment plan.
    pub const COMMITMENT_PLAN_NONE: CommitmentPlan = CommitmentPlan::new(1);

    /// 1 year commitment.
    pub const COMMITMENT_PLAN_ONE_YEAR: CommitmentPlan = CommitmentPlan::new(2);

    /// 3 years commitment.
    pub const COMMITMENT_PLAN_THREE_YEARS: CommitmentPlan = CommitmentPlan::new(3);

    /// Creates a new CommitmentPlan instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("COMMITMENT_PLAN_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("COMMITMENT_PLAN_NONE"),
            2 => std::borrow::Cow::Borrowed("COMMITMENT_PLAN_ONE_YEAR"),
            3 => std::borrow::Cow::Borrowed("COMMITMENT_PLAN_THREE_YEARS"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "COMMITMENT_PLAN_UNSPECIFIED" => {
                std::option::Option::Some(Self::COMMITMENT_PLAN_UNSPECIFIED)
            }
            "COMMITMENT_PLAN_NONE" => std::option::Option::Some(Self::COMMITMENT_PLAN_NONE),
            "COMMITMENT_PLAN_ONE_YEAR" => std::option::Option::Some(Self::COMMITMENT_PLAN_ONE_YEAR),
            "COMMITMENT_PLAN_THREE_YEARS" => {
                std::option::Option::Some(Self::COMMITMENT_PLAN_THREE_YEARS)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for CommitmentPlan {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for CommitmentPlan {
    fn default() -> Self {
        Self::new(0)
    }
}

/// The preference for a specific Google Cloud product platform.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ComputeMigrationTargetProduct(i32);

impl ComputeMigrationTargetProduct {
    /// Unspecified (default value).
    pub const COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED: ComputeMigrationTargetProduct =
        ComputeMigrationTargetProduct::new(0);

    /// Prefer to migrate to Google Cloud Compute Engine.
    pub const COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE: ComputeMigrationTargetProduct =
        ComputeMigrationTargetProduct::new(1);

    /// Prefer to migrate to Google Cloud VMware Engine.
    pub const COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE: ComputeMigrationTargetProduct =
        ComputeMigrationTargetProduct::new(2);

    /// Prefer to migrate to Google Cloud Sole Tenant Nodes.
    pub const COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY: ComputeMigrationTargetProduct =
        ComputeMigrationTargetProduct::new(3);

    /// Creates a new ComputeMigrationTargetProduct instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE"),
            2 => std::borrow::Cow::Borrowed("COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE"),
            3 => std::borrow::Cow::Borrowed("COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED" => {
                std::option::Option::Some(Self::COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED)
            }
            "COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE" => {
                std::option::Option::Some(Self::COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE)
            }
            "COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE" => {
                std::option::Option::Some(Self::COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE)
            }
            "COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY" => {
                std::option::Option::Some(Self::COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for ComputeMigrationTargetProduct {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for ComputeMigrationTargetProduct {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Specifies the types of views that provide complete or partial details
/// of a Report.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ReportView(i32);

impl ReportView {
    /// The report view is not specified. The API displays the basic view by
    /// default.
    pub const REPORT_VIEW_UNSPECIFIED: ReportView = ReportView::new(0);

    /// The report view includes only basic metadata of the Report. Useful for
    /// list views.
    pub const REPORT_VIEW_BASIC: ReportView = ReportView::new(1);

    /// The report view includes all the metadata of the Report. Useful for
    /// preview.
    pub const REPORT_VIEW_FULL: ReportView = ReportView::new(2);

    /// The report view includes the standard metadata of an report. Useful for
    /// detail view.
    pub const REPORT_VIEW_STANDARD: ReportView = ReportView::new(3);

    /// Creates a new ReportView instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("REPORT_VIEW_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("REPORT_VIEW_BASIC"),
            2 => std::borrow::Cow::Borrowed("REPORT_VIEW_FULL"),
            3 => std::borrow::Cow::Borrowed("REPORT_VIEW_STANDARD"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "REPORT_VIEW_UNSPECIFIED" => std::option::Option::Some(Self::REPORT_VIEW_UNSPECIFIED),
            "REPORT_VIEW_BASIC" => std::option::Option::Some(Self::REPORT_VIEW_BASIC),
            "REPORT_VIEW_FULL" => std::option::Option::Some(Self::REPORT_VIEW_FULL),
            "REPORT_VIEW_STANDARD" => std::option::Option::Some(Self::REPORT_VIEW_STANDARD),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for ReportView {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for ReportView {
    fn default() -> Self {
        Self::new(0)
    }
}
