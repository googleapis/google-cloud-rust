// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::AdvancedSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdvancedSettings");
        debug_struct.field(
            "audio_export_gcs_destination",
            &self.audio_export_gcs_destination,
        );
        debug_struct.field("speech_settings", &self.speech_settings);
        debug_struct.field("dtmf_settings", &self.dtmf_settings);
        debug_struct.field("logging_settings", &self.logging_settings);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::advanced_settings::SpeechSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SpeechSettings");
        debug_struct.field("endpointer_sensitivity", &self.endpointer_sensitivity);
        debug_struct.field("no_speech_timeout", &self.no_speech_timeout);
        debug_struct.field(
            "use_timeout_based_endpointing",
            &self.use_timeout_based_endpointing,
        );
        debug_struct.field("models", &self.models);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::advanced_settings::DtmfSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DtmfSettings");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("max_digits", &self.max_digits);
        debug_struct.field("finish_digit", &self.finish_digit);
        debug_struct.field(
            "interdigit_timeout_duration",
            &self.interdigit_timeout_duration,
        );
        debug_struct.field(
            "endpointing_timeout_duration",
            &self.endpointing_timeout_duration,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::advanced_settings::LoggingSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoggingSettings");
        debug_struct.field(
            "enable_stackdriver_logging",
            &self.enable_stackdriver_logging,
        );
        debug_struct.field(
            "enable_interaction_logging",
            &self.enable_interaction_logging,
        );
        debug_struct.field(
            "enable_consent_based_redaction",
            &self.enable_consent_based_redaction,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::SpeechToTextSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SpeechToTextSettings");
        debug_struct.field("enable_speech_adaptation", &self.enable_speech_adaptation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::Agent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Agent");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("default_language_code", &self.default_language_code);
        debug_struct.field("supported_language_codes", &self.supported_language_codes);
        debug_struct.field("time_zone", &self.time_zone);
        debug_struct.field("description", &self.description);
        debug_struct.field("avatar_uri", &self.avatar_uri);
        debug_struct.field("speech_to_text_settings", &self.speech_to_text_settings);
        debug_struct.field("start_flow", &self.start_flow);
        debug_struct.field("security_settings", &self.security_settings);
        debug_struct.field(
            "enable_stackdriver_logging",
            &self.enable_stackdriver_logging,
        );
        debug_struct.field("enable_spell_correction", &self.enable_spell_correction);
        debug_struct.field(
            "enable_multi_language_training",
            &self.enable_multi_language_training,
        );
        debug_struct.field("locked", &self.locked);
        debug_struct.field("advanced_settings", &self.advanced_settings);
        debug_struct.field("git_integration_settings", &self.git_integration_settings);
        debug_struct.field("text_to_speech_settings", &self.text_to_speech_settings);
        debug_struct.field("gen_app_builder_settings", &self.gen_app_builder_settings);
        debug_struct.field("answer_feedback_settings", &self.answer_feedback_settings);
        debug_struct.field("personalization_settings", &self.personalization_settings);
        debug_struct.field(
            "client_certificate_settings",
            &self.client_certificate_settings,
        );
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("satisfies_pzi", &self.satisfies_pzi);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::agent::GitIntegrationSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitIntegrationSettings");
        debug_struct.field("git_settings", &self.git_settings);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::agent::git_integration_settings::GithubSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GithubSettings");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("repository_uri", &self.repository_uri);
        debug_struct.field("tracking_branch", &self.tracking_branch);
        debug_struct.field("access_token", &self.access_token);
        debug_struct.field("branches", &self.branches);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::agent::GenAppBuilderSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenAppBuilderSettings");
        debug_struct.field("engine", &self.engine);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::agent::AnswerFeedbackSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnswerFeedbackSettings");
        debug_struct.field("enable_answer_feedback", &self.enable_answer_feedback);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::agent::PersonalizationSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PersonalizationSettings");
        debug_struct.field("default_end_user_metadata", &self.default_end_user_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::agent::ClientCertificateSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClientCertificateSettings");
        debug_struct.field("ssl_certificate", &self.ssl_certificate);
        debug_struct.field("private_key", &self.private_key);
        debug_struct.field("passphrase", &self.passphrase);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::ListAgentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAgentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::ListAgentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAgentsResponse");
        debug_struct.field("agents", &self.agents);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::GetAgentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetAgentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::CreateAgentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateAgentRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("agent", &self.agent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::UpdateAgentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateAgentRequest");
        debug_struct.field("agent", &self.agent);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::DeleteAgentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteAgentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::ExportAgentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportAgentRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("agent_uri", &self.agent_uri);
        debug_struct.field("data_format", &self.data_format);
        debug_struct.field("environment", &self.environment);
        debug_struct.field("git_destination", &self.git_destination);
        debug_struct.field(
            "include_bigquery_export_settings",
            &self.include_bigquery_export_settings,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::export_agent_request::GitDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitDestination");
        debug_struct.field("tracking_branch", &self.tracking_branch);
        debug_struct.field("commit_message", &self.commit_message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::ExportAgentResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportAgentResponse");
        debug_struct.field("agent", &self.agent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::RestoreAgentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RestoreAgentRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("restore_option", &self.restore_option);
        debug_struct.field("agent", &self.agent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::restore_agent_request::GitSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitSource");
        debug_struct.field("tracking_branch", &self.tracking_branch);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::ValidateAgentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValidateAgentRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::GetAgentValidationResultRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetAgentValidationResultRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::AgentValidationResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AgentValidationResult");
        debug_struct.field("name", &self.name);
        debug_struct.field("flow_validation_results", &self.flow_validation_results);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::GetGenerativeSettingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetGenerativeSettingsRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::UpdateGenerativeSettingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateGenerativeSettingsRequest");
        debug_struct.field("generative_settings", &self.generative_settings);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::SpeechWordInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SpeechWordInfo");
        debug_struct.field("word", &self.word);
        debug_struct.field("start_offset", &self.start_offset);
        debug_struct.field("end_offset", &self.end_offset);
        debug_struct.field("confidence", &self.confidence);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl std::fmt::Debug for super::BargeInConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BargeInConfig");
        debug_struct.field("no_barge_in_duration", &self.no_barge_in_duration);
        debug_struct.field("total_duration", &self.total_duration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl std::fmt::Debug for super::InputAudioConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InputAudioConfig");
        debug_struct.field("audio_encoding", &self.audio_encoding);
        debug_struct.field("sample_rate_hertz", &self.sample_rate_hertz);
        debug_struct.field("enable_word_info", &self.enable_word_info);
        debug_struct.field("phrase_hints", &self.phrase_hints);
        debug_struct.field("model", &self.model);
        debug_struct.field("model_variant", &self.model_variant);
        debug_struct.field("single_utterance", &self.single_utterance);
        debug_struct.field("barge_in_config", &self.barge_in_config);
        debug_struct.field(
            "opt_out_conformer_model_migration",
            &self.opt_out_conformer_model_migration,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "agents", feature = "sessions",))]
impl std::fmt::Debug for super::VoiceSelectionParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VoiceSelectionParams");
        debug_struct.field("name", &self.name);
        debug_struct.field("ssml_gender", &self.ssml_gender);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "agents", feature = "sessions",))]
impl std::fmt::Debug for super::SynthesizeSpeechConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SynthesizeSpeechConfig");
        debug_struct.field("speaking_rate", &self.speaking_rate);
        debug_struct.field("pitch", &self.pitch);
        debug_struct.field("volume_gain_db", &self.volume_gain_db);
        debug_struct.field("effects_profile_id", &self.effects_profile_id);
        debug_struct.field("voice", &self.voice);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::OutputAudioConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OutputAudioConfig");
        debug_struct.field("audio_encoding", &self.audio_encoding);
        debug_struct.field("sample_rate_hertz", &self.sample_rate_hertz);
        debug_struct.field("synthesize_speech_config", &self.synthesize_speech_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::TextToSpeechSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TextToSpeechSettings");
        debug_struct.field("synthesize_speech_configs", &self.synthesize_speech_configs);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "changelogs")]
impl std::fmt::Debug for super::ListChangelogsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListChangelogsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "changelogs")]
impl std::fmt::Debug for super::ListChangelogsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListChangelogsResponse");
        debug_struct.field("changelogs", &self.changelogs);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "changelogs")]
impl std::fmt::Debug for super::GetChangelogRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetChangelogRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "changelogs")]
impl std::fmt::Debug for super::Changelog {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Changelog");
        debug_struct.field("name", &self.name);
        debug_struct.field("user_email", &self.user_email);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("action", &self.action);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("resource", &self.resource);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl std::fmt::Debug for super::DataStoreConnection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataStoreConnection");
        debug_struct.field("data_store_type", &self.data_store_type);
        debug_struct.field("data_store", &self.data_store);
        debug_struct.field("document_processing_mode", &self.document_processing_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::DataStoreConnectionSignals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataStoreConnectionSignals");
        debug_struct.field(
            "rewriter_model_call_signals",
            &self.rewriter_model_call_signals,
        );
        debug_struct.field("rewritten_query", &self.rewritten_query);
        debug_struct.field("search_snippets", &self.search_snippets);
        debug_struct.field(
            "answer_generation_model_call_signals",
            &self.answer_generation_model_call_signals,
        );
        debug_struct.field("answer", &self.answer);
        debug_struct.field("answer_parts", &self.answer_parts);
        debug_struct.field("cited_snippets", &self.cited_snippets);
        debug_struct.field("grounding_signals", &self.grounding_signals);
        debug_struct.field("safety_signals", &self.safety_signals);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::data_store_connection_signals::RewriterModelCallSignals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RewriterModelCallSignals");
        debug_struct.field("rendered_prompt", &self.rendered_prompt);
        debug_struct.field("model_output", &self.model_output);
        debug_struct.field("model", &self.model);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::data_store_connection_signals::SearchSnippet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchSnippet");
        debug_struct.field("document_title", &self.document_title);
        debug_struct.field("document_uri", &self.document_uri);
        debug_struct.field("text", &self.text);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::data_store_connection_signals::AnswerGenerationModelCallSignals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnswerGenerationModelCallSignals");
        debug_struct.field("rendered_prompt", &self.rendered_prompt);
        debug_struct.field("model_output", &self.model_output);
        debug_struct.field("model", &self.model);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::data_store_connection_signals::AnswerPart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnswerPart");
        debug_struct.field("text", &self.text);
        debug_struct.field("supporting_indices", &self.supporting_indices);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::data_store_connection_signals::CitedSnippet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CitedSnippet");
        debug_struct.field("search_snippet", &self.search_snippet);
        debug_struct.field("snippet_index", &self.snippet_index);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::data_store_connection_signals::GroundingSignals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GroundingSignals");
        debug_struct.field("decision", &self.decision);
        debug_struct.field("score", &self.score);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::data_store_connection_signals::SafetySignals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SafetySignals");
        debug_struct.field("decision", &self.decision);
        debug_struct.field("banned_phrase_match", &self.banned_phrase_match);
        debug_struct.field("matched_banned_phrase", &self.matched_banned_phrase);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "deployments")]
impl std::fmt::Debug for super::Deployment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Deployment");
        debug_struct.field("name", &self.name);
        debug_struct.field("flow_version", &self.flow_version);
        debug_struct.field("state", &self.state);
        debug_struct.field("result", &self.result);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "deployments")]
impl std::fmt::Debug for super::deployment::Result {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Result");
        debug_struct.field("deployment_test_results", &self.deployment_test_results);
        debug_struct.field("experiment", &self.experiment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "deployments")]
impl std::fmt::Debug for super::ListDeploymentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDeploymentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "deployments")]
impl std::fmt::Debug for super::ListDeploymentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDeploymentsResponse");
        debug_struct.field("deployments", &self.deployments);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "deployments")]
impl std::fmt::Debug for super::GetDeploymentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDeploymentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "entity-types",
    feature = "session-entity-types",
    feature = "sessions",
))]
impl std::fmt::Debug for super::EntityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EntityType");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("kind", &self.kind);
        debug_struct.field("auto_expansion_mode", &self.auto_expansion_mode);
        debug_struct.field("entities", &self.entities);
        debug_struct.field("excluded_phrases", &self.excluded_phrases);
        debug_struct.field("enable_fuzzy_extraction", &self.enable_fuzzy_extraction);
        debug_struct.field("redact", &self.redact);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "entity-types",
    feature = "session-entity-types",
    feature = "sessions",
))]
impl std::fmt::Debug for super::entity_type::Entity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Entity");
        debug_struct.field("value", &self.value);
        debug_struct.field("synonyms", &self.synonyms);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "entity-types",
    feature = "session-entity-types",
    feature = "sessions",
))]
impl std::fmt::Debug for super::entity_type::ExcludedPhrase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExcludedPhrase");
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "entity-types")]
impl std::fmt::Debug for super::ExportEntityTypesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportEntityTypesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("entity_types", &self.entity_types);
        debug_struct.field("data_format", &self.data_format);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("destination", &self.destination);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "entity-types")]
impl std::fmt::Debug for super::ExportEntityTypesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportEntityTypesResponse");
        debug_struct.field("exported_entity_types", &self.exported_entity_types);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "entity-types")]
impl std::fmt::Debug for super::ExportEntityTypesMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportEntityTypesMetadata");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "entity-types")]
impl std::fmt::Debug for super::ImportEntityTypesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportEntityTypesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("merge_option", &self.merge_option);
        debug_struct.field("target_entity_type", &self.target_entity_type);
        debug_struct.field("entity_types", &self.entity_types);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "entity-types")]
impl std::fmt::Debug for super::ImportEntityTypesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportEntityTypesResponse");
        debug_struct.field("entity_types", &self.entity_types);
        debug_struct.field("conflicting_resources", &self.conflicting_resources);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "entity-types")]
impl std::fmt::Debug for super::import_entity_types_response::ConflictingResources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConflictingResources");
        debug_struct.field("entity_type_display_names", &self.entity_type_display_names);
        debug_struct.field("entity_display_names", &self.entity_display_names);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "entity-types")]
impl std::fmt::Debug for super::ImportEntityTypesMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportEntityTypesMetadata");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "entity-types")]
impl std::fmt::Debug for super::ListEntityTypesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListEntityTypesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "entity-types")]
impl std::fmt::Debug for super::ListEntityTypesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListEntityTypesResponse");
        debug_struct.field("entity_types", &self.entity_types);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "entity-types")]
impl std::fmt::Debug for super::GetEntityTypeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetEntityTypeRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "entity-types")]
impl std::fmt::Debug for super::CreateEntityTypeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateEntityTypeRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("entity_type", &self.entity_type);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "entity-types")]
impl std::fmt::Debug for super::UpdateEntityTypeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateEntityTypeRequest");
        debug_struct.field("entity_type", &self.entity_type);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "entity-types")]
impl std::fmt::Debug for super::DeleteEntityTypeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteEntityTypeRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::Environment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Environment");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("version_configs", &self.version_configs);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("test_cases_config", &self.test_cases_config);
        debug_struct.field("webhook_config", &self.webhook_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::environment::VersionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VersionConfig");
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::environment::TestCasesConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TestCasesConfig");
        debug_struct.field("test_cases", &self.test_cases);
        debug_struct.field("enable_continuous_run", &self.enable_continuous_run);
        debug_struct.field("enable_predeployment_run", &self.enable_predeployment_run);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::environment::WebhookConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WebhookConfig");
        debug_struct.field("webhook_overrides", &self.webhook_overrides);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::ListEnvironmentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListEnvironmentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::ListEnvironmentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListEnvironmentsResponse");
        debug_struct.field("environments", &self.environments);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::GetEnvironmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetEnvironmentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::CreateEnvironmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateEnvironmentRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("environment", &self.environment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::UpdateEnvironmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateEnvironmentRequest");
        debug_struct.field("environment", &self.environment);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::DeleteEnvironmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteEnvironmentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::LookupEnvironmentHistoryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LookupEnvironmentHistoryRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::LookupEnvironmentHistoryResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LookupEnvironmentHistoryResponse");
        debug_struct.field("environments", &self.environments);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::ContinuousTestResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ContinuousTestResult");
        debug_struct.field("name", &self.name);
        debug_struct.field("result", &self.result);
        debug_struct.field("test_case_results", &self.test_case_results);
        debug_struct.field("run_time", &self.run_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::RunContinuousTestRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunContinuousTestRequest");
        debug_struct.field("environment", &self.environment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::RunContinuousTestResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunContinuousTestResponse");
        debug_struct.field("continuous_test_result", &self.continuous_test_result);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::RunContinuousTestMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunContinuousTestMetadata");
        debug_struct.field("errors", &self.errors);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::ListContinuousTestResultsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListContinuousTestResultsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::ListContinuousTestResultsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListContinuousTestResultsResponse");
        debug_struct.field("continuous_test_results", &self.continuous_test_results);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::DeployFlowRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployFlowRequest");
        debug_struct.field("environment", &self.environment);
        debug_struct.field("flow_version", &self.flow_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::DeployFlowResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployFlowResponse");
        debug_struct.field("environment", &self.environment);
        debug_struct.field("deployment", &self.deployment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "environments")]
impl std::fmt::Debug for super::DeployFlowMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployFlowMetadata");
        debug_struct.field("test_errors", &self.test_errors);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::Experiment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Experiment");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("state", &self.state);
        debug_struct.field("definition", &self.definition);
        debug_struct.field("rollout_config", &self.rollout_config);
        debug_struct.field("rollout_state", &self.rollout_state);
        debug_struct.field("rollout_failure_reason", &self.rollout_failure_reason);
        debug_struct.field("result", &self.result);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("last_update_time", &self.last_update_time);
        debug_struct.field("experiment_length", &self.experiment_length);
        debug_struct.field("variants_history", &self.variants_history);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::experiment::Definition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Definition");
        debug_struct.field("condition", &self.condition);
        debug_struct.field("variants", &self.variants);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::experiment::Result {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Result");
        debug_struct.field("version_metrics", &self.version_metrics);
        debug_struct.field("last_update_time", &self.last_update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::experiment::result::ConfidenceInterval {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfidenceInterval");
        debug_struct.field("confidence_level", &self.confidence_level);
        debug_struct.field("ratio", &self.ratio);
        debug_struct.field("lower_bound", &self.lower_bound);
        debug_struct.field("upper_bound", &self.upper_bound);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::experiment::result::Metric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Metric");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("count_type", &self.count_type);
        debug_struct.field("confidence_interval", &self.confidence_interval);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::experiment::result::VersionMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VersionMetrics");
        debug_struct.field("version", &self.version);
        debug_struct.field("metrics", &self.metrics);
        debug_struct.field("session_count", &self.session_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::VersionVariants {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VersionVariants");
        debug_struct.field("variants", &self.variants);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::version_variants::Variant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Variant");
        debug_struct.field("version", &self.version);
        debug_struct.field("traffic_allocation", &self.traffic_allocation);
        debug_struct.field("is_control_group", &self.is_control_group);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::VariantsHistory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VariantsHistory");
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("variants", &self.variants);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::RolloutConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RolloutConfig");
        debug_struct.field("rollout_steps", &self.rollout_steps);
        debug_struct.field("rollout_condition", &self.rollout_condition);
        debug_struct.field("failure_condition", &self.failure_condition);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::rollout_config::RolloutStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RolloutStep");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("traffic_percent", &self.traffic_percent);
        debug_struct.field("min_duration", &self.min_duration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::RolloutState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RolloutState");
        debug_struct.field("step", &self.step);
        debug_struct.field("step_index", &self.step_index);
        debug_struct.field("start_time", &self.start_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::ListExperimentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListExperimentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::ListExperimentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListExperimentsResponse");
        debug_struct.field("experiments", &self.experiments);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::GetExperimentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetExperimentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::CreateExperimentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateExperimentRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("experiment", &self.experiment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::UpdateExperimentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateExperimentRequest");
        debug_struct.field("experiment", &self.experiment);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::DeleteExperimentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteExperimentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::StartExperimentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StartExperimentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "experiments")]
impl std::fmt::Debug for super::StopExperimentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StopExperimentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "sessions",
    feature = "test-cases",
    feature = "versions",
))]
impl std::fmt::Debug for super::NluSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NluSettings");
        debug_struct.field("model_type", &self.model_type);
        debug_struct.field("classification_threshold", &self.classification_threshold);
        debug_struct.field("model_training_mode", &self.model_training_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "flows", feature = "sessions", feature = "test-cases",))]
impl std::fmt::Debug for super::Flow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Flow");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("transition_routes", &self.transition_routes);
        debug_struct.field("event_handlers", &self.event_handlers);
        debug_struct.field("transition_route_groups", &self.transition_route_groups);
        debug_struct.field("nlu_settings", &self.nlu_settings);
        debug_struct.field("advanced_settings", &self.advanced_settings);
        debug_struct.field(
            "knowledge_connector_settings",
            &self.knowledge_connector_settings,
        );
        debug_struct.field("multi_language_settings", &self.multi_language_settings);
        debug_struct.field("locked", &self.locked);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "flows", feature = "sessions", feature = "test-cases",))]
impl std::fmt::Debug for super::flow::MultiLanguageSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MultiLanguageSettings");
        debug_struct.field(
            "enable_multi_language_detection",
            &self.enable_multi_language_detection,
        );
        debug_struct.field(
            "supported_response_language_codes",
            &self.supported_response_language_codes,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "flows")]
impl std::fmt::Debug for super::CreateFlowRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateFlowRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("flow", &self.flow);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "flows")]
impl std::fmt::Debug for super::DeleteFlowRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteFlowRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "flows")]
impl std::fmt::Debug for super::ListFlowsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListFlowsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "flows")]
impl std::fmt::Debug for super::ListFlowsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListFlowsResponse");
        debug_struct.field("flows", &self.flows);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "flows")]
impl std::fmt::Debug for super::GetFlowRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetFlowRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "flows")]
impl std::fmt::Debug for super::UpdateFlowRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateFlowRequest");
        debug_struct.field("flow", &self.flow);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "flows")]
impl std::fmt::Debug for super::TrainFlowRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TrainFlowRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "flows")]
impl std::fmt::Debug for super::ValidateFlowRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValidateFlowRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "flows")]
impl std::fmt::Debug for super::GetFlowValidationResultRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetFlowValidationResultRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "agents", feature = "flows",))]
impl std::fmt::Debug for super::FlowValidationResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FlowValidationResult");
        debug_struct.field("name", &self.name);
        debug_struct.field("validation_messages", &self.validation_messages);
        debug_struct.field("update_time", &self.update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "flows")]
impl std::fmt::Debug for super::ImportFlowRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportFlowRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("import_option", &self.import_option);
        debug_struct.field("flow_import_strategy", &self.flow_import_strategy);
        debug_struct.field("flow", &self.flow);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "flows")]
impl std::fmt::Debug for super::FlowImportStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FlowImportStrategy");
        debug_struct.field("global_import_strategy", &self.global_import_strategy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "flows")]
impl std::fmt::Debug for super::ImportFlowResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportFlowResponse");
        debug_struct.field("flow", &self.flow);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "flows")]
impl std::fmt::Debug for super::ExportFlowRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportFlowRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("flow_uri", &self.flow_uri);
        debug_struct.field("include_referenced_flows", &self.include_referenced_flows);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "flows")]
impl std::fmt::Debug for super::ExportFlowResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportFlowResponse");
        debug_struct.field("flow", &self.flow);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::Fulfillment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Fulfillment");
        debug_struct.field("messages", &self.messages);
        debug_struct.field("webhook", &self.webhook);
        debug_struct.field("return_partial_responses", &self.return_partial_responses);
        debug_struct.field("tag", &self.tag);
        debug_struct.field("set_parameter_actions", &self.set_parameter_actions);
        debug_struct.field("conditional_cases", &self.conditional_cases);
        debug_struct.field("advanced_settings", &self.advanced_settings);
        debug_struct.field(
            "enable_generative_fallback",
            &self.enable_generative_fallback,
        );
        debug_struct.field("generators", &self.generators);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::fulfillment::SetParameterAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetParameterAction");
        debug_struct.field("parameter", &self.parameter);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::fulfillment::ConditionalCases {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConditionalCases");
        debug_struct.field("cases", &self.cases);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::fulfillment::conditional_cases::Case {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Case");
        debug_struct.field("condition", &self.condition);
        debug_struct.field("case_content", &self.case_content);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::fulfillment::conditional_cases::case::CaseContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CaseContent");
        debug_struct.field("cases_or_message", &self.cases_or_message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::fulfillment::GeneratorSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GeneratorSettings");
        debug_struct.field("generator", &self.generator);
        debug_struct.field("input_parameters", &self.input_parameters);
        debug_struct.field("output_parameter", &self.output_parameter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::GcsDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsDestination");
        debug_struct.field("uri", &self.uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::GenerativeSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerativeSettings");
        debug_struct.field("name", &self.name);
        debug_struct.field("fallback_settings", &self.fallback_settings);
        debug_struct.field(
            "generative_safety_settings",
            &self.generative_safety_settings,
        );
        debug_struct.field(
            "knowledge_connector_settings",
            &self.knowledge_connector_settings,
        );
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::generative_settings::FallbackSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FallbackSettings");
        debug_struct.field("selected_prompt", &self.selected_prompt);
        debug_struct.field("prompt_templates", &self.prompt_templates);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::generative_settings::fallback_settings::PromptTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PromptTemplate");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("prompt_text", &self.prompt_text);
        debug_struct.field("frozen", &self.frozen);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::generative_settings::KnowledgeConnectorSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("KnowledgeConnectorSettings");
        debug_struct.field("business", &self.business);
        debug_struct.field("agent", &self.agent);
        debug_struct.field("agent_identity", &self.agent_identity);
        debug_struct.field("business_description", &self.business_description);
        debug_struct.field("agent_scope", &self.agent_scope);
        debug_struct.field(
            "disable_data_store_fallback",
            &self.disable_data_store_fallback,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "generators")]
impl std::fmt::Debug for super::Generator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Generator");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("prompt_text", &self.prompt_text);
        debug_struct.field("placeholders", &self.placeholders);
        debug_struct.field("model_parameter", &self.model_parameter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "generators")]
impl std::fmt::Debug for super::generator::Placeholder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Placeholder");
        debug_struct.field("id", &self.id);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "generators")]
impl std::fmt::Debug for super::generator::ModelParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ModelParameter");
        debug_struct.field("temperature", &self.temperature);
        debug_struct.field("max_decode_steps", &self.max_decode_steps);
        debug_struct.field("top_p", &self.top_p);
        debug_struct.field("top_k", &self.top_k);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "generators")]
impl std::fmt::Debug for super::Phrase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Phrase");
        debug_struct.field("text", &self.text);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "generators")]
impl std::fmt::Debug for super::ListGeneratorsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListGeneratorsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "generators")]
impl std::fmt::Debug for super::ListGeneratorsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListGeneratorsResponse");
        debug_struct.field("generators", &self.generators);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "generators")]
impl std::fmt::Debug for super::GetGeneratorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetGeneratorRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "generators")]
impl std::fmt::Debug for super::CreateGeneratorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateGeneratorRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("generator", &self.generator);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "generators")]
impl std::fmt::Debug for super::UpdateGeneratorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateGeneratorRequest");
        debug_struct.field("generator", &self.generator);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "generators")]
impl std::fmt::Debug for super::DeleteGeneratorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteGeneratorRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "entity-types", feature = "intents",))]
impl std::fmt::Debug for super::InlineDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InlineDestination");
        debug_struct.field("content", &self.content);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "entity-types", feature = "intents",))]
impl std::fmt::Debug for super::InlineSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InlineSource");
        debug_struct.field("content", &self.content);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
impl std::fmt::Debug for super::Intent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Intent");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("training_phrases", &self.training_phrases);
        debug_struct.field("parameters", &self.parameters);
        debug_struct.field("priority", &self.priority);
        debug_struct.field("is_fallback", &self.is_fallback);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("description", &self.description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
impl std::fmt::Debug for super::intent::TrainingPhrase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TrainingPhrase");
        debug_struct.field("id", &self.id);
        debug_struct.field("parts", &self.parts);
        debug_struct.field("repeat_count", &self.repeat_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
impl std::fmt::Debug for super::intent::training_phrase::Part {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Part");
        debug_struct.field("text", &self.text);
        debug_struct.field("parameter_id", &self.parameter_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
impl std::fmt::Debug for super::intent::Parameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Parameter");
        debug_struct.field("id", &self.id);
        debug_struct.field("entity_type", &self.entity_type);
        debug_struct.field("is_list", &self.is_list);
        debug_struct.field("redact", &self.redact);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "intents")]
impl std::fmt::Debug for super::ListIntentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListIntentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("intent_view", &self.intent_view);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "intents")]
impl std::fmt::Debug for super::ListIntentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListIntentsResponse");
        debug_struct.field("intents", &self.intents);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "intents")]
impl std::fmt::Debug for super::GetIntentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetIntentRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "intents")]
impl std::fmt::Debug for super::CreateIntentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateIntentRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("intent", &self.intent);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "intents")]
impl std::fmt::Debug for super::UpdateIntentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateIntentRequest");
        debug_struct.field("intent", &self.intent);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "intents")]
impl std::fmt::Debug for super::DeleteIntentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteIntentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "intents")]
impl std::fmt::Debug for super::ImportIntentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportIntentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("merge_option", &self.merge_option);
        debug_struct.field("intents", &self.intents);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "intents")]
impl std::fmt::Debug for super::ImportIntentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportIntentsResponse");
        debug_struct.field("intents", &self.intents);
        debug_struct.field("conflicting_resources", &self.conflicting_resources);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "intents")]
impl std::fmt::Debug for super::import_intents_response::ConflictingResources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConflictingResources");
        debug_struct.field("intent_display_names", &self.intent_display_names);
        debug_struct.field("entity_display_names", &self.entity_display_names);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "intents")]
impl std::fmt::Debug for super::ImportIntentsMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportIntentsMetadata");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "intents")]
impl std::fmt::Debug for super::ExportIntentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportIntentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("intents", &self.intents);
        debug_struct.field("data_format", &self.data_format);
        debug_struct.field("destination", &self.destination);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "intents")]
impl std::fmt::Debug for super::ExportIntentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportIntentsResponse");
        debug_struct.field("intents", &self.intents);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "intents")]
impl std::fmt::Debug for super::ExportIntentsMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportIntentsMetadata");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
impl std::fmt::Debug for super::Page {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Page");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("entry_fulfillment", &self.entry_fulfillment);
        debug_struct.field("form", &self.form);
        debug_struct.field("transition_route_groups", &self.transition_route_groups);
        debug_struct.field("transition_routes", &self.transition_routes);
        debug_struct.field("event_handlers", &self.event_handlers);
        debug_struct.field("advanced_settings", &self.advanced_settings);
        debug_struct.field(
            "knowledge_connector_settings",
            &self.knowledge_connector_settings,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
impl std::fmt::Debug for super::Form {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Form");
        debug_struct.field("parameters", &self.parameters);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
impl std::fmt::Debug for super::form::Parameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Parameter");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("required", &self.required);
        debug_struct.field("entity_type", &self.entity_type);
        debug_struct.field("is_list", &self.is_list);
        debug_struct.field("fill_behavior", &self.fill_behavior);
        debug_struct.field("default_value", &self.default_value);
        debug_struct.field("redact", &self.redact);
        debug_struct.field("advanced_settings", &self.advanced_settings);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
impl std::fmt::Debug for super::form::parameter::FillBehavior {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FillBehavior");
        debug_struct.field(
            "initial_prompt_fulfillment",
            &self.initial_prompt_fulfillment,
        );
        debug_struct.field("reprompt_event_handlers", &self.reprompt_event_handlers);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl std::fmt::Debug for super::EventHandler {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EventHandler");
        debug_struct.field("name", &self.name);
        debug_struct.field("event", &self.event);
        debug_struct.field("trigger_fulfillment", &self.trigger_fulfillment);
        debug_struct.field("target", &self.target);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::TransitionRoute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransitionRoute");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("intent", &self.intent);
        debug_struct.field("condition", &self.condition);
        debug_struct.field("trigger_fulfillment", &self.trigger_fulfillment);
        debug_struct.field("target", &self.target);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "pages")]
impl std::fmt::Debug for super::ListPagesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPagesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "pages")]
impl std::fmt::Debug for super::ListPagesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPagesResponse");
        debug_struct.field("pages", &self.pages);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "pages")]
impl std::fmt::Debug for super::GetPageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetPageRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "pages")]
impl std::fmt::Debug for super::CreatePageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreatePageRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page", &self.page);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "pages")]
impl std::fmt::Debug for super::UpdatePageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdatePageRequest");
        debug_struct.field("page", &self.page);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "pages")]
impl std::fmt::Debug for super::DeletePageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeletePageRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl std::fmt::Debug for super::KnowledgeConnectorSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("KnowledgeConnectorSettings");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("trigger_fulfillment", &self.trigger_fulfillment);
        debug_struct.field("data_store_connections", &self.data_store_connections);
        debug_struct.field("target", &self.target);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::ResponseMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResponseMessage");
        debug_struct.field("response_type", &self.response_type);
        debug_struct.field("channel", &self.channel);
        debug_struct.field("message", &self.message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::response_message::Text {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Text");
        debug_struct.field("text", &self.text);
        debug_struct.field(
            "allow_playback_interruption",
            &self.allow_playback_interruption,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::response_message::LiveAgentHandoff {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LiveAgentHandoff");
        debug_struct.field("metadata", &self.metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::response_message::ConversationSuccess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConversationSuccess");
        debug_struct.field("metadata", &self.metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::response_message::OutputAudioText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OutputAudioText");
        debug_struct.field(
            "allow_playback_interruption",
            &self.allow_playback_interruption,
        );
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::response_message::EndInteraction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EndInteraction");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::response_message::PlayAudio {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PlayAudio");
        debug_struct.field("audio_uri", &self.audio_uri);
        debug_struct.field(
            "allow_playback_interruption",
            &self.allow_playback_interruption,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::response_message::MixedAudio {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MixedAudio");
        debug_struct.field("segments", &self.segments);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::response_message::mixed_audio::Segment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Segment");
        debug_struct.field(
            "allow_playback_interruption",
            &self.allow_playback_interruption,
        );
        debug_struct.field("content", &self.content);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::response_message::TelephonyTransferCall {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TelephonyTransferCall");
        debug_struct.field("endpoint", &self.endpoint);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl std::fmt::Debug for super::response_message::KnowledgeInfoCard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("KnowledgeInfoCard");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::SafetySettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SafetySettings");
        debug_struct.field("banned_phrases", &self.banned_phrases);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "agents")]
impl std::fmt::Debug for super::safety_settings::Phrase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Phrase");
        debug_struct.field("text", &self.text);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "security-settings-service")]
impl std::fmt::Debug for super::GetSecuritySettingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSecuritySettingsRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "security-settings-service")]
impl std::fmt::Debug for super::UpdateSecuritySettingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateSecuritySettingsRequest");
        debug_struct.field("security_settings", &self.security_settings);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "security-settings-service")]
impl std::fmt::Debug for super::ListSecuritySettingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSecuritySettingsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "security-settings-service")]
impl std::fmt::Debug for super::ListSecuritySettingsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSecuritySettingsResponse");
        debug_struct.field("security_settings", &self.security_settings);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "security-settings-service")]
impl std::fmt::Debug for super::CreateSecuritySettingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateSecuritySettingsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("security_settings", &self.security_settings);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "security-settings-service")]
impl std::fmt::Debug for super::DeleteSecuritySettingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSecuritySettingsRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "security-settings-service")]
impl std::fmt::Debug for super::SecuritySettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecuritySettings");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("redaction_strategy", &self.redaction_strategy);
        debug_struct.field("redaction_scope", &self.redaction_scope);
        debug_struct.field("inspect_template", &self.inspect_template);
        debug_struct.field("deidentify_template", &self.deidentify_template);
        debug_struct.field("purge_data_types", &self.purge_data_types);
        debug_struct.field("audio_export_settings", &self.audio_export_settings);
        debug_struct.field("insights_export_settings", &self.insights_export_settings);
        debug_struct.field("data_retention", &self.data_retention);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "security-settings-service")]
impl std::fmt::Debug for super::security_settings::AudioExportSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AudioExportSettings");
        debug_struct.field("gcs_bucket", &self.gcs_bucket);
        debug_struct.field("audio_export_pattern", &self.audio_export_pattern);
        debug_struct.field("enable_audio_redaction", &self.enable_audio_redaction);
        debug_struct.field("audio_format", &self.audio_format);
        debug_struct.field("store_tts_audio", &self.store_tts_audio);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "security-settings-service")]
impl std::fmt::Debug for super::security_settings::InsightsExportSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InsightsExportSettings");
        debug_struct.field("enable_insights_export", &self.enable_insights_export);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::AnswerFeedback {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnswerFeedback");
        debug_struct.field("rating", &self.rating);
        debug_struct.field("rating_reason", &self.rating_reason);
        debug_struct.field("custom_rating", &self.custom_rating);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::answer_feedback::RatingReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RatingReason");
        debug_struct.field("reason_labels", &self.reason_labels);
        debug_struct.field("feedback", &self.feedback);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::SubmitAnswerFeedbackRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SubmitAnswerFeedbackRequest");
        debug_struct.field("session", &self.session);
        debug_struct.field("response_id", &self.response_id);
        debug_struct.field("answer_feedback", &self.answer_feedback);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::DetectIntentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DetectIntentRequest");
        debug_struct.field("session", &self.session);
        debug_struct.field("query_params", &self.query_params);
        debug_struct.field("query_input", &self.query_input);
        debug_struct.field("output_audio_config", &self.output_audio_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::DetectIntentResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DetectIntentResponse");
        debug_struct.field("response_id", &self.response_id);
        debug_struct.field("query_result", &self.query_result);
        debug_struct.field("output_audio", &self.output_audio);
        debug_struct.field("output_audio_config", &self.output_audio_config);
        debug_struct.field("response_type", &self.response_type);
        debug_struct.field("allow_cancellation", &self.allow_cancellation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::StreamingDetectIntentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StreamingDetectIntentRequest");
        debug_struct.field("session", &self.session);
        debug_struct.field("query_params", &self.query_params);
        debug_struct.field("query_input", &self.query_input);
        debug_struct.field("output_audio_config", &self.output_audio_config);
        debug_struct.field("enable_partial_response", &self.enable_partial_response);
        debug_struct.field("enable_debugging_info", &self.enable_debugging_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::CloudConversationDebuggingInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudConversationDebuggingInfo");
        debug_struct.field("audio_data_chunks", &self.audio_data_chunks);
        debug_struct.field("result_end_time_offset", &self.result_end_time_offset);
        debug_struct.field("first_audio_duration", &self.first_audio_duration);
        debug_struct.field("single_utterance", &self.single_utterance);
        debug_struct.field(
            "speech_partial_results_end_times",
            &self.speech_partial_results_end_times,
        );
        debug_struct.field(
            "speech_final_results_end_times",
            &self.speech_final_results_end_times,
        );
        debug_struct.field("partial_responses", &self.partial_responses);
        debug_struct.field(
            "speaker_id_passive_latency_ms_offset",
            &self.speaker_id_passive_latency_ms_offset,
        );
        debug_struct.field("bargein_event_triggered", &self.bargein_event_triggered);
        debug_struct.field("speech_single_utterance", &self.speech_single_utterance);
        debug_struct.field(
            "dtmf_partial_results_times",
            &self.dtmf_partial_results_times,
        );
        debug_struct.field("dtmf_final_results_times", &self.dtmf_final_results_times);
        debug_struct.field(
            "single_utterance_end_time_offset",
            &self.single_utterance_end_time_offset,
        );
        debug_struct.field("no_speech_timeout", &self.no_speech_timeout);
        debug_struct.field("endpointing_timeout", &self.endpointing_timeout);
        debug_struct.field("is_input_text", &self.is_input_text);
        debug_struct.field(
            "client_half_close_time_offset",
            &self.client_half_close_time_offset,
        );
        debug_struct.field(
            "client_half_close_streaming_time_offset",
            &self.client_half_close_streaming_time_offset,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::StreamingDetectIntentResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StreamingDetectIntentResponse");
        debug_struct.field("debugging_info", &self.debugging_info);
        debug_struct.field("response", &self.response);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::StreamingRecognitionResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StreamingRecognitionResult");
        debug_struct.field("message_type", &self.message_type);
        debug_struct.field("transcript", &self.transcript);
        debug_struct.field("is_final", &self.is_final);
        debug_struct.field("confidence", &self.confidence);
        debug_struct.field("stability", &self.stability);
        debug_struct.field("speech_word_info", &self.speech_word_info);
        debug_struct.field("speech_end_offset", &self.speech_end_offset);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::QueryParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryParameters");
        debug_struct.field("time_zone", &self.time_zone);
        debug_struct.field("geo_location", &self.geo_location);
        debug_struct.field("session_entity_types", &self.session_entity_types);
        debug_struct.field("payload", &self.payload);
        debug_struct.field("parameters", &self.parameters);
        debug_struct.field("current_page", &self.current_page);
        debug_struct.field("disable_webhook", &self.disable_webhook);
        debug_struct.field(
            "analyze_query_text_sentiment",
            &self.analyze_query_text_sentiment,
        );
        debug_struct.field("webhook_headers", &self.webhook_headers);
        debug_struct.field("flow_versions", &self.flow_versions);
        debug_struct.field("channel", &self.channel);
        debug_struct.field("session_ttl", &self.session_ttl);
        debug_struct.field("end_user_metadata", &self.end_user_metadata);
        debug_struct.field("search_config", &self.search_config);
        debug_struct.field(
            "populate_data_store_connection_signals",
            &self.populate_data_store_connection_signals,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::SearchConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchConfig");
        debug_struct.field("boost_specs", &self.boost_specs);
        debug_struct.field("filter_specs", &self.filter_specs);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::BoostSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BoostSpec");
        debug_struct.field("condition_boost_specs", &self.condition_boost_specs);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::boost_spec::ConditionBoostSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConditionBoostSpec");
        debug_struct.field("condition", &self.condition);
        debug_struct.field("boost", &self.boost);
        debug_struct.field("boost_control_spec", &self.boost_control_spec);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::boost_spec::condition_boost_spec::BoostControlSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BoostControlSpec");
        debug_struct.field("field_name", &self.field_name);
        debug_struct.field("attribute_type", &self.attribute_type);
        debug_struct.field("interpolation_type", &self.interpolation_type);
        debug_struct.field("control_points", &self.control_points);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ControlPoint");
        debug_struct.field("attribute_value", &self.attribute_value);
        debug_struct.field("boost_amount", &self.boost_amount);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::BoostSpecs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BoostSpecs");
        debug_struct.field("data_stores", &self.data_stores);
        debug_struct.field("spec", &self.spec);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::FilterSpecs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FilterSpecs");
        debug_struct.field("data_stores", &self.data_stores);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl std::fmt::Debug for super::QueryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryInput");
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("input", &self.input);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::QueryResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryResult");
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("parameters", &self.parameters);
        debug_struct.field("response_messages", &self.response_messages);
        debug_struct.field("webhook_ids", &self.webhook_ids);
        debug_struct.field("webhook_display_names", &self.webhook_display_names);
        debug_struct.field("webhook_latencies", &self.webhook_latencies);
        debug_struct.field("webhook_tags", &self.webhook_tags);
        debug_struct.field("webhook_statuses", &self.webhook_statuses);
        debug_struct.field("webhook_payloads", &self.webhook_payloads);
        debug_struct.field("current_page", &self.current_page);
        debug_struct.field("current_flow", &self.current_flow);
        debug_struct.field("intent", &self.intent);
        debug_struct.field(
            "intent_detection_confidence",
            &self.intent_detection_confidence,
        );
        debug_struct.field("r#match", &self.r#match);
        debug_struct.field("diagnostic_info", &self.diagnostic_info);
        debug_struct.field("sentiment_analysis_result", &self.sentiment_analysis_result);
        debug_struct.field("advanced_settings", &self.advanced_settings);
        debug_struct.field("allow_answer_feedback", &self.allow_answer_feedback);
        debug_struct.field(
            "data_store_connection_signals",
            &self.data_store_connection_signals,
        );
        debug_struct.field("query", &self.query);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl std::fmt::Debug for super::TextInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TextInput");
        debug_struct.field("text", &self.text);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl std::fmt::Debug for super::IntentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IntentInput");
        debug_struct.field("intent", &self.intent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl std::fmt::Debug for super::AudioInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AudioInput");
        debug_struct.field("config", &self.config);
        debug_struct.field("audio", &self.audio);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl std::fmt::Debug for super::EventInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EventInput");
        debug_struct.field("event", &self.event);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl std::fmt::Debug for super::DtmfInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DtmfInput");
        debug_struct.field("digits", &self.digits);
        debug_struct.field("finish_digit", &self.finish_digit);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::Match {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Match");
        debug_struct.field("intent", &self.intent);
        debug_struct.field("event", &self.event);
        debug_struct.field("parameters", &self.parameters);
        debug_struct.field("resolved_input", &self.resolved_input);
        debug_struct.field("match_type", &self.match_type);
        debug_struct.field("confidence", &self.confidence);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::MatchIntentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MatchIntentRequest");
        debug_struct.field("session", &self.session);
        debug_struct.field("query_params", &self.query_params);
        debug_struct.field("query_input", &self.query_input);
        debug_struct.field("persist_parameter_changes", &self.persist_parameter_changes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::MatchIntentResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MatchIntentResponse");
        debug_struct.field("matches", &self.matches);
        debug_struct.field("current_page", &self.current_page);
        debug_struct.field("query", &self.query);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::FulfillIntentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FulfillIntentRequest");
        debug_struct.field("match_intent_request", &self.match_intent_request);
        debug_struct.field("r#match", &self.r#match);
        debug_struct.field("output_audio_config", &self.output_audio_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::FulfillIntentResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FulfillIntentResponse");
        debug_struct.field("response_id", &self.response_id);
        debug_struct.field("query_result", &self.query_result);
        debug_struct.field("output_audio", &self.output_audio);
        debug_struct.field("output_audio_config", &self.output_audio_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Debug for super::SentimentAnalysisResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SentimentAnalysisResult");
        debug_struct.field("score", &self.score);
        debug_struct.field("magnitude", &self.magnitude);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "session-entity-types", feature = "sessions",))]
impl std::fmt::Debug for super::SessionEntityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SessionEntityType");
        debug_struct.field("name", &self.name);
        debug_struct.field("entity_override_mode", &self.entity_override_mode);
        debug_struct.field("entities", &self.entities);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "session-entity-types")]
impl std::fmt::Debug for super::ListSessionEntityTypesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSessionEntityTypesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "session-entity-types")]
impl std::fmt::Debug for super::ListSessionEntityTypesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSessionEntityTypesResponse");
        debug_struct.field("session_entity_types", &self.session_entity_types);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "session-entity-types")]
impl std::fmt::Debug for super::GetSessionEntityTypeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSessionEntityTypeRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "session-entity-types")]
impl std::fmt::Debug for super::CreateSessionEntityTypeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateSessionEntityTypeRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("session_entity_type", &self.session_entity_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "session-entity-types")]
impl std::fmt::Debug for super::UpdateSessionEntityTypeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateSessionEntityTypeRequest");
        debug_struct.field("session_entity_type", &self.session_entity_type);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "session-entity-types")]
impl std::fmt::Debug for super::DeleteSessionEntityTypeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSessionEntityTypeRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::TestCase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TestCase");
        debug_struct.field("name", &self.name);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("notes", &self.notes);
        debug_struct.field("test_config", &self.test_config);
        debug_struct.field(
            "test_case_conversation_turns",
            &self.test_case_conversation_turns,
        );
        debug_struct.field("creation_time", &self.creation_time);
        debug_struct.field("last_test_result", &self.last_test_result);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::TestCaseResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TestCaseResult");
        debug_struct.field("name", &self.name);
        debug_struct.field("environment", &self.environment);
        debug_struct.field("conversation_turns", &self.conversation_turns);
        debug_struct.field("test_result", &self.test_result);
        debug_struct.field("test_time", &self.test_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::TestConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TestConfig");
        debug_struct.field("tracking_parameters", &self.tracking_parameters);
        debug_struct.field("flow", &self.flow);
        debug_struct.field("page", &self.page);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::ConversationTurn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConversationTurn");
        debug_struct.field("user_input", &self.user_input);
        debug_struct.field("virtual_agent_output", &self.virtual_agent_output);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::conversation_turn::UserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserInput");
        debug_struct.field("input", &self.input);
        debug_struct.field("injected_parameters", &self.injected_parameters);
        debug_struct.field("is_webhook_enabled", &self.is_webhook_enabled);
        debug_struct.field("enable_sentiment_analysis", &self.enable_sentiment_analysis);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::conversation_turn::VirtualAgentOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VirtualAgentOutput");
        debug_struct.field("session_parameters", &self.session_parameters);
        debug_struct.field("differences", &self.differences);
        debug_struct.field("diagnostic_info", &self.diagnostic_info);
        debug_struct.field("triggered_intent", &self.triggered_intent);
        debug_struct.field("current_page", &self.current_page);
        debug_struct.field("text_responses", &self.text_responses);
        debug_struct.field("status", &self.status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::TestRunDifference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TestRunDifference");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("description", &self.description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::TransitionCoverage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransitionCoverage");
        debug_struct.field("transitions", &self.transitions);
        debug_struct.field("coverage_score", &self.coverage_score);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::transition_coverage::TransitionNode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransitionNode");
        debug_struct.field("kind", &self.kind);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::transition_coverage::Transition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Transition");
        debug_struct.field("source", &self.source);
        debug_struct.field("index", &self.index);
        debug_struct.field("target", &self.target);
        debug_struct.field("covered", &self.covered);
        debug_struct.field("detail", &self.detail);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::TransitionRouteGroupCoverage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransitionRouteGroupCoverage");
        debug_struct.field("coverages", &self.coverages);
        debug_struct.field("coverage_score", &self.coverage_score);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::transition_route_group_coverage::Coverage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Coverage");
        debug_struct.field("route_group", &self.route_group);
        debug_struct.field("transitions", &self.transitions);
        debug_struct.field("coverage_score", &self.coverage_score);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::transition_route_group_coverage::coverage::Transition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Transition");
        debug_struct.field("transition_route", &self.transition_route);
        debug_struct.field("covered", &self.covered);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::IntentCoverage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IntentCoverage");
        debug_struct.field("intents", &self.intents);
        debug_struct.field("coverage_score", &self.coverage_score);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::intent_coverage::Intent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Intent");
        debug_struct.field("intent", &self.intent);
        debug_struct.field("covered", &self.covered);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::CalculateCoverageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CalculateCoverageRequest");
        debug_struct.field("agent", &self.agent);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::CalculateCoverageResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CalculateCoverageResponse");
        debug_struct.field("agent", &self.agent);
        debug_struct.field("coverage_type", &self.coverage_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::ListTestCasesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTestCasesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::ListTestCasesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTestCasesResponse");
        debug_struct.field("test_cases", &self.test_cases);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::BatchDeleteTestCasesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchDeleteTestCasesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("names", &self.names);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::CreateTestCaseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateTestCaseRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("test_case", &self.test_case);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::UpdateTestCaseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateTestCaseRequest");
        debug_struct.field("test_case", &self.test_case);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::GetTestCaseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetTestCaseRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::RunTestCaseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunTestCaseRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("environment", &self.environment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::RunTestCaseResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunTestCaseResponse");
        debug_struct.field("result", &self.result);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::RunTestCaseMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunTestCaseMetadata");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::BatchRunTestCasesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchRunTestCasesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("environment", &self.environment);
        debug_struct.field("test_cases", &self.test_cases);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::BatchRunTestCasesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchRunTestCasesResponse");
        debug_struct.field("results", &self.results);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::BatchRunTestCasesMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchRunTestCasesMetadata");
        debug_struct.field("errors", &self.errors);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "environments", feature = "test-cases",))]
impl std::fmt::Debug for super::TestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TestError");
        debug_struct.field("test_case", &self.test_case);
        debug_struct.field("status", &self.status);
        debug_struct.field("test_time", &self.test_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::ImportTestCasesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportTestCasesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::ImportTestCasesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportTestCasesResponse");
        debug_struct.field("names", &self.names);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::ImportTestCasesMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportTestCasesMetadata");
        debug_struct.field("errors", &self.errors);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::TestCaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TestCaseError");
        debug_struct.field("test_case", &self.test_case);
        debug_struct.field("status", &self.status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::ExportTestCasesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportTestCasesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("data_format", &self.data_format);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("destination", &self.destination);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::ExportTestCasesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportTestCasesResponse");
        debug_struct.field("destination", &self.destination);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::ExportTestCasesMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportTestCasesMetadata");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::ListTestCaseResultsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTestCaseResultsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::ListTestCaseResultsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTestCaseResultsResponse");
        debug_struct.field("test_case_results", &self.test_case_results);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Debug for super::GetTestCaseResultRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetTestCaseResultRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "test-cases", feature = "transition-route-groups",))]
impl std::fmt::Debug for super::TransitionRouteGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransitionRouteGroup");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("transition_routes", &self.transition_routes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "transition-route-groups")]
impl std::fmt::Debug for super::ListTransitionRouteGroupsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTransitionRouteGroupsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "transition-route-groups")]
impl std::fmt::Debug for super::ListTransitionRouteGroupsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTransitionRouteGroupsResponse");
        debug_struct.field("transition_route_groups", &self.transition_route_groups);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "transition-route-groups")]
impl std::fmt::Debug for super::GetTransitionRouteGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetTransitionRouteGroupRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "transition-route-groups")]
impl std::fmt::Debug for super::CreateTransitionRouteGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateTransitionRouteGroupRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("transition_route_group", &self.transition_route_group);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "transition-route-groups")]
impl std::fmt::Debug for super::UpdateTransitionRouteGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateTransitionRouteGroupRequest");
        debug_struct.field("transition_route_group", &self.transition_route_group);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "transition-route-groups")]
impl std::fmt::Debug for super::DeleteTransitionRouteGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteTransitionRouteGroupRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "agents", feature = "flows",))]
impl std::fmt::Debug for super::ValidationMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValidationMessage");
        debug_struct.field("resource_type", &self.resource_type);
        debug_struct.field("resources", &self.resources);
        debug_struct.field("resource_names", &self.resource_names);
        debug_struct.field("severity", &self.severity);
        debug_struct.field("detail", &self.detail);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "agents", feature = "flows",))]
impl std::fmt::Debug for super::ResourceName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourceName");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "versions")]
impl std::fmt::Debug for super::CreateVersionOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateVersionOperationMetadata");
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "versions")]
impl std::fmt::Debug for super::Version {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Version");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("nlu_settings", &self.nlu_settings);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("state", &self.state);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "versions")]
impl std::fmt::Debug for super::ListVersionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListVersionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "versions")]
impl std::fmt::Debug for super::ListVersionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListVersionsResponse");
        debug_struct.field("versions", &self.versions);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "versions")]
impl std::fmt::Debug for super::GetVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetVersionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "versions")]
impl std::fmt::Debug for super::CreateVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateVersionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "versions")]
impl std::fmt::Debug for super::UpdateVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateVersionRequest");
        debug_struct.field("version", &self.version);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "versions")]
impl std::fmt::Debug for super::DeleteVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteVersionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "versions")]
impl std::fmt::Debug for super::LoadVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoadVersionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field(
            "allow_override_agent_resources",
            &self.allow_override_agent_resources,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "versions")]
impl std::fmt::Debug for super::CompareVersionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CompareVersionsRequest");
        debug_struct.field("base_version", &self.base_version);
        debug_struct.field("target_version", &self.target_version);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "versions")]
impl std::fmt::Debug for super::CompareVersionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CompareVersionsResponse");
        debug_struct.field("base_version_content_json", &self.base_version_content_json);
        debug_struct.field(
            "target_version_content_json",
            &self.target_version_content_json,
        );
        debug_struct.field("compare_time", &self.compare_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "environments", feature = "webhooks",))]
impl std::fmt::Debug for super::Webhook {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Webhook");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("timeout", &self.timeout);
        debug_struct.field("disabled", &self.disabled);
        debug_struct.field("webhook", &self.webhook);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "environments", feature = "webhooks",))]
impl std::fmt::Debug for super::webhook::GenericWebService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenericWebService");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("request_headers", &self.request_headers);
        debug_struct.field("allowed_ca_certs", &self.allowed_ca_certs);
        debug_struct.field("oauth_config", &self.oauth_config);
        debug_struct.field("service_agent_auth", &self.service_agent_auth);
        debug_struct.field("webhook_type", &self.webhook_type);
        debug_struct.field("http_method", &self.http_method);
        debug_struct.field("request_body", &self.request_body);
        debug_struct.field("parameter_mapping", &self.parameter_mapping);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "environments", feature = "webhooks",))]
impl std::fmt::Debug for super::webhook::generic_web_service::OAuthConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OAuthConfig");
        debug_struct.field("client_id", &self.client_id);
        debug_struct.field("client_secret", &self.client_secret);
        debug_struct.field("token_endpoint", &self.token_endpoint);
        debug_struct.field("scopes", &self.scopes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(any(feature = "environments", feature = "webhooks",))]
impl std::fmt::Debug for super::webhook::ServiceDirectoryConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ServiceDirectoryConfig");
        debug_struct.field("service", &self.service);
        debug_struct.field("generic_web_service", &self.generic_web_service);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "webhooks")]
impl std::fmt::Debug for super::ListWebhooksRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListWebhooksRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "webhooks")]
impl std::fmt::Debug for super::ListWebhooksResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListWebhooksResponse");
        debug_struct.field("webhooks", &self.webhooks);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "webhooks")]
impl std::fmt::Debug for super::GetWebhookRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetWebhookRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "webhooks")]
impl std::fmt::Debug for super::CreateWebhookRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateWebhookRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("webhook", &self.webhook);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "webhooks")]
impl std::fmt::Debug for super::UpdateWebhookRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateWebhookRequest");
        debug_struct.field("webhook", &self.webhook);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(feature = "webhooks")]
impl std::fmt::Debug for super::DeleteWebhookRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteWebhookRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl std::fmt::Debug for super::WebhookRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WebhookRequest");
        debug_struct.field("detect_intent_response_id", &self.detect_intent_response_id);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("fulfillment_info", &self.fulfillment_info);
        debug_struct.field("intent_info", &self.intent_info);
        debug_struct.field("page_info", &self.page_info);
        debug_struct.field("session_info", &self.session_info);
        debug_struct.field("messages", &self.messages);
        debug_struct.field("payload", &self.payload);
        debug_struct.field("sentiment_analysis_result", &self.sentiment_analysis_result);
        debug_struct.field("language_info", &self.language_info);
        debug_struct.field("query", &self.query);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl std::fmt::Debug for super::webhook_request::FulfillmentInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FulfillmentInfo");
        debug_struct.field("tag", &self.tag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl std::fmt::Debug for super::webhook_request::IntentInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IntentInfo");
        debug_struct.field("last_matched_intent", &self.last_matched_intent);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("parameters", &self.parameters);
        debug_struct.field("confidence", &self.confidence);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl std::fmt::Debug for super::webhook_request::intent_info::IntentParameterValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IntentParameterValue");
        debug_struct.field("original_value", &self.original_value);
        debug_struct.field("resolved_value", &self.resolved_value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl std::fmt::Debug for super::webhook_request::SentimentAnalysisResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SentimentAnalysisResult");
        debug_struct.field("score", &self.score);
        debug_struct.field("magnitude", &self.magnitude);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl std::fmt::Debug for super::WebhookResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WebhookResponse");
        debug_struct.field("fulfillment_response", &self.fulfillment_response);
        debug_struct.field("page_info", &self.page_info);
        debug_struct.field("session_info", &self.session_info);
        debug_struct.field("payload", &self.payload);
        debug_struct.field("transition", &self.transition);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl std::fmt::Debug for super::webhook_response::FulfillmentResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FulfillmentResponse");
        debug_struct.field("messages", &self.messages);
        debug_struct.field("merge_behavior", &self.merge_behavior);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl std::fmt::Debug for super::PageInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PageInfo");
        debug_struct.field("current_page", &self.current_page);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("form_info", &self.form_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl std::fmt::Debug for super::page_info::FormInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FormInfo");
        debug_struct.field("parameter_info", &self.parameter_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl std::fmt::Debug for super::page_info::form_info::ParameterInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ParameterInfo");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("required", &self.required);
        debug_struct.field("state", &self.state);
        debug_struct.field("value", &self.value);
        debug_struct.field("just_collected", &self.just_collected);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl std::fmt::Debug for super::SessionInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SessionInfo");
        debug_struct.field("session", &self.session);
        debug_struct.field("parameters", &self.parameters);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl std::fmt::Debug for super::LanguageInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LanguageInfo");
        debug_struct.field("input_language_code", &self.input_language_code);
        debug_struct.field("resolved_language_code", &self.resolved_language_code);
        debug_struct.field("confidence_score", &self.confidence_score);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
