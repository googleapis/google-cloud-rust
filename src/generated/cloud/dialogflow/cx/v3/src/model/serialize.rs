// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AdvancedSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.audio_export_gcs_destination.is_some() {
            state.serialize_entry(
                "audioExportGcsDestination",
                &self.audio_export_gcs_destination,
            )?;
        }
        if self.speech_settings.is_some() {
            state.serialize_entry("speechSettings", &self.speech_settings)?;
        }
        if self.dtmf_settings.is_some() {
            state.serialize_entry("dtmfSettings", &self.dtmf_settings)?;
        }
        if self.logging_settings.is_some() {
            state.serialize_entry("loggingSettings", &self.logging_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::advanced_settings::SpeechSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.endpointer_sensitivity) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "endpointerSensitivity",
                &__With(&self.endpointer_sensitivity),
            )?;
        }
        if self.no_speech_timeout.is_some() {
            state.serialize_entry("noSpeechTimeout", &self.no_speech_timeout)?;
        }
        if !wkt::internal::is_default(&self.use_timeout_based_endpointing) {
            state.serialize_entry(
                "useTimeoutBasedEndpointing",
                &self.use_timeout_based_endpointing,
            )?;
        }
        if !self.models.is_empty() {
            state.serialize_entry("models", &self.models)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::advanced_settings::DtmfSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !wkt::internal::is_default(&self.max_digits) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxDigits", &__With(&self.max_digits))?;
        }
        if !self.finish_digit.is_empty() {
            state.serialize_entry("finishDigit", &self.finish_digit)?;
        }
        if self.interdigit_timeout_duration.is_some() {
            state.serialize_entry(
                "interdigitTimeoutDuration",
                &self.interdigit_timeout_duration,
            )?;
        }
        if self.endpointing_timeout_duration.is_some() {
            state.serialize_entry(
                "endpointingTimeoutDuration",
                &self.endpointing_timeout_duration,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::advanced_settings::LoggingSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_stackdriver_logging) {
            state.serialize_entry("enableStackdriverLogging", &self.enable_stackdriver_logging)?;
        }
        if !wkt::internal::is_default(&self.enable_interaction_logging) {
            state.serialize_entry("enableInteractionLogging", &self.enable_interaction_logging)?;
        }
        if !wkt::internal::is_default(&self.enable_consent_based_redaction) {
            state.serialize_entry(
                "enableConsentBasedRedaction",
                &self.enable_consent_based_redaction,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SpeechToTextSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_speech_adaptation) {
            state.serialize_entry("enableSpeechAdaptation", &self.enable_speech_adaptation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Agent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.default_language_code.is_empty() {
            state.serialize_entry("defaultLanguageCode", &self.default_language_code)?;
        }
        if !self.supported_language_codes.is_empty() {
            state.serialize_entry("supportedLanguageCodes", &self.supported_language_codes)?;
        }
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.avatar_uri.is_empty() {
            state.serialize_entry("avatarUri", &self.avatar_uri)?;
        }
        if self.speech_to_text_settings.is_some() {
            state.serialize_entry("speechToTextSettings", &self.speech_to_text_settings)?;
        }
        if let Some(value) = self.start_flow() {
            state.serialize_entry("startFlow", value)?;
        }
        if let Some(value) = self.start_playbook() {
            state.serialize_entry("startPlaybook", value)?;
        }
        if !self.security_settings.is_empty() {
            state.serialize_entry("securitySettings", &self.security_settings)?;
        }
        if !wkt::internal::is_default(&self.enable_stackdriver_logging) {
            state.serialize_entry("enableStackdriverLogging", &self.enable_stackdriver_logging)?;
        }
        if !wkt::internal::is_default(&self.enable_spell_correction) {
            state.serialize_entry("enableSpellCorrection", &self.enable_spell_correction)?;
        }
        if !wkt::internal::is_default(&self.enable_multi_language_training) {
            state.serialize_entry(
                "enableMultiLanguageTraining",
                &self.enable_multi_language_training,
            )?;
        }
        if !wkt::internal::is_default(&self.locked) {
            state.serialize_entry("locked", &self.locked)?;
        }
        if self.advanced_settings.is_some() {
            state.serialize_entry("advancedSettings", &self.advanced_settings)?;
        }
        if self.git_integration_settings.is_some() {
            state.serialize_entry("gitIntegrationSettings", &self.git_integration_settings)?;
        }
        if self.text_to_speech_settings.is_some() {
            state.serialize_entry("textToSpeechSettings", &self.text_to_speech_settings)?;
        }
        if self.gen_app_builder_settings.is_some() {
            state.serialize_entry("genAppBuilderSettings", &self.gen_app_builder_settings)?;
        }
        if self.answer_feedback_settings.is_some() {
            state.serialize_entry("answerFeedbackSettings", &self.answer_feedback_settings)?;
        }
        if self.personalization_settings.is_some() {
            state.serialize_entry("personalizationSettings", &self.personalization_settings)?;
        }
        if self.client_certificate_settings.is_some() {
            state.serialize_entry(
                "clientCertificateSettings",
                &self.client_certificate_settings,
            )?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::agent::GitIntegrationSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.github_settings() {
            state.serialize_entry("githubSettings", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::agent::git_integration_settings::GithubSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.repository_uri.is_empty() {
            state.serialize_entry("repositoryUri", &self.repository_uri)?;
        }
        if !self.tracking_branch.is_empty() {
            state.serialize_entry("trackingBranch", &self.tracking_branch)?;
        }
        if !self.access_token.is_empty() {
            state.serialize_entry("accessToken", &self.access_token)?;
        }
        if !self.branches.is_empty() {
            state.serialize_entry("branches", &self.branches)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::agent::GenAppBuilderSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.engine.is_empty() {
            state.serialize_entry("engine", &self.engine)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::agent::AnswerFeedbackSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_answer_feedback) {
            state.serialize_entry("enableAnswerFeedback", &self.enable_answer_feedback)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::agent::PersonalizationSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.default_end_user_metadata.is_some() {
            state.serialize_entry("defaultEndUserMetadata", &self.default_end_user_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::agent::ClientCertificateSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ssl_certificate.is_empty() {
            state.serialize_entry("sslCertificate", &self.ssl_certificate)?;
        }
        if !self.private_key.is_empty() {
            state.serialize_entry("privateKey", &self.private_key)?;
        }
        if !self.passphrase.is_empty() {
            state.serialize_entry("passphrase", &self.passphrase)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListAgentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListAgentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.agents.is_empty() {
            state.serialize_entry("agents", &self.agents)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.agent.is_some() {
            state.serialize_entry("agent", &self.agent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.agent.is_some() {
            state.serialize_entry("agent", &self.agent)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.agent_uri.is_empty() {
            state.serialize_entry("agentUri", &self.agent_uri)?;
        }
        if !wkt::internal::is_default(&self.data_format) {
            state.serialize_entry("dataFormat", &self.data_format)?;
        }
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if self.git_destination.is_some() {
            state.serialize_entry("gitDestination", &self.git_destination)?;
        }
        if !wkt::internal::is_default(&self.include_bigquery_export_settings) {
            state.serialize_entry(
                "includeBigqueryExportSettings",
                &self.include_bigquery_export_settings,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::export_agent_request::GitDestination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tracking_branch.is_empty() {
            state.serialize_entry("trackingBranch", &self.tracking_branch)?;
        }
        if !self.commit_message.is_empty() {
            state.serialize_entry("commitMessage", &self.commit_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportAgentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.agent_uri() {
            state.serialize_entry("agentUri", value)?;
        }
        if let Some(value) = self.agent_content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("agentContent", &__With(value))?;
        }
        if let Some(value) = self.commit_sha() {
            state.serialize_entry("commitSha", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RestoreAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.agent_uri() {
            state.serialize_entry("agentUri", value)?;
        }
        if let Some(value) = self.agent_content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("agentContent", &__With(value))?;
        }
        if let Some(value) = self.git_source() {
            state.serialize_entry("gitSource", value)?;
        }
        if !wkt::internal::is_default(&self.restore_option) {
            state.serialize_entry("restoreOption", &self.restore_option)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::restore_agent_request::GitSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tracking_branch.is_empty() {
            state.serialize_entry("trackingBranch", &self.tracking_branch)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ValidateAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetAgentValidationResultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AgentValidationResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.flow_validation_results.is_empty() {
            state.serialize_entry("flowValidationResults", &self.flow_validation_results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetGenerativeSettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateGenerativeSettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.generative_settings.is_some() {
            state.serialize_entry("generativeSettings", &self.generative_settings)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SpeechWordInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.word.is_empty() {
            state.serialize_entry("word", &self.word)?;
        }
        if self.start_offset.is_some() {
            state.serialize_entry("startOffset", &self.start_offset)?;
        }
        if self.end_offset.is_some() {
            state.serialize_entry("endOffset", &self.end_offset)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BargeInConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.no_barge_in_duration.is_some() {
            state.serialize_entry("noBargeInDuration", &self.no_barge_in_duration)?;
        }
        if self.total_duration.is_some() {
            state.serialize_entry("totalDuration", &self.total_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InputAudioConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.audio_encoding) {
            state.serialize_entry("audioEncoding", &self.audio_encoding)?;
        }
        if !wkt::internal::is_default(&self.sample_rate_hertz) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sampleRateHertz", &__With(&self.sample_rate_hertz))?;
        }
        if !wkt::internal::is_default(&self.enable_word_info) {
            state.serialize_entry("enableWordInfo", &self.enable_word_info)?;
        }
        if !self.phrase_hints.is_empty() {
            state.serialize_entry("phraseHints", &self.phrase_hints)?;
        }
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !wkt::internal::is_default(&self.model_variant) {
            state.serialize_entry("modelVariant", &self.model_variant)?;
        }
        if !wkt::internal::is_default(&self.single_utterance) {
            state.serialize_entry("singleUtterance", &self.single_utterance)?;
        }
        if self.barge_in_config.is_some() {
            state.serialize_entry("bargeInConfig", &self.barge_in_config)?;
        }
        if !wkt::internal::is_default(&self.opt_out_conformer_model_migration) {
            state.serialize_entry(
                "optOutConformerModelMigration",
                &self.opt_out_conformer_model_migration,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "agents", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::VoiceSelectionParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.ssml_gender) {
            state.serialize_entry("ssmlGender", &self.ssml_gender)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "agents", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SynthesizeSpeechConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.speaking_rate) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("speakingRate", &__With(&self.speaking_rate))?;
        }
        if !wkt::internal::is_default(&self.pitch) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pitch", &__With(&self.pitch))?;
        }
        if !wkt::internal::is_default(&self.volume_gain_db) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("volumeGainDb", &__With(&self.volume_gain_db))?;
        }
        if !self.effects_profile_id.is_empty() {
            state.serialize_entry("effectsProfileId", &self.effects_profile_id)?;
        }
        if self.voice.is_some() {
            state.serialize_entry("voice", &self.voice)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::OutputAudioConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.audio_encoding) {
            state.serialize_entry("audioEncoding", &self.audio_encoding)?;
        }
        if !wkt::internal::is_default(&self.sample_rate_hertz) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sampleRateHertz", &__With(&self.sample_rate_hertz))?;
        }
        if self.synthesize_speech_config.is_some() {
            state.serialize_entry("synthesizeSpeechConfig", &self.synthesize_speech_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TextToSpeechSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.synthesize_speech_configs.is_empty() {
            state.serialize_entry("synthesizeSpeechConfigs", &self.synthesize_speech_configs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "changelogs")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListChangelogsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "changelogs")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListChangelogsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.changelogs.is_empty() {
            state.serialize_entry("changelogs", &self.changelogs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "changelogs")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetChangelogRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "changelogs")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Changelog {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.user_email.is_empty() {
            state.serialize_entry("userEmail", &self.user_email)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.action.is_empty() {
            state.serialize_entry("action", &self.action)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CodeBlock {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.code.is_empty() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "tools",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DataStoreConnection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.data_store_type) {
            state.serialize_entry("dataStoreType", &self.data_store_type)?;
        }
        if !self.data_store.is_empty() {
            state.serialize_entry("dataStore", &self.data_store)?;
        }
        if !wkt::internal::is_default(&self.document_processing_mode) {
            state.serialize_entry("documentProcessingMode", &self.document_processing_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DataStoreConnectionSignals {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.rewriter_model_call_signals.is_some() {
            state.serialize_entry(
                "rewriterModelCallSignals",
                &self.rewriter_model_call_signals,
            )?;
        }
        if !self.rewritten_query.is_empty() {
            state.serialize_entry("rewrittenQuery", &self.rewritten_query)?;
        }
        if !self.search_snippets.is_empty() {
            state.serialize_entry("searchSnippets", &self.search_snippets)?;
        }
        if self.answer_generation_model_call_signals.is_some() {
            state.serialize_entry(
                "answerGenerationModelCallSignals",
                &self.answer_generation_model_call_signals,
            )?;
        }
        if !self.answer.is_empty() {
            state.serialize_entry("answer", &self.answer)?;
        }
        if !self.answer_parts.is_empty() {
            state.serialize_entry("answerParts", &self.answer_parts)?;
        }
        if !self.cited_snippets.is_empty() {
            state.serialize_entry("citedSnippets", &self.cited_snippets)?;
        }
        if self.grounding_signals.is_some() {
            state.serialize_entry("groundingSignals", &self.grounding_signals)?;
        }
        if self.safety_signals.is_some() {
            state.serialize_entry("safetySignals", &self.safety_signals)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::data_store_connection_signals::RewriterModelCallSignals {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rendered_prompt.is_empty() {
            state.serialize_entry("renderedPrompt", &self.rendered_prompt)?;
        }
        if !self.model_output.is_empty() {
            state.serialize_entry("modelOutput", &self.model_output)?;
        }
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::data_store_connection_signals::SearchSnippet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.document_title.is_empty() {
            state.serialize_entry("documentTitle", &self.document_title)?;
        }
        if !self.document_uri.is_empty() {
            state.serialize_entry("documentUri", &self.document_uri)?;
        }
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::data_store_connection_signals::AnswerGenerationModelCallSignals
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rendered_prompt.is_empty() {
            state.serialize_entry("renderedPrompt", &self.rendered_prompt)?;
        }
        if !self.model_output.is_empty() {
            state.serialize_entry("modelOutput", &self.model_output)?;
        }
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::data_store_connection_signals::AnswerPart {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.supporting_indices.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("supportingIndices", &__With(&self.supporting_indices))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::data_store_connection_signals::CitedSnippet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.search_snippet.is_some() {
            state.serialize_entry("searchSnippet", &self.search_snippet)?;
        }
        if !wkt::internal::is_default(&self.snippet_index) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("snippetIndex", &__With(&self.snippet_index))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::data_store_connection_signals::GroundingSignals {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.decision) {
            state.serialize_entry("decision", &self.decision)?;
        }
        if !wkt::internal::is_default(&self.score) {
            state.serialize_entry("score", &self.score)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::data_store_connection_signals::SafetySignals {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.decision) {
            state.serialize_entry("decision", &self.decision)?;
        }
        if !wkt::internal::is_default(&self.banned_phrase_match) {
            state.serialize_entry("bannedPhraseMatch", &self.banned_phrase_match)?;
        }
        if !self.matched_banned_phrase.is_empty() {
            state.serialize_entry("matchedBannedPhrase", &self.matched_banned_phrase)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "deployments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Deployment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.flow_version.is_empty() {
            state.serialize_entry("flowVersion", &self.flow_version)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.result.is_some() {
            state.serialize_entry("result", &self.result)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "deployments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::deployment::Result {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.deployment_test_results.is_empty() {
            state.serialize_entry("deploymentTestResults", &self.deployment_test_results)?;
        }
        if !self.experiment.is_empty() {
            state.serialize_entry("experiment", &self.experiment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "deployments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListDeploymentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "deployments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListDeploymentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.deployments.is_empty() {
            state.serialize_entry("deployments", &self.deployments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "deployments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetDeploymentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "entity-types",
    feature = "session-entity-types",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::EntityType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.kind) {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !wkt::internal::is_default(&self.auto_expansion_mode) {
            state.serialize_entry("autoExpansionMode", &self.auto_expansion_mode)?;
        }
        if !self.entities.is_empty() {
            state.serialize_entry("entities", &self.entities)?;
        }
        if !self.excluded_phrases.is_empty() {
            state.serialize_entry("excludedPhrases", &self.excluded_phrases)?;
        }
        if !wkt::internal::is_default(&self.enable_fuzzy_extraction) {
            state.serialize_entry("enableFuzzyExtraction", &self.enable_fuzzy_extraction)?;
        }
        if !wkt::internal::is_default(&self.redact) {
            state.serialize_entry("redact", &self.redact)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "entity-types",
    feature = "session-entity-types",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::entity_type::Entity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self.synonyms.is_empty() {
            state.serialize_entry("synonyms", &self.synonyms)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "entity-types",
    feature = "session-entity-types",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::entity_type::ExcludedPhrase {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportEntityTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.entity_types.is_empty() {
            state.serialize_entry("entityTypes", &self.entity_types)?;
        }
        if let Some(value) = self.entity_types_uri() {
            state.serialize_entry("entityTypesUri", value)?;
        }
        if let Some(value) = self.entity_types_content_inline() {
            state.serialize_entry("entityTypesContentInline", value)?;
        }
        if !wkt::internal::is_default(&self.data_format) {
            state.serialize_entry("dataFormat", &self.data_format)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportEntityTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.entity_types_uri() {
            state.serialize_entry("entityTypesUri", value)?;
        }
        if let Some(value) = self.entity_types_content() {
            state.serialize_entry("entityTypesContent", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportEntityTypesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportEntityTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.entity_types_uri() {
            state.serialize_entry("entityTypesUri", value)?;
        }
        if let Some(value) = self.entity_types_content() {
            state.serialize_entry("entityTypesContent", value)?;
        }
        if !wkt::internal::is_default(&self.merge_option) {
            state.serialize_entry("mergeOption", &self.merge_option)?;
        }
        if !self.target_entity_type.is_empty() {
            state.serialize_entry("targetEntityType", &self.target_entity_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportEntityTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entity_types.is_empty() {
            state.serialize_entry("entityTypes", &self.entity_types)?;
        }
        if self.conflicting_resources.is_some() {
            state.serialize_entry("conflictingResources", &self.conflicting_resources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::import_entity_types_response::ConflictingResources {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entity_type_display_names.is_empty() {
            state.serialize_entry("entityTypeDisplayNames", &self.entity_type_display_names)?;
        }
        if !self.entity_display_names.is_empty() {
            state.serialize_entry("entityDisplayNames", &self.entity_display_names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportEntityTypesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListEntityTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListEntityTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entity_types.is_empty() {
            state.serialize_entry("entityTypes", &self.entity_types)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.entity_type.is_some() {
            state.serialize_entry("entityType", &self.entity_type)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.entity_type.is_some() {
            state.serialize_entry("entityType", &self.entity_type)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Environment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.version_configs.is_empty() {
            state.serialize_entry("versionConfigs", &self.version_configs)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.test_cases_config.is_some() {
            state.serialize_entry("testCasesConfig", &self.test_cases_config)?;
        }
        if self.webhook_config.is_some() {
            state.serialize_entry("webhookConfig", &self.webhook_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::environment::VersionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::environment::TestCasesConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.test_cases.is_empty() {
            state.serialize_entry("testCases", &self.test_cases)?;
        }
        if !wkt::internal::is_default(&self.enable_continuous_run) {
            state.serialize_entry("enableContinuousRun", &self.enable_continuous_run)?;
        }
        if !wkt::internal::is_default(&self.enable_predeployment_run) {
            state.serialize_entry("enablePredeploymentRun", &self.enable_predeployment_run)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::environment::WebhookConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.webhook_overrides.is_empty() {
            state.serialize_entry("webhookOverrides", &self.webhook_overrides)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListEnvironmentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListEnvironmentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environments.is_empty() {
            state.serialize_entry("environments", &self.environments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.environment.is_some() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.environment.is_some() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::LookupEnvironmentHistoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::LookupEnvironmentHistoryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environments.is_empty() {
            state.serialize_entry("environments", &self.environments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ContinuousTestResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.result) {
            state.serialize_entry("result", &self.result)?;
        }
        if !self.test_case_results.is_empty() {
            state.serialize_entry("testCaseResults", &self.test_case_results)?;
        }
        if self.run_time.is_some() {
            state.serialize_entry("runTime", &self.run_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RunContinuousTestRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RunContinuousTestResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.continuous_test_result.is_some() {
            state.serialize_entry("continuousTestResult", &self.continuous_test_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RunContinuousTestMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListContinuousTestResultsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListContinuousTestResultsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.continuous_test_results.is_empty() {
            state.serialize_entry("continuousTestResults", &self.continuous_test_results)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeployFlowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self.flow_version.is_empty() {
            state.serialize_entry("flowVersion", &self.flow_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeployFlowResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.environment.is_some() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self.deployment.is_empty() {
            state.serialize_entry("deployment", &self.deployment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeployFlowMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.test_errors.is_empty() {
            state.serialize_entry("testErrors", &self.test_errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "examples")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateExampleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.example.is_some() {
            state.serialize_entry("example", &self.example)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "examples")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteExampleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "examples")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListExamplesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "examples")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListExamplesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.examples.is_empty() {
            state.serialize_entry("examples", &self.examples)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "examples")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetExampleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "examples")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateExampleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.example.is_some() {
            state.serialize_entry("example", &self.example)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "examples", feature = "playbooks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Example {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.playbook_input.is_some() {
            state.serialize_entry("playbookInput", &self.playbook_input)?;
        }
        if self.playbook_output.is_some() {
            state.serialize_entry("playbookOutput", &self.playbook_output)?;
        }
        if !self.actions.is_empty() {
            state.serialize_entry("actions", &self.actions)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.token_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("tokenCount", &__With(&self.token_count))?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.conversation_state) {
            state.serialize_entry("conversationState", &self.conversation_state)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Experiment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.definition.is_some() {
            state.serialize_entry("definition", &self.definition)?;
        }
        if self.rollout_config.is_some() {
            state.serialize_entry("rolloutConfig", &self.rollout_config)?;
        }
        if self.rollout_state.is_some() {
            state.serialize_entry("rolloutState", &self.rollout_state)?;
        }
        if !self.rollout_failure_reason.is_empty() {
            state.serialize_entry("rolloutFailureReason", &self.rollout_failure_reason)?;
        }
        if self.result.is_some() {
            state.serialize_entry("result", &self.result)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.last_update_time.is_some() {
            state.serialize_entry("lastUpdateTime", &self.last_update_time)?;
        }
        if self.experiment_length.is_some() {
            state.serialize_entry("experimentLength", &self.experiment_length)?;
        }
        if !self.variants_history.is_empty() {
            state.serialize_entry("variantsHistory", &self.variants_history)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::experiment::Definition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.condition.is_empty() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if let Some(value) = self.version_variants() {
            state.serialize_entry("versionVariants", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::experiment::Result {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version_metrics.is_empty() {
            state.serialize_entry("versionMetrics", &self.version_metrics)?;
        }
        if self.last_update_time.is_some() {
            state.serialize_entry("lastUpdateTime", &self.last_update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::experiment::result::ConfidenceInterval {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.confidence_level) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidenceLevel", &__With(&self.confidence_level))?;
        }
        if !wkt::internal::is_default(&self.ratio) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ratio", &__With(&self.ratio))?;
        }
        if !wkt::internal::is_default(&self.lower_bound) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("lowerBound", &__With(&self.lower_bound))?;
        }
        if !wkt::internal::is_default(&self.upper_bound) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("upperBound", &__With(&self.upper_bound))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::experiment::result::Metric {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.count_type) {
            state.serialize_entry("countType", &self.count_type)?;
        }
        if let Some(value) = self.ratio() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ratio", &__With(value))?;
        }
        if let Some(value) = self.count() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("count", &__With(value))?;
        }
        if self.confidence_interval.is_some() {
            state.serialize_entry("confidenceInterval", &self.confidence_interval)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::experiment::result::VersionMetrics {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.metrics.is_empty() {
            state.serialize_entry("metrics", &self.metrics)?;
        }
        if !wkt::internal::is_default(&self.session_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sessionCount", &__With(&self.session_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VersionVariants {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.variants.is_empty() {
            state.serialize_entry("variants", &self.variants)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::version_variants::Variant {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !wkt::internal::is_default(&self.traffic_allocation) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("trafficAllocation", &__With(&self.traffic_allocation))?;
        }
        if !wkt::internal::is_default(&self.is_control_group) {
            state.serialize_entry("isControlGroup", &self.is_control_group)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VariantsHistory {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.version_variants() {
            state.serialize_entry("versionVariants", value)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RolloutConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rollout_steps.is_empty() {
            state.serialize_entry("rolloutSteps", &self.rollout_steps)?;
        }
        if !self.rollout_condition.is_empty() {
            state.serialize_entry("rolloutCondition", &self.rollout_condition)?;
        }
        if !self.failure_condition.is_empty() {
            state.serialize_entry("failureCondition", &self.failure_condition)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::rollout_config::RolloutStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.traffic_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("trafficPercent", &__With(&self.traffic_percent))?;
        }
        if self.min_duration.is_some() {
            state.serialize_entry("minDuration", &self.min_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RolloutState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.step.is_empty() {
            state.serialize_entry("step", &self.step)?;
        }
        if !wkt::internal::is_default(&self.step_index) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("stepIndex", &__With(&self.step_index))?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListExperimentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListExperimentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.experiments.is_empty() {
            state.serialize_entry("experiments", &self.experiments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetExperimentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateExperimentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.experiment.is_some() {
            state.serialize_entry("experiment", &self.experiment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateExperimentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.experiment.is_some() {
            state.serialize_entry("experiment", &self.experiment)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteExperimentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StartExperimentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StopExperimentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "sessions",
    feature = "test-cases",
    feature = "versions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::NluSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.model_type) {
            state.serialize_entry("modelType", &self.model_type)?;
        }
        if !wkt::internal::is_default(&self.classification_threshold) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "classificationThreshold",
                &__With(&self.classification_threshold),
            )?;
        }
        if !wkt::internal::is_default(&self.model_training_mode) {
            state.serialize_entry("modelTrainingMode", &self.model_training_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "flows", feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Flow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.transition_routes.is_empty() {
            state.serialize_entry("transitionRoutes", &self.transition_routes)?;
        }
        if !self.event_handlers.is_empty() {
            state.serialize_entry("eventHandlers", &self.event_handlers)?;
        }
        if !self.transition_route_groups.is_empty() {
            state.serialize_entry("transitionRouteGroups", &self.transition_route_groups)?;
        }
        if self.nlu_settings.is_some() {
            state.serialize_entry("nluSettings", &self.nlu_settings)?;
        }
        if self.advanced_settings.is_some() {
            state.serialize_entry("advancedSettings", &self.advanced_settings)?;
        }
        if self.knowledge_connector_settings.is_some() {
            state.serialize_entry(
                "knowledgeConnectorSettings",
                &self.knowledge_connector_settings,
            )?;
        }
        if !self.input_parameter_definitions.is_empty() {
            state.serialize_entry(
                "inputParameterDefinitions",
                &self.input_parameter_definitions,
            )?;
        }
        if !self.output_parameter_definitions.is_empty() {
            state.serialize_entry(
                "outputParameterDefinitions",
                &self.output_parameter_definitions,
            )?;
        }
        if self.multi_language_settings.is_some() {
            state.serialize_entry("multiLanguageSettings", &self.multi_language_settings)?;
        }
        if !wkt::internal::is_default(&self.locked) {
            state.serialize_entry("locked", &self.locked)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "flows", feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::flow::MultiLanguageSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_multi_language_detection) {
            state.serialize_entry(
                "enableMultiLanguageDetection",
                &self.enable_multi_language_detection,
            )?;
        }
        if !self.supported_response_language_codes.is_empty() {
            state.serialize_entry(
                "supportedResponseLanguageCodes",
                &self.supported_response_language_codes,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateFlowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.flow.is_some() {
            state.serialize_entry("flow", &self.flow)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteFlowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListFlowsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListFlowsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.flows.is_empty() {
            state.serialize_entry("flows", &self.flows)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetFlowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateFlowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.flow.is_some() {
            state.serialize_entry("flow", &self.flow)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TrainFlowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ValidateFlowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetFlowValidationResultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "agents", feature = "flows",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::FlowValidationResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.validation_messages.is_empty() {
            state.serialize_entry("validationMessages", &self.validation_messages)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportFlowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.flow_uri() {
            state.serialize_entry("flowUri", value)?;
        }
        if let Some(value) = self.flow_content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("flowContent", &__With(value))?;
        }
        if !wkt::internal::is_default(&self.import_option) {
            state.serialize_entry("importOption", &self.import_option)?;
        }
        if self.flow_import_strategy.is_some() {
            state.serialize_entry("flowImportStrategy", &self.flow_import_strategy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FlowImportStrategy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.global_import_strategy) {
            state.serialize_entry("globalImportStrategy", &self.global_import_strategy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportFlowResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.flow.is_empty() {
            state.serialize_entry("flow", &self.flow)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportFlowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.flow_uri.is_empty() {
            state.serialize_entry("flowUri", &self.flow_uri)?;
        }
        if !wkt::internal::is_default(&self.include_referenced_flows) {
            state.serialize_entry("includeReferencedFlows", &self.include_referenced_flows)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportFlowResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.flow_uri() {
            state.serialize_entry("flowUri", value)?;
        }
        if let Some(value) = self.flow_content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("flowContent", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Fulfillment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.messages.is_empty() {
            state.serialize_entry("messages", &self.messages)?;
        }
        if !self.webhook.is_empty() {
            state.serialize_entry("webhook", &self.webhook)?;
        }
        if !wkt::internal::is_default(&self.return_partial_responses) {
            state.serialize_entry("returnPartialResponses", &self.return_partial_responses)?;
        }
        if !self.tag.is_empty() {
            state.serialize_entry("tag", &self.tag)?;
        }
        if !self.set_parameter_actions.is_empty() {
            state.serialize_entry("setParameterActions", &self.set_parameter_actions)?;
        }
        if !self.conditional_cases.is_empty() {
            state.serialize_entry("conditionalCases", &self.conditional_cases)?;
        }
        if self.advanced_settings.is_some() {
            state.serialize_entry("advancedSettings", &self.advanced_settings)?;
        }
        if !wkt::internal::is_default(&self.enable_generative_fallback) {
            state.serialize_entry("enableGenerativeFallback", &self.enable_generative_fallback)?;
        }
        if !self.generators.is_empty() {
            state.serialize_entry("generators", &self.generators)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::fulfillment::SetParameterAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parameter.is_empty() {
            state.serialize_entry("parameter", &self.parameter)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::fulfillment::ConditionalCases {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cases.is_empty() {
            state.serialize_entry("cases", &self.cases)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::fulfillment::conditional_cases::Case {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.condition.is_empty() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !self.case_content.is_empty() {
            state.serialize_entry("caseContent", &self.case_content)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::fulfillment::conditional_cases::case::CaseContent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.message() {
            state.serialize_entry("message", value)?;
        }
        if let Some(value) = self.additional_cases() {
            state.serialize_entry("additionalCases", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::fulfillment::GeneratorSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.generator.is_empty() {
            state.serialize_entry("generator", &self.generator)?;
        }
        if !self.input_parameters.is_empty() {
            state.serialize_entry("inputParameters", &self.input_parameters)?;
        }
        if !self.output_parameter.is_empty() {
            state.serialize_entry("outputParameter", &self.output_parameter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::GcsDestination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GenerativeSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.fallback_settings.is_some() {
            state.serialize_entry("fallbackSettings", &self.fallback_settings)?;
        }
        if self.generative_safety_settings.is_some() {
            state.serialize_entry("generativeSafetySettings", &self.generative_safety_settings)?;
        }
        if self.knowledge_connector_settings.is_some() {
            state.serialize_entry(
                "knowledgeConnectorSettings",
                &self.knowledge_connector_settings,
            )?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.llm_model_settings.is_some() {
            state.serialize_entry("llmModelSettings", &self.llm_model_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::generative_settings::FallbackSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.selected_prompt.is_empty() {
            state.serialize_entry("selectedPrompt", &self.selected_prompt)?;
        }
        if !self.prompt_templates.is_empty() {
            state.serialize_entry("promptTemplates", &self.prompt_templates)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::generative_settings::fallback_settings::PromptTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.prompt_text.is_empty() {
            state.serialize_entry("promptText", &self.prompt_text)?;
        }
        if !wkt::internal::is_default(&self.frozen) {
            state.serialize_entry("frozen", &self.frozen)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::generative_settings::KnowledgeConnectorSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.business.is_empty() {
            state.serialize_entry("business", &self.business)?;
        }
        if !self.agent.is_empty() {
            state.serialize_entry("agent", &self.agent)?;
        }
        if !self.agent_identity.is_empty() {
            state.serialize_entry("agentIdentity", &self.agent_identity)?;
        }
        if !self.business_description.is_empty() {
            state.serialize_entry("businessDescription", &self.business_description)?;
        }
        if !self.agent_scope.is_empty() {
            state.serialize_entry("agentScope", &self.agent_scope)?;
        }
        if !wkt::internal::is_default(&self.disable_data_store_fallback) {
            state.serialize_entry(
                "disableDataStoreFallback",
                &self.disable_data_store_fallback,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "agents",
    feature = "generators",
    feature = "playbooks",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::LlmModelSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !self.prompt_text.is_empty() {
            state.serialize_entry("promptText", &self.prompt_text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Generator {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.prompt_text.is_some() {
            state.serialize_entry("promptText", &self.prompt_text)?;
        }
        if !self.placeholders.is_empty() {
            state.serialize_entry("placeholders", &self.placeholders)?;
        }
        if self.llm_model_settings.is_some() {
            state.serialize_entry("llmModelSettings", &self.llm_model_settings)?;
        }
        if self.model_parameter.is_some() {
            state.serialize_entry("modelParameter", &self.model_parameter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for super::generator::Placeholder {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for super::generator::ModelParameter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.temperature.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("temperature", &__With(&self.temperature))?;
        }
        if self.max_decode_steps.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxDecodeSteps", &__With(&self.max_decode_steps))?;
        }
        if self.top_p.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("topP", &__With(&self.top_p))?;
        }
        if self.top_k.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("topK", &__With(&self.top_k))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Phrase {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListGeneratorsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListGeneratorsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.generators.is_empty() {
            state.serialize_entry("generators", &self.generators)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetGeneratorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateGeneratorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.generator.is_some() {
            state.serialize_entry("generator", &self.generator)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateGeneratorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.generator.is_some() {
            state.serialize_entry("generator", &self.generator)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteGeneratorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "entity-types", feature = "intents",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InlineDestination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(&self.content))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "entity-types", feature = "intents",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InlineSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(&self.content))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Intent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.training_phrases.is_empty() {
            state.serialize_entry("trainingPhrases", &self.training_phrases)?;
        }
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !wkt::internal::is_default(&self.priority) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if !wkt::internal::is_default(&self.is_fallback) {
            state.serialize_entry("isFallback", &self.is_fallback)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::TrainingPhrase {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.parts.is_empty() {
            state.serialize_entry("parts", &self.parts)?;
        }
        if !wkt::internal::is_default(&self.repeat_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("repeatCount", &__With(&self.repeat_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::training_phrase::Part {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.parameter_id.is_empty() {
            state.serialize_entry("parameterId", &self.parameter_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::Parameter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.entity_type.is_empty() {
            state.serialize_entry("entityType", &self.entity_type)?;
        }
        if !wkt::internal::is_default(&self.is_list) {
            state.serialize_entry("isList", &self.is_list)?;
        }
        if !wkt::internal::is_default(&self.redact) {
            state.serialize_entry("redact", &self.redact)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListIntentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.intent_view) {
            state.serialize_entry("intentView", &self.intent_view)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListIntentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.intents.is_empty() {
            state.serialize_entry("intents", &self.intents)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.intent.is_some() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.intent.is_some() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportIntentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.intents_uri() {
            state.serialize_entry("intentsUri", value)?;
        }
        if let Some(value) = self.intents_content() {
            state.serialize_entry("intentsContent", value)?;
        }
        if !wkt::internal::is_default(&self.merge_option) {
            state.serialize_entry("mergeOption", &self.merge_option)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportIntentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.intents.is_empty() {
            state.serialize_entry("intents", &self.intents)?;
        }
        if self.conflicting_resources.is_some() {
            state.serialize_entry("conflictingResources", &self.conflicting_resources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::import_intents_response::ConflictingResources {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.intent_display_names.is_empty() {
            state.serialize_entry("intentDisplayNames", &self.intent_display_names)?;
        }
        if !self.entity_display_names.is_empty() {
            state.serialize_entry("entityDisplayNames", &self.entity_display_names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportIntentsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportIntentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.intents.is_empty() {
            state.serialize_entry("intents", &self.intents)?;
        }
        if let Some(value) = self.intents_uri() {
            state.serialize_entry("intentsUri", value)?;
        }
        if let Some(value) = self.intents_content_inline() {
            state.serialize_entry("intentsContentInline", value)?;
        }
        if !wkt::internal::is_default(&self.data_format) {
            state.serialize_entry("dataFormat", &self.data_format)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportIntentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.intents_uri() {
            state.serialize_entry("intentsUri", value)?;
        }
        if let Some(value) = self.intents_content() {
            state.serialize_entry("intentsContent", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportIntentsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Page {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.entry_fulfillment.is_some() {
            state.serialize_entry("entryFulfillment", &self.entry_fulfillment)?;
        }
        if self.form.is_some() {
            state.serialize_entry("form", &self.form)?;
        }
        if !self.transition_route_groups.is_empty() {
            state.serialize_entry("transitionRouteGroups", &self.transition_route_groups)?;
        }
        if !self.transition_routes.is_empty() {
            state.serialize_entry("transitionRoutes", &self.transition_routes)?;
        }
        if !self.event_handlers.is_empty() {
            state.serialize_entry("eventHandlers", &self.event_handlers)?;
        }
        if self.advanced_settings.is_some() {
            state.serialize_entry("advancedSettings", &self.advanced_settings)?;
        }
        if self.knowledge_connector_settings.is_some() {
            state.serialize_entry(
                "knowledgeConnectorSettings",
                &self.knowledge_connector_settings,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Form {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::form::Parameter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.required) {
            state.serialize_entry("required", &self.required)?;
        }
        if !self.entity_type.is_empty() {
            state.serialize_entry("entityType", &self.entity_type)?;
        }
        if !wkt::internal::is_default(&self.is_list) {
            state.serialize_entry("isList", &self.is_list)?;
        }
        if self.fill_behavior.is_some() {
            state.serialize_entry("fillBehavior", &self.fill_behavior)?;
        }
        if self.default_value.is_some() {
            state.serialize_entry("defaultValue", &self.default_value)?;
        }
        if !wkt::internal::is_default(&self.redact) {
            state.serialize_entry("redact", &self.redact)?;
        }
        if self.advanced_settings.is_some() {
            state.serialize_entry("advancedSettings", &self.advanced_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::form::parameter::FillBehavior {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.initial_prompt_fulfillment.is_some() {
            state.serialize_entry("initialPromptFulfillment", &self.initial_prompt_fulfillment)?;
        }
        if !self.reprompt_event_handlers.is_empty() {
            state.serialize_entry("repromptEventHandlers", &self.reprompt_event_handlers)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::EventHandler {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.event.is_empty() {
            state.serialize_entry("event", &self.event)?;
        }
        if self.trigger_fulfillment.is_some() {
            state.serialize_entry("triggerFulfillment", &self.trigger_fulfillment)?;
        }
        if let Some(value) = self.target_page() {
            state.serialize_entry("targetPage", value)?;
        }
        if let Some(value) = self.target_flow() {
            state.serialize_entry("targetFlow", value)?;
        }
        if let Some(value) = self.target_playbook() {
            state.serialize_entry("targetPlaybook", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::TransitionRoute {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.intent.is_empty() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !self.condition.is_empty() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if self.trigger_fulfillment.is_some() {
            state.serialize_entry("triggerFulfillment", &self.trigger_fulfillment)?;
        }
        if let Some(value) = self.target_page() {
            state.serialize_entry("targetPage", value)?;
        }
        if let Some(value) = self.target_flow() {
            state.serialize_entry("targetFlow", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListPagesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListPagesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.pages.is_empty() {
            state.serialize_entry("pages", &self.pages)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetPageRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreatePageRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.page.is_some() {
            state.serialize_entry("page", &self.page)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdatePageRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.page.is_some() {
            state.serialize_entry("page", &self.page)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeletePageRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::KnowledgeConnectorSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.trigger_fulfillment.is_some() {
            state.serialize_entry("triggerFulfillment", &self.trigger_fulfillment)?;
        }
        if let Some(value) = self.target_page() {
            state.serialize_entry("targetPage", value)?;
        }
        if let Some(value) = self.target_flow() {
            state.serialize_entry("targetFlow", value)?;
        }
        if !self.data_store_connections.is_empty() {
            state.serialize_entry("dataStoreConnections", &self.data_store_connections)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ParameterDefinition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.type_schema.is_some() {
            state.serialize_entry("typeSchema", &self.type_schema)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::TypeSchema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.inline_schema() {
            state.serialize_entry("inlineSchema", value)?;
        }
        if let Some(value) = self.schema_reference() {
            state.serialize_entry("schemaReference", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::type_schema::SchemaReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tool.is_empty() {
            state.serialize_entry("tool", &self.tool)?;
        }
        if !self.schema.is_empty() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InlineSchema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.items.is_some() {
            state.serialize_entry("items", &self.items)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreatePlaybookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.playbook.is_some() {
            state.serialize_entry("playbook", &self.playbook)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeletePlaybookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListPlaybooksRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListPlaybooksResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.playbooks.is_empty() {
            state.serialize_entry("playbooks", &self.playbooks)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetPlaybookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdatePlaybookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.playbook.is_some() {
            state.serialize_entry("playbook", &self.playbook)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Playbook {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.goal.is_empty() {
            state.serialize_entry("goal", &self.goal)?;
        }
        if !self.input_parameter_definitions.is_empty() {
            state.serialize_entry(
                "inputParameterDefinitions",
                &self.input_parameter_definitions,
            )?;
        }
        if !self.output_parameter_definitions.is_empty() {
            state.serialize_entry(
                "outputParameterDefinitions",
                &self.output_parameter_definitions,
            )?;
        }
        if self.instruction.is_some() {
            state.serialize_entry("instruction", &self.instruction)?;
        }
        if !wkt::internal::is_default(&self.token_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("tokenCount", &__With(&self.token_count))?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.referenced_playbooks.is_empty() {
            state.serialize_entry("referencedPlaybooks", &self.referenced_playbooks)?;
        }
        if !self.referenced_flows.is_empty() {
            state.serialize_entry("referencedFlows", &self.referenced_flows)?;
        }
        if !self.referenced_tools.is_empty() {
            state.serialize_entry("referencedTools", &self.referenced_tools)?;
        }
        if !self.inline_actions.is_empty() {
            state.serialize_entry("inlineActions", &self.inline_actions)?;
        }
        if self.code_block.is_some() {
            state.serialize_entry("codeBlock", &self.code_block)?;
        }
        if self.llm_model_settings.is_some() {
            state.serialize_entry("llmModelSettings", &self.llm_model_settings)?;
        }
        if !self.handlers.is_empty() {
            state.serialize_entry("handlers", &self.handlers)?;
        }
        if !wkt::internal::is_default(&self.playbook_type) {
            state.serialize_entry("playbookType", &self.playbook_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::playbook::Step {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if !self.steps.is_empty() {
            state.serialize_entry("steps", &self.steps)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::playbook::Instruction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.guidelines.is_empty() {
            state.serialize_entry("guidelines", &self.guidelines)?;
        }
        if !self.steps.is_empty() {
            state.serialize_entry("steps", &self.steps)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreatePlaybookVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.playbook_version.is_some() {
            state.serialize_entry("playbookVersion", &self.playbook_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PlaybookVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.playbook.is_some() {
            state.serialize_entry("playbook", &self.playbook)?;
        }
        if !self.examples.is_empty() {
            state.serialize_entry("examples", &self.examples)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetPlaybookVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RestorePlaybookVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RestorePlaybookVersionResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.playbook.is_some() {
            state.serialize_entry("playbook", &self.playbook)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListPlaybookVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListPlaybookVersionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.playbook_versions.is_empty() {
            state.serialize_entry("playbookVersions", &self.playbook_versions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeletePlaybookVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportPlaybookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.playbook_uri.is_empty() {
            state.serialize_entry("playbookUri", &self.playbook_uri)?;
        }
        if !wkt::internal::is_default(&self.data_format) {
            state.serialize_entry("dataFormat", &self.data_format)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportPlaybookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.playbook_uri() {
            state.serialize_entry("playbookUri", value)?;
        }
        if let Some(value) = self.playbook_content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("playbookContent", &__With(value))?;
        }
        if self.import_strategy.is_some() {
            state.serialize_entry("importStrategy", &self.import_strategy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PlaybookImportStrategy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.main_playbook_import_strategy) {
            state.serialize_entry(
                "mainPlaybookImportStrategy",
                &self.main_playbook_import_strategy,
            )?;
        }
        if !wkt::internal::is_default(&self.nested_resource_import_strategy) {
            state.serialize_entry(
                "nestedResourceImportStrategy",
                &self.nested_resource_import_strategy,
            )?;
        }
        if !wkt::internal::is_default(&self.tool_import_strategy) {
            state.serialize_entry("toolImportStrategy", &self.tool_import_strategy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportPlaybookResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.playbook.is_empty() {
            state.serialize_entry("playbook", &self.playbook)?;
        }
        if self.conflicting_resources.is_some() {
            state.serialize_entry("conflictingResources", &self.conflicting_resources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::import_playbook_response::ConflictingResources {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.main_playbook_display_name.is_empty() {
            state.serialize_entry("mainPlaybookDisplayName", &self.main_playbook_display_name)?;
        }
        if !self.nested_playbook_display_names.is_empty() {
            state.serialize_entry(
                "nestedPlaybookDisplayNames",
                &self.nested_playbook_display_names,
            )?;
        }
        if !self.tool_display_names.is_empty() {
            state.serialize_entry("toolDisplayNames", &self.tool_display_names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportPlaybookResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.playbook_uri() {
            state.serialize_entry("playbookUri", value)?;
        }
        if let Some(value) = self.playbook_content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("playbookContent", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Handler {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.event_handler() {
            state.serialize_entry("eventHandler", value)?;
        }
        if let Some(value) = self.lifecycle_handler() {
            state.serialize_entry("lifecycleHandler", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::handler::EventHandler {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.event.is_empty() {
            state.serialize_entry("event", &self.event)?;
        }
        if !self.condition.is_empty() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if self.fulfillment.is_some() {
            state.serialize_entry("fulfillment", &self.fulfillment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "playbooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::handler::LifecycleHandler {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.lifecycle_stage.is_empty() {
            state.serialize_entry("lifecycleStage", &self.lifecycle_stage)?;
        }
        if !self.condition.is_empty() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if self.fulfillment.is_some() {
            state.serialize_entry("fulfillment", &self.fulfillment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResponseMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.payload() {
            state.serialize_entry("payload", value)?;
        }
        if let Some(value) = self.conversation_success() {
            state.serialize_entry("conversationSuccess", value)?;
        }
        if let Some(value) = self.output_audio_text() {
            state.serialize_entry("outputAudioText", value)?;
        }
        if let Some(value) = self.live_agent_handoff() {
            state.serialize_entry("liveAgentHandoff", value)?;
        }
        if let Some(value) = self.end_interaction() {
            state.serialize_entry("endInteraction", value)?;
        }
        if let Some(value) = self.play_audio() {
            state.serialize_entry("playAudio", value)?;
        }
        if let Some(value) = self.mixed_audio() {
            state.serialize_entry("mixedAudio", value)?;
        }
        if let Some(value) = self.telephony_transfer_call() {
            state.serialize_entry("telephonyTransferCall", value)?;
        }
        if let Some(value) = self.knowledge_info_card() {
            state.serialize_entry("knowledgeInfoCard", value)?;
        }
        if let Some(value) = self.tool_call() {
            state.serialize_entry("toolCall", value)?;
        }
        if !wkt::internal::is_default(&self.response_type) {
            state.serialize_entry("responseType", &self.response_type)?;
        }
        if !self.channel.is_empty() {
            state.serialize_entry("channel", &self.channel)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::response_message::Text {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !wkt::internal::is_default(&self.allow_playback_interruption) {
            state.serialize_entry(
                "allowPlaybackInterruption",
                &self.allow_playback_interruption,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::response_message::LiveAgentHandoff {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::response_message::ConversationSuccess {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::response_message::OutputAudioText {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.ssml() {
            state.serialize_entry("ssml", value)?;
        }
        if !wkt::internal::is_default(&self.allow_playback_interruption) {
            state.serialize_entry(
                "allowPlaybackInterruption",
                &self.allow_playback_interruption,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::response_message::EndInteraction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::response_message::PlayAudio {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.audio_uri.is_empty() {
            state.serialize_entry("audioUri", &self.audio_uri)?;
        }
        if !wkt::internal::is_default(&self.allow_playback_interruption) {
            state.serialize_entry(
                "allowPlaybackInterruption",
                &self.allow_playback_interruption,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::response_message::MixedAudio {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.segments.is_empty() {
            state.serialize_entry("segments", &self.segments)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::response_message::mixed_audio::Segment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.audio() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("audio", &__With(value))?;
        }
        if let Some(value) = self.uri() {
            state.serialize_entry("uri", value)?;
        }
        if !wkt::internal::is_default(&self.allow_playback_interruption) {
            state.serialize_entry(
                "allowPlaybackInterruption",
                &self.allow_playback_interruption,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::response_message::TelephonyTransferCall {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.phone_number() {
            state.serialize_entry("phoneNumber", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::response_message::KnowledgeInfoCard {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SafetySettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.default_banned_phrase_match_strategy) {
            state.serialize_entry(
                "defaultBannedPhraseMatchStrategy",
                &self.default_banned_phrase_match_strategy,
            )?;
        }
        if !self.banned_phrases.is_empty() {
            state.serialize_entry("bannedPhrases", &self.banned_phrases)?;
        }
        if self.rai_settings.is_some() {
            state.serialize_entry("raiSettings", &self.rai_settings)?;
        }
        if self.default_rai_settings.is_some() {
            state.serialize_entry("defaultRaiSettings", &self.default_rai_settings)?;
        }
        if self.prompt_security_settings.is_some() {
            state.serialize_entry("promptSecuritySettings", &self.prompt_security_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::safety_settings::Phrase {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::safety_settings::RaiSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.category_filters.is_empty() {
            state.serialize_entry("categoryFilters", &self.category_filters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::safety_settings::rai_settings::CategoryFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.category) {
            state.serialize_entry("category", &self.category)?;
        }
        if !wkt::internal::is_default(&self.filter_level) {
            state.serialize_entry("filterLevel", &self.filter_level)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::safety_settings::PromptSecuritySettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_prompt_security) {
            state.serialize_entry("enablePromptSecurity", &self.enable_prompt_security)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetSecuritySettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateSecuritySettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.security_settings.is_some() {
            state.serialize_entry("securitySettings", &self.security_settings)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListSecuritySettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListSecuritySettingsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.security_settings.is_empty() {
            state.serialize_entry("securitySettings", &self.security_settings)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateSecuritySettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.security_settings.is_some() {
            state.serialize_entry("securitySettings", &self.security_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteSecuritySettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecuritySettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.redaction_strategy) {
            state.serialize_entry("redactionStrategy", &self.redaction_strategy)?;
        }
        if !wkt::internal::is_default(&self.redaction_scope) {
            state.serialize_entry("redactionScope", &self.redaction_scope)?;
        }
        if !self.inspect_template.is_empty() {
            state.serialize_entry("inspectTemplate", &self.inspect_template)?;
        }
        if !self.deidentify_template.is_empty() {
            state.serialize_entry("deidentifyTemplate", &self.deidentify_template)?;
        }
        if let Some(value) = self.retention_window_days() {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("retentionWindowDays", &__With(value))?;
        }
        if let Some(value) = self.retention_strategy() {
            state.serialize_entry("retentionStrategy", value)?;
        }
        if !self.purge_data_types.is_empty() {
            state.serialize_entry("purgeDataTypes", &self.purge_data_types)?;
        }
        if self.audio_export_settings.is_some() {
            state.serialize_entry("audioExportSettings", &self.audio_export_settings)?;
        }
        if self.insights_export_settings.is_some() {
            state.serialize_entry("insightsExportSettings", &self.insights_export_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::security_settings::AudioExportSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.gcs_bucket.is_empty() {
            state.serialize_entry("gcsBucket", &self.gcs_bucket)?;
        }
        if !self.audio_export_pattern.is_empty() {
            state.serialize_entry("audioExportPattern", &self.audio_export_pattern)?;
        }
        if !wkt::internal::is_default(&self.enable_audio_redaction) {
            state.serialize_entry("enableAudioRedaction", &self.enable_audio_redaction)?;
        }
        if !wkt::internal::is_default(&self.audio_format) {
            state.serialize_entry("audioFormat", &self.audio_format)?;
        }
        if !wkt::internal::is_default(&self.store_tts_audio) {
            state.serialize_entry("storeTtsAudio", &self.store_tts_audio)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::security_settings::InsightsExportSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_insights_export) {
            state.serialize_entry("enableInsightsExport", &self.enable_insights_export)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AnswerFeedback {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.rating) {
            state.serialize_entry("rating", &self.rating)?;
        }
        if self.rating_reason.is_some() {
            state.serialize_entry("ratingReason", &self.rating_reason)?;
        }
        if !self.custom_rating.is_empty() {
            state.serialize_entry("customRating", &self.custom_rating)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_feedback::RatingReason {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.reason_labels.is_empty() {
            state.serialize_entry("reasonLabels", &self.reason_labels)?;
        }
        if !self.feedback.is_empty() {
            state.serialize_entry("feedback", &self.feedback)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SubmitAnswerFeedbackRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if !self.response_id.is_empty() {
            state.serialize_entry("responseId", &self.response_id)?;
        }
        if self.answer_feedback.is_some() {
            state.serialize_entry("answerFeedback", &self.answer_feedback)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DetectIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if self.query_params.is_some() {
            state.serialize_entry("queryParams", &self.query_params)?;
        }
        if self.query_input.is_some() {
            state.serialize_entry("queryInput", &self.query_input)?;
        }
        if self.output_audio_config.is_some() {
            state.serialize_entry("outputAudioConfig", &self.output_audio_config)?;
        }
        if !wkt::internal::is_default(&self.response_view) {
            state.serialize_entry("responseView", &self.response_view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DetectIntentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.response_id.is_empty() {
            state.serialize_entry("responseId", &self.response_id)?;
        }
        if self.query_result.is_some() {
            state.serialize_entry("queryResult", &self.query_result)?;
        }
        if !self.output_audio.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("outputAudio", &__With(&self.output_audio))?;
        }
        if self.output_audio_config.is_some() {
            state.serialize_entry("outputAudioConfig", &self.output_audio_config)?;
        }
        if !wkt::internal::is_default(&self.response_type) {
            state.serialize_entry("responseType", &self.response_type)?;
        }
        if !wkt::internal::is_default(&self.allow_cancellation) {
            state.serialize_entry("allowCancellation", &self.allow_cancellation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StreamingDetectIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if self.query_params.is_some() {
            state.serialize_entry("queryParams", &self.query_params)?;
        }
        if self.query_input.is_some() {
            state.serialize_entry("queryInput", &self.query_input)?;
        }
        if self.output_audio_config.is_some() {
            state.serialize_entry("outputAudioConfig", &self.output_audio_config)?;
        }
        if !wkt::internal::is_default(&self.enable_partial_response) {
            state.serialize_entry("enablePartialResponse", &self.enable_partial_response)?;
        }
        if !wkt::internal::is_default(&self.enable_debugging_info) {
            state.serialize_entry("enableDebuggingInfo", &self.enable_debugging_info)?;
        }
        if !wkt::internal::is_default(&self.response_view) {
            state.serialize_entry("responseView", &self.response_view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CloudConversationDebuggingInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.audio_data_chunks) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("audioDataChunks", &__With(&self.audio_data_chunks))?;
        }
        if self.result_end_time_offset.is_some() {
            state.serialize_entry("resultEndTimeOffset", &self.result_end_time_offset)?;
        }
        if self.first_audio_duration.is_some() {
            state.serialize_entry("firstAudioDuration", &self.first_audio_duration)?;
        }
        if !wkt::internal::is_default(&self.single_utterance) {
            state.serialize_entry("singleUtterance", &self.single_utterance)?;
        }
        if !self.speech_partial_results_end_times.is_empty() {
            state.serialize_entry(
                "speechPartialResultsEndTimes",
                &self.speech_partial_results_end_times,
            )?;
        }
        if !self.speech_final_results_end_times.is_empty() {
            state.serialize_entry(
                "speechFinalResultsEndTimes",
                &self.speech_final_results_end_times,
            )?;
        }
        if !wkt::internal::is_default(&self.partial_responses) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("partialResponses", &__With(&self.partial_responses))?;
        }
        if !wkt::internal::is_default(&self.speaker_id_passive_latency_ms_offset) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "speakerIdPassiveLatencyMsOffset",
                &__With(&self.speaker_id_passive_latency_ms_offset),
            )?;
        }
        if !wkt::internal::is_default(&self.bargein_event_triggered) {
            state.serialize_entry("bargeinEventTriggered", &self.bargein_event_triggered)?;
        }
        if !wkt::internal::is_default(&self.speech_single_utterance) {
            state.serialize_entry("speechSingleUtterance", &self.speech_single_utterance)?;
        }
        if !self.dtmf_partial_results_times.is_empty() {
            state.serialize_entry("dtmfPartialResultsTimes", &self.dtmf_partial_results_times)?;
        }
        if !self.dtmf_final_results_times.is_empty() {
            state.serialize_entry("dtmfFinalResultsTimes", &self.dtmf_final_results_times)?;
        }
        if self.single_utterance_end_time_offset.is_some() {
            state.serialize_entry(
                "singleUtteranceEndTimeOffset",
                &self.single_utterance_end_time_offset,
            )?;
        }
        if self.no_speech_timeout.is_some() {
            state.serialize_entry("noSpeechTimeout", &self.no_speech_timeout)?;
        }
        if self.endpointing_timeout.is_some() {
            state.serialize_entry("endpointingTimeout", &self.endpointing_timeout)?;
        }
        if !wkt::internal::is_default(&self.is_input_text) {
            state.serialize_entry("isInputText", &self.is_input_text)?;
        }
        if self.client_half_close_time_offset.is_some() {
            state.serialize_entry(
                "clientHalfCloseTimeOffset",
                &self.client_half_close_time_offset,
            )?;
        }
        if self.client_half_close_streaming_time_offset.is_some() {
            state.serialize_entry(
                "clientHalfCloseStreamingTimeOffset",
                &self.client_half_close_streaming_time_offset,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StreamingDetectIntentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.recognition_result() {
            state.serialize_entry("recognitionResult", value)?;
        }
        if let Some(value) = self.detect_intent_response() {
            state.serialize_entry("detectIntentResponse", value)?;
        }
        if self.debugging_info.is_some() {
            state.serialize_entry("debuggingInfo", &self.debugging_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StreamingRecognitionResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.message_type) {
            state.serialize_entry("messageType", &self.message_type)?;
        }
        if !self.transcript.is_empty() {
            state.serialize_entry("transcript", &self.transcript)?;
        }
        if !wkt::internal::is_default(&self.is_final) {
            state.serialize_entry("isFinal", &self.is_final)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !wkt::internal::is_default(&self.stability) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("stability", &__With(&self.stability))?;
        }
        if !self.speech_word_info.is_empty() {
            state.serialize_entry("speechWordInfo", &self.speech_word_info)?;
        }
        if self.speech_end_offset.is_some() {
            state.serialize_entry("speechEndOffset", &self.speech_end_offset)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::QueryParameters {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if self.geo_location.is_some() {
            state.serialize_entry("geoLocation", &self.geo_location)?;
        }
        if !self.session_entity_types.is_empty() {
            state.serialize_entry("sessionEntityTypes", &self.session_entity_types)?;
        }
        if self.payload.is_some() {
            state.serialize_entry("payload", &self.payload)?;
        }
        if self.parameters.is_some() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self.parameter_scope.is_empty() {
            state.serialize_entry("parameterScope", &self.parameter_scope)?;
        }
        if !self.current_page.is_empty() {
            state.serialize_entry("currentPage", &self.current_page)?;
        }
        if !wkt::internal::is_default(&self.disable_webhook) {
            state.serialize_entry("disableWebhook", &self.disable_webhook)?;
        }
        if !wkt::internal::is_default(&self.analyze_query_text_sentiment) {
            state.serialize_entry(
                "analyzeQueryTextSentiment",
                &self.analyze_query_text_sentiment,
            )?;
        }
        if !self.webhook_headers.is_empty() {
            state.serialize_entry("webhookHeaders", &self.webhook_headers)?;
        }
        if !self.flow_versions.is_empty() {
            state.serialize_entry("flowVersions", &self.flow_versions)?;
        }
        if !self.current_playbook.is_empty() {
            state.serialize_entry("currentPlaybook", &self.current_playbook)?;
        }
        if self.llm_model_settings.is_some() {
            state.serialize_entry("llmModelSettings", &self.llm_model_settings)?;
        }
        if !self.channel.is_empty() {
            state.serialize_entry("channel", &self.channel)?;
        }
        if self.session_ttl.is_some() {
            state.serialize_entry("sessionTtl", &self.session_ttl)?;
        }
        if self.end_user_metadata.is_some() {
            state.serialize_entry("endUserMetadata", &self.end_user_metadata)?;
        }
        if self.search_config.is_some() {
            state.serialize_entry("searchConfig", &self.search_config)?;
        }
        if !wkt::internal::is_default(&self.populate_data_store_connection_signals) {
            state.serialize_entry(
                "populateDataStoreConnectionSignals",
                &self.populate_data_store_connection_signals,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SearchConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.boost_specs.is_empty() {
            state.serialize_entry("boostSpecs", &self.boost_specs)?;
        }
        if !self.filter_specs.is_empty() {
            state.serialize_entry("filterSpecs", &self.filter_specs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BoostSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.condition_boost_specs.is_empty() {
            state.serialize_entry("conditionBoostSpecs", &self.condition_boost_specs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::boost_spec::ConditionBoostSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.condition.is_empty() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !wkt::internal::is_default(&self.boost) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("boost", &__With(&self.boost))?;
        }
        if self.boost_control_spec.is_some() {
            state.serialize_entry("boostControlSpec", &self.boost_control_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::boost_spec::condition_boost_spec::BoostControlSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.field_name.is_empty() {
            state.serialize_entry("fieldName", &self.field_name)?;
        }
        if !wkt::internal::is_default(&self.attribute_type) {
            state.serialize_entry("attributeType", &self.attribute_type)?;
        }
        if !wkt::internal::is_default(&self.interpolation_type) {
            state.serialize_entry("interpolationType", &self.interpolation_type)?;
        }
        if !self.control_points.is_empty() {
            state.serialize_entry("controlPoints", &self.control_points)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attribute_value.is_empty() {
            state.serialize_entry("attributeValue", &self.attribute_value)?;
        }
        if !wkt::internal::is_default(&self.boost_amount) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("boostAmount", &__With(&self.boost_amount))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BoostSpecs {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_stores.is_empty() {
            state.serialize_entry("dataStores", &self.data_stores)?;
        }
        if !self.spec.is_empty() {
            state.serialize_entry("spec", &self.spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FilterSpecs {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_stores.is_empty() {
            state.serialize_entry("dataStores", &self.data_stores)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::QueryInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.intent() {
            state.serialize_entry("intent", value)?;
        }
        if let Some(value) = self.audio() {
            state.serialize_entry("audio", value)?;
        }
        if let Some(value) = self.event() {
            state.serialize_entry("event", value)?;
        }
        if let Some(value) = self.dtmf() {
            state.serialize_entry("dtmf", value)?;
        }
        if let Some(value) = self.tool_call_result() {
            state.serialize_entry("toolCallResult", value)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::QueryResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.trigger_intent() {
            state.serialize_entry("triggerIntent", value)?;
        }
        if let Some(value) = self.transcript() {
            state.serialize_entry("transcript", value)?;
        }
        if let Some(value) = self.trigger_event() {
            state.serialize_entry("triggerEvent", value)?;
        }
        if let Some(value) = self.dtmf() {
            state.serialize_entry("dtmf", value)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.parameters.is_some() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self.response_messages.is_empty() {
            state.serialize_entry("responseMessages", &self.response_messages)?;
        }
        if !self.webhook_statuses.is_empty() {
            state.serialize_entry("webhookStatuses", &self.webhook_statuses)?;
        }
        if !self.webhook_payloads.is_empty() {
            state.serialize_entry("webhookPayloads", &self.webhook_payloads)?;
        }
        if self.current_page.is_some() {
            state.serialize_entry("currentPage", &self.current_page)?;
        }
        if self.current_flow.is_some() {
            state.serialize_entry("currentFlow", &self.current_flow)?;
        }
        if self.intent.is_some() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !wkt::internal::is_default(&self.intent_detection_confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "intentDetectionConfidence",
                &__With(&self.intent_detection_confidence),
            )?;
        }
        if self.r#match.is_some() {
            state.serialize_entry("match", &self.r#match)?;
        }
        if self.diagnostic_info.is_some() {
            state.serialize_entry("diagnosticInfo", &self.diagnostic_info)?;
        }
        if self.sentiment_analysis_result.is_some() {
            state.serialize_entry("sentimentAnalysisResult", &self.sentiment_analysis_result)?;
        }
        if self.advanced_settings.is_some() {
            state.serialize_entry("advancedSettings", &self.advanced_settings)?;
        }
        if !wkt::internal::is_default(&self.allow_answer_feedback) {
            state.serialize_entry("allowAnswerFeedback", &self.allow_answer_feedback)?;
        }
        if self.data_store_connection_signals.is_some() {
            state.serialize_entry(
                "dataStoreConnectionSignals",
                &self.data_store_connection_signals,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::TextInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::IntentInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.intent.is_empty() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AudioInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if !self.audio.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("audio", &__With(&self.audio))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::EventInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.event.is_empty() {
            state.serialize_entry("event", &self.event)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DtmfInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.digits.is_empty() {
            state.serialize_entry("digits", &self.digits)?;
        }
        if !self.finish_digit.is_empty() {
            state.serialize_entry("finishDigit", &self.finish_digit)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Match {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.intent.is_some() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !self.event.is_empty() {
            state.serialize_entry("event", &self.event)?;
        }
        if self.parameters.is_some() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self.resolved_input.is_empty() {
            state.serialize_entry("resolvedInput", &self.resolved_input)?;
        }
        if !wkt::internal::is_default(&self.match_type) {
            state.serialize_entry("matchType", &self.match_type)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::MatchIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if self.query_params.is_some() {
            state.serialize_entry("queryParams", &self.query_params)?;
        }
        if self.query_input.is_some() {
            state.serialize_entry("queryInput", &self.query_input)?;
        }
        if !wkt::internal::is_default(&self.persist_parameter_changes) {
            state.serialize_entry("persistParameterChanges", &self.persist_parameter_changes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::MatchIntentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.trigger_intent() {
            state.serialize_entry("triggerIntent", value)?;
        }
        if let Some(value) = self.transcript() {
            state.serialize_entry("transcript", value)?;
        }
        if let Some(value) = self.trigger_event() {
            state.serialize_entry("triggerEvent", value)?;
        }
        if !self.matches.is_empty() {
            state.serialize_entry("matches", &self.matches)?;
        }
        if self.current_page.is_some() {
            state.serialize_entry("currentPage", &self.current_page)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FulfillIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.match_intent_request.is_some() {
            state.serialize_entry("matchIntentRequest", &self.match_intent_request)?;
        }
        if self.r#match.is_some() {
            state.serialize_entry("match", &self.r#match)?;
        }
        if self.output_audio_config.is_some() {
            state.serialize_entry("outputAudioConfig", &self.output_audio_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FulfillIntentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.response_id.is_empty() {
            state.serialize_entry("responseId", &self.response_id)?;
        }
        if self.query_result.is_some() {
            state.serialize_entry("queryResult", &self.query_result)?;
        }
        if !self.output_audio.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("outputAudio", &__With(&self.output_audio))?;
        }
        if self.output_audio_config.is_some() {
            state.serialize_entry("outputAudioConfig", &self.output_audio_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SentimentAnalysisResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if !wkt::internal::is_default(&self.magnitude) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("magnitude", &__With(&self.magnitude))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "session-entity-types", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SessionEntityType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.entity_override_mode) {
            state.serialize_entry("entityOverrideMode", &self.entity_override_mode)?;
        }
        if !self.entities.is_empty() {
            state.serialize_entry("entities", &self.entities)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListSessionEntityTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListSessionEntityTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session_entity_types.is_empty() {
            state.serialize_entry("sessionEntityTypes", &self.session_entity_types)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetSessionEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateSessionEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.session_entity_type.is_some() {
            state.serialize_entry("sessionEntityType", &self.session_entity_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateSessionEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.session_entity_type.is_some() {
            state.serialize_entry("sessionEntityType", &self.session_entity_type)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteSessionEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TestCase {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.notes.is_empty() {
            state.serialize_entry("notes", &self.notes)?;
        }
        if self.test_config.is_some() {
            state.serialize_entry("testConfig", &self.test_config)?;
        }
        if !self.test_case_conversation_turns.is_empty() {
            state.serialize_entry(
                "testCaseConversationTurns",
                &self.test_case_conversation_turns,
            )?;
        }
        if self.creation_time.is_some() {
            state.serialize_entry("creationTime", &self.creation_time)?;
        }
        if self.last_test_result.is_some() {
            state.serialize_entry("lastTestResult", &self.last_test_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TestCaseResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self.conversation_turns.is_empty() {
            state.serialize_entry("conversationTurns", &self.conversation_turns)?;
        }
        if !wkt::internal::is_default(&self.test_result) {
            state.serialize_entry("testResult", &self.test_result)?;
        }
        if self.test_time.is_some() {
            state.serialize_entry("testTime", &self.test_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TestConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tracking_parameters.is_empty() {
            state.serialize_entry("trackingParameters", &self.tracking_parameters)?;
        }
        if !self.flow.is_empty() {
            state.serialize_entry("flow", &self.flow)?;
        }
        if !self.page.is_empty() {
            state.serialize_entry("page", &self.page)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ConversationTurn {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.user_input.is_some() {
            state.serialize_entry("userInput", &self.user_input)?;
        }
        if self.virtual_agent_output.is_some() {
            state.serialize_entry("virtualAgentOutput", &self.virtual_agent_output)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::conversation_turn::UserInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.input.is_some() {
            state.serialize_entry("input", &self.input)?;
        }
        if self.injected_parameters.is_some() {
            state.serialize_entry("injectedParameters", &self.injected_parameters)?;
        }
        if !wkt::internal::is_default(&self.is_webhook_enabled) {
            state.serialize_entry("isWebhookEnabled", &self.is_webhook_enabled)?;
        }
        if !wkt::internal::is_default(&self.enable_sentiment_analysis) {
            state.serialize_entry("enableSentimentAnalysis", &self.enable_sentiment_analysis)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::conversation_turn::VirtualAgentOutput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.session_parameters.is_some() {
            state.serialize_entry("sessionParameters", &self.session_parameters)?;
        }
        if !self.differences.is_empty() {
            state.serialize_entry("differences", &self.differences)?;
        }
        if self.diagnostic_info.is_some() {
            state.serialize_entry("diagnosticInfo", &self.diagnostic_info)?;
        }
        if self.triggered_intent.is_some() {
            state.serialize_entry("triggeredIntent", &self.triggered_intent)?;
        }
        if self.current_page.is_some() {
            state.serialize_entry("currentPage", &self.current_page)?;
        }
        if !self.text_responses.is_empty() {
            state.serialize_entry("textResponses", &self.text_responses)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TestRunDifference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TransitionCoverage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.transitions.is_empty() {
            state.serialize_entry("transitions", &self.transitions)?;
        }
        if !wkt::internal::is_default(&self.coverage_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("coverageScore", &__With(&self.coverage_score))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::transition_coverage::TransitionNode {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.page() {
            state.serialize_entry("page", value)?;
        }
        if let Some(value) = self.flow() {
            state.serialize_entry("flow", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::transition_coverage::Transition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if !wkt::internal::is_default(&self.index) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("index", &__With(&self.index))?;
        }
        if self.target.is_some() {
            state.serialize_entry("target", &self.target)?;
        }
        if !wkt::internal::is_default(&self.covered) {
            state.serialize_entry("covered", &self.covered)?;
        }
        if let Some(value) = self.transition_route() {
            state.serialize_entry("transitionRoute", value)?;
        }
        if let Some(value) = self.event_handler() {
            state.serialize_entry("eventHandler", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TransitionRouteGroupCoverage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.coverages.is_empty() {
            state.serialize_entry("coverages", &self.coverages)?;
        }
        if !wkt::internal::is_default(&self.coverage_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("coverageScore", &__With(&self.coverage_score))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::transition_route_group_coverage::Coverage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.route_group.is_some() {
            state.serialize_entry("routeGroup", &self.route_group)?;
        }
        if !self.transitions.is_empty() {
            state.serialize_entry("transitions", &self.transitions)?;
        }
        if !wkt::internal::is_default(&self.coverage_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("coverageScore", &__With(&self.coverage_score))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::transition_route_group_coverage::coverage::Transition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.transition_route.is_some() {
            state.serialize_entry("transitionRoute", &self.transition_route)?;
        }
        if !wkt::internal::is_default(&self.covered) {
            state.serialize_entry("covered", &self.covered)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::IntentCoverage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.intents.is_empty() {
            state.serialize_entry("intents", &self.intents)?;
        }
        if !wkt::internal::is_default(&self.coverage_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("coverageScore", &__With(&self.coverage_score))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent_coverage::Intent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.intent.is_empty() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !wkt::internal::is_default(&self.covered) {
            state.serialize_entry("covered", &self.covered)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CalculateCoverageRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.agent.is_empty() {
            state.serialize_entry("agent", &self.agent)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CalculateCoverageResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.agent.is_empty() {
            state.serialize_entry("agent", &self.agent)?;
        }
        if let Some(value) = self.intent_coverage() {
            state.serialize_entry("intentCoverage", value)?;
        }
        if let Some(value) = self.transition_coverage() {
            state.serialize_entry("transitionCoverage", value)?;
        }
        if let Some(value) = self.route_group_coverage() {
            state.serialize_entry("routeGroupCoverage", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListTestCasesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListTestCasesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.test_cases.is_empty() {
            state.serialize_entry("testCases", &self.test_cases)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchDeleteTestCasesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.names.is_empty() {
            state.serialize_entry("names", &self.names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateTestCaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.test_case.is_some() {
            state.serialize_entry("testCase", &self.test_case)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateTestCaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.test_case.is_some() {
            state.serialize_entry("testCase", &self.test_case)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetTestCaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RunTestCaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RunTestCaseResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.result.is_some() {
            state.serialize_entry("result", &self.result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RunTestCaseMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchRunTestCasesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self.test_cases.is_empty() {
            state.serialize_entry("testCases", &self.test_cases)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchRunTestCasesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.results.is_empty() {
            state.serialize_entry("results", &self.results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchRunTestCasesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "environments", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::TestError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.test_case.is_empty() {
            state.serialize_entry("testCase", &self.test_case)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.test_time.is_some() {
            state.serialize_entry("testTime", &self.test_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportTestCasesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.gcs_uri() {
            state.serialize_entry("gcsUri", value)?;
        }
        if let Some(value) = self.content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportTestCasesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.names.is_empty() {
            state.serialize_entry("names", &self.names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportTestCasesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TestCaseError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.test_case.is_some() {
            state.serialize_entry("testCase", &self.test_case)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportTestCasesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.gcs_uri() {
            state.serialize_entry("gcsUri", value)?;
        }
        if !wkt::internal::is_default(&self.data_format) {
            state.serialize_entry("dataFormat", &self.data_format)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportTestCasesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_uri() {
            state.serialize_entry("gcsUri", value)?;
        }
        if let Some(value) = self.content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportTestCasesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListTestCaseResultsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListTestCaseResultsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.test_case_results.is_empty() {
            state.serialize_entry("testCaseResults", &self.test_case_results)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetTestCaseResultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateToolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.tool.is_some() {
            state.serialize_entry("tool", &self.tool)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListToolsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListToolsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tools.is_empty() {
            state.serialize_entry("tools", &self.tools)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetToolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateToolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.tool.is_some() {
            state.serialize_entry("tool", &self.tool)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteToolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Tool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if let Some(value) = self.open_api_spec() {
            state.serialize_entry("openApiSpec", value)?;
        }
        if let Some(value) = self.data_store_spec() {
            state.serialize_entry("dataStoreSpec", value)?;
        }
        if let Some(value) = self.function_spec() {
            state.serialize_entry("functionSpec", value)?;
        }
        if !wkt::internal::is_default(&self.tool_type) {
            state.serialize_entry("toolType", &self.tool_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::tool::OpenApiTool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text_schema() {
            state.serialize_entry("textSchema", value)?;
        }
        if self.authentication.is_some() {
            state.serialize_entry("authentication", &self.authentication)?;
        }
        if self.tls_config.is_some() {
            state.serialize_entry("tlsConfig", &self.tls_config)?;
        }
        if self.service_directory_config.is_some() {
            state.serialize_entry("serviceDirectoryConfig", &self.service_directory_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::tool::DataStoreTool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_store_connections.is_empty() {
            state.serialize_entry("dataStoreConnections", &self.data_store_connections)?;
        }
        if self.fallback_prompt.is_some() {
            state.serialize_entry("fallbackPrompt", &self.fallback_prompt)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::tool::data_store_tool::FallbackPrompt {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::tool::FunctionTool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.input_schema.is_some() {
            state.serialize_entry("inputSchema", &self.input_schema)?;
        }
        if self.output_schema.is_some() {
            state.serialize_entry("outputSchema", &self.output_schema)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::tool::Authentication {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.api_key_config() {
            state.serialize_entry("apiKeyConfig", value)?;
        }
        if let Some(value) = self.oauth_config() {
            state.serialize_entry("oauthConfig", value)?;
        }
        if let Some(value) = self.service_agent_auth_config() {
            state.serialize_entry("serviceAgentAuthConfig", value)?;
        }
        if let Some(value) = self.bearer_token_config() {
            state.serialize_entry("bearerTokenConfig", value)?;
        }
        if let Some(value) = self.service_account_auth_config() {
            state.serialize_entry("serviceAccountAuthConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::tool::authentication::ApiKeyConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key_name.is_empty() {
            state.serialize_entry("keyName", &self.key_name)?;
        }
        if !self.api_key.is_empty() {
            state.serialize_entry("apiKey", &self.api_key)?;
        }
        if !self.secret_version_for_api_key.is_empty() {
            state.serialize_entry("secretVersionForApiKey", &self.secret_version_for_api_key)?;
        }
        if !wkt::internal::is_default(&self.request_location) {
            state.serialize_entry("requestLocation", &self.request_location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::tool::authentication::OAuthConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.oauth_grant_type) {
            state.serialize_entry("oauthGrantType", &self.oauth_grant_type)?;
        }
        if !self.client_id.is_empty() {
            state.serialize_entry("clientId", &self.client_id)?;
        }
        if !self.client_secret.is_empty() {
            state.serialize_entry("clientSecret", &self.client_secret)?;
        }
        if !self.secret_version_for_client_secret.is_empty() {
            state.serialize_entry(
                "secretVersionForClientSecret",
                &self.secret_version_for_client_secret,
            )?;
        }
        if !self.token_endpoint.is_empty() {
            state.serialize_entry("tokenEndpoint", &self.token_endpoint)?;
        }
        if !self.scopes.is_empty() {
            state.serialize_entry("scopes", &self.scopes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::tool::authentication::ServiceAgentAuthConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.service_agent_auth) {
            state.serialize_entry("serviceAgentAuth", &self.service_agent_auth)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::tool::authentication::BearerTokenConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.token.is_empty() {
            state.serialize_entry("token", &self.token)?;
        }
        if !self.secret_version_for_token.is_empty() {
            state.serialize_entry("secretVersionForToken", &self.secret_version_for_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::tool::authentication::ServiceAccountAuthConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::tool::TLSConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ca_certs.is_empty() {
            state.serialize_entry("caCerts", &self.ca_certs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::tool::tls_config::CACert {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.cert.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cert", &__With(&self.cert))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::tool::ServiceDirectoryConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service.is_empty() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListToolVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListToolVersionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tool_versions.is_empty() {
            state.serialize_entry("toolVersions", &self.tool_versions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateToolVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.tool_version.is_some() {
            state.serialize_entry("toolVersion", &self.tool_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetToolVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteToolVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RestoreToolVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RestoreToolVersionResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.tool.is_some() {
            state.serialize_entry("tool", &self.tool)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "tools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ToolVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.tool.is_some() {
            state.serialize_entry("tool", &self.tool)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "playbooks",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ToolCall {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tool.is_empty() {
            state.serialize_entry("tool", &self.tool)?;
        }
        if !self.action.is_empty() {
            state.serialize_entry("action", &self.action)?;
        }
        if self.input_parameters.is_some() {
            state.serialize_entry("inputParameters", &self.input_parameters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ToolCallResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tool.is_empty() {
            state.serialize_entry("tool", &self.tool)?;
        }
        if !self.action.is_empty() {
            state.serialize_entry("action", &self.action)?;
        }
        if let Some(value) = self.error() {
            state.serialize_entry("error", value)?;
        }
        if let Some(value) = self.output_parameters() {
            state.serialize_entry("outputParameters", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::tool_call_result::Error {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "examples", feature = "playbooks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::PlaybookInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.preceding_conversation_summary.is_empty() {
            state.serialize_entry(
                "precedingConversationSummary",
                &self.preceding_conversation_summary,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "examples", feature = "playbooks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::PlaybookOutput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.execution_summary.is_empty() {
            state.serialize_entry("executionSummary", &self.execution_summary)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "examples", feature = "playbooks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Action {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.user_utterance() {
            state.serialize_entry("userUtterance", value)?;
        }
        if let Some(value) = self.agent_utterance() {
            state.serialize_entry("agentUtterance", value)?;
        }
        if let Some(value) = self.tool_use() {
            state.serialize_entry("toolUse", value)?;
        }
        if let Some(value) = self.playbook_invocation() {
            state.serialize_entry("playbookInvocation", value)?;
        }
        if let Some(value) = self.flow_invocation() {
            state.serialize_entry("flowInvocation", value)?;
        }
        if let Some(value) = self.playbook_transition() {
            state.serialize_entry("playbookTransition", value)?;
        }
        if let Some(value) = self.flow_transition() {
            state.serialize_entry("flowTransition", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "examples", feature = "playbooks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::UserUtterance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "examples", feature = "playbooks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AgentUtterance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "examples", feature = "playbooks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ToolUse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tool.is_empty() {
            state.serialize_entry("tool", &self.tool)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.action.is_empty() {
            state.serialize_entry("action", &self.action)?;
        }
        if self.input_action_parameters.is_some() {
            state.serialize_entry("inputActionParameters", &self.input_action_parameters)?;
        }
        if self.output_action_parameters.is_some() {
            state.serialize_entry("outputActionParameters", &self.output_action_parameters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "examples", feature = "playbooks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::PlaybookInvocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.playbook.is_empty() {
            state.serialize_entry("playbook", &self.playbook)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.playbook_input.is_some() {
            state.serialize_entry("playbookInput", &self.playbook_input)?;
        }
        if self.playbook_output.is_some() {
            state.serialize_entry("playbookOutput", &self.playbook_output)?;
        }
        if !wkt::internal::is_default(&self.playbook_state) {
            state.serialize_entry("playbookState", &self.playbook_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "examples", feature = "playbooks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::FlowInvocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.flow.is_empty() {
            state.serialize_entry("flow", &self.flow)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.flow_state) {
            state.serialize_entry("flowState", &self.flow_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "examples", feature = "playbooks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::PlaybookTransition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.playbook.is_empty() {
            state.serialize_entry("playbook", &self.playbook)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "examples", feature = "playbooks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::FlowTransition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.flow.is_empty() {
            state.serialize_entry("flow", &self.flow)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "test-cases", feature = "transition-route-groups",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::TransitionRouteGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.transition_routes.is_empty() {
            state.serialize_entry("transitionRoutes", &self.transition_routes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListTransitionRouteGroupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListTransitionRouteGroupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.transition_route_groups.is_empty() {
            state.serialize_entry("transitionRouteGroups", &self.transition_route_groups)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetTransitionRouteGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateTransitionRouteGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.transition_route_group.is_some() {
            state.serialize_entry("transitionRouteGroup", &self.transition_route_group)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateTransitionRouteGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.transition_route_group.is_some() {
            state.serialize_entry("transitionRouteGroup", &self.transition_route_group)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteTransitionRouteGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "agents", feature = "flows",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ValidationMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.resource_type) {
            state.serialize_entry("resourceType", &self.resource_type)?;
        }
        if !self.resources.is_empty() {
            state.serialize_entry("resources", &self.resources)?;
        }
        if !self.resource_names.is_empty() {
            state.serialize_entry("resourceNames", &self.resource_names)?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self.detail.is_empty() {
            state.serialize_entry("detail", &self.detail)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "agents", feature = "flows",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourceName {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateVersionOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Version {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.nlu_settings.is_some() {
            state.serialize_entry("nluSettings", &self.nlu_settings)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListVersionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.versions.is_empty() {
            state.serialize_entry("versions", &self.versions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::LoadVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.allow_override_agent_resources) {
            state.serialize_entry(
                "allowOverrideAgentResources",
                &self.allow_override_agent_resources,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CompareVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.base_version.is_empty() {
            state.serialize_entry("baseVersion", &self.base_version)?;
        }
        if !self.target_version.is_empty() {
            state.serialize_entry("targetVersion", &self.target_version)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CompareVersionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.base_version_content_json.is_empty() {
            state.serialize_entry("baseVersionContentJson", &self.base_version_content_json)?;
        }
        if !self.target_version_content_json.is_empty() {
            state.serialize_entry(
                "targetVersionContentJson",
                &self.target_version_content_json,
            )?;
        }
        if self.compare_time.is_some() {
            state.serialize_entry("compareTime", &self.compare_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "environments", feature = "webhooks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Webhook {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if let Some(value) = self.generic_web_service() {
            state.serialize_entry("genericWebService", value)?;
        }
        if let Some(value) = self.service_directory() {
            state.serialize_entry("serviceDirectory", value)?;
        }
        if self.timeout.is_some() {
            state.serialize_entry("timeout", &self.timeout)?;
        }
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "environments", feature = "webhooks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::webhook::GenericWebService {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !self.secret_version_for_username_password.is_empty() {
            state.serialize_entry(
                "secretVersionForUsernamePassword",
                &self.secret_version_for_username_password,
            )?;
        }
        if !self.request_headers.is_empty() {
            state.serialize_entry("requestHeaders", &self.request_headers)?;
        }
        if !self.secret_versions_for_request_headers.is_empty() {
            state.serialize_entry(
                "secretVersionsForRequestHeaders",
                &self.secret_versions_for_request_headers,
            )?;
        }
        if !self.allowed_ca_certs.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<serde_with::base64::Base64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("allowedCaCerts", &__With(&self.allowed_ca_certs))?;
        }
        if self.oauth_config.is_some() {
            state.serialize_entry("oauthConfig", &self.oauth_config)?;
        }
        if !wkt::internal::is_default(&self.service_agent_auth) {
            state.serialize_entry("serviceAgentAuth", &self.service_agent_auth)?;
        }
        if self.service_account_auth_config.is_some() {
            state.serialize_entry(
                "serviceAccountAuthConfig",
                &self.service_account_auth_config,
            )?;
        }
        if !wkt::internal::is_default(&self.webhook_type) {
            state.serialize_entry("webhookType", &self.webhook_type)?;
        }
        if !wkt::internal::is_default(&self.http_method) {
            state.serialize_entry("httpMethod", &self.http_method)?;
        }
        if !self.request_body.is_empty() {
            state.serialize_entry("requestBody", &self.request_body)?;
        }
        if !self.parameter_mapping.is_empty() {
            state.serialize_entry("parameterMapping", &self.parameter_mapping)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "environments", feature = "webhooks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::webhook::generic_web_service::SecretVersionHeaderValue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.secret_version.is_empty() {
            state.serialize_entry("secretVersion", &self.secret_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "environments", feature = "webhooks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::webhook::generic_web_service::OAuthConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.client_id.is_empty() {
            state.serialize_entry("clientId", &self.client_id)?;
        }
        if !self.client_secret.is_empty() {
            state.serialize_entry("clientSecret", &self.client_secret)?;
        }
        if !self.secret_version_for_client_secret.is_empty() {
            state.serialize_entry(
                "secretVersionForClientSecret",
                &self.secret_version_for_client_secret,
            )?;
        }
        if !self.token_endpoint.is_empty() {
            state.serialize_entry("tokenEndpoint", &self.token_endpoint)?;
        }
        if !self.scopes.is_empty() {
            state.serialize_entry("scopes", &self.scopes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "environments", feature = "webhooks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::webhook::generic_web_service::ServiceAccountAuthConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "environments", feature = "webhooks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::webhook::ServiceDirectoryConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service.is_empty() {
            state.serialize_entry("service", &self.service)?;
        }
        if self.generic_web_service.is_some() {
            state.serialize_entry("genericWebService", &self.generic_web_service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListWebhooksRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListWebhooksResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.webhooks.is_empty() {
            state.serialize_entry("webhooks", &self.webhooks)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetWebhookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateWebhookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.webhook.is_some() {
            state.serialize_entry("webhook", &self.webhook)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateWebhookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.webhook.is_some() {
            state.serialize_entry("webhook", &self.webhook)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteWebhookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "examples",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "playbooks",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "tools",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::WebhookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.detect_intent_response_id.is_empty() {
            state.serialize_entry("detectIntentResponseId", &self.detect_intent_response_id)?;
        }
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.trigger_intent() {
            state.serialize_entry("triggerIntent", value)?;
        }
        if let Some(value) = self.transcript() {
            state.serialize_entry("transcript", value)?;
        }
        if let Some(value) = self.trigger_event() {
            state.serialize_entry("triggerEvent", value)?;
        }
        if let Some(value) = self.dtmf_digits() {
            state.serialize_entry("dtmfDigits", value)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.fulfillment_info.is_some() {
            state.serialize_entry("fulfillmentInfo", &self.fulfillment_info)?;
        }
        if self.intent_info.is_some() {
            state.serialize_entry("intentInfo", &self.intent_info)?;
        }
        if self.page_info.is_some() {
            state.serialize_entry("pageInfo", &self.page_info)?;
        }
        if self.session_info.is_some() {
            state.serialize_entry("sessionInfo", &self.session_info)?;
        }
        if !self.messages.is_empty() {
            state.serialize_entry("messages", &self.messages)?;
        }
        if self.payload.is_some() {
            state.serialize_entry("payload", &self.payload)?;
        }
        if self.sentiment_analysis_result.is_some() {
            state.serialize_entry("sentimentAnalysisResult", &self.sentiment_analysis_result)?;
        }
        if self.language_info.is_some() {
            state.serialize_entry("languageInfo", &self.language_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "examples",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "playbooks",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "tools",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::webhook_request::FulfillmentInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tag.is_empty() {
            state.serialize_entry("tag", &self.tag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "examples",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "playbooks",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "tools",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::webhook_request::IntentInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.last_matched_intent.is_empty() {
            state.serialize_entry("lastMatchedIntent", &self.last_matched_intent)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "examples",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "playbooks",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "tools",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::webhook_request::intent_info::IntentParameterValue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.original_value.is_empty() {
            state.serialize_entry("originalValue", &self.original_value)?;
        }
        if self.resolved_value.is_some() {
            state.serialize_entry("resolvedValue", &self.resolved_value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "examples",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "playbooks",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "tools",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::webhook_request::SentimentAnalysisResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if !wkt::internal::is_default(&self.magnitude) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("magnitude", &__With(&self.magnitude))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "examples",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "playbooks",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "tools",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::WebhookResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.fulfillment_response.is_some() {
            state.serialize_entry("fulfillmentResponse", &self.fulfillment_response)?;
        }
        if self.page_info.is_some() {
            state.serialize_entry("pageInfo", &self.page_info)?;
        }
        if self.session_info.is_some() {
            state.serialize_entry("sessionInfo", &self.session_info)?;
        }
        if self.payload.is_some() {
            state.serialize_entry("payload", &self.payload)?;
        }
        if let Some(value) = self.target_page() {
            state.serialize_entry("targetPage", value)?;
        }
        if let Some(value) = self.target_flow() {
            state.serialize_entry("targetFlow", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "examples",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "playbooks",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "tools",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::webhook_response::FulfillmentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.messages.is_empty() {
            state.serialize_entry("messages", &self.messages)?;
        }
        if !wkt::internal::is_default(&self.merge_behavior) {
            state.serialize_entry("mergeBehavior", &self.merge_behavior)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "examples",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "playbooks",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "tools",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::PageInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.current_page.is_empty() {
            state.serialize_entry("currentPage", &self.current_page)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.form_info.is_some() {
            state.serialize_entry("formInfo", &self.form_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "examples",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "playbooks",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "tools",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::page_info::FormInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parameter_info.is_empty() {
            state.serialize_entry("parameterInfo", &self.parameter_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "examples",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "playbooks",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "tools",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::page_info::form_info::ParameterInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.required) {
            state.serialize_entry("required", &self.required)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !wkt::internal::is_default(&self.just_collected) {
            state.serialize_entry("justCollected", &self.just_collected)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "examples",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "playbooks",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "tools",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SessionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "examples",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "playbooks",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "tools",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::LanguageInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.input_language_code.is_empty() {
            state.serialize_entry("inputLanguageCode", &self.input_language_code)?;
        }
        if !self.resolved_language_code.is_empty() {
            state.serialize_entry("resolvedLanguageCode", &self.resolved_language_code)?;
        }
        if !wkt::internal::is_default(&self.confidence_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidenceScore", &__With(&self.confidence_score))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
