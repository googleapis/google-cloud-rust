// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

//! Traits to mock the clients in this library.
//!
//! Application developers may need to mock the clients in this library to test
//! how their application works with different (and sometimes hard to trigger)
//! client and service behavior. Such test can define mocks implementing the
//! trait(s) defined in this module, initialize the client with an instance of
//! this mock in their tests, and verify their application responds as expected.

#![allow(rustdoc::broken_intra_doc_links)]

use gax::error::Error;
use std::sync::Arc;

pub(crate) mod dynamic;

/// Defines the trait used to implement [crate::client::Agents].
///
/// Application developers may need to implement this trait to mock
/// `client::Agents`.  In other use-cases, application developers only
/// use `client::Agents` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Agents: std::fmt::Debug + Send + Sync {
    /// Implements [crate::client::Agents::list_agents].
    fn list_agents(
        &self,
        _req: crate::model::ListAgentsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListAgentsResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListAgentsResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Agents::get_agent].
    fn get_agent(
        &self,
        _req: crate::model::GetAgentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Agent>> + Send {
        std::future::ready::<crate::Result<crate::model::Agent>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::Agents::create_agent].
    fn create_agent(
        &self,
        _req: crate::model::CreateAgentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Agent>> + Send {
        std::future::ready::<crate::Result<crate::model::Agent>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::Agents::update_agent].
    fn update_agent(
        &self,
        _req: crate::model::UpdateAgentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Agent>> + Send {
        std::future::ready::<crate::Result<crate::model::Agent>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::Agents::delete_agent].
    fn delete_agent(
        &self,
        _req: crate::model::DeleteAgentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::Agents::export_agent].
    fn export_agent(
        &self,
        _req: crate::model::ExportAgentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Agents::restore_agent].
    fn restore_agent(
        &self,
        _req: crate::model::RestoreAgentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Agents::validate_agent].
    fn validate_agent(
        &self,
        _req: crate::model::ValidateAgentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::AgentValidationResult>> + Send
    {
        std::future::ready::<crate::Result<crate::model::AgentValidationResult>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Agents::get_agent_validation_result].
    fn get_agent_validation_result(
        &self,
        _req: crate::model::GetAgentValidationResultRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::AgentValidationResult>> + Send
    {
        std::future::ready::<crate::Result<crate::model::AgentValidationResult>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Agents::get_generative_settings].
    fn get_generative_settings(
        &self,
        _req: crate::model::GetGenerativeSettingsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::GenerativeSettings>> + Send
    {
        std::future::ready::<crate::Result<crate::model::GenerativeSettings>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Agents::update_generative_settings].
    fn update_generative_settings(
        &self,
        _req: crate::model::UpdateGenerativeSettingsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::GenerativeSettings>> + Send
    {
        std::future::ready::<crate::Result<crate::model::GenerativeSettings>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Agents::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Agents::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Agents::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::ListOperationsResponse>>
           + Send {
        std::future::ready::<crate::Result<longrunning::model::ListOperationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Agents::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Agents::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Returns the polling policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> Arc<dyn gax::polling_policy::PollingPolicy> {
        Arc::new(gax::polling_policy::Aip194Strict)
    }

    /// Returns the polling backoff policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_backoff_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        Arc::new(gax::exponential_backoff::ExponentialBackoff::default())
    }
}

/// Defines the trait used to implement [crate::client::Changelogs].
///
/// Application developers may need to implement this trait to mock
/// `client::Changelogs`.  In other use-cases, application developers only
/// use `client::Changelogs` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Changelogs: std::fmt::Debug + Send + Sync {
    /// Implements [crate::client::Changelogs::list_changelogs].
    fn list_changelogs(
        &self,
        _req: crate::model::ListChangelogsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListChangelogsResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListChangelogsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Changelogs::get_changelog].
    fn get_changelog(
        &self,
        _req: crate::model::GetChangelogRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Changelog>> + Send {
        std::future::ready::<crate::Result<crate::model::Changelog>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Changelogs::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Changelogs::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Changelogs::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::ListOperationsResponse>>
           + Send {
        std::future::ready::<crate::Result<longrunning::model::ListOperationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Changelogs::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Changelogs::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }
}

/// Defines the trait used to implement [crate::client::Deployments].
///
/// Application developers may need to implement this trait to mock
/// `client::Deployments`.  In other use-cases, application developers only
/// use `client::Deployments` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Deployments: std::fmt::Debug + Send + Sync {
    /// Implements [crate::client::Deployments::list_deployments].
    fn list_deployments(
        &self,
        _req: crate::model::ListDeploymentsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListDeploymentsResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListDeploymentsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Deployments::get_deployment].
    fn get_deployment(
        &self,
        _req: crate::model::GetDeploymentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Deployment>> + Send {
        std::future::ready::<crate::Result<crate::model::Deployment>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Deployments::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Deployments::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Deployments::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::ListOperationsResponse>>
           + Send {
        std::future::ready::<crate::Result<longrunning::model::ListOperationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Deployments::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Deployments::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }
}

/// Defines the trait used to implement [crate::client::EntityTypes].
///
/// Application developers may need to implement this trait to mock
/// `client::EntityTypes`.  In other use-cases, application developers only
/// use `client::EntityTypes` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait EntityTypes: std::fmt::Debug + Send + Sync {
    /// Implements [crate::client::EntityTypes::get_entity_type].
    fn get_entity_type(
        &self,
        _req: crate::model::GetEntityTypeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::EntityType>> + Send {
        std::future::ready::<crate::Result<crate::model::EntityType>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::EntityTypes::create_entity_type].
    fn create_entity_type(
        &self,
        _req: crate::model::CreateEntityTypeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::EntityType>> + Send {
        std::future::ready::<crate::Result<crate::model::EntityType>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::EntityTypes::update_entity_type].
    fn update_entity_type(
        &self,
        _req: crate::model::UpdateEntityTypeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::EntityType>> + Send {
        std::future::ready::<crate::Result<crate::model::EntityType>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::EntityTypes::delete_entity_type].
    fn delete_entity_type(
        &self,
        _req: crate::model::DeleteEntityTypeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::EntityTypes::list_entity_types].
    fn list_entity_types(
        &self,
        _req: crate::model::ListEntityTypesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListEntityTypesResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListEntityTypesResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::EntityTypes::export_entity_types].
    fn export_entity_types(
        &self,
        _req: crate::model::ExportEntityTypesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::EntityTypes::import_entity_types].
    fn import_entity_types(
        &self,
        _req: crate::model::ImportEntityTypesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::EntityTypes::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::EntityTypes::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::EntityTypes::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::ListOperationsResponse>>
           + Send {
        std::future::ready::<crate::Result<longrunning::model::ListOperationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::EntityTypes::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::EntityTypes::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Returns the polling policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> Arc<dyn gax::polling_policy::PollingPolicy> {
        Arc::new(gax::polling_policy::Aip194Strict)
    }

    /// Returns the polling backoff policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_backoff_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        Arc::new(gax::exponential_backoff::ExponentialBackoff::default())
    }
}

/// Defines the trait used to implement [crate::client::Environments].
///
/// Application developers may need to implement this trait to mock
/// `client::Environments`.  In other use-cases, application developers only
/// use `client::Environments` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Environments: std::fmt::Debug + Send + Sync {
    /// Implements [crate::client::Environments::list_environments].
    fn list_environments(
        &self,
        _req: crate::model::ListEnvironmentsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListEnvironmentsResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListEnvironmentsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Environments::get_environment].
    fn get_environment(
        &self,
        _req: crate::model::GetEnvironmentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Environment>> + Send {
        std::future::ready::<crate::Result<crate::model::Environment>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Environments::create_environment].
    fn create_environment(
        &self,
        _req: crate::model::CreateEnvironmentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Environments::update_environment].
    fn update_environment(
        &self,
        _req: crate::model::UpdateEnvironmentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Environments::delete_environment].
    fn delete_environment(
        &self,
        _req: crate::model::DeleteEnvironmentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::Environments::lookup_environment_history].
    fn lookup_environment_history(
        &self,
        _req: crate::model::LookupEnvironmentHistoryRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<crate::model::LookupEnvironmentHistoryResponse>,
    > + Send {
        std::future::ready::<crate::Result<crate::model::LookupEnvironmentHistoryResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Environments::run_continuous_test].
    fn run_continuous_test(
        &self,
        _req: crate::model::RunContinuousTestRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Environments::list_continuous_test_results].
    fn list_continuous_test_results(
        &self,
        _req: crate::model::ListContinuousTestResultsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<crate::model::ListContinuousTestResultsResponse>,
    > + Send {
        std::future::ready::<crate::Result<crate::model::ListContinuousTestResultsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Environments::deploy_flow].
    fn deploy_flow(
        &self,
        _req: crate::model::DeployFlowRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Environments::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Environments::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Environments::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::ListOperationsResponse>>
           + Send {
        std::future::ready::<crate::Result<longrunning::model::ListOperationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Environments::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Environments::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Returns the polling policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> Arc<dyn gax::polling_policy::PollingPolicy> {
        Arc::new(gax::polling_policy::Aip194Strict)
    }

    /// Returns the polling backoff policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_backoff_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        Arc::new(gax::exponential_backoff::ExponentialBackoff::default())
    }
}

/// Defines the trait used to implement [crate::client::Experiments].
///
/// Application developers may need to implement this trait to mock
/// `client::Experiments`.  In other use-cases, application developers only
/// use `client::Experiments` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Experiments: std::fmt::Debug + Send + Sync {
    /// Implements [crate::client::Experiments::list_experiments].
    fn list_experiments(
        &self,
        _req: crate::model::ListExperimentsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListExperimentsResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListExperimentsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Experiments::get_experiment].
    fn get_experiment(
        &self,
        _req: crate::model::GetExperimentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Experiment>> + Send {
        std::future::ready::<crate::Result<crate::model::Experiment>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Experiments::create_experiment].
    fn create_experiment(
        &self,
        _req: crate::model::CreateExperimentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Experiment>> + Send {
        std::future::ready::<crate::Result<crate::model::Experiment>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Experiments::update_experiment].
    fn update_experiment(
        &self,
        _req: crate::model::UpdateExperimentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Experiment>> + Send {
        std::future::ready::<crate::Result<crate::model::Experiment>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Experiments::delete_experiment].
    fn delete_experiment(
        &self,
        _req: crate::model::DeleteExperimentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::Experiments::start_experiment].
    fn start_experiment(
        &self,
        _req: crate::model::StartExperimentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Experiment>> + Send {
        std::future::ready::<crate::Result<crate::model::Experiment>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Experiments::stop_experiment].
    fn stop_experiment(
        &self,
        _req: crate::model::StopExperimentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Experiment>> + Send {
        std::future::ready::<crate::Result<crate::model::Experiment>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Experiments::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Experiments::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Experiments::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::ListOperationsResponse>>
           + Send {
        std::future::ready::<crate::Result<longrunning::model::ListOperationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Experiments::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Experiments::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }
}

/// Defines the trait used to implement [crate::client::Flows].
///
/// Application developers may need to implement this trait to mock
/// `client::Flows`.  In other use-cases, application developers only
/// use `client::Flows` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Flows: std::fmt::Debug + Send + Sync {
    /// Implements [crate::client::Flows::create_flow].
    fn create_flow(
        &self,
        _req: crate::model::CreateFlowRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Flow>> + Send {
        std::future::ready::<crate::Result<crate::model::Flow>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::Flows::delete_flow].
    fn delete_flow(
        &self,
        _req: crate::model::DeleteFlowRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::Flows::list_flows].
    fn list_flows(
        &self,
        _req: crate::model::ListFlowsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListFlowsResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListFlowsResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Flows::get_flow].
    fn get_flow(
        &self,
        _req: crate::model::GetFlowRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Flow>> + Send {
        std::future::ready::<crate::Result<crate::model::Flow>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::Flows::update_flow].
    fn update_flow(
        &self,
        _req: crate::model::UpdateFlowRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Flow>> + Send {
        std::future::ready::<crate::Result<crate::model::Flow>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::Flows::train_flow].
    fn train_flow(
        &self,
        _req: crate::model::TrainFlowRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Flows::validate_flow].
    fn validate_flow(
        &self,
        _req: crate::model::ValidateFlowRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::FlowValidationResult>> + Send
    {
        std::future::ready::<crate::Result<crate::model::FlowValidationResult>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Flows::get_flow_validation_result].
    fn get_flow_validation_result(
        &self,
        _req: crate::model::GetFlowValidationResultRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::FlowValidationResult>> + Send
    {
        std::future::ready::<crate::Result<crate::model::FlowValidationResult>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Flows::import_flow].
    fn import_flow(
        &self,
        _req: crate::model::ImportFlowRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Flows::export_flow].
    fn export_flow(
        &self,
        _req: crate::model::ExportFlowRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Flows::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Flows::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Flows::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::ListOperationsResponse>>
           + Send {
        std::future::ready::<crate::Result<longrunning::model::ListOperationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Flows::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Flows::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Returns the polling policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> Arc<dyn gax::polling_policy::PollingPolicy> {
        Arc::new(gax::polling_policy::Aip194Strict)
    }

    /// Returns the polling backoff policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_backoff_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        Arc::new(gax::exponential_backoff::ExponentialBackoff::default())
    }
}

/// Defines the trait used to implement [crate::client::Generators].
///
/// Application developers may need to implement this trait to mock
/// `client::Generators`.  In other use-cases, application developers only
/// use `client::Generators` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Generators: std::fmt::Debug + Send + Sync {
    /// Implements [crate::client::Generators::list_generators].
    fn list_generators(
        &self,
        _req: crate::model::ListGeneratorsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListGeneratorsResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListGeneratorsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Generators::get_generator].
    fn get_generator(
        &self,
        _req: crate::model::GetGeneratorRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Generator>> + Send {
        std::future::ready::<crate::Result<crate::model::Generator>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Generators::create_generator].
    fn create_generator(
        &self,
        _req: crate::model::CreateGeneratorRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Generator>> + Send {
        std::future::ready::<crate::Result<crate::model::Generator>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Generators::update_generator].
    fn update_generator(
        &self,
        _req: crate::model::UpdateGeneratorRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Generator>> + Send {
        std::future::ready::<crate::Result<crate::model::Generator>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Generators::delete_generator].
    fn delete_generator(
        &self,
        _req: crate::model::DeleteGeneratorRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::Generators::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Generators::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Generators::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::ListOperationsResponse>>
           + Send {
        std::future::ready::<crate::Result<longrunning::model::ListOperationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Generators::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Generators::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }
}

/// Defines the trait used to implement [crate::client::Intents].
///
/// Application developers may need to implement this trait to mock
/// `client::Intents`.  In other use-cases, application developers only
/// use `client::Intents` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Intents: std::fmt::Debug + Send + Sync {
    /// Implements [crate::client::Intents::list_intents].
    fn list_intents(
        &self,
        _req: crate::model::ListIntentsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListIntentsResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListIntentsResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Intents::get_intent].
    fn get_intent(
        &self,
        _req: crate::model::GetIntentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Intent>> + Send {
        std::future::ready::<crate::Result<crate::model::Intent>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Intents::create_intent].
    fn create_intent(
        &self,
        _req: crate::model::CreateIntentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Intent>> + Send {
        std::future::ready::<crate::Result<crate::model::Intent>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Intents::update_intent].
    fn update_intent(
        &self,
        _req: crate::model::UpdateIntentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Intent>> + Send {
        std::future::ready::<crate::Result<crate::model::Intent>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Intents::delete_intent].
    fn delete_intent(
        &self,
        _req: crate::model::DeleteIntentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::Intents::import_intents].
    fn import_intents(
        &self,
        _req: crate::model::ImportIntentsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Intents::export_intents].
    fn export_intents(
        &self,
        _req: crate::model::ExportIntentsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Intents::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Intents::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Intents::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::ListOperationsResponse>>
           + Send {
        std::future::ready::<crate::Result<longrunning::model::ListOperationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Intents::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Intents::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Returns the polling policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> Arc<dyn gax::polling_policy::PollingPolicy> {
        Arc::new(gax::polling_policy::Aip194Strict)
    }

    /// Returns the polling backoff policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_backoff_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        Arc::new(gax::exponential_backoff::ExponentialBackoff::default())
    }
}

/// Defines the trait used to implement [crate::client::Pages].
///
/// Application developers may need to implement this trait to mock
/// `client::Pages`.  In other use-cases, application developers only
/// use `client::Pages` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Pages: std::fmt::Debug + Send + Sync {
    /// Implements [crate::client::Pages::list_pages].
    fn list_pages(
        &self,
        _req: crate::model::ListPagesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListPagesResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListPagesResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Pages::get_page].
    fn get_page(
        &self,
        _req: crate::model::GetPageRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Page>> + Send {
        std::future::ready::<crate::Result<crate::model::Page>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::Pages::create_page].
    fn create_page(
        &self,
        _req: crate::model::CreatePageRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Page>> + Send {
        std::future::ready::<crate::Result<crate::model::Page>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::Pages::update_page].
    fn update_page(
        &self,
        _req: crate::model::UpdatePageRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Page>> + Send {
        std::future::ready::<crate::Result<crate::model::Page>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::Pages::delete_page].
    fn delete_page(
        &self,
        _req: crate::model::DeletePageRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::Pages::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Pages::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Pages::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::ListOperationsResponse>>
           + Send {
        std::future::ready::<crate::Result<longrunning::model::ListOperationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Pages::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Pages::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }
}

/// Defines the trait used to implement [crate::client::SecuritySettingsService].
///
/// Application developers may need to implement this trait to mock
/// `client::SecuritySettingsService`.  In other use-cases, application developers only
/// use `client::SecuritySettingsService` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait SecuritySettingsService: std::fmt::Debug + Send + Sync {
    /// Implements [crate::client::SecuritySettingsService::create_security_settings].
    fn create_security_settings(
        &self,
        _req: crate::model::CreateSecuritySettingsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::SecuritySettings>> + Send
    {
        std::future::ready::<crate::Result<crate::model::SecuritySettings>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::SecuritySettingsService::get_security_settings].
    fn get_security_settings(
        &self,
        _req: crate::model::GetSecuritySettingsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::SecuritySettings>> + Send
    {
        std::future::ready::<crate::Result<crate::model::SecuritySettings>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::SecuritySettingsService::update_security_settings].
    fn update_security_settings(
        &self,
        _req: crate::model::UpdateSecuritySettingsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::SecuritySettings>> + Send
    {
        std::future::ready::<crate::Result<crate::model::SecuritySettings>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::SecuritySettingsService::list_security_settings].
    fn list_security_settings(
        &self,
        _req: crate::model::ListSecuritySettingsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListSecuritySettingsResponse>>
           + Send {
        std::future::ready::<crate::Result<crate::model::ListSecuritySettingsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::SecuritySettingsService::delete_security_settings].
    fn delete_security_settings(
        &self,
        _req: crate::model::DeleteSecuritySettingsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::SecuritySettingsService::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::SecuritySettingsService::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::SecuritySettingsService::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::ListOperationsResponse>>
           + Send {
        std::future::ready::<crate::Result<longrunning::model::ListOperationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::SecuritySettingsService::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::SecuritySettingsService::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }
}

/// Defines the trait used to implement [crate::client::Sessions].
///
/// Application developers may need to implement this trait to mock
/// `client::Sessions`.  In other use-cases, application developers only
/// use `client::Sessions` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Sessions: std::fmt::Debug + Send + Sync {
    /// Implements [crate::client::Sessions::detect_intent].
    fn detect_intent(
        &self,
        _req: crate::model::DetectIntentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::DetectIntentResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::DetectIntentResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Sessions::match_intent].
    fn match_intent(
        &self,
        _req: crate::model::MatchIntentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::MatchIntentResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::MatchIntentResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Sessions::fulfill_intent].
    fn fulfill_intent(
        &self,
        _req: crate::model::FulfillIntentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::FulfillIntentResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::FulfillIntentResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Sessions::submit_answer_feedback].
    fn submit_answer_feedback(
        &self,
        _req: crate::model::SubmitAnswerFeedbackRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::AnswerFeedback>> + Send {
        std::future::ready::<crate::Result<crate::model::AnswerFeedback>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Sessions::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Sessions::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Sessions::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::ListOperationsResponse>>
           + Send {
        std::future::ready::<crate::Result<longrunning::model::ListOperationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Sessions::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Sessions::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }
}

/// Defines the trait used to implement [crate::client::SessionEntityTypes].
///
/// Application developers may need to implement this trait to mock
/// `client::SessionEntityTypes`.  In other use-cases, application developers only
/// use `client::SessionEntityTypes` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait SessionEntityTypes: std::fmt::Debug + Send + Sync {
    /// Implements [crate::client::SessionEntityTypes::list_session_entity_types].
    fn list_session_entity_types(
        &self,
        _req: crate::model::ListSessionEntityTypesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListSessionEntityTypesResponse>>
           + Send {
        std::future::ready::<crate::Result<crate::model::ListSessionEntityTypesResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::SessionEntityTypes::get_session_entity_type].
    fn get_session_entity_type(
        &self,
        _req: crate::model::GetSessionEntityTypeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::SessionEntityType>> + Send
    {
        std::future::ready::<crate::Result<crate::model::SessionEntityType>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::SessionEntityTypes::create_session_entity_type].
    fn create_session_entity_type(
        &self,
        _req: crate::model::CreateSessionEntityTypeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::SessionEntityType>> + Send
    {
        std::future::ready::<crate::Result<crate::model::SessionEntityType>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::SessionEntityTypes::update_session_entity_type].
    fn update_session_entity_type(
        &self,
        _req: crate::model::UpdateSessionEntityTypeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::SessionEntityType>> + Send
    {
        std::future::ready::<crate::Result<crate::model::SessionEntityType>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::SessionEntityTypes::delete_session_entity_type].
    fn delete_session_entity_type(
        &self,
        _req: crate::model::DeleteSessionEntityTypeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::SessionEntityTypes::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::SessionEntityTypes::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::SessionEntityTypes::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::ListOperationsResponse>>
           + Send {
        std::future::ready::<crate::Result<longrunning::model::ListOperationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::SessionEntityTypes::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::SessionEntityTypes::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }
}

/// Defines the trait used to implement [crate::client::TestCases].
///
/// Application developers may need to implement this trait to mock
/// `client::TestCases`.  In other use-cases, application developers only
/// use `client::TestCases` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait TestCases: std::fmt::Debug + Send + Sync {
    /// Implements [crate::client::TestCases::list_test_cases].
    fn list_test_cases(
        &self,
        _req: crate::model::ListTestCasesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListTestCasesResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListTestCasesResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::TestCases::batch_delete_test_cases].
    fn batch_delete_test_cases(
        &self,
        _req: crate::model::BatchDeleteTestCasesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::TestCases::get_test_case].
    fn get_test_case(
        &self,
        _req: crate::model::GetTestCaseRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::TestCase>> + Send {
        std::future::ready::<crate::Result<crate::model::TestCase>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::TestCases::create_test_case].
    fn create_test_case(
        &self,
        _req: crate::model::CreateTestCaseRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::TestCase>> + Send {
        std::future::ready::<crate::Result<crate::model::TestCase>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::TestCases::update_test_case].
    fn update_test_case(
        &self,
        _req: crate::model::UpdateTestCaseRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::TestCase>> + Send {
        std::future::ready::<crate::Result<crate::model::TestCase>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::TestCases::run_test_case].
    fn run_test_case(
        &self,
        _req: crate::model::RunTestCaseRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::TestCases::batch_run_test_cases].
    fn batch_run_test_cases(
        &self,
        _req: crate::model::BatchRunTestCasesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::TestCases::calculate_coverage].
    fn calculate_coverage(
        &self,
        _req: crate::model::CalculateCoverageRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::CalculateCoverageResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::CalculateCoverageResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::TestCases::import_test_cases].
    fn import_test_cases(
        &self,
        _req: crate::model::ImportTestCasesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::TestCases::export_test_cases].
    fn export_test_cases(
        &self,
        _req: crate::model::ExportTestCasesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::TestCases::list_test_case_results].
    fn list_test_case_results(
        &self,
        _req: crate::model::ListTestCaseResultsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListTestCaseResultsResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListTestCaseResultsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::TestCases::get_test_case_result].
    fn get_test_case_result(
        &self,
        _req: crate::model::GetTestCaseResultRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::TestCaseResult>> + Send {
        std::future::ready::<crate::Result<crate::model::TestCaseResult>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::TestCases::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::TestCases::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::TestCases::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::ListOperationsResponse>>
           + Send {
        std::future::ready::<crate::Result<longrunning::model::ListOperationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::TestCases::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::TestCases::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Returns the polling policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> Arc<dyn gax::polling_policy::PollingPolicy> {
        Arc::new(gax::polling_policy::Aip194Strict)
    }

    /// Returns the polling backoff policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_backoff_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        Arc::new(gax::exponential_backoff::ExponentialBackoff::default())
    }
}

/// Defines the trait used to implement [crate::client::TransitionRouteGroups].
///
/// Application developers may need to implement this trait to mock
/// `client::TransitionRouteGroups`.  In other use-cases, application developers only
/// use `client::TransitionRouteGroups` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait TransitionRouteGroups: std::fmt::Debug + Send + Sync {
    /// Implements [crate::client::TransitionRouteGroups::list_transition_route_groups].
    fn list_transition_route_groups(
        &self,
        _req: crate::model::ListTransitionRouteGroupsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<crate::model::ListTransitionRouteGroupsResponse>,
    > + Send {
        std::future::ready::<crate::Result<crate::model::ListTransitionRouteGroupsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::TransitionRouteGroups::get_transition_route_group].
    fn get_transition_route_group(
        &self,
        _req: crate::model::GetTransitionRouteGroupRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::TransitionRouteGroup>> + Send
    {
        std::future::ready::<crate::Result<crate::model::TransitionRouteGroup>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::TransitionRouteGroups::create_transition_route_group].
    fn create_transition_route_group(
        &self,
        _req: crate::model::CreateTransitionRouteGroupRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::TransitionRouteGroup>> + Send
    {
        std::future::ready::<crate::Result<crate::model::TransitionRouteGroup>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::TransitionRouteGroups::update_transition_route_group].
    fn update_transition_route_group(
        &self,
        _req: crate::model::UpdateTransitionRouteGroupRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::TransitionRouteGroup>> + Send
    {
        std::future::ready::<crate::Result<crate::model::TransitionRouteGroup>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::TransitionRouteGroups::delete_transition_route_group].
    fn delete_transition_route_group(
        &self,
        _req: crate::model::DeleteTransitionRouteGroupRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::TransitionRouteGroups::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::TransitionRouteGroups::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::TransitionRouteGroups::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::ListOperationsResponse>>
           + Send {
        std::future::ready::<crate::Result<longrunning::model::ListOperationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::TransitionRouteGroups::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::TransitionRouteGroups::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }
}

/// Defines the trait used to implement [crate::client::Versions].
///
/// Application developers may need to implement this trait to mock
/// `client::Versions`.  In other use-cases, application developers only
/// use `client::Versions` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Versions: std::fmt::Debug + Send + Sync {
    /// Implements [crate::client::Versions::list_versions].
    fn list_versions(
        &self,
        _req: crate::model::ListVersionsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListVersionsResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListVersionsResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Versions::get_version].
    fn get_version(
        &self,
        _req: crate::model::GetVersionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Version>> + Send {
        std::future::ready::<crate::Result<crate::model::Version>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Versions::create_version].
    fn create_version(
        &self,
        _req: crate::model::CreateVersionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Versions::update_version].
    fn update_version(
        &self,
        _req: crate::model::UpdateVersionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Version>> + Send {
        std::future::ready::<crate::Result<crate::model::Version>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Versions::delete_version].
    fn delete_version(
        &self,
        _req: crate::model::DeleteVersionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::Versions::load_version].
    fn load_version(
        &self,
        _req: crate::model::LoadVersionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Versions::compare_versions].
    fn compare_versions(
        &self,
        _req: crate::model::CompareVersionsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::CompareVersionsResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::CompareVersionsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Versions::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Versions::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Versions::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::ListOperationsResponse>>
           + Send {
        std::future::ready::<crate::Result<longrunning::model::ListOperationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Versions::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Versions::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Returns the polling policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> Arc<dyn gax::polling_policy::PollingPolicy> {
        Arc::new(gax::polling_policy::Aip194Strict)
    }

    /// Returns the polling backoff policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_backoff_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        Arc::new(gax::exponential_backoff::ExponentialBackoff::default())
    }
}

/// Defines the trait used to implement [crate::client::Webhooks].
///
/// Application developers may need to implement this trait to mock
/// `client::Webhooks`.  In other use-cases, application developers only
/// use `client::Webhooks` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Webhooks: std::fmt::Debug + Send + Sync {
    /// Implements [crate::client::Webhooks::list_webhooks].
    fn list_webhooks(
        &self,
        _req: crate::model::ListWebhooksRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListWebhooksResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListWebhooksResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Webhooks::get_webhook].
    fn get_webhook(
        &self,
        _req: crate::model::GetWebhookRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Webhook>> + Send {
        std::future::ready::<crate::Result<crate::model::Webhook>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Webhooks::create_webhook].
    fn create_webhook(
        &self,
        _req: crate::model::CreateWebhookRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Webhook>> + Send {
        std::future::ready::<crate::Result<crate::model::Webhook>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Webhooks::update_webhook].
    fn update_webhook(
        &self,
        _req: crate::model::UpdateWebhookRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Webhook>> + Send {
        std::future::ready::<crate::Result<crate::model::Webhook>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Webhooks::delete_webhook].
    fn delete_webhook(
        &self,
        _req: crate::model::DeleteWebhookRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Implements [crate::client::Webhooks::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Webhooks::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Webhooks::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::ListOperationsResponse>>
           + Send {
        std::future::ready::<crate::Result<longrunning::model::ListOperationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [crate::client::Webhooks::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [crate::client::Webhooks::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }
}
